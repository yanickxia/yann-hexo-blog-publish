<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于KMP算法中的一个小问题</title>
    <url>/2017/01/25/algorithm/why-is-x-in-kmp/</url>
    <content><![CDATA[<p>最近看了一个算法，KMP，字符串查询算法，这个方法有各种各样的讲解，我个人最喜欢的还是在 <a href="https://book.douban.com/subject/10432347/">《算法》</a> 中所提到的用DFA的方式去解答这个算法。</p>
<p>算法的核心可以看这篇文章：</p>
<ul>
<li><a href="http://blog.csdn.net/congduan/article/details/45459963">从DFA角度理解KMP算法</a></li>
<li><a href="http://judes.me/2016/04/10/kmp/">算法第四版 kmp 算法</a></li>
</ul>
<span id="more"></span>
<h2 id="问题"><a class="header-anchor" href="#问题">¶</a>问题</h2>
<p>关于其中一个小问题，我想仔细的聊一聊(如果没有看前面，请看下上文)。<br>
这个问题就是关于DFA这个二维数组构建的时候，其中有一个变量X是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy  dfa[][X] to  dfa[][j]</span><br><span class="line">dfa[pat.charAt(j)][j] = j+1;</span><br><span class="line">X = dfa[pat.charAt(j)][X];</span><br></pre></td></tr></table></figure>
<h2 id="探寻"><a class="header-anchor" href="#探寻">¶</a>探寻</h2>
<p>** 我们要明白X就是当前回退的状态 **</p>
<h3 id="Step-0："><a class="header-anchor" href="#Step-0：">¶</a>Step 0：</h3>
<p>第一步构造，我们发现 我们现在所在的状态，能够回退的只有状态 0，而只有输入A的时候<br>
我们才能进入1状态，这个没什么好说的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  X （这是在初始化之后赋值的）</span><br><span class="line">  ↓</span><br><span class="line">J 0 1 2 3 4 5</span><br><span class="line">  A B A B A C</span><br><span class="line">¯¯¯¯¯¯¯¯¯¯¯¯¯¯</span><br><span class="line">A 1</span><br><span class="line">B 0</span><br><span class="line">C 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Step-2"><a class="header-anchor" href="#Step-2">¶</a>Step 2:</h3>
<p>第二步构造，我们首先确认，我们发现我们回退的状态是 0，那我怎么确定，我们所能回退的状态，这个时候X的作用出来了，X = 0这个时候，因为我们这个时候输入所有的，都是从0 开始回退的。</p>
<ul>
<li>copy  dfa[][X] to  dfa[][j] ， 这里其实就是匹配失败，我们发现，在第二次 匹配B的时候<br>
如果我们匹配的是A，我们是的确回到1状态就是 0 状态那一列，但是问题来了，这是我们自己想出来的，从DFA怎么看出来的，一开始我们所能回退的状态对于任何输入来说都是从 上一次的状态开始 开始，那我们这一次能够回退的就是 0 状态，就是所谓 <strong>状态为0的那一列</strong>。 换言之，我们这次输入如果不成功，那我们所有的输入都是从新开始计算的，那从新计算是不是状态0+某个数据 = 新状态，而这个新状态就是 0 状态那一列？</li>
</ul>
<p><strong>上面可能看不懂</strong> 其实就是假设，1 -&gt; 2 状态转换的时候，我们失败了，那我们需要从哪里开始重新计算，那很简单，因为我们才 1 -&gt; 2 状态，那我们只能从 0 -&gt; 1重新计算。你 0 -&gt; 1 状态的变化，是不是 J = 0 的那一列？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  X</span><br><span class="line">  ↓</span><br><span class="line">J 0 1 2 3 4 5</span><br><span class="line">  A B A B A C</span><br><span class="line">¯¯¯¯¯¯¯¯¯¯¯¯¯¯</span><br><span class="line">A 1 1</span><br><span class="line">B 0 0</span><br><span class="line">C 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>dfa[pat.charAt(j)][j] = j+1; 这里很简单，就是如果是正确输入的字符串，我们的状态应该是当前输入状态+1.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  X</span><br><span class="line">  ↓</span><br><span class="line">J 0 1 2 3 4 5</span><br><span class="line">  A B A B A C</span><br><span class="line">¯¯¯¯¯¯¯¯¯¯¯¯¯¯</span><br><span class="line">A 1 1</span><br><span class="line">B 0 2</span><br><span class="line">C 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>X = dfa[pat.charAt(j)][X] 这里为什么要升级X，原因是因为我们需要知道B这次是不是部份匹配上了，这一次 X = dfa[pat.charAt(j)][X] 带入参数，我们发现是 X = dfa[B][0], 这里就是以B为输入量，状态为 0 的时候，转换成了对象的状态, X= 0, 但是这个 0 和上次的 0 不是一个含义，这个 0 的含义是，这次输入B，<strong>所能从0状态转换成的状态也是0！</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  X</span><br><span class="line">  ↓</span><br><span class="line">J 0 1 2 3 4 5</span><br><span class="line">  A B A B A C</span><br><span class="line">¯¯¯¯¯¯¯¯¯¯¯¯¯¯</span><br><span class="line">A 1 1</span><br><span class="line">B 0 2</span><br><span class="line">C 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Step-3"><a class="header-anchor" href="#Step-3">¶</a>Step 3:</h3>
<ul>
<li>copy  dfa[][X] to  dfa[][j]</li>
<li>dfa[pat.charAt(j)][j] = j+1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  X</span><br><span class="line">  ↓</span><br><span class="line">J 0 1 2 3 4 5</span><br><span class="line">  A B A B A C</span><br><span class="line">¯¯¯¯¯¯¯¯¯¯¯¯¯¯</span><br><span class="line">A 1 1 3</span><br><span class="line">B 0 2 0</span><br><span class="line">C 0 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>X = dfa[pat.charAt(j)][X] 重点看这个问题，这个时候，我们看见我们的表格还是如上图。这个时候 X = dfa[A][0], X = 1, 为什么这里是 1，这个问题很和谐，其实这里的含义是，我们之前所能回退的状态都是0，而这一次我们输入的是 A，那在0状态输入A状态会变成什么？，当然是变成1状态。好，这个X我们保存。所以X = 1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    X</span><br><span class="line">    ↓</span><br><span class="line">J 0 1 2 3 4 5</span><br><span class="line">  A B A B A C</span><br><span class="line">¯¯¯¯¯¯¯¯¯¯¯¯¯¯</span><br><span class="line">A 1 1 3</span><br><span class="line">B 0 2 0</span><br><span class="line">C 0 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Step-4"><a class="header-anchor" href="#Step-4">¶</a>Step 4:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      X</span><br><span class="line">      ↓</span><br><span class="line">J 0 1 2 3 4 5</span><br><span class="line">  A B A B A C</span><br><span class="line">¯¯¯¯¯¯¯¯¯¯¯¯¯¯</span><br><span class="line">A 1 1 3 1</span><br><span class="line">B 0 2 0 4</span><br><span class="line">C 0 0 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里哦我们就发现了，其实这里我们 <em>copy  dfa[][X] to  dfa[][j]</em> 的时候，我们是考虑匹配失败的时候，因为之前上一次的A，已经保证我们的状态会在1上，我们只需要从 1状态上把失败的状态Copy过来，更新成功的对象，在更新X就可以了。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>本篇是关于KMP的基于DFA状态机的理解，至于在算导中的next数组，还没有看各位看官还望斧正。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>KMP</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome to the Yanick Blog</title>
    <url>/2015/03/01/announcement/announcement/</url>
    <content><![CDATA[<p>如果打不开图片，记得使用梯子哦.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>APM 杂谈</title>
    <url>/2020/09/23/apm/apm/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/09/23/HTv8R.png" alt="HTv8R.png"></p>
<p>人人都需要的 <code>Application Performance Monitoring</code> 了解一下</p>
<span id="more"></span>
<h1>需要收集什么数据</h1>
<p>首先我们要做 <code>APM</code> 那我们，我们先明确我们的 <code>APM</code> 需要收集的数据有哪些？因为是针对 <code>Application</code> 而言，<code>CPU</code> <code>DISK</code> 就不算是在这个范围之内。一般认为有两类数据需要收集</p>
<ul>
<li>运行状态数据 [Metrics]： uptime，health，snaphost，avg_response_time</li>
<li>链路数据 [Tracing]：单次调用的上下文和链路信息</li>
</ul>
<p>第一类数据的作用是分析现在的系统状态，比如依赖的中间件是否有问题，系统的 GC 状态是否正常，对外的 Web 服务是否正常。</p>
<p>第二类数据的作用是分析在单次处理的过程中是否出现一些问题，以及出现问题时的上下文是如何的。</p>
<h1>采集侧</h1>
<h2 id="探针体系"><a class="header-anchor" href="#探针体系">¶</a>探针体系</h2>
<p>探针顾名思义，插在运行程序上面的一层。因此探针体系的 <code>APM</code> 都有着最好的一个卖点 <code>无侵入</code>，大多数都是利用了特定语言提供的无侵入能力做这件事。这里面的玩家有很多 <code>Skywalking</code> <code>pinpoint</code> 等。</p>
<h3 id="例子：-Java-Agent"><a class="header-anchor" href="#例子：-Java-Agent">¶</a>例子： Java Agent</h3>
<p>因为 <code>Java</code> 是一门虚拟机语言，支持一种名为 <code>动态字节码</code> 的功能，这个在功能提供了 <code>2</code> 种模式，<code>C++</code> 版本的 <code>agentlib</code> 和 <code>Java</code> 版本的 <code>javaagent</code></p>
<p><img src="https://s3.jpg.cm/2020/09/23/HanCe.png" alt="HanCe.png"></p>
<p>只需要在启动的时候</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -javaagent:agent1.jar -javaagent:agent2.jar -jar MyProgram.jar</span><br></pre></td></tr></table></figure>
<p>这里的 <code>agent.jar</code> 就是我们的探针代码，比如有以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ElementMatcher.Junction&lt;NamedElement&gt; springApplicationType = ElementMatchers.nameEndsWith(<span class="string">&quot;ApplicationObjectSupport&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//捕获到 `ApplicationObjectSupport.setApplicationContext()` 函数，并且创建一个代理函数，逻辑如下个class</span></span><br><span class="line">    <span class="keyword">final</span> AgentBuilder.<span class="type">Transformer</span> <span class="variable">transformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AgentBuilder</span>.Transformer() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> DynamicType.Builder&lt;?&gt; transform(DynamicType.Builder&lt;?&gt; builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule javaModule) &#123;</span><br><span class="line">            <span class="keyword">return</span> builder.method(ElementMatchers.named(<span class="string">&quot;setApplicationContext&quot;</span>))</span><br><span class="line">                    .intercept(Advice.to(ContextAdvice.class));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// 捕获 ApplicationContext 对象用于处理后面的逻辑</span></span><br><span class="line">    <span class="meta">@Advice</span>.OnMethodEnter</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">enter</span><span class="params">(<span class="meta">@Advice</span>.AllArguments Object[] args)</span> &#123;</span><br><span class="line">        ApplicationContextHolder.applicationContextObj = args[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Advice</span>.OnMethodExit</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">()</span> &#123;</span><br><span class="line">        VersionLoader.getVersion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h3>
<p>探针体系依赖于语言提供的能力，优点也是不辩自明的，无需客户端做任何修改就可以兼容大部分的框架。主要说说这个体系的缺点</p>
<ul>
<li>适用性低：受限于语言本身的能力</li>
<li>适配繁琐：这可以参考 Skywalking 的适配，对于开源的还好，如果是内部框架呢？</li>
</ul>
<p>主要选手：</p>
<img src="https://s3.jpg.cm/2020/09/23/HacrG.png" alt="skywalking" width="500" height="300" style="display:inline">
<img src="https://s3.jpg.cm/2020/09/23/HaUC4.png" alt="pinpiont" width="500" height="300" style="display:inline">
<h2 id="SDK-体系"><a class="header-anchor" href="#SDK-体系">¶</a>SDK 体系</h2>
<p><code>SDK</code> 体系最好理解，提供了一套 <code>SDK API</code> 供使用者调用，这样就可以让使用者无感知监控的内部实现。对于大部分的 <code>编译型</code> 语言来说，这是唯一可选的路径。</p>
<h3 id="例子-go-agent"><a class="header-anchor" href="#例子-go-agent">¶</a>例子: <a href="https://github.com/newrelic/go-agent/blob/master/GETTING_STARTED.md">go-agent</a></h3>
<p>比如 <code>Newrelic</code> <code>Tingyun</code> 都是采用这种模式，支持大部分的常见的 <code>Middware</code>，然后也支持手动的创建一些监控数据。</p>
<figure class="highlight go"><figcaption><span>启动一个外部通讯服务</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create an Application:</span></span><br><span class="line">    app, err := newrelic.NewApplication(</span><br><span class="line">        <span class="comment">// Name your application</span></span><br><span class="line">        newrelic.ConfigAppName(<span class="string">&quot;Your Application Name&quot;</span>),</span><br><span class="line">        <span class="comment">// Fill in your New Relic license key</span></span><br><span class="line">        newrelic.ConfigLicense(<span class="string">&quot;__YOUR_NEW_RELIC_LICENSE_KEY__&quot;</span>),</span><br><span class="line">        <span class="comment">// Add logging:</span></span><br><span class="line">        newrelic.ConfigDebugLogger(os.Stdout),</span><br><span class="line">        <span class="comment">// Optional: add additional changes to your configuration via a config function:</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(cfg *newrelic.Config)</span></span> &#123;</span><br><span class="line">            cfg.CustomInsightsEvents.Enabled = <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// If an application could not be created then err will reveal why.</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;unable to create New Relic Application&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Now use the app to instrument everything!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再我们想要的地方进行埋点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原逻辑</span></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/users&quot;</span>, usersHandler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现逻辑</span></span><br><span class="line">http.HandleFunc(newrelic.WrapHandleFunc(app, <span class="string">&quot;/users&quot;</span>, usersHandler))</span><br></pre></td></tr></table></figure>
<p>原理不用猜也知道了，对于大部分的框架来说，我们在处理上下文的时候都会传递一个 <code>Context</code> 对象，我们希望能够捕获一些状态数据的话，将其放置于 <code>Context</code> 中，然后将其在最终 <code>End</code> 的地方通过异步的队列上报即可。</p>
<h3 id="例子：Cat"><a class="header-anchor" href="#例子：Cat">¶</a>例子：<a href="https://github.com/dianping/cat">Cat</a></h3>
<p>单纯的埋点，无需支持任何框架，本身就是一个全局对象。用起来也非常的粗暴简单</p>
<p><img src="https://s3.jpg.cm/2020/09/23/HTOBf.png" alt="HTOBf.png"></p>
<figure class="highlight java"><figcaption><span>CAT手动埋点</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> Cat.newTransaction(<span class="string">&quot;URL&quot;</span>, <span class="string">&quot;pageName&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Cat.logEvent(<span class="string">&quot;URL.Server&quot;</span>, <span class="string">&quot;serverIp&quot;</span>, Event.SUCCESS, <span class="string">&quot;ip=$&#123;serverIp&#125;&quot;</span>);</span><br><span class="line">    Cat.logMetricForCount(<span class="string">&quot;metric.key&quot;</span>);</span><br><span class="line">    Cat.logMetricForDuration(<span class="string">&quot;metric.key&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    yourBusiness();</span><br><span class="line"></span><br><span class="line">    t.setStatus(Transaction.SUCCESS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    t.setStatus(e);</span><br><span class="line">    Cat.logError(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    t.complete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自报体系"><a class="header-anchor" href="#自报体系">¶</a>自报体系</h3>
<p>还有一类以 <code>Web API</code> 提供远端的消费者来提供服务的，这样的需要自行在客户端侧进行逻辑适配，然后按照 <code>API</code> 的要求将数据上报来，因此在我们上面所说的两种监控数据类型上，社区有相对标准的数据格式。</p>
<p>指标类型：prometheus 的 <a href="https://prometheus.io/docs/concepts/metric_types/">metric types</a>，不过这块还没有什么标准的文件出现，不过有一个 <a href="https://micrometer.io/">micrometer</a> spring 社区在推进。</p>
<p>链路类型：<a href="https://opentracing.io/">opentracing</a> 一统天下</p>
<h3 id="小结-v2"><a class="header-anchor" href="#小结-v2">¶</a>小结</h3>
<p><code>SDK</code> 体系就实现起来很简单，并且在使用的过程中如果有什么不兼容的在使用侧进行修改都可以，但是缺点就是一旦引入了 <code>SDK</code>，就是涉及到代码的更新，这就是传统 <code>SDK</code> 同样导致的问题。</p>
<p>主要选手：<br>
<img src="https://s3.jpg.cm/2020/09/23/HauqX.png" width="500" height="300" alt="cat" style="display:inline"></p>
<h1>处理侧</h1>
<p>对于收集上来的数据总是需要进行处理的，因此这块设计也不尽相同。</p>
<h2 id="聚合处理型"><a class="header-anchor" href="#聚合处理型">¶</a>聚合处理型</h2>
<p><code>Skywalking</code> 和 <code>Pinpoint</code> 都是这个模式，以 <code>Skywalking</code> 为例子，有一个单独的部署的模块为 <code>Observability Analysis Platform</code> 下称 <code>OAP</code></p>
<p><img src="https://s3.jpg.cm/2020/09/23/HaJZ6.png" alt="HaJZ6.png"></p>
<p><code>OAP</code> 承担三件事情</p>
<ol start="0">
<li>数据计算：对于 <code>Tracing</code> 数据需要将多个 <code>Span</code> 聚合在一起</li>
<li>数据的收集对接储存: <code>OAP</code> 支持 <code>H2</code> <code>Mysql</code> <code>Elasticsearch</code></li>
<li>数据的查询: 因为不同的数据库，对应不同的储存模型，但是对外要提供统一的接口</li>
</ol>
<hr>
<p>这个模式看起来还不错，不过从开源的版本看起来，都会有几个问题。</p>
<ul>
<li>OAP 的性能堪忧，随着接入节点的变多，OAP 既是接入端，又是处理端，还是查询端。</li>
<li>OAP 的逻辑复杂，且难以扩展。</li>
</ul>
<h2 id="简单透传型"><a class="header-anchor" href="#简单透传型">¶</a>简单透传型</h2>
<p><code>jaeger</code> 就属于这一类型，只有最终的一份工作，将 <code>Tracing</code> 的数据落到不同的数据库中，而且几乎不进行什么处理，因此在数据内存放的都是散落的 <code>Span</code> 信息，在后面继续分析的时候，聚合数据的工作需要留到查询侧再进行，这样的设计也不是不无道理，因为对于大部分的时间来说，我们不会去看 <code>Tracing</code> 的信息，等我们真的点击的时候再进行数据分析即可。</p>
<p><img src="https://s3.jpg.cm/2020/09/23/HaNAT.png" alt="HaNAT.png"></p>
<h2 id="理想型"><a class="header-anchor" href="#理想型">¶</a>理想型</h2>
<ul>
<li>数据接入：所有的数据应该可以直接连接 <code>OAP</code> 或者 <code>Kafka</code>，因为对于 <code>POC</code> 或者小客户场景，加入 <code>Kafka</code> 是不适合的，增加了运维复杂度，直接在 <code>OAP</code> 进行处理即可。</li>
<li>数据处理：1. 对于大规模的场景，数据的消费者应该是 <code>Spark/Flink</code> ，基于流处理的能力减少开发复杂度， 2.  对于简单场景， <code>OAP</code> 进行逻辑处理即可</li>
</ul>
<h1>储存侧</h1>
<blockquote>
<p>储存方案笔者也不是很精通，随便看看</p>
</blockquote>
<p>对于数据的存储一般都是监控体系最头疼的地方，不过还算是比较好的现在已经有很多可以参考的案例。现在常见的储存有 <code>Hbase</code> <code>Elasticsearch</code> <code>TSDB</code> 等。<br>
对于大规模的长时间储存有需要检索分析的话，<code>Hbase</code> 也许符合需求，对于每日场景分析的数据我认为使用 <code>Elasticsearch</code> 更加适合，对于 <code>Metris</code> 指标的话，采用时序数据库又更更适合。因此我认为这几个应该搭配起来使用，大部分时候链路数据的热点也就是在一天左右，因为这些数据可以一开始储存在 <code>Elasticsearch</code> 方便分析，之后可以将数据归档到 <code>Hbase</code> 进行冷处理。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://www.cnblogs.com/rickiyang/p/11368932.html">javaagent 使用指南</a></li>
<li><a href="https://github.com/dianping/cat/wiki/overall">cat wiki</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>apm</category>
      </categories>
      <tags>
        <tag>apm</tag>
      </tags>
  </entry>
  <entry>
    <title>架构亦非玄学</title>
    <url>/2020/07/14/architecture/architecture-not-mysticism/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/07/15/UbEWe.png" alt="UbEWe.png"></p>
<blockquote>
<p>它是一个唯有我们自己才能带秩序的过程,它不可能被求取,但只要我们顺应它,它便会自然而然地出现。 《建筑永恒之道》</p>
</blockquote>
<p>套用一句杜甫的话 <code>架构本天成，妙手偶得之</code>。而现在的互联网仿佛在神话架构师这样的角色。在这里不是要去否定 <code>martinfowler</code> 这样伟大的架构师，但是<code>martin</code> 老师实在是向社会输出了太多 <code>New Concept</code>，虽然本意是好的，然而在在多数的从业人眼中，架构变成了一个玄之又玄的东西。</p>
<span id="more"></span>
<p>我们就从最常见的高并发的秒杀场景入手，看看架构是如何演化的。</p>
<h1>情景分析</h1>
<p>商品秒杀、商品抢购、群红包、抢优惠券、抽奖等等。秒杀商品价格低廉、抢购商品很好|抢手、大幅推广|广为人知、瞬时售空、一般是定时上架、持续时间短、瞬时并发量高等。</p>
<p><img src="https://s3.jpg.cm/2020/07/17/UF2tU.png" alt="UF2tU.png"></p>
<ul>
<li>秒杀前：用户不断刷新商品详情页，页面请求达到瞬时峰值。</li>
<li>秒杀开始：用户点击秒杀按钮，下单请求达到瞬时峰值。</li>
<li>秒杀后：一部分成功下单的用户不断刷新订单或者产生退单操作，大部分用户继续刷新商品详情页等待退单机会。</li>
</ul>
<h1>转换为技术问题</h1>
<p>那我们用技术来定问题</p>
<ul>
<li>秒杀前：<strong>多读少写(无写)</strong></li>
<li>秒杀中：<strong>多写多读</strong></li>
<li>秒杀后：<strong>多读少写</strong></li>
</ul>
<h2 id="秒杀前：多度少写"><a class="header-anchor" href="#秒杀前：多度少写">¶</a>秒杀前：多度少写</h2>
<p>对于多度少写的场景，是最容易解决的，对于大部分的秒杀场景，将页面静态化即可，页面静态化 + CDN分发。<br>
<img src="https://s3.jpg.cm/2020/07/17/UF3zO.png" alt="UF3zO.png"></p>
<h2 id="秒杀中"><a class="header-anchor" href="#秒杀中">¶</a>秒杀中</h2>
<p>问题开始变的复杂起来，我们先从最简单的架构体系看起来。</p>
<p><img src="https://s3.jpg.cm/2020/07/17/UFKIw.png" alt="UFKIw.png"></p>
<p>应用直接怼到服务端，服务端直接将数据落盘。这大概就是最简单的系统架构了，我们看看秒杀系统是如何一步步的迭代的。</p>
<h3 id="扩容"><a class="header-anchor" href="#扩容">¶</a>扩容</h3>
<p>最简单的方式，肯定是扩容。<br>
<img src="https://s3.jpg.cm/2020/07/17/UFhU8.png" alt="UFhU8.png"></p>
<p>一套系统不够，两套，三套。看起来很美好，但是这种方案需要考虑</p>
<ul>
<li>数据分片：不同的实例如何将数据放置于不同的实例</li>
<li>请求路由：这样的架构势必要求用户能够在存有自己数据的那一套上进行访问</li>
<li>弹性困难</li>
</ul>
<p>因此根据这套系统略微的变形一下。</p>
<p><img src="https://s3.jpg.cm/2020/07/17/UFyxk.png" alt="UFyxk.png"></p>
<p>让应用自行进行数据分区的选择，简单来说，比如我们可以根据 <code>用户手机号</code> 取模，然后将数据定位某一台机器。</p>
<p><img src="https://s3.jpg.cm/2020/07/17/UFT6e.png" alt="UFT6e.png"></p>
<p>对于这样的规则可以选择的余地还是比较的多，<code>用户ID</code>，<code>生日</code>，只要数据均衡都比较好。对于这条路，我们发现社区已经有了 <a href="http://shardingsphere.apache.org/">shardingsphere</a> 这样的数据库中间件可以帮助我们。</p>
<h4 id="扩容遇见的问题"><a class="header-anchor" href="#扩容遇见的问题">¶</a>*扩容遇见的问题</h4>
<p>当我们在支撑更大规模的场景的时候，原有的系统不足够支撑的时候，我们又需要增加更多的 <code>Datebase</code> 的时候，我们遇见了一个问题。</p>
<p><img src="https://s3.jpg.cm/2020/07/17/UknjD.png" alt="UknjD.png"></p>
<p>因为多了一个数据节点，所有的数据需要重新<strong>锚定</strong>节点，这时候如何尽可能少的迁移数据，这时候就提出了 <a href="https://zh.wikipedia.org/zh-hans/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C">一致性Hash</a></p>
<hr>
<p>当然扩容并非是一条最好的选择，我们还要面临数据库中其实还有大量没有那么高频的数据，在这样的架构下，我们不就不得将一些同样的数据存多，当然也可以单独出一个 <code>Metadata</code> 的数据库。这套方案最为致命的问题应该是我们这样拆分之后，对于未来的系统开发有着非常大的限制，所有的批处理都要考虑多节点。因此在这套 <code>应用分库分表</code> 的基础上，会进化为出下一一个版本。</p>
<p><img src="https://s3.jpg.cm/2020/07/17/UkS48.png" alt="UkS48.png"></p>
<p>我们将分发的逻辑抽离出来，这样不就好了，如果可以的话最好还可以直接将这个<strong>分片逻辑</strong>变成业务无关性的。等等，此时是不是想到了我们熟悉的 <code>tidb</code> 了。</p>
<p><img src="https://s3.jpg.cm/2020/07/17/UkoPt.png" alt="UkoPt.png"></p>
<p>我们将整个 <code>Database Proxy</code> 和 <code>Database</code> 独立出来行成了 <code>NewSQL Database</code>，弹性扩容和伸缩都搞定了，岂不是很爽。对于开发者来说，再也不用担心数据库所带来的压力。</p>
<h3 id="异步化"><a class="header-anchor" href="#异步化">¶</a>异步化</h3>
<p>除了扩容之外，异步化也是一个很好的思路，因为对于数据库系统需要保证 <code>Atom</code> 特性，并且因为本身的数据结构的复杂，因此单一处理速度的上限并不算高。此时我们可以将用户的行为记录下来然后再顺序处理。</p>
<p>但是值得注意的是，异步化本身不能提高秒杀的最终写入速度，但是因为保护的系统（不会导致系统雪崩）整体上会让秒杀系统变的健壮，也变相让系统处理更快。</p>
<p><img src="https://s3.jpg.cm/2020/07/17/Umfqf.png" alt="Umfqf.png"></p>
<h4 id="异步化问题"><a class="header-anchor" href="#异步化问题">¶</a>异步化问题</h4>
<p>异步化本身会带来一个非常不舒服的体验，就是你可以只是拿到一个一个排队的序号，但是你并没有真正的落单。就像是彩票系统，我们买了事先就存在的号码，等到最终的摇号。</p>
<h3 id="缓存"><a class="header-anchor" href="#缓存">¶</a>缓存</h3>
<p>上面的方案完美了么？显然不是，虽然 <code>NewSQL</code> 带来的更大的并发，但是并发并非不是没有成本的，因为数据库系统从单机变成分布式，系统内的协调耗时增加，整个处理的链路会变的更加的慢，用户的体验不是非常的好，对于真の瞬时并发也是可能击穿的。因此我们还是需要额外的技能：缓存化。</p>
<p><img src="https://s1.ax1x.com/2020/07/18/UgHafP.png" alt="UgHafP.png"></p>
<div>
    <label class="author-mark-label">小声比比</label>
    <p class="author-mark">更多时候是成本问题，用内存能解决的问题换做磁盘，就会带来架构和复杂的上升，但是实际上架构是类似的。</p>
</div>
<p>因为缓存多数工作在 <code>内存</code> 中，并且不一定提供的可靠的 <code>持久化</code> 方案，换来的是更快的读写速度。</p>
<h4 id="缓存分片"><a class="header-anchor" href="#缓存分片">¶</a>缓存分片</h4>
<p>当一个Redis不够用的时候，自然需要需要多个 Redis 来支撑系统，不过由于 <code>Redis</code> 的发展较晚也比较的完善，自带了数据分片的 <code>Cluster</code> 组件 <a href="#%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F"><sup>参考3</sup></a>。</p>
<p><img src="https://s3.jpg.cm/2020/07/18/Uv4uU.png" alt="Uv4uU.png"></p>
<hr>
<p>架构就自然变成了</p>
<p><img src="https://s3.jpg.cm/2020/07/18/UvB4O.png" alt="UvB4O.png"></p>
<p>不过因为绝大多数的时候，我们都是混合使用 <code>DB in file</code>/<code>DB in memory</code> 这两种技术，绝大多数的时候我们的最终数据依然要落入  <code>Mysql</code> 这样的数据内，因此无论是在 <code>写入时刻</code> 将数据存入 <code>Mysql</code> 或者还是 <code>秒杀结束</code> 将数据存入 <code>Mysql</code> 都是可以的。</p>
<h2 id="秒杀后"><a class="header-anchor" href="#秒杀后">¶</a>秒杀后</h2>
<p>秒杀后的场景是：当某些客户进行秒杀成功之后就会疯狂的刷新自己的订单页面，而此时其他的客户可能仍在秒杀活动中。<br>
其实这段时间场景是简单的，可以直接将所有的数据都在 Redis 中进行处理，等到彻底所有的数据都刷新到磁盘上再切换至平时的系统，也可以增加缓存的方式都是可解的。</p>
<h1>场景工具箱</h1>
<p>想来我最喜欢的一句话</p>
<blockquote>
<p>技术就是对现象的有目的的编程。</p>
</blockquote>
<p>对于我们来说，我们就像是在一套工具箱中选择最适合的工具然后将目标达成。</p>
<p><img src="https://s3.jpg.cm/2020/07/18/Uv29k.png" alt="Uv29k.png"></p>
<p>当个工程师的意义也在于如何选择好的工具将我们的系统完成。</p>
<p><img src="https://s3.jpg.cm/2020/07/18/Uv0ki.png" alt="Uv0ki.png"></p>
<h1>聊一聊</h1>
<p>不得承认，现在的中国的程序员行业由于过度竞争，导致了面试的水涨船高，无论你之前是做什么行业什么工种，都喜欢问关于 <code>高并发</code> 系统的设计（大概也只有前端可幸免），导致慢慢的风气也从踏实解决问题变成了背诵式的架构面试。而真正的架构是一门实践技术，无论是看了多少网上的博客，最终如果不能在实践中获得反馈，那注定是收益有限的，因此也为什么大厂的场景是那么的值钱了。</p>
<hr>
<p>最初是基于 <code>现象</code>（内存比磁盘快，异步更稳定）的一系列物理现象，演化成了特定环境解决问题的解决方案（A pattern is a successful or efficient solution to a recurring problem within a context）称之为 <code>模式</code>，当 <code>模式</code> 反复使用，我们就付出一些代价分割为 <code>功能单元</code>(redis/mysql) ，然后再基于一些联系（即：工作架构 working architecute），将所有的模块/功能单元集在一起完成一个有目的的事情，也就是我们架构师所应尽的职能。</p>
<p><code>功能单元</code>因为随着时代在不断的迭代，因此架构师们也需要不断的和时代进步，才能完成一个正确的架构设计。</p>
<h1>参考</h1>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/34969168">负载均衡–一致性hash算法</a></li>
<li><a href="https://github.com/qiurunze123/miaosha">秒杀系统</a></li>
<li><a href="https://redis.io/topics/cluster-tutorial">Redis cluster tutorial</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>architecture</category>
      </categories>
      <tags>
        <tag>architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生的下一步</title>
    <url>/2020/07/30/architecture/next/</url>
    <content><![CDATA[<iframe width="100%" height="400" src="https://time.graphics/embed?v=1&id=398280" frameborder="0" allowfullscreen></iframe>
<div><a rel="nofollow" style="font-size: 12px; text-decoration: none;" title="Powered by Time.Graphics" href="https://time.graphics">Powered by Time.Graphics</a></div>
<span id="more"></span>
<p>从时间线看，我们大致上可以从 <code>2014</code> 开始作为 <code>微服务</code> 元年，作为首先践行 <code>微服务</code> 的 <code>SpringCloud</code> 体系，从 <code>2015</code> 年，那时候还没有 <code>CNCF</code> 的体系诞生，因此形成了如下的两条路线：</p>
<ol>
<li>Spring Cloud + Docker: 应用侧自行搞定微服务的基础设施</li>
<li>CNCF: 大包大揽的搞定基础设施</li>
</ol>
<h1>Spring Cloud 体系</h1>
<p>Spring Cloud 体系优势是一体化程度搞，从<code>Java</code>开发体系中选择一些人出来就可以成为 <code>Spring Cloud</code> 的开发者，但是问题也很多。</p>
<ul>
<li>异构语言的接入</li>
<li>研发要求的水涨船高</li>
</ul>
<h1>Cloud Native 体系</h1>
<p><code>Cloud Native</code> 体系立意就会比单纯的 <code>SpringCloud</code> 体系高一些，力争为所有的软件都提供统一的 <code>微服务</code>基础设施。在 <code>2020</code> 年的如今，我们的分布式系统基础设施已经完善了，<code>Cloud OS</code> 已经初具雏形，未来就是如何将这个 <code>New OS</code> 更好的服务于应用是我们值得思考的。</p>
<div>
    <label class="author-mark-label">夹带私货</label>
    <p class="author-mark"> 水一篇的博客，为了夹带我下面的 PPT 。</p>
</div>
<hr>
<p><code>Slides</code> 由 <a href="https://speakerdeck.com/"><code>speakerdeck</code></a> 或者 <a href="https://www.slideshare.net/"><code>slideshare</code></a> 提供服务，请使用合理方式打开。</p>
<script async class="speakerdeck-embed" data-id="3413a3cb3c3d4f6d8c73eed7e5eee502" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>architecture</category>
      </categories>
      <tags>
        <tag>architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次奇怪的Apollo配置中心错误</title>
    <url>/2018/05/20/bugs/a-strange-apollo-config-error/</url>
    <content><![CDATA[

<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<span id="more"></span>
<h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:apollo</span>=<span class="string">&quot;http://www.ctrip.com/schema/apollo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.ctrip.com/schema/apollo</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.ctrip.com/schema/apollo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">apollo:config</span> <span class="attr">namespaces</span>=<span class="string">&quot;mallcenter&quot;</span> <span class="attr">order</span>=<span class="string">&quot;-99999&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/sqlMapConfig.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath*:mybatis/*mapper.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cn.htd.zeus.mall.biz.dmo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cn.daocloud.**.dao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.htd.zeus.mall.common.util.XBasicDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;dataSource.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;dataSource.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;dataSource.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;dataSource.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;dataSource.initialSize&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动 项目的时候会报错  <code>$&#123;dataSource.initialSize&#125;</code> 不能转为 <code>int</code>，这个很容易知道是因为我们没有获取到配置 <code>dataSource.initialSize</code> 下面就漫长的分析之路。</p>
<h2 id="第一回合：怀疑-apollo-没有成功注册PostProcessBeanFactory"><a class="header-anchor" href="#第一回合：怀疑-apollo-没有成功注册PostProcessBeanFactory">¶</a>第一回合：怀疑 apollo 没有成功注册PostProcessBeanFactory</h2>
<p>因为这个项目是War项目，找个Tomcat镜像，war放进去RemoteDebug一下，我们知道 Apollo 是<br>
<code>com.ctrip.framework.apollo.spring.config.ConfigPropertySourcesProcessor</code> 在这个类装载的时候会注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, PropertySourcesPlaceholderConfigurer.class.getName(), PropertySourcesPlaceholderConfigurer.class);</span><br><span class="line">        BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, ApolloAnnotationProcessor.class.getName(), ApolloAnnotationProcessor.class);</span><br><span class="line">        BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, SpringValueProcessor.class.getName(), SpringValueProcessor.class);</span><br><span class="line">        BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, ApolloJsonValueProcessor.class.getName(), ApolloJsonValueProcessor.class);</span><br><span class="line">        <span class="built_in">this</span>.processSpringValueDefinition(registry);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>果不其然，还没有运行到这里的时候系统已经挂掉了，那问题可以大概确认，apollo 并没有起作用。</p>
<h2 id="第二回合：确认Spring在哪个阶段挂掉了"><a class="header-anchor" href="#第二回合：确认Spring在哪个阶段挂掉了">¶</a>第二回合：确认Spring在哪个阶段挂掉了</h2>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">  postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">  invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">  registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">  initMessageSource();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">  initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">  onRefresh();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">  registerListeners();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">  finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">  finishRefresh();</span><br></pre></td></tr></table></figure>
<p>上面的代码大家应该很熟悉，我们都知道Spring的顺序，通过Debug，我们发现Apollo在 <code>invokeBeanFactoryPostProcessors(beanFactory)</code> 阶段已经挂掉了，那问题到这里就有点清晰了，我们的Apollo作用的范围在 <code>invokeBeanFactoryPostProcessors</code>之后，那问题就来了，为什么我们的 <code>datasource</code> 对象在 <code>invokeBeanFactoryPostProcessors </code>阶段初始化？</p>
<h2 id="第三回合：抓住凶手"><a class="header-anchor" href="#第三回合：抓住凶手">¶</a>第三回合：抓住凶手</h2>
<p>上个Section我们知道，<code>invokeBeanFactoryPostProcessors</code> 系统挂掉，那为什么我们的 <code>datasource</code> 会在 <code>invokeBeanFactoryPostProcessors</code> 运行，从注释中，我们可以看出来这个阶段其实在注册 <code>factory processors</code>,通过Debug，我们发现了在注册完 Apollo之后，又注册了 <code>MapperScannerConfigurer</code>，<code>SqlSessionFactoryBean</code>, <code>XBasicDataSource</code>, DataSource 和 SqlSessionFactoryBean的关系很容易发现，写着呢，那 MapperScannerConfigurer 查看Google</p>
<blockquote>
<p>注 意 , 没 有 必 要 去 指 定 SqlSessionFactory 或 SqlSessionTemplate , 因 为 MapperScannerConfigurer 将会创建 MapperFactoryBean,之后自动装配。 ------&lt;第六章 注入映射器&gt;</p>
</blockquote>
<p>那我们明白，因为我们的注入了一个非必要的Bean在注册PostBeanFactory导致的失败。</p>


<div id="diagram"></div>
<script>
	var data =
	['Title: 此次错误启动时序图',
	 'Refresh()->invokeBeanFactoryPostProcessors(): 1.注册factory processors',
	 'invokeBeanFactoryPostProcessors()->MapperScannerConfigurer(): 2.构建MapperScannerConfigurer',
	 'MapperScannerConfigurer()->SqlSessionFactoryBean(): 3.构建SqlSessionFactoryBean',
	 'SqlSessionFactoryBean()->XBasicDataSource(): 4.构建XBasicDataSource',
	 'Note left of XBasicDataSource(): 此阶段的ApolloConfig没有成功注入',
	 ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple'});
</script>

<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
        <category>apollo</category>
      </categories>
  </entry>
  <entry>
    <title>兵法与项目管理</title>
    <url>/2019/04/13/cs/art-of-software/</url>
    <content><![CDATA[<p>孙子兵法有云：“凡战者，以正合，以奇胜。” 讲的是从战略是正面要刚得住，而依靠一支尖刀部队打开战场的僵局，而获得战场的胜利。项目管理也应担如此，然而往往大部分的项目截取了后半段而忽略了前半段，呜呼哀哉。</p>
<p>现代软件工程也存在着形如蒙代尔三角，质量，成本，风险。当控制得了风险和成本，那就不能要求太高的质量。</p>
<span id="more"></span>
<p><img src="https://i.loli.net/2019/04/13/5cb1fbec0c3c9.png" alt=""></p>
<p>当要求质量和成本，那就得面临巨大的项目风险（System/360 Operating System），而这一切就取决于你如何选择，对于传统的ToB项目来说，成本相对固定（固定的工期和固定的人员投入），而此时我们为了追求可以结项拿钱，我们不得不降低软件的成本，而低质量的交付软件意味着没有二期项目，而二期又是大部分的ToB赚钱的核心。那对于企业来说，这样难道是无解之道？那当然不对，对于企业来说，聪明的你一定会想到，为什么我们不从源头解决这个问题，卖的贵一点不就好了，但是很抱歉，当你的价格上升的时候，就意味着你的竞争力下降，那你又如何获得这笔订单呢，对于一个充分成熟的市场，寄希望于单方面的提高价格是困难的，那还有什么办法，既然涨不了价格，那我可以降低人员成本，这也是大部分企业的选择，如何降低员工成本，又分为降低员工的工资，和提高员工的效率。聪明的企业往往选择后面一种，企业培训，采购更好的协作平台，使用更好的合作模式，都是在提高员工的效率。但显然这个路也是有尽头的，而且异常的难做。有没有什么轻松的办法呢？降低工资这个太影响士气，往往不到生死存亡的时候并不会选择这样的方式，啪，灵光乍现，我可以让员工承担更多的职能，这样的话，不就可以了？原本的开发可以兼职售前，售后，交付。这样我们可以成本上直接降低，我们就可以大幅度的提高软件质量，降低成本。但是这条路和上面的路类似，有一个不得不去面对的问题，让员工变成一条龙开发工程师，就真的会让企业的成本降低吗？我的答案是否定的，我们可以把身兼数职的人比喻成特种兵，自古以来有依靠特种兵完成全面战场胜利的案例吗？显然是没有的，中国的先人早就知道，好钢用在刀刃上。因为这样的复合型人才是极为的稀缺的，正如以奇胜的那个单独的军事单位，而在漫长的软件开发过程中，我们是正面战场需要的是精密合作的怀揣不同技能的人才，无论多么富有才能的人，最终也得面临精力的衰退。</p>
<p>再说说，全栈工程师，有人对全站工程的误会很深，觉得是全栈即是全都做，非也非也，在经济学的奠基之作《国富论》中早已提出，分工是提高社会效率的有效方式，而且全都做和这个相悖的，显然是错误的，而真正的全栈的含义是，如何有效的进行分工，之前的分工模式以简单粗暴的前端，后台，项目经理等等角色为分工，这样的分类是低效的，而且全栈的存在正是对这个分工的反思，我们为什么要用固定的角色分类来进行分工，技能的熟练程度，对业务的理解，这些都分工值得参考的依据。</p>
<p>John.Boddie在1987年出版的《Crunch Mode》一书提出了“两难境地”，处于“两难境地” 的项目面临着无法达到最初目标的威胁，而项目团队在努力想要跨越该困境。软件工程本身就会面临这样的两难境地，或长或短，短期的两难境地是常见，也是无法避免的，而长期的两难境地会变成“死亡行军”，Ed.Yourdon在1997年出版的《Death March》一书提出，而这个词也同样是由那些被迫在“死亡行军”项目中行走的人们发明的，通常用来描述进度表几乎不可能完成的项目，说明项目参与者的周围弥漫着的是难以忍受的潜在的失败气味。在漫长的死亡行军中，就很难保证项目的质量，团队的士气，而终点也不再具有真实的意义，人们纷纷在中路就死亡了，一个无法抵达的终点和没有终点又有什么区别呢。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://github.com/lifesinger/blog/issues/185">说说全栈工程师</a></li>
<li><a href="https://book.douban.com/subject/1073041/">软件开发的滑铁卢</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>使用Daocloud持续部署Hexo</title>
    <url>/2016/05/26/docker/use-daocloud-hexo/</url>
    <content><![CDATA[<p>开始写博客，不太喜欢CSDN之类的技术博客，还是喜欢维护自己的博客网站，买了一个域名也一直没用，虽然手上也有一个ECS，但是搭建一个WordPress真的挺麻烦，而且只是想做一个安静的美男子。选来选取还是全静态的博客比较适合我这样的懒人，现在Github page使用的静态博客很轻便，大致上现在就是Jekyll 和 Hexo <a href="https://www.zhihu.com/question/21981094">优缺点对比</a>. 总而言之，咱们也不能沦为设备党，还是应该以内容为主。</p>
<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>静态博客的核心就在于整个生成的网站是全静态，没有任何与服务器交互的部分，所以服务器只要提供HTTP服务即可，所以可以部署在Github, Coding, BAE最便宜的静态实例之上。这些都是网上的教程很多，大家百度一波就好了，就在我把自己的HEXO博客挂在BAE的静态实例之上，就在考虑为什么不把博客放在Daoclou之上呢，Docker的容器化简直是现在是最火的方向。</p>
<p>整理下思路，大致上也就是</p>
<ol>
<li>Step 1 ：打包一个Http server</li>
<li>Step 2 ：把Pages放进web目录</li>
<li>Step 3 ：启动服务器</li>
</ol>
<p>思路搞清楚，那我们就开始搞起来吧，首先我们需要的是一个WebServer，Nginx大家都耳熟能详，我们仅仅需要的是一个web 服务器，所以我选择使用Lighttpd，为什么选择这个可能是看见Light，我觉得占用的内存会低很多，毕竟我们使用的是免费的资源，配置还是很一般的。</p>
<h2 id="编写Dockerfile"><a class="header-anchor" href="#编写Dockerfile">¶</a>编写Dockerfile</h2>
<p>Dockerfile</p>
<pre><code>FROM jprjr/lighttpd
#添加静态页面
ADD public/ /srv/http/
#启动服务器
ENTRYPOINT [&quot;lighttpd&quot;, &quot;-D&quot;, &quot;-f&quot;, &quot;/etc/lighttpd/lighttpd.conf&quot;]
</code></pre>
<p>内容只有这么多，注意public目录是放置Hexo generate 生成的全静态页面目录</p>
<h2 id="部署项目"><a class="header-anchor" href="#部署项目">¶</a>部署项目</h2>
<p>首先当然将我们的代码上传至Coding or Github，建议对国有的支持，我选择了将整个项目创建于 Coding上，最终的项目如<br>
<a href="https://coding.net/u/yann/p/my-blog-page/git">Coding-Hexo-项目</a></p>
<ol>
<li>创建一个新的构建<br>
<img src="http://cache.yannxia.info/%E5%88%9B%E5%BB%BA%E6%96%B0%E6%9E%84%E5%BB%BA.png" alt="创建新构建"><br>
<img src="http://cache.yannxia.info/%E6%9E%84%E5%BB%BA%E6%88%90%E5%8A%9F.png" alt="构建成功"></li>
<li>构建成功后进行部署<br>
<img src="http://cache.yannxia.info/%E6%9E%84%E5%BB%BA%E6%88%90%E5%8A%9F.png" alt="部署成功"><br>
<img src="http://cache.yannxia.info/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D.png" alt="绑定域名"><br>
最后就是一路下一步，等待成功就Ok</li>
</ol>
<h2 id="检验成果"><a class="header-anchor" href="#检验成果">¶</a>检验成果</h2>
<p>从执行的域名就可以访问，<br>
<img src="http://cache.yannxia.info/5D5B2352-D79F-4AE1-936B-8046C3B39490.png" alt="访问域名"></p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>整来来说这么使用Daocloud进行Docker部署和Bae部署Hexo的静态是一样的道理，也能做到持续集成，但是我们仍然和hexo的命令没有完整的结合在一起，下一步实现一个Hook或者使用Python编写一个基于主分支修改之后，Daocloud也可以自动更新的方案。</p>
<p>最后的最后，感谢Daocloud提供服务。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Docker</category>
        <category>Daocloud</category>
        <category>Ci</category>
        <category>Lighttpd</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Daocloud</tag>
        <tag>Ci</tag>
        <tag>Lighttpd</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用C语言写一个五子棋</title>
    <url>/2017/01/20/game/how-to-code-gobang-in-c/</url>
    <content><![CDATA[<p>为什么突然想起来写这么个东西，大概是有一天，突然想测试下自己的C语言到底还记得多少。<br>
就找了年末没什么事情的时候，花了大概2个小时撸了一个这么个东西。<br>
<a href="https://github.com/yannxia-self/renju-c">renju-c 源码下载</a></p>
<span id="more"></span>
<h2 id="我们需要怎么个东西"><a class="header-anchor" href="#我们需要怎么个东西">¶</a>我们需要怎么个东西</h2>
<p>大概是我们需要一个黑框框里面能过下五子棋的东西。</p>
<h2 id="完善需求"><a class="header-anchor" href="#完善需求">¶</a>完善需求</h2>
<p>我们需要的是 能够双人进行五子棋游戏的一个小程序。</p>
<h2 id="我的计划是"><a class="header-anchor" href="#我的计划是">¶</a>我的计划是</h2>
<p>我需要这么几个函数</p>
<ul>
<li>显示棋盘</li>
<li>下棋</li>
<li>判断胜负</li>
</ul>
<h2 id="如何实现我的计划"><a class="header-anchor" href="#如何实现我的计划">¶</a>如何实现我的计划</h2>
<p>简单的画了一个图</p>
<iframe id="embed_dom" name="embed_dom" frameborder="0" style="border:1px solid #000;display:block;width:430px; height:400px;" src="https://www.processon.com/embed/5881d2bbe4b098bf4cee4a2a"></iframe>
<h3 id="1-绘图的逻辑"><a class="header-anchor" href="#1-绘图的逻辑">¶</a>1. 绘图的逻辑</h3>
<p>标准的五子棋是 19 x 19，那我们很直觉的使用一个二维数组.初始化都是 *，绘图直接打印出这个棋盘就好了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHESSBOARD_SIZE 19 <span class="comment">//19 * 19 size</span></span></span><br><span class="line"><span class="type">char</span> chessboard[CHESSBOARD_SIZE][CHESSBOARD_SIZE]; <span class="comment">//整个棋盘</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; CHESSBOARD_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; CHESSBOARD_SIZE; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            chessboard[i][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-判断的逻辑"><a class="header-anchor" href="#2-判断的逻辑">¶</a>2. 判断的逻辑</h3>
<p>这个项目最复杂的就是判断如何成立了，我的逻辑是这样的。</p>
<p>蓝色的在中间，就是我们需要判断的棋子，我们可以从 竖横的方向 和 斜的方向去判断是否有五个字。</p>
<p>比如图示中，我们假设 蓝色点是 (a,b) 点，我们先从左侧找，最长的同色我们发现是2个，我们再向后找最长同色，我们发现是0个，那我们只有 2+1[自身] = 3 就是3个。</p>
<iframe id="embed_dom" name="embed_dom" frameborder="0" style="border:1px solid #000;display:block;width:800px; height:400px;" src="https://www.processon.com/embed/5881d5bae4b049e795be4834"></iframe>
<p>具体的参见代码</p>
<h3 id="3-下棋的逻辑"><a class="header-anchor" href="#3-下棋的逻辑">¶</a>3. 下棋的逻辑</h3>
<p>这个逻辑就不是很复杂，就是分为检测，不允许下在同一个位置，并且在棋盘内，就是一个Scanf的问题。</p>
<h2 id="一些细枝末节"><a class="header-anchor" href="#一些细枝末节">¶</a>一些细枝末节</h2>
<h3 id="1-关于清屏幕"><a class="header-anchor" href="#1-关于清屏幕">¶</a>1. 关于清屏幕</h3>
<p>因为清屏幕是必须的··保证游戏的可玩性，一开始我调用了 system(“clear”) ,不过这里的问题有了，如果是在windows上，这个时候，我们唯一能做的就是是否能够在运行时判断操作性，不过好像做不到，<br>
只能找到一个基于编译器的判断编译器的方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clearscr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(unix) || defined(__unix__) || defined(__unix) || (defined(__APPLE__) &amp;&amp; defined(__MACH__))</span></span><br><span class="line">    system(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line"><span class="comment">//add some other OSes here if needed</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;OS not supported.&quot;</span></span></span><br><span class="line"><span class="comment">//you can also throw an exception indicating the function can&#x27;t be used</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-如何处理-0，0-点"><a class="header-anchor" href="#2-如何处理-0，0-点">¶</a>2. 如何处理 0，0 点</h3>
<p>这个时候遇见的问题就是 左边偏移量是越界的怎么办，两个办法。</p>
<ul>
<li>把棋盘变成 30 * 30 ,我们只有中间 19*19</li>
<li>处理越界下标都处理为 棋盘属性</li>
</ul>
<p>最后选择了第二种</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">get_piece</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (BETWEEN_IN_SIZE(x + <span class="number">1</span>) &amp;&amp; BETWEEN_IN_SIZE(y + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> chessboard[x][y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>算了完成了自己多年之前想做了一个东西，实际上的确不是很复杂。给C初学者了一点小小的启示。如果有问题可以在下面提或者在Github，我会尽量回答的。</p>
<h2 id="Next"><a class="header-anchor" href="#Next">¶</a>Next</h2>
<p>准备下次做一个自动下棋的AI，大家期待一下吧。撒花完结。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C</category>
        <category>Game</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Generic</title>
    <url>/2022/03/17/go/generic/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/202203161135891.png" alt=""></p>
<p>在最近发布的 <code>go 1.18</code> 的版本中，泛型被正式发布，我们可以来尝鲜了，当然现在学习是最简单的时候。<code>go</code> 的 <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">泛型提案</a> 本文大部分翻译从此。</p>
<span id="more"></span>
<h2 id="Overview"><a class="header-anchor" href="#Overview">¶</a>Overview</h2>
<ul>
<li css-module=".">函数可以有一个额外的类型参数列表，它使用方括号，但在其他方面看起来像一个普通的参数列表: func f [ t any ](p t)</li>
<li>这些类型参数可以由常规参数和在函数体中使用。</li>
<li>类型还可以有一个类型参数列表: 类型 m [ t any ][] t (any 就是任意类型)</li>
<li>每个类型参数都有一个类型约束，就像每个普通参数都有一个类型: func f [ t Constraint ](p t){ … }。</li>
<li>接口类型的类型约束。</li>
<li>新的预声明名 <code>any</code> 是允许任何类型的类型约束。</li>
<li>作为类型约束使用的接口类型可以嵌入额外的元素来限制满足约束的类型参数集:
<ul>
<li>任意类型 <code>T</code> 限制为该类型</li>
<li>近似元素 <code>~T</code> 限制所有基础类型为T的类型</li>
<li>并集元素 <code>T1 | T2 |…</code> 限制为列出的任何元素</li>
</ul>
</li>
<li>泛型函数只能使用约束允许的所有类型支持的操作。</li>
</ul>
<h2 id="设计实现"><a class="header-anchor" href="#设计实现">¶</a>设计实现</h2>
<h3 id="Type-parameters"><a class="header-anchor" href="#Type-parameters">¶</a>Type parameters</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s []T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着在函数 Print 中，标识符 t 是一个类型参数，这个类型当前未知，但在调用函数时将是已知的。Any 意味着 t 可以是任何类型。如上所示，在描述普通非类型参数的类型时，类型参数可用作类型。它也可以用作函数体中的类型。</p>
<h3 id="Constraints-约束"><a class="header-anchor" href="#Constraints-约束">¶</a>Constraints 约束</h3>
<h4 id="任意约束"><a class="header-anchor" href="#任意约束">¶</a>任意约束</h4>
<p>我们知道在 <code>GO</code> 中 <code>interface&#123;&#125;</code> 是代表任意值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Print prints the elements of any slice.</span></span><br><span class="line"><span class="comment">// Print has a type parameter T and has a single (non-type)</span></span><br><span class="line"><span class="comment">// parameter s which is a slice of that type parameter.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span>[<span class="title">T</span> <span class="title">interface</span></span>&#123;&#125;](s []T) &#123;</span><br><span class="line">	<span class="comment">// same as above</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就能够表达为接受任意类型的 Print，但是很多时候我们希望只有部分类型才能传入</p>
<h4 id="类型约束"><a class="header-anchor" href="#类型约束">¶</a>类型约束</h4>
<p>比如我们约定了一个 Stringer 类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以这些表达 Print 函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stringify</span>[<span class="title">T</span> <span class="title">Stringer</span>]<span class="params">(s []T)</span></span> (ret []<span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, v.String())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多类型约束的话，我们可以这么来申明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plusser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Plus(<span class="type">string</span>) <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcatTo</span>[<span class="title">S</span> <span class="title">Stringer</span>, <span class="title">P</span> <span class="title">Plusser</span>]<span class="params">(s []S, p []P)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	r := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		r[i] = p[i].Plus(v.String())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型参数"><a class="header-anchor" href="#泛型参数">¶</a>泛型参数</h2>
<p>之前我们定义一个接受任意类型的数组是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vector is a name for a slice of any element type.</span></span><br><span class="line"><span class="keyword">type</span> Vector []<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vector is a name for a slice of any element type.</span></span><br><span class="line"><span class="keyword">type</span> Vector[T any] []T</span><br></pre></td></tr></table></figure>
<p>当然可以函数约束一样，可以使用类型约束</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义够传入 int 的数组</span></span><br><span class="line"><span class="keyword">var</span> v Vector[<span class="type">int</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以泛型的实现函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vector[T])</span></span> Push(x T) &#123; *v = <span class="built_in">append</span>(*v, x) &#125;</span><br></pre></td></tr></table></figure>
<p>不过要注意</p>
<blockquote>
<p>Although methods of a generic type may use the type’s parameters, methods may not themselves have additional type parameters. Where it would be useful to add type arguments to a method, people will have to write a suitably parameterized top-level function.</p>
</blockquote>
<p>Go 并没有实现，函数类型中的泛型</p>
<h2 id="约束单元"><a class="header-anchor" href="#约束单元">¶</a>约束单元</h2>
<h3 id="任意约束-v2"><a class="header-anchor" href="#任意约束-v2">¶</a>任意约束</h3>
<p>就是没有约束的话，也就是 any， 我们知道了</p>
<h3 id="近似约束（Approximation-constraint-element）"><a class="header-anchor" href="#近似约束（Approximation-constraint-element）">¶</a>近似约束（Approximation constraint element）</h3>
<p>我们只需要某个特定的函数实现的话，我们就可以使用这样的约束</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意基础类型是 string 的约束</span></span><br><span class="line"><span class="keyword">type</span> AnyString <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="联合约束"><a class="header-anchor" href="#联合约束">¶</a>联合约束</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PredeclaredSignedInteger is a constraint that matches the</span></span><br><span class="line"><span class="comment">// five predeclared signed integer types.</span></span><br><span class="line"><span class="keyword">type</span> PredeclaredSignedInteger <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="type">int</span> | <span class="type">int8</span> | <span class="type">int16</span> | <span class="type">int32</span> | <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于这个逻辑我们就可以定义 比如 <code>可以比较</code>的类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span> |</span><br><span class="line">		~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span> |</span><br><span class="line">		~<span class="type">float32</span> | ~<span class="type">float64</span> |</span><br><span class="line">		~<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口参数"><a class="header-anchor" href="#接口参数">¶</a>接口参数</h2>
<p>除了，我们可以使用类型放置于参数中。我们还可以使用 接口作为参数类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span>[<span class="title">F</span>, <span class="title">T</span> <span class="title">any</span>]<span class="params">(s []F, f <span class="keyword">func</span>(F)</span></span> T) []T &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>非常标准的 MAP 函数，从 F 转换为 T</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int64</span> &#123; <span class="keyword">return</span> <span class="type">int64</span>(i) &#125;</span><br><span class="line"><span class="keyword">var</span> r []<span class="type">int64</span></span><br><span class="line"><span class="comment">// Specify both type arguments explicitly.</span></span><br><span class="line">r = Map[<span class="type">int</span>, <span class="type">int64</span>](s, f)</span><br><span class="line"><span class="comment">// Specify just the first type argument, for F,</span></span><br><span class="line"><span class="comment">// and let T be inferred.</span></span><br><span class="line">r = Map[<span class="type">int</span>](s, f)</span><br><span class="line"><span class="comment">// Don&#x27;t specify any type arguments, and let both be inferred.</span></span><br><span class="line">r = Map(s, f)</span><br></pre></td></tr></table></figure>
<h2 id="尚未包含的"><a class="header-anchor" href="#尚未包含的">¶</a>尚未包含的</h2>
<ul>
<li>没有专门化。没有办法编写一个泛型函数的多个版本，这些版本被设计用于处理特定的类型参数。也就是比如我处理 T any 的泛型，就没办法单独处理 T one 类型的</li>
<li>没有元编程。没有办法编写在编译时执行的代码来生成在运行时执行的代码。</li>
<li>没有更高层次的抽象。除了调用或实例化函数之外，没有办法使用具有类型参数的函数。除了实例化泛型类型之外，没有其他方法可以使用它。</li>
<li>没有一般的类型描述。为了在泛型函数中使用运算符，约束列出特定的类型，而不是描述类型必须具有的特征。这很容易理解，但有时可能会受到限制。</li>
<li>函数参数没有协边 和 逆变。</li>
<li>无操作符方法。您可以编写一个编译时类型安全的泛型容器，但是只能使用普通方法访问它，而不能使用 c [ k ]这样的语法。</li>
<li>没有柯里化。除了使用 helper 函数或包装器类型之外，没有办法部分地实例化泛型函数或类型。所有类型参数必须在实例化时显式传递或推断。</li>
<li>没有可变类型参数。不支持可变参数类型参数，这将允许编写单个泛型函数，该函数接受不同数量的类型参数和常规参数。</li>
<li>没有适配器。约束无法定义可用于支持尚未实现约束的类型参数的适配器，例如，根据 Equal 方法定义 = = 操作符，反之亦然。</li>
<li>对于非类型的值，如常量，没有参量化。对于数组来说，这种情况最为明显，在这种情况下，编写类型 Matrix [ n int ][ n ][ n ][ n ] float64可能很方便。有时，为容器类型指定有效值(如元素的默认值)也是有用的。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>go</category>
        <category>generic</category>
      </categories>
  </entry>
  <entry>
    <title>Go Impossible Missions</title>
    <url>/2021/04/30/go/go-impossible-missions/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210430161943.png" alt=""></p>
<p>主要就是为了吐槽 <code>GO</code></p>
<span id="more"></span>
<h2 id="模板方法"><a class="header-anchor" href="#模板方法">¶</a>模板方法</h2>
<p>在绝大多数的 <code>OOP</code> 语言中，我们都希望，我们可能在父类中完成绝大多数的任务，子类仅仅完成一部分的任务即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Named</span> &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">firstName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name().split(<span class="string">&quot;/&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们实现 <code>EN</code> 和 <code>CN</code> 的版本时候，只需要。</p>
<div class="tabs" id="named"><ul class="nav-tabs"><li class="tab active"><a href="#named-1">EnglishNamed</a></li><li class="tab"><a href="#named-2">ChineseNamed</a></li></ul><div class="tab-content"><div class="tab-pane active" id="named-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EnglishNamed</span> <span class="keyword">implements</span> <span class="title class_">Named</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;jack/ma&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="named-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChineseNamed</span> <span class="keyword">implements</span> <span class="title class_">Named</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;春/天&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p>对于获取 <code>FirstName</code> 的逻辑是一致的。</p>
<p>那如果我们使用 <code>GO</code> 来实现的话。</p>
<div class="tabs" id="gonamed1"><ul class="nav-tabs"><li class="tab active"><a href="#gonamed1-1">EnglishNamed</a></li><li class="tab"><a href="#gonamed1-2">ChineseNamed</a></li></ul><div class="tab-content"><div class="tab-pane active" id="gonamed1-1"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EnglishNamed <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EnglishNamed)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;jack/ma&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EnglishNamed)</span></span> FirstName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strings.Split(e.Name(), <span class="string">&quot;/&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="gonamed1-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ChineseNamed <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ChineseNamed)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;jack/ma&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ChineseNamed)</span></span> FirstName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strings.Split(e.Name(), <span class="string">&quot;/&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div>
<p>我们发现其实我们有一个 <code>重复的</code> 代码。为了让这个代码不重复，单纯的依靠组合不能够达成。我们需要修改下实现的方式，重新定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Name <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Named <span class="keyword">interface</span> &#123;</span><br><span class="line">	Name() Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n Name)</span></span> FirstName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strings.Split(<span class="type">string</span>(n), <span class="string">&quot;/&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再来实现对象</p>
<div class="tabs" id="gonamed"><ul class="nav-tabs"><li class="tab active"><a href="#gonamed-1">EnglishNamed</a></li><li class="tab"><a href="#gonamed-2">ChineseNamed</a></li></ul><div class="tab-content"><div class="tab-pane active" id="gonamed-1"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EnglishNamed <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EnglishNamed)</span></span> Name() Name &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;jack/ma&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="gonamed-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ChineseNamed <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ChineseNamed)</span></span> Name() Name &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;jack/ma&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p>使用 <code>Rust</code> 我们可以实现和 <code>Java</code> 类似的代码。<code>go</code> 缺失在 <code>inteface</code> 没有 <code>default method</code></p>
<h2 id="Deep-Equal"><a class="header-anchor" href="#Deep-Equal">¶</a>Deep Equal</h2>
<p>我们经常会有这么一个需求，比如我有一个对象 A，包含了对象 B，又包含了对象 C，我希望 <a href="http://C.xxx">C.xxx</a> 字段如果是 True 就进行一些处理</p>
<figure class="highlight go"><figcaption><span>基础定义</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">	B *B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">	C *C</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;</span><br><span class="line">	Flag <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是 <code>go</code> 只能写出如下代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDo</span><span class="params">(a *A)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a != <span class="literal">nil</span> &amp;&amp; a.B != <span class="literal">nil</span> &amp;&amp; a.B.C != <span class="literal">nil</span> &amp;&amp; a.B.C.Flag &#123;</span><br><span class="line">		<span class="comment">//Do something</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对比之下，Java 可以写出略微优雅的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifDo</span><span class="params">(A a)</span>&#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">ifCondition</span> <span class="operator">=</span> Optional.ofNullable(a)</span><br><span class="line">            .map(A::getB)</span><br><span class="line">            .map(B::getC)</span><br><span class="line">            .map(C::isFlag)</span><br><span class="line">            .orElse(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而到了 <code>Rust | kotlin</code> 我们可以借助于语法糖</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">doIf</span>(a: <span class="type">Option</span>&lt;A&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">bool</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> a?.b?.c &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(it) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Option</span>::<span class="title function_ invoke__">Some</span>(it.flag);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; <span class="type">Option</span>::<span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>go</category>
        <category>rust</category>
      </categories>
  </entry>
  <entry>
    <title>Go 面试汇总</title>
    <url>/2020/07/29/go/interview/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/07/29/bnUSE.png" alt="bnUSE.png"></p>
<p>作为一个跨界的 <code>Java Boy</code> 面对 <code>Go</code> 的岗位还是先整理一波。</p>
<span id="more"></span>
<h1>Go 的 Goroutine</h1>
<p>CSP，全称Communicating Sequential Processes，意为通讯顺序进程，它是七大并发模型中的一种，它的核心观念是将两个并发执行的实体通过通道channel连接起来，所有的消息都通过channel传输，Go语言对CSP并发模型的实现——GPM调度模型。</p>
<p>GPM代表了三个角色，分别是<code>Goroutine</code>、<code>Processor</code>、<code>Machine</code>。</p>
<p><img src="https://s3.jpg.cm/2020/07/29/bnRyC.png" alt="bnRyC.png"></p>
<ul>
<li><code>Goroutine</code>：承担运行的实体</li>
<li><code>Processor</code>： 联通 G 和 M 的处理器</li>
<li><code>Machine</code>： 操作系统的调度单位：线程</li>
</ul>
<p><img src="https://s3.jpg.cm/2020/07/29/bnW7t.png" alt="bnW7t.png"></p>
<p><code>Machine</code> 和 <code>Processor</code> 是 <code>1:1</code>，我们创建的 <code>Goroutine</code> 会通过放入 <code>Queue</code> 让 <code>Processor</code> 在 <code>Machine</code> 执行。<br>
不过值得注意，在实现的过程中，有一种名为  <code>work-stealing</code> 的算法，如果某个 <code>Machine</code> 的 <code>Queue</code> 为空的时候会尝试从其他地方偷点回来。</p>
<div>
    <label class="author-mark-label">题外话</label>
    <p class="author-mark">Java体系中： JDK1.7引入的Fork/Join框架就是基于工作窃取算法。</p>
</div>
<p>单纯的从图上看，我们至少提出几个问题</p>
<ul>
<li><code>Goroutine</code> 如何调用了 <code>Systemcall</code> 在阻塞状态会怎么样</li>
<li><code>Goroutine</code> 如何保证时间公平</li>
</ul>
<h2 id="Go的调度"><a class="header-anchor" href="#Go的调度">¶</a>Go的调度</h2>
<p>OS 调度器是一个<code>抢占式</code>调度器。Go 调度器在内核之上的用户空间中运行。Go 调度器的当前实现不是抢占式调度器，而是协作式调度器。</p>
<p>Go 的状态也有三种状态：</p>
<ul>
<li><code>Waiting：这意味着</code> Goroutine 已停止并等待一些事情以继续。这可能是因为等待操作系统（系统调用）或同步调用（原子和互斥操作）等原因。这些类型的延迟是性能下降的根本原因。</li>
<li><code>Runnable</code> ：这意味着 Goroutine 需要M上的时间片，来执行它的指令。如果同一时间有很多 Goroutines 在竞争时间片，它们都必须等待更长时间才能得到时间片，而且每个 Goroutine 获得的时间片都缩短了。这种类型的调度延迟也可能导致性能下降。</li>
<li><code>Executing</code> ：这意味着 Goroutine 已经被放置在M上并且正在执行它的指令。</li>
</ul>
<h3 id="系统调用"><a class="header-anchor" href="#系统调用">¶</a>系统调用</h3>
<p>对于大部分的 <code>Blocking</code> 系统调用，都是直接将这个阻塞的 <code>G</code> 从 <code>M</code> 卸载下来，换上其他的 <code>G</code> 进行运行。略有不同的，对于异步的系统调用 <code>GO</code> 实现一种 <code>NetPoller</code> 机制，这些操作并不在 <code>M</code> 进行操作，会将这个 <code>Go</code> 移动到 <code>Netpoller</code> 进行操作。这里其实也就是高性能 <code>Web</code> 的核心，不要在 <code>Blocking</code> 进行阻塞。</p>
<p><img src="https://s3.jpg.cm/2020/07/29/bnVVD.png" alt="bnVVD.png"></p>
<h1>CGo 的低效问题</h1>
<p>在 <code>dave</code> 的 <a href="https://dave.cheney.net/2016/01/18/cgo-is-not-go"><code>cgo is not go</code></a> 中写到了</p>
<blockquote>
<p>C doesn’t know anything about Go’s calling convention or growable stacks, so a call down to C code must record all the details of the goroutine stack, switch to the C stack, and run C code which has no knowledge of how it was invoked, or the larger Go runtime in charge of the program.</p>
</blockquote>
<p>Cgo在编译的时候会为代码生成大量的中间文件。 在一个Go源文件中，如果出现了import &quot;C&quot;指令则表示将调用cgo命令生成对应的中间文件。整个过程会涉及到大量的 <code>堆栈</code>切换</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Go --&gt; runtime.cgocall --&gt; runtime.entersyscall --&gt; runtime.asmcgocall --&gt; _cgo_Cfunc_f</span><br><span class="line">                                                                                 |</span><br><span class="line">                                                                                 |</span><br><span class="line">Go &lt;-- runtime.exitsyscall &lt;-- runtime.cgocall &lt;-- runtime.asmcgocall &lt;----------+</span><br></pre></td></tr></table></figure>
<h1>Go 的常见姿势</h1>
<h2 id="Channel-关闭"><a class="header-anchor" href="#Channel-关闭">¶</a>Channel 关闭</h2>
<p>因为关闭一个 <code>Channel</code> 之后，依然可以从中获得数据，因此一个适用的原则是不要从接收端关闭channel，也不要关闭有多个并发发送者的channel。</p>
<ul>
<li>channel 只有一个发送方的情况：直接等到发送完毕关不即可</li>
<li>channel 有多个发送方一个接收方： 额外增加一个 channel ，让接收方通知发送方关闭，因为消息只有一次，因此只有一个人可以关闭</li>
<li>channel 有多个发送方以及多个接收方: 增加一个调停者，等条件满足的时候通知发送方关闭即可。</li>
</ul>
<h1>其他</h1>
<ul>
<li>go defer: FILO 特性，不过值得注意的是在 <code>Return</code> 之前，<code>PAIN</code> 可以看做一种 <code>Retrun</code></li>
<li>chan 缓冲/无缓冲：channel<code>无缓冲</code>时，发送阻塞直到数据被接收，接收阻塞直到读到数据。channel<code>有缓冲</code>时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。</li>
</ul>
<h1>参考</h1>
<ul>
<li><a href="https://github.com/lifei6671/interview-go/blob/master/base/go-scheduler-base.md">goroutine调度器概述</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title>Opentelemetry Collector 源码解读</title>
    <url>/2021/03/26/go/ot/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210326194325.png" alt=""></p>
<p><code>opentelemetry</code> 作为 <code>CNCF</code> 社区的全新项目，最为核心的就是 <code>Collector</code></p>
<span id="more"></span>
<h2 id="核心"><a class="header-anchor" href="#核心">¶</a>核心</h2>
<p><code>Collector</code> 由三种组件构建而成</p>
<ul>
<li><code>Receivers</code>: 接受数据</li>
<li><code>Processors</code>: 处理数据</li>
<li><code>Exporters</code>: 将数据暴露出去</li>
</ul>
<p>使用一种 <code>pipelines</code> 将这三者聚合而来，除此之外还有一些 <code>extensions</code> 用来拓展 <code>collector</code></p>
<figure class="highlight yaml"><figcaption><span>common</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">receivers:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">protocols:</span></span><br><span class="line">      <span class="attr">grpc:</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="attr">batch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">exporters:</span></span><br><span class="line">  <span class="attr">otlp:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">otelcol:55680</span></span><br><span class="line"></span><br><span class="line"><span class="attr">extensions:</span></span><br><span class="line">  <span class="attr">health_check:</span></span><br><span class="line">  <span class="attr">pprof:</span></span><br><span class="line">  <span class="attr">zpages:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">extensions:</span> [<span class="string">health_check</span>,<span class="string">pprof</span>,<span class="string">zpages</span>]</span><br><span class="line">  <span class="attr">pipelines:</span></span><br><span class="line">    <span class="attr">traces:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">otlp</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">otlp</span>]</span><br><span class="line">    <span class="attr">metrics:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">otlp</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">otlp</span>]</span><br><span class="line">    <span class="attr">logs:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">otlp</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">otlp</span>]</span><br></pre></td></tr></table></figure>
<p>通过配置，我们可以初窥之。</p>
<h2 id="源码探路"><a class="header-anchor" href="#源码探路">¶</a>源码探路</h2>
<blockquote>
<p>opentelemetry 下称之为 OT</p>
</blockquote>
<h3 id="Component"><a class="header-anchor" href="#Component">¶</a>Component</h3>
<p><code>OT</code> 将所有组件的公用抽象为 <code>Component interface</code>,</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Component <span class="keyword">interface</span> &#123;</span><br><span class="line">	Start(ctx context.Context, host Host) <span class="type">error</span></span><br><span class="line">	Shutdown(ctx context.Context) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于 <code>Component</code> 拓展出 <code>Receiver</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Receiver <span class="keyword">interface</span> &#123;</span><br><span class="line">	Component</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而基于 <code>Receiver</code> 继续拓展出 <code>TracesReceiver</code> <code>MetricsReceiver</code> <code>LogsReceiver</code>，这个 <code>OOP</code> 的味道真的很熟悉。</p>
<h3 id="Service"><a class="header-anchor" href="#Service">¶</a>Service</h3>
<p>看代码先抓核心脉络，显然从配置上我们可以出来， <code>pipelines</code> 作为处理的贯穿者，<code>pipelines</code> 又是包含在 <code>service</code> 中，我们来看看 <code>service</code> 是怎么将这些串起来的。</p>
<figure class="highlight go"><figcaption><span>buildPipelines()</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *service)</span></span> buildPipelines() <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先准备好 Exporters</span></span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	srv.builtExporters, err = builder.BuildExporters(srv.logger, srv.startInfo, srv.config, srv.factories.Exporters)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot build builtExporters: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建 Pipeline 使用 Service 中包含的 Processer</span></span><br><span class="line">	srv.builtPipelines, err = builder.BuildPipelines(srv.logger, srv.startInfo, srv.config, srv.builtExporters, srv.factories.Processors)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot build pipelines: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最终创建 Reciver 然后插入 Pipeline 中</span></span><br><span class="line">	srv.builtReceivers, err = builder.BuildReceivers(srv.logger, srv.startInfo, srv.config, srv.builtPipelines, srv.factories.Receivers)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot build receivers: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建完成之后，记得调用 <code>Start</code> 启动即可</p>
<figure class="highlight go"><figcaption><span>Start()</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *service)</span></span> Start(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := srv.startExtensions(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot setup extensions: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := srv.startPipelines(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot setup pipelines: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> srv.builtExtensions.NotifyPipelineReady()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而构建的过程大同消息，我们这里举一个 <code>BuildExporters</code> 的例子</p>
<figure class="highlight go"><figcaption><span>BuildExporters</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildExporters</span><span class="params">(logger *zap.Logger,appInfo component.ApplicationStartInfo,config *configmodels.Config,factories <span class="keyword">map</span>[configmodels.Type]component.ExporterFactory)</span></span> (Exporters, <span class="type">error</span>) &#123;</span><br><span class="line">	eb := &amp;exportersBuilder&#123;logger.With(zap.String(kindLogKey, kindLogsExporter)), appInfo, config, factories&#125;</span><br><span class="line"></span><br><span class="line">	exporterInputDataTypes := eb.calcExportersRequiredDataTypes()</span><br><span class="line"></span><br><span class="line">	exporters := <span class="built_in">make</span>(Exporters)</span><br><span class="line">	<span class="comment">// 以配置文件的方式循环</span></span><br><span class="line">	<span class="keyword">for</span> _, cfg := <span class="keyword">range</span> eb.config.Exporters &#123;</span><br><span class="line">		componentLogger := eb.logger.With(zap.String(typeLogKey, <span class="type">string</span>(cfg.Type())), zap.String(nameLogKey, cfg.Name()))</span><br><span class="line">        <span class="comment">// 按照配置文件进行 Export 的构建</span></span><br><span class="line">		exp, err := eb.buildExporter(context.Background(), componentLogger, eb.appInfo, cfg, exporterInputDataTypes)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		exporters[cfg] = exp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> exporters, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的 <code>Export</code> 调用根据类型，会是 <code>CreateTracesExporter/CreateMetricsExporter/CreateLogsExporter</code> 这三者之一</p>
<p>以 <code>CreateTracesExporter</code>，实现类是 <code>factory</code></p>
<figure class="highlight go"><figcaption><span>CreateTracesExporter</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *factory)</span></span> CreateTracesExporter(</span><br><span class="line">	ctx context.Context,</span><br><span class="line">	params component.ExporterCreateParams,</span><br><span class="line">	cfg configmodels.Exporter) (component.TracesExporter, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> f.createTracesExporter != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> f.createTracesExporter(ctx, params, cfg) <span class="comment">// 调用 f 的内部函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, configerror.ErrDataTypeIsNotSupported</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从名字就可以看出来，这是一个工厂模式，而构建 <code>Exporter</code> 是由 <code>factory</code> 的构建者传入的</p>
<figure class="highlight go"><figcaption><span>WithTraces</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTraces</span><span class="params">(createTraceExporter CreateTracesExporter)</span></span> FactoryOption &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *factory)</span></span> &#123;</span><br><span class="line">		o.createTracesExporter = createTraceExporter</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个 <code>factorey</code> 恰恰也是由 <code>Export</code> 自己构建的</p>
<figure class="highlight go"><figcaption><span>NewFactory</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFactory</span><span class="params">()</span></span> component.ExporterFactory &#123;</span><br><span class="line">	<span class="keyword">return</span> exporterhelper.NewFactory(</span><br><span class="line">		typeStr,</span><br><span class="line">		createDefaultConfig,</span><br><span class="line">		exporterhelper.WithTraces(createTraceExporter))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些 <code>Factory</code> 是作为默认存在的代码写死在系统内的</p>
<figure class="highlight go"><figcaption><span>service/defaultcomponents/defaults.go:54</span></figcaption><table><tr><td class="code"><pre><span class="line">receivers, err := component.MakeReceiverFactoryMap(</span><br><span class="line">    jaegerreceiver.NewFactory(),</span><br><span class="line">    fluentforwardreceiver.NewFactory(),</span><br><span class="line">    zipkinreceiver.NewFactory(),</span><br><span class="line">    prometheusreceiver.NewFactory(),</span><br><span class="line">    opencensusreceiver.NewFactory(),</span><br><span class="line">    otlpreceiver.NewFactory(),</span><br><span class="line">    hostmetricsreceiver.NewFactory(),</span><br><span class="line">    kafkareceiver.NewFactory(),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210326214327.png" alt=""></p>
<p>不仅仅只支持单入口的，我们也可以支持多入口的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">pipelines:</span> </span><br><span class="line">    <span class="attr">traces:</span> </span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">otlp</span>, <span class="string">jaeger</span>, <span class="string">zipkin</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">memory_limiter</span>, <span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">otlp</span>, <span class="string">jaeger</span>, <span class="string">zipkin</span>]</span><br></pre></td></tr></table></figure>
<p>到这里，我们就明白了 <code>service</code> 的功能，就是读取配置文件，按照文件去构建系统，让我们回到真正运行的部分</p>
<h3 id="Receiver"><a class="header-anchor" href="#Receiver">¶</a>Receiver</h3>
<p><code>Receiver</code> 组件我们用 <code>ZipkinReceiver</code> 看看是怎么工作的。如果构建的我们已经知道，包含如何运行，我们显然需要看看他到底做了什么。</p>
<figure class="highlight go"><figcaption><span>Start</span><a href="https://github.com/open-telemetry/opentelemetry-collector/blob/main/receiver/zipkinreceiver/trace_receiver.go#L86">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(zr *ZipkinReceiver)</span></span> Start(_ context.Context, host component.Host) <span class="type">error</span> &#123;</span><br><span class="line">	zr.startOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err = <span class="literal">nil</span></span><br><span class="line">		zr.host = host</span><br><span class="line">		zr.server = zr.config.HTTPServerSettings.ToServer(zr)</span><br><span class="line">		<span class="keyword">var</span> listener net.Listener</span><br><span class="line">		listener, err = zr.config.HTTPServerSettings.ToListener()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		zr.shutdownWG.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> zr.shutdownWG.Done()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> errHTTP := zr.server.Serve(listener); errHTTP != http.ErrServerClosed &#123;</span><br><span class="line">				host.ReportFatalError(errHTTP)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动里面就打开了监听器，标准一个 <code>HTTP</code> 服务。处理逻辑肯定在我们熟悉的 <code>ServeHTTP</code> 这了。</p>
<figure class="highlight go"><figcaption><span>ServceHTTP</span><a href="https://github.com/open-telemetry/opentelemetry-collector/blob/main/receiver/zipkinreceiver/trace_receiver.go#L218">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(zr *ZipkinReceiver)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	<span class="comment">// 这里需要处理 gzip 之类的</span></span><br><span class="line">	pr := processBodyIfNecessary(r)</span><br><span class="line">	slurp, _ := ioutil.ReadAll(pr)</span><br><span class="line">	<span class="keyword">if</span> c, ok := pr.(io.Closer); ok &#123;</span><br><span class="line">		_ = c.Close()</span><br><span class="line">	&#125;</span><br><span class="line">	_ = r.Body.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> td pdata.Traces</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> asZipkinv1 &#123;</span><br><span class="line">        <span class="comment">// 处理 v1</span></span><br><span class="line">		td, err = zr.v1ToTraceSpans(slurp, r.Header)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理 v2</span></span><br><span class="line">		td, err = zr.v2ToTraceSpans(slurp, r.Header)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 这里的  nextConsumer 就是 pipeline 的下一跳</span></span><br><span class="line">	consumerErr := zr.nextConsumer.ConsumeTraces(ctx, td)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理结束</span></span><br><span class="line">	obsreport.EndTraceDataReceiveOp(ctx, receiverTagValue, td.SpanCount(), consumerErr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回 HTTP REPSONE 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见比较核心的是 <code>ConsumeTraces</code>，如何让这个枢纽运作起来，代码在</p>
<figure class="highlight go"><figcaption><span>attach</span><a href="https://github.com/open-telemetry/opentelemetry-collector/blob/main/service/internal/builder/receivers_builder.go#L161">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rb *receiversBuilder)</span></span> attachReceiverToPipelines()&#123;</span><br><span class="line">    <span class="keyword">case</span> configmodels.TracesDataType:</span><br><span class="line">		junction := buildFanoutTraceConsumer(builtPipelines)</span><br><span class="line">		createdReceiver, err = factory.CreateTracesReceiver(ctx, creationParams, config, junction)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildFanoutTraceConsumer</span><span class="params">(pipelines []*builtPipeline)</span></span> consumer.Traces &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(pipelines) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> pipelines[<span class="number">0</span>].firstTC</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> pipelineConsumers []consumer.Traces</span><br><span class="line">	anyPipelineMutatesData := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> _, pipeline := <span class="keyword">range</span> pipelines &#123;</span><br><span class="line">		pipelineConsumers = <span class="built_in">append</span>(pipelineConsumers, pipeline.firstTC)</span><br><span class="line">		anyPipelineMutatesData = anyPipelineMutatesData || pipeline.MutatesConsumedData</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a junction point that fans out to all pipelines.</span></span><br><span class="line">	<span class="keyword">if</span> anyPipelineMutatesData &#123;</span><br><span class="line">		<span class="keyword">return</span> fanoutconsumer.NewTracesCloning(pipelineConsumers)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fanoutconsumer.NewTraces(pipelineConsumers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exporter"><a class="header-anchor" href="#Exporter">¶</a>Exporter</h3>
<p>对于 <code>Exporter</code> 我们来看看 <code>JaegerExporter</code> 逻辑也是非常的清晰的</p>
<figure class="highlight go"><figcaption><span>pushTraceData</span><a href="https://github.com/open-telemetry/opentelemetry-collector/blob/main/exporter/jaegerexporter/exporter.go#L112">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *protoGRPCSender)</span></span> pushTraceData(ctx context.Context, td pdata.Traces,) <span class="type">error</span> &#123;</span><br><span class="line">	batches, err := jaegertranslator.InternalTracesToJaegerProto(td)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> consumererror.Permanent(fmt.Errorf(<span class="string">&quot;failed to push trace data via Jaeger exporter: %w&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.metadata.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		ctx = metadata.NewOutgoingContext(ctx, s.metadata)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, batch := <span class="keyword">range</span> batches &#123;</span><br><span class="line">		_, err = s.client.PostSpans(</span><br><span class="line">			ctx,</span><br><span class="line">			&amp;jaegerproto.PostSpansRequest&#123;Batch: *batch&#125;, grpc.WaitForReady(s.waitForReady))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			s.logger.Debug(<span class="string">&quot;failed to push trace data to Jaeger&quot;</span>, zap.Error(err))</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to push trace data via Jaeger exporter: %w&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个 <code>client</code> 恰好就是 <code>jaegerproto.CollectorServiceClient</code> 而将这些串通在一起，我们需要一个稳定的 <code>ABI</code>，而这个就是</p>
<figure class="highlight go"><figcaption><span>consumer/consumer.go:33</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Traces <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// ConsumeTraces receives pdata.Traces for consumption.</span></span><br><span class="line">	ConsumeTraces(ctx context.Context, td pdata.Traces) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们发现，其实这几个组件都是实现了此接口。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>go</category>
        <category>opentelemetry</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>opentelemetry</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle 简易入门教程</title>
    <url>/2018/07/14/gradle/easy-to-gradle/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2018/07/14/PMmeYQ.png" alt="banner"></p>
<p><code>Gradle</code> 是一种构建工具，它抛弃了基于XML的构建脚本，取而代之的是采用一种基于 <code>Groovy</code>（现在也支持 <code>Kotlin</code>）的内部领域特定语言。</p>
<span id="more"></span>
<h2 id="Gradle-特点"><a class="header-anchor" href="#Gradle-特点">¶</a>Gradle 特点</h2>
<ol>
<li>Gradle是很成熟的技术，可以处理大规模构建</li>
<li>Gradle对多语言、多平台支持性更好</li>
<li>Gradle关注在构建效率上</li>
<li>Gradle发布很频繁，重要feature开发计划透明化</li>
<li>Gradle社区很活跃，并且增加迅速</li>
</ol>
<h2 id="安装Gradle"><a class="header-anchor" href="#安装Gradle">¶</a>安装Gradle</h2>
<ul>
<li>从 <a href="https://gradle.org/install/">这个页面</a> 下载二进制文件。</li>
<li>解压Zip文件，加入环境变量（在PATH中加入GRADLE_HOME/bin目录）</li>
</ul>
<p>如果在安装过程中遇到问题，可以进一步查看官方的 <a href="https://gradle.org/install/">安装指南</a>。<br>
最后验证一下 <code>Gradle</code> 是否工作正常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gradle -v</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 4.2.1</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build time:   2017-10-02 15:36:21 UTC</span><br><span class="line">Revision:     a88ebd6be7840c2e59ae4782eb0f27fbe3405ddf</span><br><span class="line"></span><br><span class="line">Groovy:       2.4.12</span><br><span class="line">Ant:          Apache Ant(TM) version 1.9.6 compiled on June 29 2015</span><br><span class="line">JVM:          1.8.0_162-ea (Oracle Corporation 25.162-b01)</span><br><span class="line">OS:           Mac OS X 10.13.5 x86_64</span><br></pre></td></tr></table></figure>
<h2 id="Gradle-快速体验"><a class="header-anchor" href="#Gradle-快速体验">¶</a>Gradle 快速体验</h2>
<h3 id="初始化一个项目"><a class="header-anchor" href="#初始化一个项目">¶</a>初始化一个项目</h3>
<ul>
<li>创建一个 <code>demo</code> 目录  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">mkdir</span> gradle-demo</span><br></pre></td></tr></table></figure>
</li>
<li>创始化 <code>Gradle</code> 项目  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ gradle init </span><br><span class="line">Starting a Gradle Daemon (subsequent builds will be faster)</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> 3s</span><br><span class="line">2 actionable tasks: 2 executed</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Gradle-目录结构"><a class="header-anchor" href="#Gradle-目录结构">¶</a>Gradle 目录结构</h3>
<p>我们看看上一步我们生成了什么文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">├── build.gradle  ❶</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">│       ├── gradle-wrapper.jar    ➋</span><br><span class="line">│       └── gradle-wrapper.properties  ➌</span><br><span class="line">├── gradlew    ➍</span><br><span class="line">├── gradlew.bat  ➎</span><br><span class="line">└── settings.gradle  ➏</span><br></pre></td></tr></table></figure>
<p>❶ 当前项目的配置脚本<br>
➋ <code>Gradle Wrapper</code> 的执行jar包（后续介绍）<br>
➌ <code>Gradle Wrapper</code> 的配置文件<br>
➍ <code>Gradle Wrapper</code> Unix 系执行脚本<br>
➎ <code>Gradle Wrapper</code> Windows 系执行脚本<br>
➏ 项目脚本设置</p>
<h3 id="创建一个-Task"><a class="header-anchor" href="#创建一个-Task">¶</a>创建一个 Task</h3>
<p><code>Gradle</code>提供了用于通过基于<code>Groovy</code>或<code>Kotlin</code>的DSL创建和配置。项目包括一组<code>Task</code>，每个<code>Task</code>执行一些基本操作。</p>
<ul>
<li>创建一个目录叫 <code>src</code></li>
<li>在<code>src</code>目录创建一个 <code>myfile.txt</code></li>
<li>在构建文件中定义一个名为Copy的类型 <code>Task</code> ，该任务将src目录复制到名为dest的新目录</li>
</ul>
<div class="tabs" id="create-task"><ul class="nav-tabs"><li class="tab active"><a href="#create-task-1">Groovy</a></li><li class="tab"><a href="#create-task-2">Kotlin</a></li></ul><div class="tab-content"><div class="tab-pane active" id="create-task-1"><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task copy(<span class="attr">type:</span> Copy, <span class="attr">group:</span> <span class="string">&quot;Custom&quot;</span>, <span class="attr">description:</span> <span class="string">&quot;Copies sources to the dest directory&quot;</span>) &#123;</span><br><span class="line">    from <span class="string">&quot;src&quot;</span></span><br><span class="line">    into <span class="string">&quot;dest&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="create-task-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">tasks.create&lt;Copy&gt;(<span class="string">&quot;copy&quot;</span>) &#123;</span><br><span class="line">    description = <span class="string">&quot;Copies sources to the dest directory&quot;</span></span><br><span class="line">    group = <span class="string">&quot;Custom&quot;</span></span><br><span class="line"></span><br><span class="line">    from(<span class="string">&quot;src&quot;</span>)</span><br><span class="line">    into(<span class="string">&quot;dest&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p><code>group</code> 和 <code>description</code> 是自定义的任意值。现在让我们执行这个 <code>task</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ ./gradlew copy</span><br><span class="line">&gt; Task :copy</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> 0s</span><br><span class="line">1 actionable task: 1 executed</span><br></pre></td></tr></table></figure>
<p>再一次 <code>ls</code> 我们就可以看见 <code>gradle</code> 为我们创建了一个新的 <code>dest</code> 目录并且将 文件复制进去</p>
<h2 id="Gradle-Task"><a class="header-anchor" href="#Gradle-Task">¶</a>Gradle Task</h2>
<p>在<code>Gradle</code>中，有两个基本概念：项目和任务。</p>
<ul>
<li>项目是指我们的构建产物（比如Jar包）或实施产物（将应用程序部署到生产环境）一个项目包含一个或多个任务。</li>
<li>任务是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）。<br>
<img src="https://s1.ax1x.com/2018/07/14/PMCmKe.png" alt=""></li>
</ul>
<p>在项目目录中的 <code>build.gradle</code> 指定了一个项目和它的任务。</p>
<h3 id="Task-执行顺序"><a class="header-anchor" href="#Task-执行顺序">¶</a>Task 执行顺序</h3>
<p>任务可能依赖于其他任务，或者可能被安排为始终在另一个任务之后运行。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">project(<span class="string">&#x27;projectA&#x27;</span>) &#123;</span><br><span class="line">    task taskX(<span class="attr">dependsOn:</span> <span class="string">&#x27;:projectB:taskY&#x27;</span>) &#123;</span><br><span class="line">        doLast &#123;</span><br><span class="line">            println <span class="string">&#x27;taskX&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">project(<span class="string">&#x27;projectB&#x27;</span>) &#123;</span><br><span class="line">    task taskY &#123;</span><br><span class="line">        doLast &#123;</span><br><span class="line">            println <span class="string">&#x27;taskY&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; gradle -q taskX</span><br><span class="line">taskY</span><br><span class="line">taskX  // taskx 在 y 之后</span><br></pre></td></tr></table></figure>
<p>我们可以用 <code>dependsOn</code> 让我们的 <code>Task</code> 有顺序的运行起来<br>
<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html">Task 文档</a></p>
<h2 id="Gradle-插件"><a class="header-anchor" href="#Gradle-插件">¶</a>Gradle 插件</h2>
<p>看到这里，如果每一件事情我们都需要写 <code>Task</code> 岂不是会累死，而且很多功能是可以被复用的，所以<code>Gradle</code> 提供一个 <code>插件</code> 功能，<code>Gradle</code> 默认就内置了大量的插件，比如在 <code>base</code> 中有一系列的功能。</p>
<div class="tabs" id="plugin"><ul class="nav-tabs"><li class="tab active"><a href="#plugin-1">Groovy  build.gradle</a></li><li class="tab"><a href="#plugin-2">Kotlin build.gradle.kts</a></li></ul><div class="tab-content"><div class="tab-pane active" id="plugin-1"><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&quot;base&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="plugin-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">&quot;base&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p>这个时候我们就可以利用一些额外的 <code>Task</code>，举个例子，我们要把一个目录中的东西都打成一个 <code>ZIP</code> 压缩包。</p>
<div class="tabs" id="zip"><ul class="nav-tabs"><li class="tab active"><a href="#zip-1">Groovy  build.gradle</a></li><li class="tab"><a href="#zip-2">Kotlin build.gradle.kts</a></li></ul><div class="tab-content"><div class="tab-pane active" id="zip-1"><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task zip(<span class="attr">type:</span> Zip, <span class="attr">group:</span> <span class="string">&quot;Archive&quot;</span>, <span class="attr">description:</span> <span class="string">&quot;Archives sources in a zip file&quot;</span>) &#123;</span><br><span class="line">    from <span class="string">&quot;src&quot;</span></span><br><span class="line">    setArchiveName <span class="string">&quot;basic-demo-1.0.zip&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="zip-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">tasks.create&lt;Zip&gt;(<span class="string">&quot;zip&quot;</span>) &#123;</span><br><span class="line">    description = <span class="string">&quot;Archives sources in a zip file&quot;</span></span><br><span class="line">    group = <span class="string">&quot;Archive&quot;</span></span><br><span class="line"></span><br><span class="line">    from(<span class="string">&quot;src&quot;</span>)</span><br><span class="line">    setArchiveName(<span class="string">&quot;basic-demo-1.0.zip&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p><code>Gradle</code> 的设计理念是</p>
<ul>
<li>在项目中添加新任务</li>
<li>为新加入的任务提供默认配置，这个默认配置会在项目中注入新的约定（如源文件位置）。</li>
<li>加入新的属性，可以覆盖插件的默认配置属性。</li>
<li>为项目加入新的依赖。</li>
</ul>
<h3 id="Gradle-Java"><a class="header-anchor" href="#Gradle-Java">¶</a>Gradle Java</h3>
<p><code>Gradle</code> 内置了 <code>Java</code> 插件，Java插件将Java编译以及测试和捆绑功能添加到项目中。它是许多其他Gradle插件的基础。<br>
如果我们需要使用 <code>Java</code> 插件 修改 <code>build.gradle</code></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦导入了 Java 插件，就会有一系列的默认的配置值，并且会导入大量的 <code>Task</code></p>
<table>
<thead>
<tr>
<th>Task</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>compileJava(type: JavaCompile)</td>
<td>Java 编译</td>
</tr>
<tr>
<td>processResources(type: Copy)</td>
<td>拷贝 Resources 资源</td>
</tr>
<tr>
<td>classes(type: Task)</td>
<td>组装 Java 类</td>
</tr>
<tr>
<td>compileTestJava(type: JavaCompile)</td>
<td>Java Test 编译</td>
</tr>
<tr>
<td>processTestResources(type: Copy)</td>
<td>拷贝 Test Resources 资源</td>
</tr>
<tr>
<td>testClasses(type: Task)</td>
<td>组装 Test 类</td>
</tr>
<tr>
<td>jar(type: Jar)</td>
<td>合成Jar包</td>
</tr>
<tr>
<td>javadoc(type: Javadoc)</td>
<td>生成 doc 文档</td>
</tr>
<tr>
<td>test(type: Test)</td>
<td>运行测试</td>
</tr>
<tr>
<td>uploadArchives(type: Upload)</td>
<td>上传 jar 到仓库</td>
</tr>
<tr>
<td>clean(type: Delete)</td>
<td>clean</td>
</tr>
</tbody>
</table>
<p>我们从这些 <code>Task</code> 名字就可以看出来他们分别作作了， 和其他的设计理念类型，在 <code>Task</code> 也会嵌入一些生命周期，其实原理也就是我们之前看的执行顺序。<a href="https://docs.gradle.org/current/userguide/java_plugin.html#_lifecycle_tasks">Java Lifecycle</a></p>
<p><img src="https://docs.gradle.org/current/userguide/img/javaPluginTasks.png" alt="JavaPluginTasks"></p>
<h3 id="资源"><a class="header-anchor" href="#资源">¶</a>资源</h3>
<p><a href="https://plugins.gradle.org/">Gradle插件仓库</a></p>
<h2 id="Gradle-依赖管理"><a class="header-anchor" href="#Gradle-依赖管理">¶</a>Gradle 依赖管理</h2>
<p>先盗取一张官方的图<br>
<img src="https://docs.gradle.org/current/userguide/img/dependency-management-dependencies-to-modules.png" alt=""></p>
<p>和 <code>Maven</code> 类似，<code>Gradle</code> 也会将依赖缓冲在本地中，方便在无网的环境使用，和依赖管理相关的有两个参数，举个例子。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral() <span class="comment">// 定义仓库</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">&#x27;org.springframework:spring-web:5.0.2.RELEASE&#x27;</span> <span class="comment">// 定义依赖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Gradle支持以下仓库格式：</p>
<ul>
<li>Ivy仓库</li>
<li>Maven仓库</li>
<li>Flat directory仓库</li>
</ul>
<h3 id="lvy仓库"><a class="header-anchor" href="#lvy仓库">¶</a>lvy仓库</h3>
<p>我们可以通过URL地址或本地文件系统地址，将Ivy仓库加入到我们的构建中。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    ivy &#123;</span><br><span class="line">        url <span class="string">&quot;http://ivy.petrikainulainen.net/repo&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者是本地</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    ivy &#123;       </span><br><span class="line">        url <span class="string">&quot;../ivy-repo&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Maven仓库"><a class="header-anchor" href="#Maven仓库">¶</a>Maven仓库</h3>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url <span class="string">&quot;http://maven.petrikainulainen.net/repo&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在加入Maven仓库时，Gradle提供了三种“别名”供我们使用，它们分别是</p>
<ul>
<li><code>mavenCentral()</code>别名，表示依赖是从Central Maven 2 仓库中获取的。</li>
<li><code>jcenter()</code>别名，表示依赖是从Bintary’s JCenter Maven 仓库中获取的。</li>
<li><code>mavenLocal()</code>别名，表示依赖是从本地的Maven仓库中获取的。</li>
</ul>
<h3 id="Flat-Directory仓库"><a class="header-anchor" href="#Flat-Directory仓库">¶</a>Flat Directory仓库</h3>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    flatDir &#123;</span><br><span class="line">        dirs <span class="string">&#x27;lib&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个仓库</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    flatDir &#123;</span><br><span class="line">        dirs <span class="string">&#x27;libA&#x27;</span>, <span class="string">&#x27;libB&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="依赖管理"><a class="header-anchor" href="#依赖管理">¶</a>依赖管理</h3>
<p>在配置完项目仓库后，我们可以声明其中的依赖，首先 <code>Java</code> 插件指定了若干依赖配置项</p>
<ul>
<li><code>compile</code> 配置项中的依赖是依赖必须的。</li>
<li><code>runtime</code> 配置项中包含的依赖在运行时是必须的。</li>
<li><code>testCompile</code> 配置项中包含的依赖在编译项目的测试代码时是必须的。</li>
<li><code>testRuntime</code> 配置项中包含的依赖在运行测试代码时是必须的。</li>
</ul>
<p>在 <code>Gradle</code> 最新版本中更是增加</p>
<ul>
<li><code>implementation</code> 配置项中的实现类</li>
<li><code>api</code> 配置项中的暴露API</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    api <span class="string">&#x27;commons-httpclient:commons-httpclient:3.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.commons:commons-lang3:3.5&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="声明项目依赖"><a class="header-anchor" href="#声明项目依赖">¶</a>声明项目依赖</h4>
<p>最普遍的依赖称为外部依赖，这些依赖存放在外部仓库中。一个外部依赖可以由以下属性指定：</p>
<ul>
<li><code>group</code>属性指定依赖的分组（在<code>Maven</code>中，就是<code>groupId</code>）</li>
<li><code>name</code>属性指定依赖的名称（在<code>Maven</code>中，就是<code>artifactId</code>）</li>
<li><code>version</code>属性指定外部依赖的版本（在<code>Maven</code>中，就是<code>version</code>）</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="attr">group:</span> <span class="string">&#x27;foo&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;foo&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;0.1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们也可以合并到一起去</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">&#x27;foo:foo:0.1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="声明项目文件依赖"><a class="header-anchor" href="#声明项目文件依赖">¶</a>声明项目文件依赖</h4>
<p>我们如何依赖本地的一些 <code>jar</code> 呢，正确的操作是如下</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile files(<span class="string">&#x27;libs/commons-lang.jar&#x27;</span>, <span class="string">&#x27;libs/log4j.jar&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="声明依赖排除项目"><a class="header-anchor" href="#声明依赖排除项目">¶</a>声明依赖排除项目</h4>
<p>我们都知道在 <code>Maven</code>中我们有</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectB<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而在 <code>Gradle</code> 中，我们可以这么做。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile(<span class="string">&#x27;com.example.m:m:1.0&#x27;</span>) &#123;</span><br><span class="line">    exclude <span class="attr">group:</span> <span class="string">&#x27;org.unwanted&#x27;</span>, <span class="attr">module:</span> <span class="string">&#x27;x </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Gradle-与-Kotlin"><a class="header-anchor" href="#Gradle-与-Kotlin">¶</a>Gradle 与 Kotlin</h2>
<p>我们想要在 <code>gradle</code> 中增加 <code>kotlin</code> 非常的简单，仅仅需要在 <code>build.gradle</code> 增加</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">     id <span class="string">&quot;org.jetbrains.kotlin.jvm&quot;</span> version <span class="string">&quot;x.x.xx&quot;</span> <span class="comment">// 增加插件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  compile <span class="string">&quot;org.jetbrains.kotlin:kotlin-stdlib:x.xx.xx&quot;</span> <span class="comment">// 增加依赖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大功告成，对了，默认的 <code>Kotlin</code> 的源码路径是 <code>src/main/kotlin</code>, 测试源码是 <code>src/text/kotlin</code> 如果需要修改可以使用</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main.kotlin.srcDirs += <span class="string">&#x27;src/main/myKotlin&#x27;</span></span><br><span class="line">    main.java.srcDirs += <span class="string">&#x27;src/main/myJava&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2>
<h3 id="Gradle-Wrapper"><a class="header-anchor" href="#Gradle-Wrapper">¶</a>Gradle Wrapper</h3>
<p><code>Gradle Wrapper</code> 做了三件事情</p>
<ul>
<li>解析参数传入 gradlew</li>
<li>安装正确的 <code>Gradle</code> 版本</li>
<li>调用 <code>Gradle</code> 执行命令</li>
</ul>
<p>Ops，<code>Gradle Wrapper</code> 为什么还需要安装 <code>Gradle</code>，我们在用 <code>Maven</code> 都知道，我们需要自己先安装好一个 <code>Maven</code>版本，因为 <code>Maven</code> 发展多年，现在已经稳定，已经不存在很多个版本并存的现状了，但是我们依然需要去在每个机器上去安装，那我什么我们不能在自己的 <code>构建脚本</code> 中就指定我们的构建工具呢？<br>
所以我们在 <code>wrapper/gradle-wrapper.properties</code> 中就可以发现 <code>distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-bin.zip</code> 这里也就是定义了我们的gradle所使用的版本。<br>
<img src="https://docs.gradle.org/current/userguide/img/wrapper-workflow.png" alt="wrapper-workflow"></p>
<h2 id="Gradle-In-Real-World"><a class="header-anchor" href="#Gradle-In-Real-World">¶</a>Gradle In Real World</h2>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一堆基础插件</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;java&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&quot;jacoco&quot;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;checkstyle&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;pmd&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;findbugs&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;eclipse&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;idea&#x27;</span></span><br><span class="line"><span class="comment">// 定义项目属性</span></span><br><span class="line">group = <span class="string">&#x27;Common&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;1.0.0&#x27;</span></span><br><span class="line">description = <span class="string">&quot;&quot;&quot;Giant common library&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义依赖仓库</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 额外增加source path</span></span><br><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        resources &#123;</span><br><span class="line">            srcDir <span class="string">&quot;src/main/profiles/$&#123;profile&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// project依赖</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">&#x27;ch.qos.logback:logback-core:1.0.13&#x27;</span></span><br><span class="line">    compile <span class="string">&#x27;ch.qos.logback:logback-classic:1.0.13&#x27;</span></span><br><span class="line">    compile <span class="string">&#x27;ch.qos.logback:logback-access:1.0.13&#x27;</span></span><br><span class="line">    compile <span class="string">&#x27;commons-io:commons-io:2.0.1&#x27;</span></span><br><span class="line">    compile <span class="string">&#x27;commons-lang:commons-lang:2.6&#x27;</span></span><br><span class="line">    compile <span class="string">&#x27;joda-time:joda-time:1.6.2&#x27;</span></span><br><span class="line">    compile <span class="string">&#x27;org.testng:testng:6.8.7&#x27;</span></span><br><span class="line">    compile <span class="string">&#x27;com.googlecode.jmockit:jmockit:1.5&#x27;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// task配置</span></span><br><span class="line">checkstyle &#123;</span><br><span class="line">    ignoreFailures = <span class="literal">true</span></span><br><span class="line">    sourceSets = [sourceSets.main]</span><br><span class="line">&#125;</span><br><span class="line">findbugs &#123;</span><br><span class="line">    ignoreFailures = <span class="literal">true</span></span><br><span class="line">    sourceSets = [sourceSets.main]</span><br><span class="line">&#125;</span><br><span class="line">pmd &#123;</span><br><span class="line">    ruleSets = [<span class="string">&quot;basic&quot;</span>, <span class="string">&quot;braces&quot;</span>, <span class="string">&quot;design&quot;</span>]</span><br><span class="line">    ignoreFailures = <span class="literal">true</span></span><br><span class="line">    sourceSets = [sourceSets.main]</span><br><span class="line">&#125;</span><br><span class="line">jacocoTestReport &#123;</span><br><span class="line">    reports &#123;</span><br><span class="line">        xml.enabled <span class="literal">true</span></span><br><span class="line">        html.enabled <span class="literal">true</span></span><br><span class="line">        csv.enabled <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    sourceSets sourceSets.main</span><br><span class="line">&#125;</span><br><span class="line">tasks.withType(Compile) &#123;</span><br><span class="line">    options.encoding = <span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">test &#123;</span><br><span class="line">    useTestNG()</span><br><span class="line">    jacoco &#123;</span><br><span class="line">        excludes = [<span class="string">&quot;org.*&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Gradle-常用指令"><a class="header-anchor" href="#Gradle-常用指令">¶</a>Gradle 常用指令</h2>
<h3 id="枚列所有可用任务"><a class="header-anchor" href="#枚列所有可用任务">¶</a>枚列所有可用任务</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ gradle tasks</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">All tasks runnable from root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Archive tasks</span><br><span class="line">-------------</span><br><span class="line">zip - Archives sources <span class="keyword">in</span> a zip file</span><br><span class="line"></span><br><span class="line">Build tasks</span><br><span class="line">-----------</span><br><span class="line">assemble - Assembles the outputs of this project.</span><br><span class="line">build - Assembles and tests this project.</span><br><span class="line">clean - Deletes the build directory.</span><br></pre></td></tr></table></figure>
<h3 id="构建配置属性"><a class="header-anchor" href="#构建配置属性">¶</a>构建配置属性</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ gradle properties</span><br></pre></td></tr></table></figure>
<h3 id="显示构建详情"><a class="header-anchor" href="#显示构建详情">¶</a>显示构建详情</h3>
<p>在 <code>build.gradle</code> 设置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">logging.level = LogLevel.DEBUG</span><br></pre></td></tr></table></figure>
<p>或者在运行的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ gradle build --stacktrace </span><br></pre></td></tr></table></figure>
<h2 id="参考资料-推荐文档"><a class="header-anchor" href="#参考资料-推荐文档">¶</a>参考资料 &amp; 推荐文档</h2>
<ul>
<li><a href="http://blog.jobbole.com/71999/">Gradle入门教程</a></li>
<li><a href="https://www.jianshu.com/p/00d5469e25e7">Gradle介绍</a></li>
<li><a href="https://guides.gradle.org/creating-new-gradle-builds/">官方教材</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>buildtool</category>
        <category>gradle</category>
      </categories>
  </entry>
  <entry>
    <title>The Hard Way Learn Computer Science [实践班]</title>
    <url>/2021/01/13/hard-way/learn-by-self-hard-way-practices/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210113101402.png" alt=""></p>
<p>我们在 <a href="/2020/11/17/hard-way/learn-by-self-hard-way/">The Hard Way Learn Computer Science</a> 分享了一些学习的书籍和视频，不过都理论大过实践，所以我的女朋友觉得贼难，那我们今天就实践大于理论来分享一下。</p>
<span id="more"></span>
<h2 id="Pre"><a class="header-anchor" href="#Pre">¶</a>Pre</h2>
<p>让我们先重温下 <a href="http://norvig.com/21-days.html">Teach Yourself Programming in Ten Years</a> 一切都不用那么着急。</p>
<h2 id="编程基础"><a class="header-anchor" href="#编程基础">¶</a>编程基础</h2>
<h3 id="语言学习"><a class="header-anchor" href="#语言学习">¶</a>语言学习</h3>
<p>当然程序员应该懂好几门语言，入门的时候，我还是推荐 <code>Python</code> | <code>C</code> | <code>Java</code> 三者之一</p>
<p><code>面向对象</code> 语言处理 <code>IO</code> 一般还是会比 <code>函数式</code> 语言略好的一点，但是 <code>IO</code> 是我们程序不可回避的部分，编写一个入门的 <code>CLI</code> 程序是作为入门的最好办法。</p>
<h2 id="计算机网络"><a class="header-anchor" href="#计算机网络">¶</a>计算机网络</h2>
<h3 id="基础"><a class="header-anchor" href="#基础">¶</a>基础</h3>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210113113733.png" alt=""></p>
<p>网络编程人人要，打基础从 <code>Socket</code> 编程开始</p>
<ul>
<li><a href="https://www.tutorialspoint.com/unix_sockets/what_is_socket.htm">unix_sockets</a></li>
</ul>
<h4 id="实验-基于-TCP-聊天"><a class="header-anchor" href="#实验-基于-TCP-聊天">¶</a>实验: 基于 TCP 聊天</h4>
<p><strong>目标</strong>: 在两台网络互连的机器上通过 <code>tcp</code> 相互可以聊天，效果如下:<br>
<strong>关键词</strong>: <code>socket</code> <code>bio</code></p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210113114131.png" alt=""></p>
<hr>
<p>当我们完成了基础的 <code>socket</code> 编程之后，我们进入不同系统的特定的 <code>多路复用</code> 网络部分。</p>
<ul>
<li><a href="https://notes.shichao.io/unp/ch6/">I/O Multiplexing: The select and poll Functions</a></li>
</ul>
<h4 id="实验-基于-TCP-聊天室-Plus"><a class="header-anchor" href="#实验-基于-TCP-聊天室-Plus">¶</a>实验: 基于 TCP 聊天室 Plus</h4>
<p><strong>目标</strong>: 在多台网络互连的机器上通过 <code>tcp</code> 相互可以聊天，服务端用 <code>UDP</code> 对所有的的聊天客户端进 <code>Multicast</code> 或 <code>Broadcast</code>，效果如下:<br>
<strong>关键词</strong>: <code>socket</code> <code>nio</code> <code>thread</code></p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210113114654.png" alt=""></p>
<h3 id="进阶"><a class="header-anchor" href="#进阶">¶</a>进阶</h3>
<p>上面的学习都没有涉及到如何做 <code>TCP</code> 上层的协议解析，当我们完成了 <code>TCP</code> 通讯部分的代码之后，我们就可以进入 <code>协议解析</code> 部分</p>
<ul>
<li><a href="https://www.aosabook.org/en/500L/a-simple-web-server.html">Simple Web Server</a></li>
</ul>
<h4 id="实验-静态-Web-服务器"><a class="header-anchor" href="#实验-静态-Web-服务器">¶</a>实验: 静态 Web 服务器</h4>
<p><strong>目标</strong>: 接受 HTTP 请求根据请求的 <code>Path</code> 返回对应的 <code>静态文件</code><br>
<strong>关键词</strong>: <code>http</code></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>自学</category>
      </categories>
      <tags>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title>The Hard Way Learn Computer Science</title>
    <url>/2020/11/17/hard-way/learn-by-self-hard-way/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201117213257.png" alt=""></p>
<blockquote>
<p>写给我的女朋友，一个不愿意减肥的小可爱</p>
</blockquote>
<span id="more"></span>
<p>如何从零开始成为一个工程师，现在知识如同浩瀚银河，如果没有目标就很容易迷失在知识的海洋之中。</p>
<blockquote>
<p>软件工程师分为两种：一种充分理解了计算机科学，从而有能力应对充满挑战的创造性工作；另一种仅仅凭着对一些高级工具的熟悉而勉强应付。</p>
</blockquote>
<p>如果是完全的新手请左转 <a href="https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_getting_started">编程新手指南</a></p>
<table>
<thead>
<tr>
<th>科目</th>
<th>为何要学？</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="#%E7%BC%96%E7%A8%8B">编程</a></strong></td>
<td>编程乃是程序之基础</td>
</tr>
<tr>
<td><strong><a href="#%E7%AE%97%E6%B3%95">算法与数据结构</a></strong></td>
<td>如果你不懂得如何使用栈、队列、树、图等常见数据结构，遇到有难度的问题时，你将束手无策。</td>
</tr>
<tr>
<td><strong><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84">计算机架构</a></strong></td>
<td>如果你对于计算机如何工作没有具体的概念，那么你所做出的所有高级抽象都是空中楼阁。</td>
</tr>
<tr>
<td><strong><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a></strong></td>
<td>离开了网络世界，计算机世界也不剩下什么。</td>
</tr>
<tr>
<td><strong><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F">分布式系统</a></strong></td>
<td>现在的系统绝大多数都是分布式的。</td>
</tr>
<tr>
<td><strong><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></strong></td>
<td>你所写的代码，基本上都由操作系统来运行，因此你应当了解其运作的原理。</td>
</tr>
</tbody>
</table>
<h2 id="编程"><a class="header-anchor" href="#编程">¶</a>编程</h2>
<p>在此时代如果你说自己仅仅是一个 <code>XXX</code> 语言程序员，那显然是不合格的，一个合格的程序员可以专注于某个领域，但是不能专注于某门语言，因此在现代至少需要学会</p>
<ol>
<li>系统级编程语言: C [<code>Linux驱动</code>] &gt; Rust [<code>未来驱动</code>]</li>
<li>工具语言: 帮助我们完成一些小工具或者是原型设计</li>
<li>工业语言: 一门在行业大规模使用的通用语言 Java Go …</li>
</ol>
<p>但是这一些还只是 <code>编程语言</code>，完全达不成 <code>程序设计</code> 的范畴，对于应该如何设计程序，推荐两本书  <a href="https://book.douban.com/subject/3892590/">《面向对象分析与设计》</a>  和 <a href="https://book.douban.com/subject/1148282/">《计算机程序的构造和解释》</a> 分别代表了 <code>OOP</code> 和 <code>FP</code>  的程序应该如何设计，除了对于程序设计，我们还需要知道一些写代码的 <code>工业实践</code> 那这些内容就不得不推荐看一下 <a href="https://book.douban.com/subject/1477390/">《代码大全》</a>。</p>
<table>
<thead>
<tr>
<th>资料</th>
<th>级别</th>
<th>为什么是它</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="https://book.douban.com/subject/1148282/">计算机程序的构造和解释</a></strong></td>
<td>入门</td>
<td>洗礼入教，懂一点FP很棒。</td>
</tr>
<tr>
<td><strong><a href="https://book.douban.com/subject/3892590/">面向对象分析与设计</a></strong></td>
<td>入门</td>
<td>和 FP 抗衡并且赢下了半个世界的 OOP 总是要学对吧</td>
</tr>
<tr>
<td><strong><a href="https://book.douban.com/subject/1139336/">C程序设计语言</a></strong></td>
<td>入门</td>
<td>最贴近硬件的高级语言，在底层的世界总是逃不了</td>
</tr>
<tr>
<td><strong><a href="https://book.douban.com/subject/1477390/">代码大全</a></strong></td>
<td>进阶</td>
<td>软件工程研发领域的方方面面</td>
</tr>
<tr>
<td><strong><a href="https://golang.org/doc/tutorial/getting-started">Tutorial: Get started with Go</a></strong></td>
<td>可选</td>
<td>云原生的最佳语言</td>
</tr>
<tr>
<td><strong><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a></strong></td>
<td>可选</td>
<td>如何写一个安全的代码，Rust 会告诉你答案</td>
</tr>
<tr>
<td><strong><a href="https://learnpythonthehardway.org/python3/">The Hard Way to Python3</a></strong></td>
<td>可选</td>
<td>你总是需要一个方便实现想法的小工具</td>
</tr>
</tbody>
</table>
<h2 id="算法"><a class="header-anchor" href="#算法">¶</a>算法</h2>
<p>算法是无限的，但是经典算法是有限的，有成百上千的书可供使用，但是我觉得最经典的莫过于 <a href="https://book.douban.com/subject/19952400/">《算法》</a>，用 <code>Java</code> 描述算是一个不错的选择。花一些时间将算法搞定，是一件受益终身的事情。</p>
<table>
<thead>
<tr>
<th>资料</th>
<th>级别</th>
<th>为什么是它</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="https://book.douban.com/subject/19952400/">算法</a></strong></td>
<td>入门</td>
<td>正儿八经写给软件工程师看的算法书，并且更关注实践上。</td>
</tr>
<tr>
<td><strong><a href="https://book.douban.com/subject/25837031/">算法心得：高效算法的奥秘</a></strong></td>
<td>进阶</td>
<td>瞧瞧真实编程世界的一些算法优化手段</td>
</tr>
<tr>
<td><strong><a href="https://book.douban.com/subject/26302533/">编程珠玑</a></strong></td>
<td>进阶</td>
<td>如何活学活用才是学会的标准</td>
</tr>
</tbody>
</table>
<p>为什么不推荐 <a href="https://book.douban.com/subject/1885170/"><code>算法导论（原书第2版）</code></a>，在我看来这本书更像是一本数学系的数据，是否适合软件工程师是一个大大的问号。</p>
<h2 id="计算机架构"><a class="header-anchor" href="#计算机架构">¶</a>计算机架构</h2>
<p>计算机架构——有时候又被称为“计算机系统”或者“计算机组成”——是了解软件底层的的重要视角。根据我们的经验，这是自学的软件工程师最容易忽视的领域。最棒的入门书是 <a href="https://book.douban.com/subject/1896753">《深入理解计算机系统》</a>。</p>
<table>
<thead>
<tr>
<th>资料</th>
<th>级别</th>
<th>为什么是它</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="https://book.douban.com/subject/1896753/">深入理解计算机系统</a></strong></td>
<td>入门</td>
<td>高屋建瓴的完成一次计算机体系的知识更新。</td>
</tr>
</tbody>
</table>
<h2 id="计算机网络"><a class="header-anchor" href="#计算机网络">¶</a>计算机网络</h2>
<p>计算机网络现在已经是逃不了的学科，个人推荐可以先从实操性很强的 <code>CCNA</code> 入门，比较学起来会比较有趣，一下子就会修公司的网了。之后我们需要完善 <code>知识体系</code>，因此推荐 <a href="https://book.douban.com/subject/30280001/">《计算机网络》</a> ，之后可以单独看下 <code>TCP/IP</code> 然后实现它，那你就会对网络流有8层的掌握，最终看看真实世界的网络是如何被操作系统驱动起来的 <strong><a href="https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html">Linux IP Networking</a></strong>。</p>
<table>
<thead>
<tr>
<th>资料</th>
<th>级别</th>
<th>为什么是它</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="https://book.douban.com/subject/2968802/">CCNA学习指南</a></strong></td>
<td>入门</td>
<td>建议所有的软件工程师从实践的角度实践下网络设备于IP网络基础。</td>
</tr>
<tr>
<td><strong><a href="https://book.douban.com/subject/30280001/">计算机网络</a></strong></td>
<td>入门</td>
<td>体系化的学习网络</td>
</tr>
<tr>
<td><strong><a href="https://book.douban.com/subject/1088054/">TCP/IP详解 卷1：协议</a></strong></td>
<td>进阶</td>
<td>理解协议的原理才能越战越勇</td>
</tr>
<tr>
<td><strong><a href="https://www.saminiir.com/lets-code-tcp-ip-stack-1-ethernet-arp/">Let’s code a TCP/IP stack</a></strong></td>
<td>实践</td>
<td>实现一个 TCP IP Stack，多么合乎道理</td>
</tr>
<tr>
<td><strong><a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol</a></strong></td>
<td>进阶</td>
<td>拒绝二手知识，好好读一遍协议本身</td>
</tr>
<tr>
<td><strong><a href="https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html">Linux IP Networking</a></strong></td>
<td>进阶</td>
<td>只有了解真实的网络才有切实的价值，资料较早，自行过滤过期知识</td>
</tr>
</tbody>
</table>
<h2 id="操作系统"><a class="header-anchor" href="#操作系统">¶</a>操作系统</h2>
<blockquote>
<p>笔者在操作系统上溜达了好多年，发现最终你还是要自己动手去实现才能了解这一切的背后</p>
</blockquote>
<p><strong><a href="https://book.douban.com/subject/1390650/">《现代操作系统》</a></strong> 值得一看，预备一点知识的基础，之后就应该去看一些简单的系统的实现，略过 <code>Virtual Memory</code> 的 <code>RTOS</code> 也是可以作为入门的对象，因此本文推荐了三个<code>“从零实现操作系统”</code>的教程，完成一个操作系统再去看看现在的操作系统会进步的快一点。</p>
<p>当然最后我们需要看看真实世界的操作系统是怎么运作，如果是Linux推荐：<strong><a href="https://book.douban.com/subject/6097773/">《Linux内核设计与实现(原书第3版)》</a></strong></p>
<table>
<thead>
<tr>
<th>资料</th>
<th>级别</th>
<th>为什么是它</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="https://book.douban.com/subject/1390650/">现代操作系统</a></strong></td>
<td>预科</td>
<td>了解操作系统应有的抽象</td>
</tr>
<tr>
<td><strong><a href="https://www.bilibili.com/video/av51437944/">操作系统（哈工大李治军老师</a></strong></td>
<td>入门</td>
<td>基于 <strong>Linux 0.11</strong> 讲解一个最简单的系统构成</td>
</tr>
<tr>
<td><strong><a href="https://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf">os-dev</a></strong> &amp;&amp; <strong><a href="http://jamesmolloy.co.uk/tutorial_html/">Roll your own toy UNIX-clone OS</a></strong> &amp;&amp; <strong><a href="https://tuhdo.github.io/os01/">Operating Systems: From 0 to 1</a></strong></td>
<td>进阶</td>
<td>一个操作系统的五脏六腑</td>
</tr>
<tr>
<td><strong><a href="https://pdos.csail.mit.edu/6.828/2018/index.html">MIT 6.828</a></strong></td>
<td>进阶</td>
<td>完整的完成一个 OS</td>
</tr>
<tr>
<td><strong><a href="https://book.douban.com/subject/6097773/">Linux内核设计与实现(原书第3版)</a></strong></td>
<td>进阶</td>
<td>了解 Linux 的实现</td>
</tr>
</tbody>
</table>
<h2 id="分布式系统"><a class="header-anchor" href="#分布式系统">¶</a>分布式系统</h2>
<p>随着计算机在数量上的增加，计算机需要很多机器联动才能完成一些任务，因此分布式系统已经成了一门显学。推荐的自学参考书是 Martin Kleppmann 的 **<a href="https://book.douban.com/subject/30329536/">《数据密集型应用系统设计》</a>**它是一本为实践者设计的具有很高的可读性的书。<br>
对于喜欢视频课程的人，MIT 的 <strong><a href="https://pdos.csail.mit.edu/6.824/schedule.html">6.824</a></strong> 是一门很好的在线视频课程，由 Robert Morris 教授的研究生课程，记得做习题。</p>
<table>
<thead>
<tr>
<th>资料</th>
<th>级别</th>
<th>为什么是它</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="https://pdos.csail.mit.edu/6.824/schedule.html">MIT 6.824</a></strong></td>
<td>入门</td>
<td>分布式领域的王牌教程</td>
</tr>
<tr>
<td><strong><a href="https://book.douban.com/subject/30329536/">数据密集型应用系统设计</a></strong></td>
<td>入门</td>
<td>分布式领域的数据系统</td>
</tr>
</tbody>
</table>
<h2 id="数据库"><a class="header-anchor" href="#数据库">¶</a>*数据库</h2>
<p>数据库是较为复杂的多学科构成的领域，很多系统并没有开源，开源的文档或者研究也不算甚多，因此推荐 <a href="https://book.douban.com/subject/2256069/">Readings in Database Systems</a> 作为入门的选项， <a href="https://book.douban.com/subject/1155934/">《数据库管理系统：原理与设计》</a> 可以作为导论查阅。</p>
<blockquote>
<p>数据库笔者涉及甚少，不做推荐了</p>
</blockquote>
<h2 id="NEXT"><a class="header-anchor" href="#NEXT">¶</a>NEXT</h2>
<p>当你完成了这一些，或者在半途，你总是会遇见很多不一样的情况，比如你加入了 <code>CNCF</code> 的社区，为公司编写 <code>API Gateway</code> 等等，那时候你可以会超过本文推荐的任意一本的深度，你不得不去自学去探索这一切，不用畏惧，你已经有了良好的基础，剩下来的路需要你带上这些武器，披荆斩棘，希望你在计算机的世界玩的开心。</p>
<h2 id="Ref"><a class="header-anchor" href="#Ref">¶</a>Ref</h2>
<ul>
<li><a href="https://teachyourselfcs.com/">Teach Yourself Computer Science</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>自学</category>
      </categories>
      <tags>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生之下的Java</title>
    <url>/2019/05/29/java/fxxk-java-in-cloud-native/</url>
    <content><![CDATA[<p>自从公司的运行平台全线迁入了 <code>Kubenetes</code> 之后总是觉得 <code>Devops</code> 变成了一个比以前更困难的事情，反思了一下，这一切的困境居然是从现在所使用的 <code>Java</code> 编程语言而来，那我们先聊聊云原生。</p>
<span id="more"></span>
<p><code>Cloud Native</code> 在我的理解是，虚拟化之后企业上云，现在的企业几乎底层设施都已经云化之后，对应用的一种倒逼，<code>Cloud Native</code>是一个框，什么都可以往里面扔，但是有些基础是被大家共识的，首先云原生当然和编程语言无关，说的是一个应用如何被创建/部署，后续的就引申出了比如<code>Devops</code>之类的新的理念，但是回到问题的本身，<code>Cloud Native</code>提出的一个很重要的要求，<strong>应用如何部署</strong> 这个问题从以前由应用决定，现在变成了，基础设施 <strong>决定</strong> 应用应该如何部署。</p>
<p>让我们回到一切的开始，首先<code>云原生</code>亦或者是<code>Devops</code>都有一个基础的要求，当前版本的代码能够在任何一个环境运行，看起来是不是一个很简单的需求，但是这个需求有一个隐喻所有的环境的基础设施是一样的，显然不能你的开发环境是 <code>Windows</code> 测试环境<code>Debian</code>生产环境又是<code>Centos</code>那怎么解决呢，从这一环，我们需要一个<code>工具箱</code>然后往这个工具箱里面扔我们需要的工具了。首先我们需要的就是 <code>Cloud Native</code>工具箱中最为明显的产品 <code>Docker/Continar</code>，经常有 <code>Java </code>开发者问我，<code>Docker</code> 有什么用，我的回答是，<code>Docker</code> 对<code>Java</code> 不是必须的，但是对于其他的语言往往是如果伊甸园中的苹果一样的诱人，打个比方，一个随系统打包的二进制发行版本，可以在任何地方运行，是不是让人很激动，对于大部分的<code>Java</code>开发者可能无感，对于C语言项目的编写者，那些只要不是基于虚拟机的语言，他们都需要系统提供运行环境，而系统千变万化，当然开发者不愿意为了不同的系统进行适配，在以前我们需要交叉编译，现在我们把这个复杂的事情交给了<code>Docker</code>，让<code>Docker</code>如同<code>Java</code>一样，一次编写处处运行，这样的事情简直就像是端了<code>Java</code>的饭碗，以前我们交付一个复杂的系统，往往连着操作系统一起交付，而客户可能买了一些商业系统，为了适配有可能还要改代码，现在你有了<code>Docker</code>，开发者喜大普奔，而这里的代价呢？<code>C&amp;C++&amp;GO</code>他们失去的是枷锁，获得全世界，而Java如同被革命一般，失去了 <code>Once Code，Everywhere Run</code>，获得的是更大的 <code>Docker Image Size</code>，获得被人诟病的 <code>Big Size Runtime</code>。</p>
<p><img src="https://i.loli.net/2019/05/29/5cee90a3a69d629314.png" alt=""></p>
<p>当我们从代码构建完成了镜像，<code>Cloud Navtive</code>的故事才刚刚开始，当你的<code>Team Leader</code>要求你的系统架构是<code>MicroServices</code>的，你把原来的项目进行拆分了，或者是开发的就拆分的足够小的时候，你发现因为代码拆分开了，出现了一点点的代码的重复，有适合也避免不了的，你的依赖库也变的 <code>xN</code>，隔壁Go程序员想了想，不行我们就搞个 <code>.so</code> 共享一部分代码吧，然后看了构建出来的二进制文件才 <code>15MB</code>，运维大手一挥，这点大小有啥要共享的，<code>Java</code> 程序员望了望了自己的 <code>Jar</code> 包，<code>60MB</code>还行吧，维护镜像仓库的运维同事这个时候跑出来，你的镜像怎么有 <code>150MB</code> 了， 你看看你们把磁盘都塞满了，只能苦笑，运维小哥坑次坑次的给打包机加了一块硬盘，顺便问你马上部署了，你需要多大的<strong>配额</strong>，你说道 2C4G，运维一脸嫌弃的问你，为什么隔壁GO项目组的同事才需要 <code>0.5C512MB</code>。你当然也不用告诉他，<code>SpringBoot</code> 依赖的了 <code>XXX</code>,<code>YYY</code>,<code>ZZZ</code> 的库，虽然一半的功能你都没用到。</p>
<p>部署到线上，刚刚准备喘口气，突然发现新的需求又来了，虽然是一个很小的功能，但是和现在的系统内的任何一个服务都没有什么直接关联性，你提出再新写一个服务，运维主管抱怨道，现在的服务器资源还是很紧张，你尝试着用现在最流行的 <code>Vertx</code>开发一个简单的Web服务，你对构建出来的jar 只有 10MB 很满意，可是镜像加起来还是有 60 MB，也算一种进步，你找到QA主管，准备Show一下你用了Java社区最酷的框架，最强的性能，QA主管找了一个台 1C2G 的服务让你压测一下，你发现你怎么也拼不过别人Go系统，你研究之后发现，原来协程模型在这样的少核心的情况下性能要更好，你找运维希望能升级下配置，你走到运维门口的时候，你停了下来，醒醒吧，不是你错了，而是时代变了。</p>
<hr>
<p>云原生压根不是为了 Java 存在的，云原生的时代已经不是 90 年代，那时候的软件是一个技术活，每一个系统都需要精心设计，一个系统数个月才会更新一个版本，每一个功能都需要进行完整的测试，软件也跑在了企业内部的服务器上，软件是IT部分的宝贝，给他最好的环境，而在 9012 年，软件是什么？软件早就爆炸了，IT从业者已经到达一个峰值，还有源源不断的人输入进来，市场的竞争也变的激烈，软件公司的竞争力也早就不是质量高，而是如何更快的应对市场的变化，Java就如同一个身披无数荣光的二战将军，你让他去打21世纪的信息战，哪里还跟着上时代。</p>
<p>云原生需要的是，More Fast &amp; More Fast 的<strong>交付</strong>系统，一个系统开发很快的系统，那天生就和精心设计是违背的，一个精心设计又能很快开发完的系统实在少见，所以我们从 <code>Spring Boot</code> 上直接堆砌业务代码，最多按照 <code>MVC</code>进行一个简单的分层，那些优秀的OOP理念都活在哪里，那些底层框架，而你突然有一天对Go来了兴趣，你按照学 juc 的包的姿势，想要学习下 Go 的优雅源码，你发现，天呐，那些底层库原来可以设计的如此简单，Cache只需要使用简单的 Map 加上一个 Lock 就可以获得很好的性能了，你开始怀疑了，随着你了解的越深入，你发现GO这个语言真是充满了各种各样的缺点，但是足够简单这个优势简直让你羡慕到不行，你回想起来，<code>Executors</code> 的用法你学了好几天，看了好多文章，才把自己的姿势学完，你发现 go func(){} 就解决你的需求了，你顺手删掉了 <code>JDK</code>，走上了真香之路。虽然你还会怀念 <code>SpringBoot</code> 的方便，你发现Go也足够满足你 80%的需求了，剩下俩的一点点就捏着鼻子就好了。你老婆也不怪你没时间陪孩子了，你的工资也涨了点，偶尔翻开自己充满设计模式的 <code>Old Style</code> 代码，再也没有什么兴趣了。</p>
<hr>
<p>PS：今天被查出来肾结石 17MM 了，兄弟们还是多注意身体，多喝水，保持锻炼。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>通过代码学习 - Java中的Synchronized</title>
    <url>/2018/03/28/java/java-lock-by-code/</url>
    <content><![CDATA[<h2 id="Synchronized-关键字"><a class="header-anchor" href="#Synchronized-关键字">¶</a>Synchronized 关键字</h2>
<h4 id="无Synchronized"><a class="header-anchor" href="#无Synchronized">¶</a>无Synchronized</h4>
<p>Synchronized是互斥锁，非常接近底层Mux的概念，就是把内存的一块区间给锁住，只允许一个线程使用。</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printIncrease</span><span class="params">()</span> &#123;</span><br><span class="line">        count = count + <span class="number">1</span>;  <span class="comment">//这里注意不能为 count++；这是一个原子性操作</span></span><br><span class="line">        System.out.println(Thread.currentThread().toString() + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;count is &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先创建一个Sender类，我们声明一个printIncrease函数，注意此时没有 synchronized 关键字。我们再构建一个测试Demo,模拟50个线程同时运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Synchronization</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Sender</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sender</span>();</span><br><span class="line">        List&lt;Thread&gt; runnables = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">            runnables.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(s::printIncrease));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        runnables.forEach(Thread::start);</span><br><span class="line">        runnables.forEach((r) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                r.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理论上我们最后一次的打印出来的Counter应该是49，因为我们运行了50次。但是在本机的结果是如下图（根据机器都不太一样）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread[Thread-44,5,main]:count is 44</span><br><span class="line">Thread[Thread-45,5,main]:count is 44</span><br><span class="line">Thread[Thread-46,5,main]:count is 46</span><br><span class="line">Thread[Thread-48,5,main]:count is 47</span><br><span class="line">Thread[Thread-49,5,main]:count is 47</span><br><span class="line">Thread[Thread-47,5,main]:count is 47</span><br></pre></td></tr></table></figure>
<h3 id="Synchronized方式"><a class="header-anchor" href="#Synchronized方式">¶</a>Synchronized方式</h3>
<p>那我们此时加上 synchronized</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">printIncrease</span><span class="params">()</span> &#123;</span><br><span class="line">         count = count + <span class="number">1</span>;</span><br><span class="line">         System.out.println(Thread.currentThread().toString() + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;count is &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如图如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread[Thread-47,5,main]:count is 47</span><br><span class="line">Thread[Thread-48,5,main]:count is 49</span><br><span class="line">Thread[Thread-49,5,main]:count is 50</span><br></pre></td></tr></table></figure>
<p>我们可以看出来synchronized第一特性就是同步函数的特性。</p>
<h3 id="Synchronized-属性"><a class="header-anchor" href="#Synchronized-属性">¶</a>Synchronized 属性</h3>
<p>我们换一种方式，我们synchronized 这个 count 属性，结果呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printIncrease</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (count) &#123;</span><br><span class="line">            count = count + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().toString() + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;count is &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread[Thread-1,5,main]:count is 0</span><br><span class="line">Thread[Thread-4,5,main]:count is 0</span><br><span class="line">Thread[Thread-3,5,main]:count is 0</span><br><span class="line">Thread[Thread-2,5,main]:count is 0</span><br><span class="line">Thread[Thread-0,5,main]:count is 0</span><br><span class="line">Thread[Thread-6,5,main]:count is 4</span><br></pre></td></tr></table></figure>
<p>我们发现没有完成我的需求，这是为什么呢，这是因为count并非是一个final的对象，其实每一个锁都是加在不同的对象上的。那我们应该怎么写呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printIncrease</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count = count + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().toString() + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;count is &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在内部申明一个变量就可以达到这样的效果。但是结果是怎么样的呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread[pool-1-thread-2,5,main]:synchronization.Sender@65570b43count is 2</span><br><span class="line">Thread[pool-1-thread-1,5,main]:synchronization.Sender@65570b43count is 2</span><br><span class="line">Thread[pool-1-thread-3,5,main]:synchronization.Sender@65570b43count is 3</span><br></pre></td></tr></table></figure>
<p>我们依然发现有并发的问题，很多同学会觉得是 <a href="https://www.cnblogs.com/redcreen/archive/2011/03/29/1998802.html">DCL双检锁</a> 的问题，实际上并非是，这里的问题在于<br>
System.out.println 的代码是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们发现这里其实有自己的一个Lock，相当在过程中会出现线程之间修改了Counter的值，但是我们可以看出来最后值是对的，说明我们执行的次数是正确的，如果避免这个问题呢？</p>
<p><em><strong>方法一</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printIncrease</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count = count + <span class="number">1</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().toString() + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.toString() + <span class="string">&quot;count is &quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>方法二</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printIncrease</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> realCount;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count = count + <span class="number">1</span>;</span><br><span class="line">            realCount = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().toString() + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.toString() + <span class="string">&quot;count is &quot;</span> + realCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Synchronized-类型"><a class="header-anchor" href="#Synchronized-类型">¶</a>Synchronized 类型</h3>
<p>我们再尝试将 此类型的 Class 锁住，效果也可以达成，因为Class其实也在我们内存中的一块区域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printIncrease</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Sender.class) &#123;</span><br><span class="line">            count = count + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().toString() + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;count is &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread[Thread-47,5,main]:count is 48</span><br><span class="line">Thread[Thread-48,5,main]:count is 49</span><br><span class="line">Thread[Thread-49,5,main]:count is 50</span><br></pre></td></tr></table></figure>
<h3 id="Synchronized-多实例"><a class="header-anchor" href="#Synchronized-多实例">¶</a>Synchronized 多实例</h3>
<p>OK，这个时候如果申明多个实例呢？尝试一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Synchronization</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Sender</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sender</span>();</span><br><span class="line">        <span class="type">Sender</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sender</span>();</span><br><span class="line">        LinkedList&lt;SimpleCallback&gt; runnables = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                runnables.add(i, <span class="keyword">new</span> <span class="title class_">SimpleCallback</span>(s));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                runnables.add(i, <span class="keyword">new</span> <span class="title class_">SimpleCallback</span>(s2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">50</span>);</span><br><span class="line">        executorService.invokeAll(runnables);</span><br><span class="line">        executorService.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printIncrease</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> realCount;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count = count + <span class="number">1</span>;</span><br><span class="line">            realCount = count;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().toString() + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.toString() + <span class="string">&quot;count is &quot;</span> + realCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleCallback</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sender sender;</span><br><span class="line"></span><br><span class="line">    SimpleCallback(Sender sender) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sender = sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Void <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sender.printIncrease();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread[pool-1-thread-2,5,main]:synchronization.Sender@af58fe3count is 1</span><br><span class="line">Thread[pool-1-thread-1,5,main]:synchronization.Sender@17748af7count is 1</span><br><span class="line">1s 之后</span><br><span class="line">Thread[pool-1-thread-50,5,main]:synchronization.Sender@af58fe3count is 2</span><br><span class="line">Thread[pool-1-thread-49,5,main]:synchronization.Sender@17748af7count is 2</span><br></pre></td></tr></table></figure>
<p>我们可以发现其实锁的本质就在于增加某一个变量的内存空间，如果是不同的对象自然是不同的锁。大胆的猜测如果锁加在类上，因为是唯一的地址空间那因为是一个接着一个启动的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printIncrease</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> realCount;</span><br><span class="line">        <span class="keyword">synchronized</span> (Sender.class) &#123;</span><br><span class="line">            count = count + <span class="number">1</span>;</span><br><span class="line">            realCount = count;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().toString() + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.toString() + <span class="string">&quot;count is &quot;</span> + realCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看见结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread[pool-1-thread-1,5,main]:synchronization.Sender@4878c7d7count is 1</span><br><span class="line">1s 之后</span><br><span class="line">Thread[pool-1-thread-50,5,main]:synchronization.Sender@7b267845count is 1</span><br><span class="line">1s 之后</span><br><span class="line">Thread[pool-1-thread-49,5,main]:synchronization.Sender@4878c7d7count is 2</span><br><span class="line">1s 之后</span><br></pre></td></tr></table></figure>
<h3 id="Synchronized-可重入性"><a class="header-anchor" href="#Synchronized-可重入性">¶</a>Synchronized 可重入性</h3>
<p>这个特性主要是针对当前线程而言的，可重入即是自己可以再次获得自己的内部锁，在尝试获取对象锁时，如果当前线程已经拥有了此对象的锁，则把锁的计数器加一，在释放锁时则对应地减一，当锁计数器为0时表示锁完全被释放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadLock</span> <span class="variable">deadLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLock</span>();</span><br><span class="line">        deadLock.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Synchronized-的非公平"><a class="header-anchor" href="#Synchronized-的非公平">¶</a>Synchronized 的非公平</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TODO 如何复现</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h3>
<p>synchronized最后一个特性（缺点）就是不可中断性，在所有等待的线程中，你们唯一能做的就是等，而实际情况可能是有些任务等了足够久了，我要取消此任务去干别的事情，此时synchronized是无法帮你实现的，它把所有实现机制都交给了JVM，提供了方便的同时也体现出了自己的局限性。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>java 小技巧 (1)</title>
    <url>/2018/03/07/java/java-tips/</url>
    <content><![CDATA[<ol>
<li>空间换时间的小把戏</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">        NAME(<span class="string">&quot;姓名&quot;</span>), AGE(<span class="string">&quot;年龄&quot;</span>), ADDRESS(<span class="string">&quot;住址&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String typeName;</span><br><span class="line"></span><br><span class="line">        Type(String typeName) &#123;</span><br><span class="line">            <span class="built_in">this</span>.typeName = typeName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Type <span class="title function_">fromTypeName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Type t : Type.values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.typeName.equals(name)) <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>这样写的坏处大概就是这个 fromTypeName 里面的for循环，虽然语义很清晰，但是我们每次都要去遍历整个枚举对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">        NAME(<span class="string">&quot;姓名&quot;</span>), AGE(<span class="string">&quot;年龄&quot;</span>), ADDRESS(<span class="string">&quot;住址&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Type&gt; all = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Type&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (Type t : Type.values()) &#123;</span><br><span class="line">                    all.put(t.typeName, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">private</span> String typeName;</span><br><span class="line"></span><br><span class="line">        Type(String typeName) &#123;</span><br><span class="line">            <span class="built_in">this</span>.typeName = typeName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> B.Type <span class="title function_">fromTypeName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> all.get(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在运行之初，我们将所有的对象都放置于Map中，这样直接通过HaskMap去获取对象的效率更高，从O(n) -&gt; O(1) 很标准的空间换时间的小把戏。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Java</category>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring cloud 配置中心服务</title>
    <url>/2017/03/01/java/spring-cloud-01-config/</url>
    <content><![CDATA[<p>为什么要写这一个系列的博客，主要是记录在自己学习Spring cloud中思考，倘若能够给大家一点点帮助，就更好了，写这个系列的话，抱着少即是多的心态，我们每一章讲的不会特别多，尽可能的每一章都比知识萃取的深一点。</p>
<hr>
<h4 id="PRE"><a class="header-anchor" href="#PRE">¶</a>PRE</h4>
<p>本文写于 2017-03-01， 代码针对于 <strong>Spring Cloud Camden.SR5</strong> 版本。</p>
<span id="more"></span>
<h2 id="Spring-Cloud-Config"><a class="header-anchor" href="#Spring-Cloud-Config">¶</a>Spring Cloud Config</h2>
<blockquote>
<p>Spring Cloud Config provides server and client-side support for externalized configuration in a distributed system.</p>
</blockquote>
<p>如官网所言，Spring cloud config 为分布式系统提供 CS架构的配置服务。按照这么个说法，其实我们就明白了，Spring Cloud Config 必然分为 Client 和 Server。下面我们就分别初始化一个Demo项目进行进一步的学习。</p>
<h2 id="Config-Server"><a class="header-anchor" href="#Config-Server">¶</a>Config Server</h2>
<ul>
<li><a href="https://github.com/spring-cloud/spring-cloud-config">Spring官网Demo</a></li>
<li><a href="https://github.com/yannxia-self/spring-cloud-sample/tree/master/spring-cloud-config-server-sample">作者编写的Demo</a></li>
<li><a href="http://www.baeldung.com/spring-cloud-configuration">Quick Intro to Spring Cloud Configuration</a></li>
</ul>
<p>具体的步骤这里就不说了，可以参考 Quick Intro to Spring Cloud Configuration 这个文章写的很详细，关于几点，接下来会细聊一下。</p>
<h3 id="Config-Server如何选择配置文件"><a class="header-anchor" href="#Config-Server如何选择配置文件">¶</a>Config Server如何选择配置文件</h3>
<blockquote>
<p>Where do you want to store the configuration data for the Config Server? The strategy that governs this behaviour is the EnvironmentRepository</p>
</blockquote>
<ul>
<li>{application} maps to “<a href="http://spring.application.name">spring.application.name</a>” on the client side;</li>
<li>{profile} maps to “spring.profiles.active” on the client (comma separated list); and</li>
<li>{label} which is a server side feature labelling a “versioned” set of config files.</li>
</ul>
<p>Config Server 是从哪里去读文件的，这里说明了，核心的是EnvironmentRepository这个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EnvironmentRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">	Environment <span class="title function_">findOne</span><span class="params">(String application, String profile, String label)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看出来，根据application+ profile+ label 就可以确定一个唯一的环境变量对象。正如上文所言application是 <em>客户端</em> 的spring.application.name的属性，profile 是 <em>客户端</em> 的spring.profiles.active属性，而 label 是 <em>服务端</em> 的版本概念。</p>
<p>在服务端的代码中，我们发现我们是配置了我们所有的配置所在的仓库地址的，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.cloud.config.server.git.uri: file:///$&#123;user.home&#125;/config-repo</span><br></pre></td></tr></table></figure>
<p>在此处的含义我们存放配置的路径是 ~/config-repo ，那具体对应的文件名是什么？<br>
很神奇的是在文档中我并没有找到说明 (针对编写时的文档)，而从网上得知，所对应的文件是：<br>
application+profile+.yml 等<br>
倘若 application = foo， profile = dev， 那配置文件应该是 foo-dev.yml。<br>
这段逻辑在Spring Cloud Config的文档中并无说明，这段逻辑在固有的Spring 文档有说明可以查看<br>
<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-profile-specific-properties">24.4 Profile-specific properties</a> 在这段中说明，Spring的逻辑是这样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Environment <span class="title function_">findOne</span><span class="params">(String config, String profile, String label)</span> &#123;</span><br><span class="line">	<span class="type">SpringApplicationBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>(</span><br><span class="line">			PropertyPlaceholderAutoConfiguration.class);</span><br><span class="line">	<span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> getEnvironment(profile);</span><br><span class="line">	builder.environment(environment);</span><br><span class="line">	builder.web(<span class="literal">false</span>).bannerMode(Mode.OFF);</span><br><span class="line">	<span class="keyword">if</span> (!logger.isDebugEnabled()) &#123;</span><br><span class="line">		<span class="comment">// Make the mini-application startup less verbose</span></span><br><span class="line">		builder.logStartupInfo(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	String[] args = getArgs(config, profile, label);</span><br><span class="line">	<span class="comment">// Explicitly set the listeners (to exclude logging listener which would change</span></span><br><span class="line">	<span class="comment">// log levels in the caller)</span></span><br><span class="line">	builder.application()</span><br><span class="line">			.setListeners(Arrays.asList(<span class="keyword">new</span> <span class="title class_">ConfigFileApplicationListener</span>()));</span><br><span class="line">	<span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> builder.run(args);  ①</span><br><span class="line">	environment.getPropertySources().remove(<span class="string">&quot;profiles&quot;</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> clean(<span class="keyword">new</span> <span class="title class_">PassthruEnvironmentRepository</span>(environment).findOne(config,</span><br><span class="line">				profile, label));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		context.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 NativeEnvironmentRepository 中，我们发现这样的代码，我们在①处看见，其实Spring是在Config Server这段将我们传入的参数组装成一个普通启动的参数，去尝试自己去运行一个ApplicationContext，这样就是解释清楚了为什么这里的逻辑是SpringContext中的，所以我们发现一个简单的道理，其实Spring不仅仅是直接吧文件返回这么简单，自己是尝试使用 Spring固有的逻辑在服务器端就将配置解析成 Environment 这个类的。</p>
<p>那再深层次为何是这个文件，经过不懈的努力，在 ConfigFileApplicationListener 中发现。<br>
org.springframework.boot.context.config.ConfigFileApplicationListener.Loader#load(java.lang.String, java.lang.String, org.springframework.boot.context.config.ConfigFileApplicationListener.Profile) 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(String location, String name, Profile profile)</span></span><br><span class="line">				<span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;profile=&quot;</span> + (profile == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : profile);</span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasText(name)) &#123;</span><br><span class="line">		<span class="comment">// Try to load directly from the location</span></span><br><span class="line">		loadIntoGroup(group, location, profile);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// Search for a file with the given name</span></span><br><span class="line">	<span class="keyword">for</span> (String ext : <span class="built_in">this</span>.propertiesLoader.getAllFileExtensions()) &#123; ①</span><br><span class="line">		<span class="keyword">if</span> (profile != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Try the profile-specific file</span></span><br><span class="line">			loadIntoGroup(group, location + name + <span class="string">&quot;-&quot;</span> + profile + <span class="string">&quot;.&quot;</span> + ext,<span class="literal">null</span>);</span><br><span class="line">			<span class="keyword">for</span> (Profile processedProfile : <span class="built_in">this</span>.processedProfiles) &#123;</span><br><span class="line">				<span class="keyword">if</span> (processedProfile != <span class="literal">null</span>) &#123;</span><br><span class="line">					loadIntoGroup(group, location + name + <span class="string">&quot;-&quot;</span> + processedProfile + <span class="string">&quot;.&quot;</span> + ext, profile); ②</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Sometimes people put &quot;spring.profiles: dev&quot; in</span></span><br><span class="line">				<span class="comment">// application-dev.yml (gh-340). Arguably we should try and error</span></span><br><span class="line">				<span class="comment">// out on that, but we can be kind and load it anyway.</span></span><br><span class="line">				loadIntoGroup(group, location + name + <span class="string">&quot;-&quot;</span> + profile + <span class="string">&quot;.&quot;</span> + ext, profile);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Also try the profile-specific section (if any) of the normal file</span></span><br><span class="line">				loadIntoGroup(group, location + name + <span class="string">&quot;.&quot;</span> + ext, profile);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以从 ① 发现Spring所支持的后缀名：“properties”,“xml”,“yml”,“yaml” ，而在②处我们发现就是按照 - 逻辑给拼接起来的。</p>
<h3 id="Config-Server-是怎么样的一种服务呢？"><a class="header-anchor" href="#Config-Server-是怎么样的一种服务呢？">¶</a>Config Server 是怎么样的一种服务呢？</h3>
<ul>
<li>org.springframework.cloud.config.server.environment.EnvironmentController</li>
<li>org.springframework.cloud.config.server.resource.ResourceController<br>
这两个类出卖了整个项目，每次看Spring源码都能发现一些比较高级的用法。<br>
比如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&#123;name&#125;-&#123;profiles&#125;.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">properties</span><span class="params">(<span class="meta">@PathVariable</span> String name,</span></span><br><span class="line"><span class="params">		<span class="meta">@PathVariable</span> String profiles,</span></span><br><span class="line"><span class="params">		<span class="meta">@RequestParam(defaultValue = &quot;true&quot;)</span> <span class="type">boolean</span> resolvePlaceholders)</span></span><br><span class="line">		<span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="keyword">return</span> labelledProperties(name, profiles, <span class="literal">null</span>, resolvePlaceholders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来可以在一个 ／ 后面直接使用2个@PathVariable。</p>
<p>看到这里也就明白了，整个Config Server其实是一个Web服务，基于HTTP的方式。从这个方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&#123;name&#125;/&#123;profiles&#125;/&#123;label:.*&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Environment <span class="title function_">labelled</span><span class="params">(<span class="meta">@PathVariable</span> String name, <span class="meta">@PathVariable</span> String profiles,</span></span><br><span class="line"><span class="params">		<span class="meta">@PathVariable</span> String label)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (label != <span class="literal">null</span> &amp;&amp; label.contains(<span class="string">&quot;(_)&quot;</span>)) &#123;</span><br><span class="line">		<span class="comment">// &quot;(_)&quot; is uncommon in a git branch name, but &quot;/&quot; cannot be matched</span></span><br><span class="line">		<span class="comment">// by Spring MVC</span></span><br><span class="line">		label = label.replace(<span class="string">&quot;(_)&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="built_in">this</span>.repository.findOne(name, profiles, label); ①</span><br><span class="line">	<span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从①得知，最核心的就是Environment，正如我们上一点所说。</p>
<hr>
<p>Config Server的内容并不多，从源码的包中我们就发现，更多的功能就有待后续的增加吧，我们接下来看看 Config Client</p>
<h2 id="Config-Clinet"><a class="header-anchor" href="#Config-Clinet">¶</a>Config Clinet</h2>
<h3 id="Client-如何查询-Server"><a class="header-anchor" href="#Client-如何查询-Server">¶</a>Client 如何查询 Server</h3>
<p>我们把眼光转型到 org.springframework.cloud.config.client.ConfigServicePropertySourceLocator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> org.springframework.core.env.PropertySource&lt;?&gt; locate(</span><br><span class="line">			org.springframework.core.env.Environment environment) &#123;</span><br><span class="line">	<span class="type">ConfigClientProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="built_in">this</span>.defaultProperties.override(environment);</span><br><span class="line">	<span class="type">CompositePropertySource</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompositePropertySource</span>(<span class="string">&quot;configService&quot;</span>);</span><br><span class="line">	<span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="built_in">this</span>.restTemplate == <span class="literal">null</span> ? getSecureRestTemplate(properties): <span class="built_in">this</span>.restTemplate;</span><br><span class="line">	<span class="type">Exception</span> <span class="variable">error</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">errorBody</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	logger.info(<span class="string">&quot;Fetching config from server at: &quot;</span> + properties.getRawUri());</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		String[] labels = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(properties.getLabel())) &#123;</span><br><span class="line">			labels = StringUtils.commaDelimitedListToStringArray(properties.getLabel());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">state</span> <span class="operator">=</span> ConfigClientStateHolder.getState();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Try all the labels until one works</span></span><br><span class="line">		<span class="keyword">for</span> (String label : labels) &#123;</span><br><span class="line">			<span class="type">Environment</span> <span class="variable">result</span> <span class="operator">=</span> getRemoteEnvironment(restTemplate,properties, label.trim(), state);  ①</span><br><span class="line">			<span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">				logger.info(String.format(<span class="string">&quot;Located environment: name=%s, profiles=%s, label=%s, version=%s, state=%s&quot;</span>,</span><br><span class="line">						result.getName(),</span><br><span class="line">						result.getProfiles() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : Arrays.asList(result.getProfiles()),</span><br><span class="line">						result.getLabel(), result.getVersion(), result.getState()));</span><br><span class="line">				<span class="keyword">if</span> (result.getPropertySources() != <span class="literal">null</span>) &#123; <span class="comment">// result.getPropertySources() can be null if using xml</span></span><br><span class="line">					<span class="keyword">for</span> (PropertySource source : result.getPropertySources()) &#123;</span><br><span class="line">						<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">						Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) source</span><br><span class="line">								.getSource();</span><br><span class="line">						composite.addPropertySource(<span class="keyword">new</span> <span class="title class_">MapPropertySource</span>(source</span><br><span class="line">								.getName(), map));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (StringUtils.hasText(result.getState()) || StringUtils.hasText(result.getVersion())) &#123;</span><br><span class="line">					HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">					putValue(map, <span class="string">&quot;config.client.state&quot;</span>, result.getState());</span><br><span class="line">					putValue(map, <span class="string">&quot;config.client.version&quot;</span>, result.getVersion());</span><br><span class="line">					composite.addFirstPropertySource(<span class="keyword">new</span> <span class="title class_">MapPropertySource</span>(<span class="string">&quot;configClient&quot;</span>, map));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> composite;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	以下异常处理略…………</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Environment <span class="title function_">getRemoteEnvironment</span><span class="params">(RestTemplate restTemplate, ConfigClientProperties properties,</span></span><br><span class="line"><span class="params">											 String label, String state)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/&#123;name&#125;/&#123;profile&#125;&quot;</span>;   ②</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> properties.getName();</span><br><span class="line">	<span class="type">String</span> <span class="variable">profile</span> <span class="operator">=</span> properties.getProfile();</span><br><span class="line">	<span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> properties.getToken();</span><br><span class="line">	<span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> properties.getRawUri();</span><br><span class="line"></span><br><span class="line">	Object[] args = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; name, profile &#125;;</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasText(label)) &#123;</span><br><span class="line">		args = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; name, profile, label &#125;;</span><br><span class="line">		path = path + <span class="string">&quot;/&#123;label&#125;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ResponseEntity&lt;Environment&gt; response = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(token)) &#123;</span><br><span class="line">			headers.add(TOKEN_HEADER, token);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(state)) &#123; <span class="comment">//<span class="doctag">TODO:</span> opt in to sending state?</span></span><br><span class="line">				headers.add(STATE_HEADER, state);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">final</span> HttpEntity&lt;Void&gt; entity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;((Void) <span class="literal">null</span>, headers);</span><br><span class="line">		response = restTemplate.exchange(uri + path, HttpMethod.GET,</span><br><span class="line">					entity, Environment.class, args); ③</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (HttpClientErrorException e) &#123;</span><br><span class="line">		<span class="keyword">if</span> (e.getStatusCode() != HttpStatus.NOT_FOUND) &#123;</span><br><span class="line">			<span class="keyword">throw</span> e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (response == <span class="literal">null</span> || response.getStatusCode() != HttpStatus.OK) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Environment</span> <span class="variable">result</span> <span class="operator">=</span> response.getBody();</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从 ① 处我们看出来这最后是一个Http的请求。 从 ② 处，我们直接看出最终访问的 HTTP的地址就是 “/{name}/{profile}”， 从 ③ 处我们又发现最后得到的就是  Environment.class 这个类型，和我们在Server上看见的代码是一致，这样我们的整个逻辑就串联起来了。</p>
<hr>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>Spring Cloud Config 在编写此博客的时候还是一个很简单的服务，仅仅是提供一个 Environment.class 的CS架构的服务，在Server也没实现分布式等等，现在看来还说一个比较基础的服务。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Java</category>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-convert-(基本结构)</title>
    <url>/2016/12/13/java/spring-convert-01/</url>
    <content><![CDATA[<p>上次自己留的坑，自己填一下吧。</p>
<span id="more"></span>
<h2 id="PRE"><a class="header-anchor" href="#PRE">¶</a>PRE</h2>
<p><strong>S -&gt; Source</strong><br>
<strong>T -&gt; Target</strong></p>
<h2 id="KeySPI"><a class="header-anchor" href="#KeySPI">¶</a>KeySPI</h2>
<h3 id="Converter"><a class="header-anchor" href="#Converter">¶</a>Converter</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;S, T&gt; &#123;</span><br><span class="line">    T <span class="title function_">convert</span><span class="params">(S source)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从名称就能很轻易的看出，这是最基础的从 S -&gt; T.  这点应该和Spring学习。对比我喜欢用A -&gt; B<br>
的确不如Spring的 Soruce 和 Target 专业。细节处应该好好学(doge:)。大家都是写Java的，至于用法，就不用细说。</p>
<h3 id="ConverterFactory"><a class="header-anchor" href="#ConverterFactory">¶</a>ConverterFactory</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConverterFactory</span>&lt;S, R&gt; &#123;</span><br><span class="line">    &lt;T <span class="keyword">extends</span> <span class="title class_">R</span>&gt; Converter&lt;S, T&gt; <span class="title function_">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个从ConverterFactory貌似看不出来啥，核心是 &lt;T extends R&gt; 这个返回值，说明最终得到的是 R的SubClass。用法可以参考 <a href="https://github.com/spring-projects/spring-framework/blob/bc14c5ba83e1f211628456bbccce7b2531aac58c/spring-core/src/main/java/org/springframework/core/convert/support/StringToEnumConverterFactory.java">StringToEnumConverterFactory</a> 这个类.核心是因为传入T的实际类型，可以通过反射做些什么，大部分都用在枚举中，其他场景使用很少。</p>
<h3 id="GenericConverter"><a class="header-anchor" href="#GenericConverter">¶</a>GenericConverter</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericConverter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title function_">getConvertibleTypes</span><span class="params">()</span>;</span><br><span class="line">    Object <span class="title function_">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GenericConverter如官网所言 <em>When you require a</em> <strong>sophisticated</strong>  <em>Converter implementation, consider the GenericConverter interface.</em><br>
当我们需要复杂些的实现的时候可以考虑，这个实现是多种转换的聚合。</p>
<h3 id="ConditionalGenericConverter"><a class="header-anchor" href="#ConditionalGenericConverter">¶</a>ConditionalGenericConverter</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConditionalGenericConverter</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">GenericConverter</span>, ConditionalConverter &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如名所见，满足Source 和 TargetType 的条件。至于 <a href="https://github.com/spring-projects/spring-framework/blob/e49813f2c4c6bb645c0990b3bd0fc290fc7c9f8e/spring-core/src/main/java/org/springframework/core/convert/TypeDescriptor.java">TypeDescriptor</a>可以看作成S和T的包装类。</p>
<h3 id="ConversionService"><a class="header-anchor" href="#ConversionService">¶</a>ConversionService</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConversionService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">canConvert</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span>;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">convert</span><span class="params">(Object source, Class&lt;T&gt; targetType)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">canConvert</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line">    Object <span class="title function_">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于我们得到了最终的SPI，从SPI中我们就看出来，前两个接口是普通的 S -&gt; T，下面两个增加了ConditionalGenericConverter中的条件转换。</p>
<p>到这里Spring的核心SPI就结束了，官方文档也就说了这么多，那下面进行我们自己的探秘，文档不写的东西，让我们都去代码里面找答案。</p>
<h2 id="SPI-实现"><a class="header-anchor" href="#SPI-实现">¶</a>SPI 实现</h2>
<p><a href="https://github.com/spring-projects/spring-framework/blob/b22a59a0c4ea118147dc45c563d68234b8692d97/spring-core/src/main/java/org/springframework/core/convert/support/DefaultConversionService.java">DefaultConversionService.java</a>是Spring的默认标准实现，我们从这个类开始看起。</p>
<p>先立FLAG，根据我对源码的了解，肯定有一个类似于<a href="https://github.com/yannxia/chameleon/blob/master/src/main/java/info/yannxia/java/chameleon/AbstractConvertFactory.java">keyCovertInstantConcurrentHashMap</a> 的东西作为一个核心容器。</p>
<p><img src="http://ww2.sinaimg.cn/large/759074fcjw1f0d87evnxdj21bc0qo0ws.jpg" alt="Flag"></p>
<p>看代码，老司机告诉你们一个真理，从第一行往下看是不明智的，从调用端入口看，那才是明智之选。<br>
所以我们先从convert这个最核心的方法看起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericConversionService</span> <span class="keyword">implements</span> <span class="title class_">ConfigurableConversionService</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; T <span class="title function_">convert</span><span class="params">(Object source, Class&lt;T&gt; targetType)</span> &#123;</span><br><span class="line">			Assert.notNull(targetType, <span class="string">&quot;targetType to convert to cannot be null&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> (T) convert(source, TypeDescriptor.forObject(source), TypeDescriptor.valueOf(targetType));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是DefaultConversionService的Convert的入口，从这里，我们一步一步的深入核心，然后我们可以发现，代码的流向是<br>
convert() -&gt; getConverter() -&gt; this.converters.find(sourceType, targetType)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> GenericConverter <span class="title function_">find</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">			<span class="comment">// Search the full type hierarchy</span></span><br><span class="line">			List&lt;Class&lt;?&gt;&gt; sourceCandidates = getClassHierarchy(sourceType.getType());</span><br><span class="line">			List&lt;Class&lt;?&gt;&gt; targetCandidates = getClassHierarchy(targetType.getType());</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; sourceCandidate : sourceCandidates) &#123;</span><br><span class="line">				<span class="keyword">for</span> (Class&lt;?&gt; targetCandidate : targetCandidates) &#123;</span><br><span class="line">					<span class="type">ConvertiblePair</span> <span class="variable">convertiblePair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConvertiblePair</span>(sourceCandidate, targetCandidate);</span><br><span class="line">					<span class="type">GenericConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getRegisteredConverter(sourceType, targetType, convertiblePair);</span><br><span class="line">					<span class="keyword">if</span> (converter != <span class="literal">null</span>) &#123;</span><br><span class="line">						<span class="keyword">return</span> converter;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bingo,我们最终发现一个非常重要的东西getRegisteredConverter()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> GenericConverter <span class="title function_">getRegisteredConverter</span><span class="params">(TypeDescriptor sourceType,</span></span><br><span class="line"><span class="params">				TypeDescriptor targetType, ConvertiblePair convertiblePair)</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check specifically registered converters</span></span><br><span class="line">			<span class="type">ConvertersForPair</span> <span class="variable">convertersForPair</span> <span class="operator">=</span> <span class="built_in">this</span>.converters.get(convertiblePair);</span><br><span class="line">			<span class="keyword">if</span> (convertersForPair != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="type">GenericConverter</span> <span class="variable">converter</span> <span class="operator">=</span> convertersForPair.getConverter(sourceType, targetType);</span><br><span class="line">				<span class="keyword">if</span> (converter != <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> converter;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Check ConditionalConverters for a dynamic match</span></span><br><span class="line">			<span class="keyword">for</span> (GenericConverter globalConverter : <span class="built_in">this</span>.globalConverters) &#123;</span><br><span class="line">				<span class="keyword">if</span> (((ConditionalConverter) globalConverter).matches(sourceType, targetType)) &#123;</span><br><span class="line">					<span class="keyword">return</span> globalConverter;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上，我们就发现了，this.converters 和 this.globalConverters 这两个就是整个转换的核心所在。<br>
看下比较核心的converters的声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;GenericConverter&gt; globalConverters = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;GenericConverter&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ConvertiblePair, ConvertersForPair&gt; converters =</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;ConvertiblePair, ConvertersForPair&gt;(<span class="number">36</span>);</span><br></pre></td></tr></table></figure>
<p>上面立的那个Flag算是成功了解围了，的确是一个HashMap，不过实际是一个LinkedHashMap。<br>
那我继续看啊···ConvertiblePair是个什么鬼东西</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConvertiblePair</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; sourceType;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; targetType;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">ConvertiblePair</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span> &#123;</span><br><span class="line">			Assert.notNull(sourceType, <span class="string">&quot;Source type must not be null&quot;</span>);</span><br><span class="line">			Assert.notNull(targetType, <span class="string">&quot;Target type must not be null&quot;</span>);</span><br><span class="line">			<span class="built_in">this</span>.sourceType = sourceType;</span><br><span class="line">			<span class="built_in">this</span>.targetType = targetType;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (<span class="built_in">this</span>.sourceType.hashCode() * <span class="number">31</span> + <span class="built_in">this</span>.targetType.hashCode());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>那我们找到了这个Key，这个设计，正如我之前变色龙中所声明 <a href="https://github.com/yannxia/chameleon/blob/master/src/main/java/info/yannxia/java/chameleon/ConvertKey.java">ConvertKey</a>极为的类似。</p>
<p>不过Spring的Value就是复杂了些，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConvertersForPair</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;GenericConverter&gt; converters = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;GenericConverter&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(GenericConverter converter)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.converters.addFirst(converter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> GenericConverter <span class="title function_">getConverter</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (GenericConverter converter : <span class="built_in">this</span>.converters) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(converter <span class="keyword">instanceof</span> ConditionalGenericConverter) ||</span><br><span class="line">					((ConditionalGenericConverter) converter).matches(sourceType, targetType)) &#123;</span><br><span class="line">				<span class="keyword">return</span> converter;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从这里getConverter方法，可以看出，通过S和T的类型描述去获得真正的转换器。举个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultConversionService</span> <span class="variable">defaultConversionService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConversionService</span>();</span><br><span class="line">defaultConversionService.convert(<span class="string">&quot;1&quot;</span>, Integer.class);</span><br></pre></td></tr></table></figure>
<p>这里最后会调用的是 StringToNumber 这个 Converter。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Spring</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-convert-(具体调用)</title>
    <url>/2016/12/27/java/spring-convert-02/</url>
    <content><![CDATA[<p>续上章，我们还是从具体实现指出看看，Spring Converter到底是怎么工作的。</p>
<span id="more"></span>
<h2 id="目录"><a class="header-anchor" href="#目录">¶</a>目录</h2>
<ul>
<li><a href="#%E6%B3%A8%E5%86%8CConverter">注册Converter</a></li>
<li><a href="#%E8%B0%83%E7%94%A8Converter">调用Converter</a></li>
<li><a href="#%E6%9F%A5%E8%AF%A2Converter">查询Converter</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<hr>
<h3 id="注册Converter"><a class="header-anchor" href="#注册Converter">¶</a>注册Converter</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addScalarConverters</span><span class="params">(ConverterRegistry converterRegistry)</span> &#123;</span><br><span class="line">    converterRegistry.addConverterFactory(<span class="keyword">new</span> <span class="title class_">NumberToNumberConverterFactory</span>());</span><br><span class="line">    converterRegistry.addConverter(Number.class, String.class, <span class="keyword">new</span> <span class="title class_">ObjectToStringConverter</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现其实有2个不同的注册方法，分别是 addConverter 和 addConverterFactory，我们先看看addConverter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;S, T&gt; <span class="keyword">void</span> <span class="title function_">addConverter</span><span class="params">(Class&lt;S&gt; sourceType, Class&lt;T&gt; targetType, Converter&lt;? <span class="built_in">super</span> S, ? extends T&gt; converter)</span> &#123;</span><br><span class="line">    addConverter(<span class="keyword">new</span> <span class="title class_">ConverterAdapter</span>(</span><br><span class="line">            converter, ResolvableType.forClass(sourceType), ResolvableType.forClass(targetType)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这里是把最终的ObjectToStringConverter的包装成一个ConverterAdapter，而去看ConverterAdapter的声明我们会发现，他最终的接口表现形式是ConditionalGenericConverter。<br>
那问题也清晰起来，还记得上一章，我们聊到ConditionalGenericConverter是一个带条件的转换，具体能否调用，我们需要看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">    <span class="comment">// Check raw type first...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.typeInfo.getTargetType() != targetType.getObjectType()) &#123;  <span class="comment">//直接比较 Target 类型，不匹配直接就false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Full check for complex generic type match required?</span></span><br><span class="line">    <span class="type">ResolvableType</span> <span class="variable">rt</span> <span class="operator">=</span> targetType.getResolvableType();</span><br><span class="line">    <span class="keyword">if</span> (!(rt.getType() <span class="keyword">instanceof</span> Class) &amp;&amp; !rt.isAssignableFrom(<span class="built_in">this</span>.targetType) &amp;&amp;</span><br><span class="line">            !<span class="built_in">this</span>.targetType.hasUnresolvableGenerics()) &#123; <span class="comment">//比较是不是 targetType的子类，或者不能够泛型化 直接 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !(<span class="built_in">this</span>.converter <span class="keyword">instanceof</span> ConditionalConverter) ||</span><br><span class="line">            ((ConditionalConverter) <span class="built_in">this</span>.converter).matches(sourceType, targetType);  <span class="comment">//如果是ConditionalConverter 还需要继续自己的matches比较。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现最终注册的ConverterAdapter，是需要比较S和T再确定是否能够调用的。</p>
<p><strong>这个matches</strong> 其实很有意思。最后一步比较其实就允许 ConditionalConverter的2层嵌套。</p>
<hr>
<p>继续看另外一个addConverterFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addConverterFactory</span><span class="params">(ConverterFactory&lt;?, ?&gt; factory)</span> &#123;</span><br><span class="line">    ResolvableType[] typeInfo = getRequiredTypeInfo(factory.getClass(), ConverterFactory.class);</span><br><span class="line">    <span class="keyword">if</span> (typeInfo == <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> DecoratingProxy) &#123;</span><br><span class="line">        typeInfo = getRequiredTypeInfo(((DecoratingProxy) factory).getDecoratedClass(), ConverterFactory.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (typeInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unable to determine source type &lt;S&gt; and target type &lt;T&gt; for your &quot;</span> +</span><br><span class="line">                <span class="string">&quot;ConverterFactory [&quot;</span> + factory.getClass().getName() + <span class="string">&quot;]; does the class parameterize those types?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    addConverter(<span class="keyword">new</span> <span class="title class_">ConverterFactoryAdapter</span>(factory,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConvertiblePair</span>(typeInfo[<span class="number">0</span>].resolve(), typeInfo[<span class="number">1</span>].resolve())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们也发现最终也是得到了ConverterFactoryAdapter，这个就不去细看，和上面那个ConverterAdapter极为相似，我们从中学会了设计模式-<a href="http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/adapter.html">适配器模式</a>.<br>
果然Java处处是设计模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Converters</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;GenericConverter&gt; globalConverters = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;GenericConverter&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(GenericConverter converter)</span> &#123;</span><br><span class="line">        Set&lt;ConvertiblePair&gt; convertibleTypes = converter.getConvertibleTypes();</span><br><span class="line">        <span class="keyword">if</span> (convertibleTypes == <span class="literal">null</span>) &#123;</span><br><span class="line">            Assert.state(converter <span class="keyword">instanceof</span> ConditionalConverter,</span><br><span class="line">                    <span class="string">&quot;Only conditional converters may return null convertible types&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.globalConverters.add(converter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (ConvertiblePair convertiblePair : convertibleTypes) &#123;</span><br><span class="line">                <span class="type">ConvertersForPair</span> <span class="variable">convertersForPair</span> <span class="operator">=</span> getMatchableConverters(convertiblePair);</span><br><span class="line">                convertersForPair.add(converter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终所有的Covert都通过Adapter适配到，我们的核心容器 globalConverters 中。</p>
<hr>
<h3 id="调用Converter"><a class="header-anchor" href="#调用Converter">¶</a>调用Converter</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">    Assert.notNull(targetType, <span class="string">&quot;targetType to convert to cannot be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sourceType == <span class="literal">null</span>) &#123;</span><br><span class="line">        Assert.isTrue(source == <span class="literal">null</span>, <span class="string">&quot;source must be [null] if sourceType == [null]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> handleResult(<span class="literal">null</span>, targetType, convertNullSource(<span class="literal">null</span>, targetType));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (source != <span class="literal">null</span> &amp;&amp; !sourceType.getObjectType().isInstance(source)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;source to convert from must be an instance of &quot;</span> +</span><br><span class="line">                sourceType + <span class="string">&quot;; instead it was a &quot;</span> + source.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">GenericConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getConverter(sourceType, targetType);</span><br><span class="line">    <span class="keyword">if</span> (converter != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> ConversionUtils.invokeConverter(converter, source, sourceType, targetType);</span><br><span class="line">        <span class="keyword">return</span> handleResult(sourceType, targetType, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handleConverterNotFound(source, sourceType, targetType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现 getConverter(sourceType, targetType) 这一行，就是查询Converter的核心。而调用的过程就很简单，直接调用Convert.convert()方法就OK了，那我们把注意力放在查询的过程。</p>
<hr>
<h3 id="查询Converter"><a class="header-anchor" href="#查询Converter">¶</a>查询Converter</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> GenericConverter <span class="title function_">getConverter</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">    <span class="type">ConverterCacheKey</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConverterCacheKey</span>(sourceType, targetType); <span class="comment">//构建缓存Key</span></span><br><span class="line">    <span class="type">GenericConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="built_in">this</span>.converterCache.get(key); <span class="comment">//从缓存中取</span></span><br><span class="line">    <span class="keyword">if</span> (converter != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (converter != NO_MATCH ? converter : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    converter = <span class="built_in">this</span>.converters.find(sourceType, targetType);</span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="literal">null</span>) &#123;</span><br><span class="line">        converter = getDefaultConverter(sourceType, targetType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (converter != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.converterCache.put(key, converter);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.converterCache.put(key, NO_MATCH);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这行代码，我们就发现一个在Spring里面用的特别多的设计理念，包括我们平时也可以用的就是缓存。我们下次在自己的项目里可以考虑多使用缓存。关于这个，我也会在后续写一点关于Cache使用的小技巧出来(好像给自己又挖了一个坑)。<br>
那我们继续看find这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> GenericConverter <span class="title function_">find</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">    <span class="comment">// Search the full type hierarchy</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; sourceCandidates = getClassHierarchy(sourceType.getType());</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; targetCandidates = getClassHierarchy(targetType.getType());</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; sourceCandidate : sourceCandidates) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; targetCandidate : targetCandidates) &#123;</span><br><span class="line">            <span class="type">ConvertiblePair</span> <span class="variable">convertiblePair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConvertiblePair</span>(sourceCandidate, targetCandidate);</span><br><span class="line">            <span class="type">GenericConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getRegisteredConverter(sourceType, targetType, convertiblePair);</span><br><span class="line">            <span class="keyword">if</span> (converter != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> converter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Wow，我第一次看到这里极为的惊叹，这就是Spring的能力而我所达不到的，所有的声明起的也很清晰，这里是拿出所有的继承的类型。<br>
这样话，可能我们注册的Convert是一个Source类型的父类，那我们也是可以从中获得匹配的方法，在我们没有和入参一样类型的情况下。继续进去看getRegisteredConverter这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> GenericConverter <span class="title function_">getRegisteredConverter</span><span class="params">(TypeDescriptor sourceType,</span></span><br><span class="line"><span class="params">				TypeDescriptor targetType, ConvertiblePair convertiblePair)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check specifically registered converters</span></span><br><span class="line">    <span class="type">ConvertersForPair</span> <span class="variable">convertersForPair</span> <span class="operator">=</span> <span class="built_in">this</span>.converters.get(convertiblePair); <span class="comment">//尝试从用户自己注册的converters中取</span></span><br><span class="line">    <span class="keyword">if</span> (convertersForPair != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">GenericConverter</span> <span class="variable">converter</span> <span class="operator">=</span> convertersForPair.getConverter(sourceType, targetType);</span><br><span class="line">        <span class="keyword">if</span> (converter != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> converter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check ConditionalConverters for a dynamic match</span></span><br><span class="line">    <span class="keyword">for</span> (GenericConverter globalConverter : <span class="built_in">this</span>.globalConverters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((ConditionalConverter) globalConverter).matches(sourceType, targetType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> globalConverter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这段代码里面，我们就能看出，Spring给用户拓展留下的入口是converters这个变量，自己维护的是globalConverters。而ConvertersForPair有兴趣看的读者可以也是维护了一个GenericConverter的数组。<br>
可见最终所有的converter想要可用都是需要调用matches进行类型匹配的，所以我们自己现实一个 Convert 也是不可完全不顾 Source 的类型从而实现一个。</p>
<p>**到这里，Convert服务的注册，发现，调用。**我们都已经了解，但是还缺点什么。比如我们经常会有这样的需求，比如把 List A 转换成 List B，如果我们还需要自己实现岂不是特别笨。<br>
当然Spring这么聪明也为我们想到了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addCollectionConverters</span><span class="params">(ConverterRegistry converterRegistry)</span> &#123;</span><br><span class="line">    <span class="type">ConversionService</span> <span class="variable">conversionService</span> <span class="operator">=</span> (ConversionService) converterRegistry;</span><br><span class="line"></span><br><span class="line">    converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ArrayToCollectionConverter</span>(conversionService));</span><br><span class="line">    converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">CollectionToArrayConverter</span>(conversionService));</span><br><span class="line"></span><br><span class="line">    converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ArrayToArrayConverter</span>(conversionService));</span><br><span class="line">    converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">CollectionToCollectionConverter</span>(conversionService));</span><br><span class="line">    converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">MapToMapConverter</span>(conversionService));</span><br><span class="line"></span><br><span class="line">    converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ArrayToStringConverter</span>(conversionService));</span><br><span class="line">    converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">StringToArrayConverter</span>(conversionService));</span><br><span class="line"></span><br><span class="line">    converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ArrayToObjectConverter</span>(conversionService));</span><br><span class="line">    converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ObjectToArrayConverter</span>(conversionService));</span><br><span class="line"></span><br><span class="line">    converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">CollectionToStringConverter</span>(conversionService));</span><br><span class="line">    converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">StringToCollectionConverter</span>(conversionService));</span><br><span class="line"></span><br><span class="line">    converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">CollectionToObjectConverter</span>(conversionService));</span><br><span class="line">    converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">ObjectToCollectionConverter</span>(conversionService));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (streamAvailable) &#123;</span><br><span class="line">        converterRegistry.addConverter(<span class="keyword">new</span> <span class="title class_">StreamConverter</span>(conversionService));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在注册服务的，我们从名字也可以看出，提供了很多类似于 Array to Collection 方法，而这些Convert是没有具体的类型转换的，是负责将容器互相转换。<br>
我们就举个ArrayToCollectionConverter的例子。</p>
<p>我们看看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.core.convert.support.ArrayToCollectionConverter</span><br><span class="line"></span><br><span class="line">public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) &#123;</span><br><span class="line">		return ConversionUtils.canConvertElements(</span><br><span class="line">				sourceType.getElementTypeDescriptor(), targetType.getElementTypeDescriptor(), this.conversionService);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ArrayToCollectionConverter的匹配方式是是单独的工具类。源码中的注释写的很清楚就不解释了。我们还看看如何转换的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (source == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> Array.getLength(source);</span><br><span class="line">    <span class="type">TypeDescriptor</span> <span class="variable">elementDesc</span> <span class="operator">=</span> targetType.getElementTypeDescriptor();</span><br><span class="line">    Collection&lt;Object&gt; target = CollectionFactory.createCollection(targetType.getType(),</span><br><span class="line">            (elementDesc != <span class="literal">null</span> ? elementDesc.getType() : <span class="literal">null</span>), length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elementDesc == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">sourceElement</span> <span class="operator">=</span> Array.get(source, i);</span><br><span class="line">            target.add(sourceElement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">sourceElement</span> <span class="operator">=</span> Array.get(source, i);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">targetElement</span> <span class="operator">=</span> <span class="built_in">this</span>.conversionService.convert(sourceElement,</span><br><span class="line">                    sourceType.elementTypeDescriptor(sourceElement), elementDesc); <span class="comment">//遍历调用</span></span><br><span class="line">            target.add(targetElement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实从某种角度上看，也应是是这样的，分为构造返回的Collections类型，然后遍历调用。这里就发现cache的重要性了，因为增加的缓存，我们在大规模的List转换的时候，查找只需要进行一次就可以了。</p>
<hr>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>Spring-Convert 虽然只是Spring 的一个小功能，但是其实这个使用的地方特别多，比如HttpRequest里面获得原始类型都是String，也就是通过ConvertService 转换成不同的Int，Long等等。<br>
也算是阅读Spring源码的一点点收获。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes-网络原理(0) - 网络知识预备</title>
    <url>/2019/03/07/kubernetes/how-kubernetes-network-0/</url>
    <content><![CDATA[<p>Docker 是“新瓶装旧酒”的产物，依赖于 Linux 内核技术 chroot 、namespace 和 cgroup。本篇先来看 namespace 技术。</p>
<p>Docker 和虚拟机技术一样，从操作系统级上实现了资源的隔离，它本质上是宿主机上的进程（容器进程），所以资源隔离主要就是指进程资源的隔离。实现资源隔离的核心技术就是 Linux namespace。这技术和很多语言的命名空间的设计思想是一致的（如 C++ 的 namespace）。</p>
<p>第零篇的话，我们就来看看最基础的 <code>namespace</code>，和我们后续需要使用的 <code>Tcpdump</code> 这个抓包工具。</p>
<span id="more"></span>
<h2 id="NAMESPACE"><a class="header-anchor" href="#NAMESPACE">¶</a>NAMESPACE</h2>
<p>我们都知道 <code>Docker</code> 的基础是 <code>NAMESPACE</code>，通过<code>NAMESPACE</code>我们做到不同的隔离，因为我们这次只聊网络，那我们来看看<code>NAMESPACE</code>的网络隔离。</p>
<ol>
<li>
<p>创建一个 <code>Network Namespace</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns add &lt;new namespace name&gt;</span><br></pre></td></tr></table></figure>
<p>假如我们创建一个 <code>test</code> 的 <code>namespace</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns add <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>namespace</code> 操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> &lt;you namespace name&gt; &lt;operator&gt;</span><br></pre></td></tr></table></figure>
<p>我们打开一个 bash 在 <code>test</code> 的 <code>namespace</code> 中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> <span class="built_in">test</span> bash</span><br><span class="line"><span class="comment"># 查询下网络信息</span></span><br><span class="line">ip a</span><br></pre></td></tr></table></figure>
<p>我们获得一个有趣的结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@debian:~<span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br></pre></td></tr></table></figure>
<p>我们默认获得一个回环地址的网卡，并没有启动，那我们让其启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> <span class="built_in">test</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev lo up</span><br><span class="line"><span class="comment"># 再次查看IP</span></span><br><span class="line">ip netns <span class="built_in">exec</span> <span class="built_in">test</span> ip a</span><br><span class="line"></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line"><span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">inet 127.0.0.1/8 scope host lo</span><br><span class="line">   valid_lft forever preferred_lft forever</span><br><span class="line">inet6 ::1/128 scope host</span><br><span class="line">   valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>我们就获得一个 IP 地址，这样的话，我们系统内部通讯就有了一个 <code>IP</code> 地址。</p>
</li>
<li>
<p>在 <code>Network Namespace</code> 相互通讯<br>
我们首先在 <code>Namespace</code> 打开一个 <code>Shell</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> <span class="built_in">test</span> zsh</span><br></pre></td></tr></table></figure>
<p>然后在里面启动一个<code>HTTP</code>服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello world&quot;</span> &gt; index.html ; python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure>
<p>我们再开启一个新的的 <code>Shell</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> <span class="built_in">test</span> zsh</span><br><span class="line"><span class="comment"># 尝试访问 8080，得到 hello word 的结果</span></span><br><span class="line">~ curl localhost:8080</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="网络抓包"><a class="header-anchor" href="#网络抓包">¶</a>网络抓包</h2>
<p>我们已经创建了一个虚拟的网络，内部的通讯就是通过这个 <code>localhost</code> 进行通讯。<br>
我们使用 <code>tcpdump</code> 进行网络抓包</p>
<ol>
<li>
<p>监听 lo 的回环网卡<br>
<code>tcpdump -i lo</code></p>
</li>
<li>
<p>分析数据包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listening on lo, link-type EN10MB (Ethernet)</span><br><span class="line"><span class="comment">## TCP 链接建立</span></span><br><span class="line"><span class="comment"># TCP 第一次握手 Client -&gt; Server，Seq = N</span></span><br><span class="line">15:03:42.394751 IP localhost.42514 &gt; localhost.http-alt: Flags [S], <span class="built_in">seq</span> 435521204, win 43690, options [mss 65495,sackOK,TS val 3638139 ecr 0,nop,wscale 7], length 0</span><br><span class="line"><span class="comment"># TCP 第二次握手 Server -&gt; Client，ACK = N+1， SEQ = J</span></span><br><span class="line">15:03:42.394774 IP localhost.http-alt &gt; localhost.42514: Flags [S.], <span class="built_in">seq</span> 1254554874, ack 435521205, win 43690, options [mss 65495,sackOK,TS val 3638139 ecr 3638139,nop,wscale 7], length 0</span><br><span class="line"><span class="comment"># TCP 第三次握手 Client -&gt; Server，Seq = J + 1，这里的ACK = 1 是相对报文的开始</span></span><br><span class="line">15:03:42.394792 IP localhost.42514 &gt; localhost.http-alt: Flags [.], ack 1, win 342, options [nop,nop,TS val 3638139 ecr 3638139], length 0</span><br><span class="line"><span class="comment">## TCP 数据发送</span></span><br><span class="line"><span class="comment"># 发送HTTP报文 1 - 79 部分</span></span><br><span class="line">15:03:42.396258 IP localhost.42514 &gt; localhost.http-alt: Flags [P.], <span class="built_in">seq</span> 1:79, ack 1, win 342, options [nop,nop,TS val 3638139 ecr 3638139], length 78: HTTP: GET / HTTP/1.1</span><br><span class="line"><span class="comment"># 服务端应答收到</span></span><br><span class="line">15:03:42.396372 IP localhost.http-alt &gt; localhost.42514: Flags [.], ack 79, win 342, options [nop,nop,TS val 3638139 ecr 3638139], length 0</span><br><span class="line"><span class="comment"># 客户端发送额外的 18 部分</span></span><br><span class="line">15:03:42.396999 IP localhost.http-alt &gt; localhost.42514: Flags [P.], <span class="built_in">seq</span> 1:18, ack 79, win 342, options [nop,nop,TS val 3638139 ecr 3638139], length 17: HTTP: HTTP/1.0 200 OK</span><br><span class="line"><span class="comment"># 服务端应答收到</span></span><br><span class="line">15:03:42.397002 IP localhost.42514 &gt; localhost.http-alt: Flags [.], ack 18, win 342, options [nop,nop,TS val 3638139 ecr 3638139], length 0</span><br><span class="line"><span class="comment"># 客户端发送 Fin + Ack</span></span><br><span class="line">15:03:42.398629 IP localhost.42514 &gt; localhost.http-alt: Flags [F.], <span class="built_in">seq</span> 79, ack 199, win 342, options [nop,nop,TS val 3638140 ecr 3638139], length 0</span><br><span class="line"><span class="comment"># 服务端响应结束</span></span><br><span class="line">15:03:42.398639 IP localhost.http-alt &gt; localhost.42514: Flags [.], ack 80, win 342, options [nop,nop,TS val 3638140 ecr 3638140], length 0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="镜像准备"><a class="header-anchor" href="#镜像准备">¶</a>镜像准备</h2>
<p>因为为了方便我们在容器内调试网络，我使用<code>ubuntu</code>构建一个工具箱的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull yannxia/ubuntu-with-tcpdump</span><br></pre></td></tr></table></figure>
<p>里面包含了本次实验所需要的所有的网络工具。</p>
<h2 id="How-Network-Namespace-Work"><a class="header-anchor" href="#How-Network-Namespace-Work">¶</a>How Network Namespace Work</h2>
<p>至于 <code>Network namespace</code> 怎么工作的？我们知道对于不同的 <code>Namespace</code> 是相互隔离的，我们需要打通的话，我们需要建立一个 <code>Veth</code> 设备对。我们将 <code>Veth0</code> 放置于某个 <code>Namespace</code> 而将 <code>Veth1</code> 放置于另外一个 <code>Namespace</code>。</p>
<p><img src="https://s3.jpg.cm/2020/08/17/uUc8U.png" alt="uUc8U.png"></p>
<p>对于 <code>Docker</code> 来说，我们的 <code>Veth</code> 默认还会挂载到 <code>Bridge</code> 上<br>
<img src="https://s3.jpg.cm/2020/08/17/uUUkO.png" alt="uUUkO.png"></p>
<p>对于 IPTABLES 工作在 IPV4 和 IPV6 收到包，而收到包是在网卡接收到之后，所以在配置 <code>Iptables</code> 的时候，我们基于 <code>interface</code> 进行配置。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/">introducing-linux-network-namespaces</a></li>
<li><a href="https://www.tecmint.com/12-tcpdump-commands-a-network-sniffer-tool/">Tcpdump Commands</a></li>
<li><a href="https://cloud.docker.com/u/yannxia/repository/docker/yannxia/ubuntu-with-tcpdump">yannxia/ubuntu-with-tcpdump</a></li>
<li><a href="http://ifeanyi.co/posts/linux-namespaces-part-4/">A deep dive into Linux namespaces</a></li>
</ul>
<h2 id="TCP-标志位"><a class="header-anchor" href="#TCP-标志位">¶</a>TCP 标志位</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>TCP 标志位</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SYN</td>
<td>建立连接</td>
</tr>
<tr>
<td>2</td>
<td>FIN</td>
<td>关闭连接</td>
</tr>
<tr>
<td>3</td>
<td>ACK</td>
<td>响应</td>
</tr>
<tr>
<td>4</td>
<td>PSH</td>
<td>数据传输</td>
</tr>
<tr>
<td>5</td>
<td>RST</td>
<td>链接重置</td>
</tr>
</tbody>
</table>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kubernetes</category>
        <category>network</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes-Calico-网络原理(1) - 环境预备 &amp; 初窥网络</title>
    <url>/2019/03/17/kubernetes/how-kubernetes-network-1/</url>
    <content><![CDATA[<h2 id="安装-kubernetes"><a class="header-anchor" href="#安装-kubernetes">¶</a>安装 kubernetes</h2>
<ul>
<li><a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/">create cluster kubeadm</a></li>
<li><a href="http://mediawiki.yannxia.top/index.php/Fastest_Install_Kubernetes">fastest install kubernetes</a></li>
</ul>
<p>并且基于 <a href="https://www.projectcalico.org/"><code>Calico</code></a> 网络构建 <code>Cluster</code> 集群</p>
<span id="more"></span>
<h2 id="部署架构"><a class="header-anchor" href="#部署架构">¶</a>部署架构</h2>
<p><img src="https://ws1.sinaimg.cn/large/eddc95fcgy1g0zwugecopj20m40dkq3b.jpg" alt="deplyment-arch"><br>
最终我们按照上图配置好物理网络即可。</p>
<p>我们给机器打上不同的 <code>tag</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label nodes k8s-worker-1 worker=no-1</span><br><span class="line">kubectl label nodes k8s-worker-2 worker=no-2</span><br></pre></td></tr></table></figure>
<h2 id="网络初窥"><a class="header-anchor" href="#网络初窥">¶</a>网络初窥</h2>
<p>我们在 <code>k8s-master</code> 的机器上执行 <code>ip a</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回环地址</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="comment"># 物理网卡</span></span><br><span class="line">2: ens192: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:50:56:b4:60:31 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.12.22.1/16 brd 10.12.255.255 scope global ens192</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::250:56ff:feb4:6031/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="comment"># Docker0</span></span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:f3:85:bf:61 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="comment"># Tun0 网卡</span></span><br><span class="line">4: tunl0@NONE: &lt;NOARP,UP,LOWER_UP&gt; mtu 1440 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    <span class="built_in">link</span>/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">    inet 192.168.0.1/32 brd 192.168.0.1 scope global tunl0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>我们发现除了，我们经常看到的 <code>docker0</code> 网卡，还多了一个 <code>tunl0</code> 网卡，我们知道 <code>tunl0</code> 一头连接着一个<code>Aplication</code>，那我们大致上可以猜测出来，<code>tunl0</code>的出口就是<code>Calico</code>的网络处理应用。</p>
<p>我们先汇总下信息</p>
<table>
<thead>
<tr>
<th>机器</th>
<th>物理 IP</th>
<th>TUN0-IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>Master</td>
<td>10.12.22.1</td>
<td>192.168.0.1</td>
</tr>
<tr>
<td>Worker-1</td>
<td>10.12.22.2</td>
<td>192.168.1.1</td>
</tr>
<tr>
<td>Worker-2</td>
<td>10.12.22.3</td>
<td>192.168.2.1</td>
</tr>
</tbody>
</table>
<h2 id="基本原理"><a class="header-anchor" href="#基本原理">¶</a>基本原理</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+--------------------+              +--------------------+</span><br><span class="line">|   +------------+   |              |   +------------+   |</span><br><span class="line">|   |            |   |              |   |            |   |</span><br><span class="line">|   |    ConA    |   |              |   |    ConB    |   |</span><br><span class="line">|   |            |   |              |   |            |   |</span><br><span class="line">|   +-----+------+   |              |   +-----+------+   |</span><br><span class="line">|         |veth      |              |         |veth      |</span><br><span class="line">|       wl-A         |              |       wl-B         |</span><br><span class="line">|         |          |              |         |          |</span><br><span class="line">+-------node-A-------+              +-------node-B-------+</span><br><span class="line">        |    |                               |    |</span><br><span class="line">        |    | type1.  <span class="keyword">in</span> the same lan       |    |</span><br><span class="line">        |    +-------------------------------+    |</span><br><span class="line">        |                                         |</span><br><span class="line">        |      type2. <span class="keyword">in</span> different network        |</span><br><span class="line">        |             +-------------+             |</span><br><span class="line">        |             |             |             |</span><br><span class="line">        +-------------+   Routers   |-------------+</span><br><span class="line">                      |             |</span><br><span class="line">                      +-------------+</span><br></pre></td></tr></table></figure>
<p>图片与文字来自<sup><a href="#Calico%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8E%9F%E7%90%86-%E7%BB%84%E7%BD%91%E6%96%B9%E5%BC%8F%E4%B8%8E%E4%BD%BF%E7%94%A8">附录 2</a></sup></p>
<blockquote>
<p>核心问题是，nodeA 怎样得知下一跳的地址？答案是 node 之间通过 BGP 协议交换路由信息。<br>
每个 node 上运行一个软路由软件 bird，并且被设置成 BGP Speaker，与其它 node 通过 BGP 协议交换路由信息。<br>
可以简单理解为，每一个 node 都会向其它 node 通知这样的信息:<br>
我是 X.X.X.X，某个 IP 或者网段在我这里，它们的下一跳地址是我。<br>
通过这种方式每个 node 知晓了每个 workload-endpoint 的下一跳地址。</p>
</blockquote>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/">introducing-linux-network-namespaces</a></li>
<li><a href="https://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2017/04/11/calico-usage.html#as-per-rack">Calico 网络的原理-组网方式与使用</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kubernetes</category>
        <category>network</category>
        <category>calico</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>network</tag>
        <tag>calico</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes-Calico-网络原理(3) - Pod &amp; Node</title>
    <url>/2019/03/20/kubernetes/how-kubernetes-network-3/</url>
    <content><![CDATA[

<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<p>在 <a href="http://blog.yannxia.top/2019/03/17/kubernetes/how-kubernetes-network-2/">Kubernetes 网络原理(2) - Container &amp; Pod</a> 中，我们已经看到了在一个 <code>Node</code> 内部的 <code>Pod</code> 和 <code>Container</code> 的通讯，我们今天来看看跨<code>Node</code>的<code>Pod</code>通讯。</p>
<span id="more"></span>
<h2 id="Pod-Node"><a class="header-anchor" href="#Pod-Node">¶</a>Pod &lt;-&gt; Node</h2>
<p>我们首先先部署一个环境，在 <code>work-2</code> 上部署一个新的 <code>echo-server</code></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Pod部署Yaml文件
    </div>
    <div class='spoiler-content'>
        <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">c2c-network-demo-w2</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">c2c-network-demo-w2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello-world-server</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">python:2.7</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">command:</span> [<span class="string">&quot;/bin/bash&quot;</span>]</span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo \&quot;&lt;p&gt;Hi from $(hostname)&lt;/p&gt;\&quot; &gt; index.html; python -m SimpleHTTPServer 8080&quot;</span>]</span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">curl-client</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">yannxia/ubuntu-with-tcpdump</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>]</span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;while true; do sleep 10; done;&quot;</span>]</span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">  <span class="attr">worker:</span> <span class="literal">no</span><span class="number">-2</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>我们可以查看到在 <code>worker-2</code> 上面有了新的服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get pod -o wide</span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE     IP             NODE           NOMINATED NODE   READINESS GATES</span><br><span class="line">c2c-network-demo      2/2     Running   0          2d2h    192.168.1.10   k8s-worker-1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">c2c-network-demo-w2   2/2     Running   0          87s     192.168.2.6    k8s-worker-2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">echo-server           1/1     Running   0          11d     192.168.1.2    k8s-worker-1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">test-tools            1/1     Running   0          7h45m   192.168.1.12   k8s-worker-1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 <code>c2c-network-demo-w2</code> 分配的 IP 是 <code>192.168.2.6</code>，我们在 <code>k8s-worker-1</code> 的 <code>Node</code> 尝试访问下，毫无疑问的可以访问通。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@test-tools:/<span class="comment"># ping 192.168.2.6</span></span><br><span class="line">PING 192.168.2.6 (192.168.2.6): 56 data bytes</span><br><span class="line">64 bytes from 192.168.2.6: icmp_seq=0 ttl=62 time=0.467 ms</span><br></pre></td></tr></table></figure>
<p>在<code>k8s-worker-1</code>的路由表查一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         10.12.0.1       0.0.0.0         UG    0      0        0 ens192</span><br><span class="line">10.12.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens192</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.0.0     10.12.22.1      255.255.255.0   UG    0      0        0 tunl0</span><br><span class="line">192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 *</span><br><span class="line">192.168.1.2     0.0.0.0         255.255.255.255 UH    0      0        0 cali0005aea454a</span><br><span class="line">192.168.1.10    0.0.0.0         255.255.255.255 UH    0      0        0 calid9d486e54a8</span><br><span class="line">192.168.1.12    0.0.0.0         255.255.255.255 UH    0      0        0 calied9d42cb137</span><br><span class="line">192.168.2.0     10.12.22.3      255.255.255.0   UG    0      0        0 tunl0</span><br></pre></td></tr></table></figure>
<p>我们可以发现命中的是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.2.0     10.12.22.3      255.255.255.0   UG    0      0        0 tunl0</span><br></pre></td></tr></table></figure>
<p>我们的网络包从 <code>tunl0</code> 网卡出去，目标是下一条的 <code>Gateway:10.12.22.3</code> 但是我们 <code>tunl0</code> 的另一头是一个单独的应用，此时我们同时抓包 <code>ens192</code> 和 <code>tunl0</code> 从黑盒的模式看看，这个<code>Calico</code>的应用做了什么事情。</p>
<ul>
<li><code>tunl0</code><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Tunl0
    </div>
    <div class='spoiler-content'>
        <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ ~ tcpdump -i tunl0</span><br><span class="line">01:24:59.482498 IP 192.168.1.12.46282 &gt; 192.168.2.6.http-alt: Flags [S], <span class="built_in">seq</span> 2194532999, win 28000, options [m</span><br><span class="line">ss 1400,sackOK,TS val 248040654 ecr 0,nop,wscale 7], length 0</span><br><span class="line">01:24:59.482918 IP 192.168.2.6.http-alt &gt; 192.168.1.12.46282: Flags [S.], <span class="built_in">seq</span> 2179183161, ack 2194533000, win</span><br><span class="line">27760, options [mss 1400,sackOK,TS val 247938639 ecr 248040654,nop,wscale 7], length 0</span><br><span class="line">01:24:59.482982 IP 192.168.1.12.46282 &gt; 192.168.2.6.http-alt: Flags [.], ack 1, win 219, options [nop,nop,TS v</span><br><span class="line">al 248040655 ecr 247938639], length 0</span><br><span class="line">01:24:59.483073 IP 192.168.1.12.46282 &gt; 192.168.2.6.http-alt: Flags [P.], <span class="built_in">seq</span> 1:81, ack 1, win 219, options [n</span><br><span class="line">op,nop,TS val 248040655 ecr 247938639], length 80: HTTP: GET / HTTP/1.1</span><br><span class="line">01:24:59.483209 IP 192.168.2.6.http-alt &gt; 192.168.1.12.46282: Flags [.], ack 81, win 217, options [nop,nop,TS</span><br><span class="line">val 247938639 ecr 248040655], length 0</span><br><span class="line">01:24:59.484042 IP 192.168.2.6.http-alt &gt; 192.168.1.12.46282: Flags [P.], <span class="built_in">seq</span> 1:18, ack 81, win 217, options [</span><br><span class="line">nop,nop,TS val 247938639 ecr 248040655], length 17: HTTP: HTTP/1.0 200 OK</span><br><span class="line">01:24:59.484115 IP 192.168.1.12.46282 &gt; 192.168.2.6.http-alt: Flags [.], ack 18, win 219, options [nop,nop,TS</span><br><span class="line">val 248040655 ecr 247938639], length 0</span><br></pre></td></tr></table></figure>
    </div>
</div>
</li>
<li><code>ens192</code><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Tunl0
    </div>
    <div class='spoiler-content'>
        <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ ~ tcpdump -i ens192 dst 10.12.22.3 and not port 6443</span><br><span class="line">01:24:59.482524 IP k8s-worker-1 &gt; k8s-worker-2: IP 192.168.1.12.46282 &gt; 192.168.2.6.http-alt: Flags [S], <span class="built_in">seq</span> 2</span><br><span class="line">194532999, win 28000, options [mss 1400,sackOK,TS val 248040654 ecr 0,nop,wscale 7], length 0 (ipip-proto-4)</span><br><span class="line">01:24:59.482882 IP k8s-worker-2 &gt; k8s-worker-1: IP 192.168.2.6.http-alt &gt; 192.168.1.12.46282: Flags [S.], <span class="built_in">seq</span></span><br><span class="line">2179183161, ack 2194533000, win 27760, options [mss 1400,sackOK,TS val 247938639 ecr 248040654,nop,wscale 7],</span><br><span class="line">length 0 (ipip-proto-4)</span><br><span class="line">01:24:59.483005 IP k8s-worker-1 &gt; k8s-worker-2: IP 192.168.1.12.46282 &gt; 192.168.2.6.http-alt: Flags [.], ack 1</span><br><span class="line">, win 219, options [nop,nop,TS val 248040655 ecr 247938639], length 0 (ipip-proto-4)</span><br><span class="line">01:24:59.483083 IP k8s-worker-1 &gt; k8s-worker-2: IP 192.168.1.12.46282 &gt; 192.168.2.6.http-alt: Flags [P.], <span class="built_in">seq</span></span><br><span class="line">1:81, ack 1, win 219, options [nop,nop,TS val 248040655 ecr 247938639], length 80: HTTP: GET / HTTP/1.1 (ipip-</span><br><span class="line">proto-4)</span><br><span class="line">01:24:59.483194 IP k8s-worker-2 &gt; k8s-worker-1: IP 192.168.2.6.http-alt &gt; 192.168.1.12.46282: Flags [.], ack 8</span><br><span class="line">1, win 217, options [nop,nop,TS val 247938639 ecr 248040655], length 0 (ipip-proto-4)</span><br><span class="line">01:24:59.483992 IP k8s-worker-2 &gt; k8s-worker-1: IP 192.168.2.6.http-alt &gt; 192.168.1.12.46282: Flags [P.], <span class="built_in">seq</span></span><br><span class="line">1:18, ack 81, win 217, options [nop,nop,TS val 247938639 ecr 248040655], length 17: HTTP: HTTP/1.0 200 OK (ipi</span><br><span class="line">p-proto-4)</span><br><span class="line">01:24:59.484128 IP k8s-worker-1 &gt; k8s-worker-2: IP 192.168.1.12.46282 &gt; 192.168.2.6.http-alt: Flags [.], ack 1</span><br><span class="line">8, win 219, options [nop,nop,TS val 248040655 ecr 247938639], length 0 (ipip-proto-4)</span><br></pre></td></tr></table></figure>
    </div>
</div>
</li>
</ul>
<p>从上面的抓包里面可以分辨出，从 <code>tun0</code> 出来的数据包，到了 <code>eth0</code> 这里被封装成了 <code>IP in IP</code> 的数据包，也就是在本来的 <code>TCP/IP</code> 的协议包之外又封装了一层物理网络的 <code>IP</code>。</p>
<p><img src="https://i.loli.net/2019/03/21/5c92e80a5a4da.png" alt=""></p>
<h2 id="汇总"><a class="header-anchor" href="#汇总">¶</a>汇总</h2>
<p>我们从最近的一系列分析中：</p>
<ul>
<li>Pod -&gt; Node-A<br>
通过 veth 设备将数据从容器的 eth0 发出</li>
<li>Node-A -&gt; Node-B<br>
eth 通过路由表将数据发送到 tunl0, 然后 tunl0 将报文分装成 IPinIP</li>
<li>Node-B -&gt; Pod<br>
eth 将 IPIP 协议包解包，使用路由表将数据从 veth 输入到 Pod 的 eth0</li>
</ul>
<h2 id="New-Question"><a class="header-anchor" href="#New-Question">¶</a>New Question</h2>
<p>除了 IPIP 的模式以为，Calico 还提供了 BGP 模式，那它的工作模式又是如何呢？切看我们下章分解。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kubernetes</category>
        <category>network</category>
        <category>calico</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>network</tag>
        <tag>calico</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes-Calico-网络原理(4) - BGP</title>
    <url>/2019/03/21/kubernetes/how-kubernetes-network-4/</url>
    <content><![CDATA[<p>我们按照 <a href="http://blog.yannxia.top/2019/03/17/kubernetes/how-kubernetes-network-1/">kubernetes 网络原理(1) - 环境预备 &amp; 初窥网络</a> 重新部署一个 <code>BGP</code> 集群的 <code>Calico</code>。</p>
<span id="more"></span>
<p><img src="https://i.loli.net/2019/03/21/5c934dd658d89.png" alt="arch"></p>
<h2 id="部署-Demo"><a class="header-anchor" href="#部署-Demo">¶</a>部署 Demo</h2>
<p>按照下文的 2 个 yaml 文件部署我们的测试镜像。</p>
<div class="tabs" id="部署-yaml"><ul class="nav-tabs"><li class="tab active"><a href="#部署-yaml-1">c2c-demo.yaml</a></li><li class="tab"><a href="#部署-yaml-2">c2c-demo-w2.yaml</a></li></ul><div class="tab-content"><div class="tab-pane active" id="部署-yaml-1"><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">c2c-network-demo</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">c2c-network-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello-world-server</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">python:2.7</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">command:</span> [<span class="string">&quot;/bin/bash&quot;</span>]</span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo \&quot;&lt;p&gt;Hi from $(hostname)&lt;/p&gt;\&quot; &gt; index.html; python -m SimpleHTTPServer 8080&quot;</span>]</span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">curl-client</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">yannxia/ubuntu-with-tcpdump</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>]</span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;while true; do echo &#x27;GET / HTTP/1.1\r\n\r\n&#x27; | nc localhost 8080; sleep 10; done;&quot;</span>]</span><br><span class="line"><span class="attr">nodeSelector:</span></span><br><span class="line">  <span class="attr">worker:</span> <span class="literal">no</span><span class="number">-1</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="部署-yaml-2"><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">c2c-network-demo-w2</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">c2c-network-demo-w2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello-world-server</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">python:2.7</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">command:</span> [<span class="string">&quot;/bin/bash&quot;</span>]</span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo \&quot;&lt;p&gt;Hi from $(hostname)&lt;/p&gt;\&quot; &gt; index.html; python -m SimpleHTTPServer 8080&quot;</span>]</span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">curl-client</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">yannxia/ubuntu-with-tcpdump</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>]</span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;while true; do sleep 10; done;&quot;</span>]</span><br><span class="line"><span class="attr">nodeSelector:</span></span><br><span class="line">  <span class="attr">worker:</span> <span class="literal">no</span><span class="number">-2</span></span><br></pre></td></tr></table></figure></div></div></div>
<p>执行部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f c2c-demo.yaml</span><br><span class="line">$ kubectl apply -f c2c-demo-w2.yaml</span><br></pre></td></tr></table></figure>
<h2 id="状态检测"><a class="header-anchor" href="#状态检测">¶</a>状态检测</h2>
<p>我们先看看我们的 <code>Pod</code> 运行状态:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods -o wide</span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE     IP            NODE           NOMINATED NODE   READINESS GATES</span><br><span class="line">c2c-network-demo      2/2     Running   0          12m     192.168.1.2   k8s-worker-1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">c2c-network-demo-w2   2/2     Running   0          3h57m   192.168.2.3   k8s-worker-2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>我们从 <code>192.168.1.2</code> 访问 <code>192.168.2.3</code> 访问是通畅的。检查下网卡状态</p>
<div class="tabs" id="网卡状态"><ul class="nav-tabs"><li class="tab active"><a href="#网卡状态-1">容器内</a></li><li class="tab"><a href="#网卡状态-2">宿主机</a></li></ul><div class="tab-content"><div class="tab-pane active" id="网卡状态-1"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@c2c-network-demo-w2:/<span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: eth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1440 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether de:bf:dc:6d:a0:ed brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 192.168.2.3/32 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="网卡状态-2"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens192: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:50:56:b4:bf:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.12.22.151/16 brd 10.12.255.255 scope global ens192</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::250:56ff:feb4:bf02/64 scope <span class="built_in">link</span> </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:40:ac:69:a4 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4: calid9d486e54a8@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1440 qdisc noqueue state UP group default </span><br><span class="line">    <span class="built_in">link</span>/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::ecee:eeff:feee:eeee/64 scope <span class="built_in">link</span> </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure></div></div></div>
<p>按照上文中的检查<code>veth</code>的方式，我们还是可以发现这里的 <code>eth0</code> 和 <code>calid9d486e54a8</code> 是一对<code>veth</code>，那我们的数据包从此处流出。</p>
<h2 id="抓包大作战"><a class="header-anchor" href="#抓包大作战">¶</a>抓包大作战</h2>
<p>尝试在物理网卡上抓取 <code>10.12.22.152</code>  的包，并没有获得什么有用的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i ens192 dst host 10.12.22.152</span><br></pre></td></tr></table></figure>
<p>尝试使用 <code>tcpdump -i ens192 src 192.168.1.2</code> 抓包，我们却获得真实的数据，这又是为什么？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ tcpdump -i ens192 src 192.168.1.2</span><br><span class="line"></span><br><span class="line">21:10:19.551022 IP 192.168.1.2.44728 &gt; 192.168.2.3.http-alt: Flags [S], <span class="built_in">seq</span> 1948023235, win 28000, options [ms</span><br><span class="line">s 1400,sackOK,TS val 6225662 ecr 0,nop,wscale 7], length 0</span><br><span class="line">21:10:19.551462 IP 192.168.1.2.44728 &gt; 192.168.2.3.http-alt: Flags [.], ack 1874405356, win 219, options [nop,</span><br><span class="line">nop,TS val 6225662 ecr 6117673], length 0</span><br><span class="line">21:10:19.551492 IP 192.168.1.2.44728 &gt; 192.168.2.3.http-alt: Flags [P.], <span class="built_in">seq</span> 0:80, ack 1, win 219, options [no</span><br><span class="line">p,nop,TS val 6225662 ecr 6117673], length 80: HTTP: GET / HTTP/1.1</span><br><span class="line">21:10:19.552159 IP 192.168.1.2.44728 &gt; 192.168.2.3.http-alt: Flags [.], ack 18, win 219, options [nop,nop,TS v</span><br><span class="line">al 6225663 ecr 6117674], length 0</span><br><span class="line">21:10:19.552328 IP 192.168.1.2.44728 &gt; 192.168.2.3.http-alt: Flags [F.], <span class="built_in">seq</span> 80, ack 222, win 228, options [no</span><br><span class="line">p,nop,TS val 6225663 ecr 6117674], length 0</span><br></pre></td></tr></table></figure>
<p>我们检查下<code>路由表</code>，我们发现其中的玄妙：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         10.12.0.1       0.0.0.0         UG    0      0        0 ens192</span><br><span class="line">10.12.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens192</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.0.0     10.12.22.150    255.255.255.0   UG    0      0        0 ens192</span><br><span class="line">192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 *</span><br><span class="line">192.168.1.2     0.0.0.0         255.255.255.255 UH    0      0        0 calid9d486e54a8</span><br><span class="line">192.168.2.0     10.12.22.152    255.255.255.0   UG    0      0        0 ens192</span><br></pre></td></tr></table></figure>
<p>我们发现，系统在处理的时候，将数据包报文直接从 <code>ens192</code> 的网卡，将数据交付给下一跳的 <code>10.12.22.152</code> 机器。因为这两台机器隶属于同一个网络，不需要交换机作为外部桥接，直接采用 <code>IP转发-直接交付</code> 的方式，将数据包转发到 <code>10.12.22.152</code></p>
<p>所以我们自然在 <code>10.12.22.152</code> 的机器上去监听网卡就获得了如下的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ tcpdump -i ens192 src host 192.168.1.2</span><br><span class="line"></span><br><span class="line">21:58:11.027773 IP 192.168.1.2.47600 &gt; 192.168.2.3.http-alt: Flags [S], <span class="built_in">seq</span> 957159585, win 28000, options [mss</span><br><span class="line"> 1400,sackOK,TS val 6943526 ecr 0,nop,wscale 7], length 0</span><br><span class="line">21:58:11.028019 IP 192.168.1.2.47600 &gt; 192.168.2.3.http-alt: Flags [.], ack 702012394, win 219, options [nop,n</span><br><span class="line">op,TS val 6943526 ecr 6835553], length 0</span><br><span class="line">21:58:11.028058 IP 192.168.1.2.47600 &gt; 192.168.2.3.http-alt: Flags [P.], <span class="built_in">seq</span> 0:80, ack 1, win 219, options [no</span><br><span class="line">p,nop,TS val 6943526 ecr 6835553], length 80: HTTP: GET / HTTP/1.1</span><br><span class="line">21:58:11.029092 IP 192.168.1.2.47600 &gt; 192.168.2.3.http-alt: Flags [.], ack 18, win 219, options [nop,nop,TS v</span><br><span class="line">al 6943527 ecr 6835553], length 0</span><br><span class="line">21:58:11.029258 IP 192.168.1.2.47600 &gt; 192.168.2.3.http-alt: Flags [.], ack 56, win 219, options [nop,nop,TS v</span><br><span class="line">al 6943527 ecr 6835553], length 0</span><br><span class="line">21:58:11.029438 IP 192.168.1.2.47600 &gt; 192.168.2.3.http-alt: Flags [.], ack 184, win 228, options [nop,nop,TS </span><br><span class="line">val 6943527 ecr 6835553], length 0</span><br><span class="line">21:58:11.029538 IP 192.168.1.2.47600 &gt; 192.168.2.3.http-alt: Flags [F.], <span class="built_in">seq</span> 80, ack 222, win 228, options [no</span><br><span class="line">p,nop,TS val 6943527 ecr 6835553], length 0</span><br></pre></td></tr></table></figure>
<p>到现在，整个系统的扭转如下：<br>
<img src="https://i.loli.net/2019/03/21/5c939cae25908.png" alt=""></p>
<p>摆在我们面前，也就是<code>10.12.22.152</code>的机器又如何处理这个 <code>IP</code> 报文呢？</p>
<h2 id="抵达目的地"><a class="header-anchor" href="#抵达目的地">¶</a>抵达目的地</h2>
<p>当我们抵达<code>10.12.22.152</code>的机器的时候，我们在此机器上查看下路由表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         10.12.0.1       0.0.0.0         UG    0      0        0 ens192</span><br><span class="line">10.12.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens192</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.0.0     10.12.22.150    255.255.255.0   UG    0      0        0 ens192</span><br><span class="line">192.168.1.0     10.12.22.151    255.255.255.0   UG    0      0        0 ens192</span><br><span class="line">192.168.2.0     0.0.0.0         255.255.255.0   U     0      0        0 *</span><br><span class="line">192.168.2.3     0.0.0.0         255.255.255.255 UH    0      0        0 calia4d5046802b</span><br></pre></td></tr></table></figure>
<p>熟悉的配方，我们又从 192.168.2.3 的路由表将数据转发到真正的容器内。</p>
<h2 id="汇总"><a class="header-anchor" href="#汇总">¶</a>汇总</h2>
<p>我们从最近的一系列分析中：</p>
<ul>
<li>Pod -&gt; Node-A<br>
通过 veth 设备将数据从容器的 eth0 发出</li>
<li>Node-A -&gt; Node-B<br>
通过路由表将数据发送到 eth0，直接转发IP包</li>
<li>Node-B -&gt; Pod<br>
eth0 使用路由表将数据从 veth 输入到 Pod 的 eth0</li>
</ul>
<p><img src="https://i.loli.net/2019/03/22/5c9454b024160.png" alt=""></p>
<h2 id="New-Question"><a class="header-anchor" href="#New-Question">¶</a>New Question</h2>
<p>我们整个过程，我们有一些疑问，</p>
<ul>
<li>这些路由表的维护是如何维护的？</li>
<li>iptable 好像一直没有发现用途？<br>
带着这些问题我们进入下一步的。</li>
</ul>
<h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2>
<ul>
<li><a href="https://jakubbujny.com/2018/09/02/what-stores-kubernetes-in-etcd/">What stores Kubernetes in Etcd?</a></li>
</ul>
<h3 id="ETCD-操作指南"><a class="header-anchor" href="#ETCD-操作指南">¶</a>ETCD 操作指南</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl --endpoints=&lt;etcd_ip&gt;:2379 get / --prefix --keys-only</span><br><span class="line">ETCDCTL_API=3 etcdctl --endpoints &lt;etcd_ip&gt;:2379 --cacert &lt;ca_cert_path&gt; --cert &lt;cert_path&gt; --key &lt;cert_key_path&gt; get / --prefix --keys-only</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kubernetes</category>
        <category>network</category>
        <category>calico</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>network</tag>
        <tag>calico</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes-网络原理(5) - ClusterIP</title>
    <url>/2019/03/22/kubernetes/how-kubernetes-network-5/</url>
    <content><![CDATA[<p>我们看完的了简单的网络通讯，在<code>Kubernetes</code>中还有一个很重要的<code>ClusterIP</code>的概念。如下图所示，这个是<code>K8s</code>实现服务负载均衡的核心基础。<br>
<img src="https://i.loli.net/2019/03/22/5c946f9b14785.png" alt=""></p>
<span id="more"></span>
<h2 id="部署环境"><a class="header-anchor" href="#部署环境">¶</a>部署环境</h2>
<div class="tabs" id="deployment-environment"><ul class="nav-tabs"><li class="tab active"><a href="#deployment-environment-1">hello-world-server-deployment.yaml</a></li><li class="tab"><a href="#deployment-environment-2">hello-world-server-service.yaml</a></li></ul><div class="tab-content"><div class="tab-pane active" id="deployment-environment-1"><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">hello-world-server</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">hello-world-server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">matchLabels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">hello-world-server</span></span><br><span class="line"><span class="attr">template:</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">hello-world-server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers: - name:</span> <span class="string">hello-world-server</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">python:2.7</span></span><br><span class="line"><span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">command:</span> [<span class="string">&quot;/bin/bash&quot;</span>]</span><br><span class="line"><span class="attr">args:</span> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo \&quot;&lt;p&gt;Hi from $(hostname)&lt;/p&gt;\&quot; &gt; index.html; python -m SimpleHTTPServer 8080&quot;</span>]</span><br><span class="line"><span class="attr">ports: - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">containerPort: 8080 - name:</span> <span class="string">curl-client</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">yannxia/ubuntu-with-tcpdump</span></span><br><span class="line"><span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>]</span><br><span class="line"><span class="attr">args:</span> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;while true; do sleep 10; done;&quot;</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="deployment-environment-2"><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">hello-world-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">hello-world-server</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure></div></div></div>
<p>敲个小命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f hello-world-server-deployment.yaml</span><br><span class="line">$ kubectl apply -f hello-world-server-service.yaml</span><br></pre></td></tr></table></figure>
<p>检查下环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods -o wide</span><br><span class="line">NAME                                  READY   STATUS    RESTARTS   AGE   IP            NODE           NOMINATED NODE   READINESS GATES</span><br><span class="line">c2c-network-demo                      2/2     Running   0          18h   192.168.1.2   k8s-worker-1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">c2c-network-demo-w2                   2/2     Running   0          22h   192.168.2.3   k8s-worker-2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">hello-world-server-6469546c67-bbtjp   2/2     Running   0          71s   192.168.2.4   k8s-worker-2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">hello-world-server-6469546c67-d6j9n   2/2     Running   0          71s   192.168.1.3   k8s-worker-1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">hello-world-server-6469546c67-fbsvv   2/2     Running   0          72s   192.168.1.4   k8s-worker-1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">$ kubectl get services -o wide</span><br><span class="line">NAME                  TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE   SELECTOR</span><br><span class="line">hello-world-service   ClusterIP   10.100.3.59   &lt;none&gt;        80/TCP    16s   app=hello-world-server</span><br><span class="line">kubernetes            ClusterIP   10.96.0.1     &lt;none&gt;        443/TCP   24h   &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>此时我们有了一个 <code>CLUSTER-IP:10.100.3.59</code></p>
<p><img src="https://i.loli.net/2019/03/22/5c9494bf2ea2f.png" alt=""></p>
<p class="image-footer">cluster ip</p>
<h2 id="探索"><a class="header-anchor" href="#探索">¶</a>探索</h2>
<p>在我们的服务器上执行 <code>curl</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ curl 10.100.3.59</span><br><span class="line">&lt;p&gt;Hi from hello-world-server-6469546c67-bbtjp&lt;/p&gt;</span><br><span class="line">➜  ~ curl 10.100.3.59</span><br><span class="line">&lt;p&gt;Hi from hello-world-server-6469546c67-d6j9n&lt;/p&gt;</span><br><span class="line">➜  ~ curl 10.100.3.59</span><br><span class="line">&lt;p&gt;Hi from hello-world-server-6469546c67-bbtjp&lt;/p&gt;</span><br><span class="line">➜  ~ curl 10.100.3.59</span><br><span class="line">&lt;p&gt;Hi from hello-world-server-6469546c67-d6j9n&lt;/p&gt;</span><br><span class="line">➜  ~ curl 10.100.3.59</span><br><span class="line">&lt;p&gt;Hi from hello-world-server-6469546c67-fbsvv&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>我们发现我们的请求会均衡的转发到不同的<code>Pod</code>上去了，显然也达成了一个<code>load balance</code>的功能。<br>
在我们的 <code>worker-2</code> 的节点上，我们检查我们的路由表:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         10.12.0.1       0.0.0.0         UG    0      0        0 ens192</span><br><span class="line">10.12.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens192</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.0.0     10.12.22.150    255.255.255.0   UG    0      0        0 ens192</span><br><span class="line">192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 *</span><br><span class="line">192.168.1.2     0.0.0.0         255.255.255.255 UH    0      0        0 calid9d486e54a8</span><br><span class="line">192.168.1.3     0.0.0.0         255.255.255.255 UH    0      0        0 cali11d6478e38f</span><br><span class="line">192.168.1.4     0.0.0.0         255.255.255.255 UH    0      0        0 calief5eb3245cc</span><br><span class="line">192.168.2.0     10.12.22.152    255.255.255.0   UG    0      0        0 ens192</span><br></pre></td></tr></table></figure>
<p>没有任意匹配的路由表（除了 0.0.0.0）。</p>
<h2 id="ClusterIP-模式"><a class="header-anchor" href="#ClusterIP-模式">¶</a>ClusterIP 模式</h2>
<p>按照官网的说明，<code>ClusterIP</code> 有三种工作模式</p>
<ul>
<li><code>userspace</code>(since v1.0)</li>
<li><code>iptables</code> (since v1.1)</li>
<li><code>ipvs</code> (since v1.9)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ iptables -L | grep 10.100.3.59</span><br></pre></td></tr></table></figure>
<p>我们可以从 <code>kube-proxy</code> 的启动日志中发现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">W0321 06:39:55.760705       1 server_others.go:295] Flag proxy-mode=<span class="string">&quot;&quot;</span> unknown, assuming iptables proxy</span><br><span class="line">I0321 06:39:55.778302       1 server_others.go:148] Using iptables Proxier.</span><br><span class="line">I0321 06:39:55.778589       1 server_others.go:178] Tearing down inactive rules.</span><br><span class="line">I0321 06:39:56.188482       1 server.go:483] Version: v1.13.4</span><br></pre></td></tr></table></figure>
<p>如果没有特意的指定，我们所使用的还是<code>iptables</code> 的方式</p>
<h2 id="Debug-Iptable"><a class="header-anchor" href="#Debug-Iptable">¶</a>Debug Iptable</h2>
<p>我们从本机访问出去的连接会经历 <code>POSTROUTING</code> 和 <code>OUTPUT</code> 这两个<code>Chain</code>，我们给<code>OUTPUT</code> 增加一个 <code>DEBUG</code> 的 <code>Rule</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables  -A OUTPUT -t raw -p tcp --destination 10.100.3.59 -j TRACE</span><br></pre></td></tr></table></figure>
<p>从 <code>/var/log/kern.log</code> 中我们看到</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        kern.log
    </div>
    <div class='spoiler-content'>
        <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mar 23 23:51:35 k8s-worker-1 kernel: [207676.158750] TRACE: raw:OUTPUT:policy:3 IN= OUT=ens192 SRC=10.12.22.151 DST=10.100.3.59 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=31766 DF PROTO=TCP SPT=47644 DPT=80 SEQ=1655794081 ACK=0 WINDOW=29200 RES=0x00 SYN URGP=0 OPT (020405B40402080A031715B70000000001030307) UID=0 GID=0</span><br><span class="line">Mar 23 23:51:35 k8s-worker-1 kernel: [207676.158769] TRACE: mangle:OUTPUT:policy:1 IN= OUT=ens192 SRC=10.12.22.151 DST=10.100.3.59 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=31766 DF PROTO=TCP SPT=47644 DPT=80 SEQ=1655794081 ACK=0 WINDOW=29200 RES=0x00 SYN URGP=0 OPT (020405B40402080A031715B70000000001030307) UID=0 GID=0</span><br><span class="line">Mar 23 23:51:35 k8s-worker-1 kernel: [207676.158779] TRACE: nat:OUTPUT:rule:1 IN= OUT=ens192 SRC=10.12.22.151 DST=10.100.3.59 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=31766 DF PROTO=TCP SPT=47644 DPT=80 SEQ=1655794081 ACK=0 WINDOW=29200 RES=0x00 SYN URGP=0 OPT (020405B40402080A031715B70000000001030307) UID=0 GID=0</span><br><span class="line">Mar 23 23:51:35 k8s-worker-1 kernel: [207676.158794] TRACE: nat:cali-OUTPUT:rule:1 IN= OUT=ens192 SRC=10.12.22.151 DST=10.100.3.59 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=31766 DF PROTO=TCP SPT=47644 DPT=80 SEQ=1655794081 ACK=0 WINDOW=29200 RES=0x00 SYN URGP=0 OPT (020405B40402080A031715B70000000001030307) UID=0 GID=0</span><br><span class="line">Mar 23 23:51:35 k8s-worker-1 kernel: [207676.158806] TRACE: nat:cali-fip-dnat:return:1 IN= OUT=ens192 SRC=10.12.22.151 DST=10.100.3.59 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=31766 DF PROTO=TCP SPT=47644 DPT=80 SEQ=1655794081 ACK=0 WINDOW=29200 RES=0x00 SYN URGP=0 OPT (020405B40402080A031715B70000000001030307) UID=0 GID=0</span><br><span class="line">Mar 23 23:51:35 k8s-worker-1 kernel: [207676.158816] TRACE: nat:cali-OUTPUT:return:2 IN= OUT=ens192 SRC=10.12.22.151 DST=10.100.3.59 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=31766 DF PROTO=TCP SPT=47644 DPT=80 SEQ=1655794081 ACK=0 WINDOW=29200 RES=0x00 SYN URGP=0 OPT (020405B40402080A031715B70000000001030307) UID=0 GID=0</span><br><span class="line">Mar 23 23:51:35 k8s-worker-1 kernel: [207676.158823] TRACE: nat:OUTPUT:rule:2 IN= OUT=ens192 SRC=10.12.22.151 DST=10.100.3.59 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=31766 DF PROTO=TCP SPT=47644 DPT=80 SEQ=1655794081 ACK=0 WINDOW=29200 RES=0x00 SYN URGP=0 OPT (020405B40402080A031715B70000000001030307) UID=0 GID=0</span><br><span class="line">Mar 23 23:51:35 k8s-worker-1 kernel: [207676.158832] TRACE: nat:KUBE-SERVICES:rule:3 IN= OUT=ens192 SRC=10.12.22.151 DST=10.100.3.59 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=31766 DF PROTO=TCP SPT=47644 DPT=80 SEQ=1655794081 ACK=0 WINDOW=29200 RES=0x00 SYN URGP=0 OPT (020405B40402080A031715B70000000001030307) UID=0 GID=0</span><br><span class="line">Mar 23 23:51:35 k8s-worker-1 kernel: [207676.158840] TRACE: nat:KUBE-MARK-MASQ:rule:1 IN= OUT=ens192 SRC=10.12.22.151 DST=10.100.3.59 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=31766 DF PROTO=TCP SPT=47644 DPT=80 SEQ=1655794081 ACK=0 WINDOW=29200 RES=0x00 SYN URGP=0 OPT (020405B40402080A031715B70000000001030307) UID=0 GID=0</span><br><span class="line">Mar 23 23:51:35 k8s-worker-1 kernel: [207676.158848] TRACE: nat:KUBE-MARK-MASQ:return:2 IN= OUT=ens192 SRC=10.12.22.151 DST=10.100.3.59 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=31766 DF PROTO=TCP SPT=47644 DPT=80 SEQ=1655794081 ACK=0 WINDOW=29200 RES=0x00 SYN URGP=0 OPT (020405B40402080A031715B70000000001030307) UID=0 GID=0 MARK=0x4000</span><br><span class="line">Mar 23 23:51:35 k8s-worker-1 kernel: [207676.158857] TRACE: nat:KUBE-SERVICES:rule:4 IN= OUT=ens192 SRC=10.12.22.151 DST=10.100.3.59 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=31766 DF PROTO=TCP SPT=47644 DPT=80 SEQ=1655794081 ACK=0 WINDOW=29200 RES=0x00 SYN URGP=0 OPT (020405B40402080A031715B70000000001030307) UID=0 GID=0 MARK=0x4000</span><br><span class="line"></span><br><span class="line"># ➊</span><br><span class="line"></span><br><span class="line">Mar 23 23:51:35 k8s-worker-1 kernel: [207676.158870] TRACE: nat:KUBE-SVC-5MRENC7Q6ZQR6GKR:rule:3 IN= OUT=ens192 SRC=10.12.22.151 DST=10.100.3.59 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=31766 DF PROTO=TCP SPT=47644 DPT=80 SEQ=1655794081 ACK=0 WINDOW=29200 RES=0x00 SYN URGP=0 OPT (020405B40402080A031715B70000000001030307) UID=0 GID=0 MARK=0x4000</span><br><span class="line"></span><br><span class="line"># ➋ 这里进行了 IP 地址的</span><br><span class="line"></span><br><span class="line">Mar 23 23:51:35 k8s-worker-1 kernel: [207676.158879] TRACE: nat:KUBE-SEP-M7XDXP4L3HZCSYD6:rule:2 IN= OUT=ens192 SRC=10.12.22.151 DST=10.100.3.59 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=31766 DF PROTO=TCP SPT=47644 DPT=80 SEQ=1655794081 ACK=0 WINDOW=29200 RES=0x00 SYN URGP=0 OPT (020405B40402080A031715B70000000001030307) UID=0 GID=0 MARK=0x4000</span><br><span class="line"></span><br><span class="line"># ➌ 这里首次将 ClusterIP 转换为了 容器的 IP</span><br><span class="line"></span><br><span class="line">Mar 23 23:51:35 k8s-worker-1 kernel: [207676.158896] TRACE: filter:OUTPUT:rule:1 IN= OUT=ens192 SRC=10.12.22.151 DST=192.168.2.4 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=31766 DF PROTO=TCP SPT=47644 DPT=8080 SEQ=1655794081 ACK=0 WINDOW=29200 RES=0x00 SYN URGP=0 OPT (020405B40402080A031715B70000000001030307) UID=0 GID=0 MARK=0x4000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    </div>
</div>
<ol>
<li>
<p>我们再去查询下 <code>iptables</code> 查询 ➌ 处的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ iptables -L KUBE-SEP-M7XDXP4L3HZCSYD6 -t nat --line-number</span><br><span class="line">Chain KUBE-SEP-M7XDXP4L3HZCSYD6 (1 references)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">1    KUBE-MARK-MASQ  all  --  192.168.2.4          anywhere</span><br><span class="line">2    DNAT       tcp  --  anywhere             anywhere             tcp to:192.168.2.4:8080</span><br></pre></td></tr></table></figure>
<p>在这里，我们使用了使用第二条的 <code>DNAT</code> 方式将数据包转换了 <code>IP目标地址</code></p>
</li>
<li>
<p>我们沿着记录往上追溯，查询 ➋ 处</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ➜  ~ iptables -t nat -L KUBE-SVC-5MRENC7Q6ZQR6GKR</span><br><span class="line">Chain KUBE-SVC-5MRENC7Q6ZQR6GKR (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line"><span class="comment"># 192.168.1.3</span></span><br><span class="line">KUBE-SEP-PG5HHQCRLP6OHBWJ  all  --  anywhere             anywhere             statistic mode random probability 0.33332999982</span><br><span class="line"><span class="comment"># 192.168.1.4 </span></span><br><span class="line">KUBE-SEP-Z7HABNZOJAQBPZC7  all  --  anywhere             anywhere             statistic mode random probability 0.50000000000</span><br><span class="line"><span class="comment"># 192.168.2.4</span></span><br><span class="line">KUBE-SEP-M7XDXP4L3HZCSYD6  all  --  anywhere             anywhere</span><br></pre></td></tr></table></figure>
<p>我们发现了我们是这里直接将数据进行随机的选择，（为什么不是均等的：黑脸问号），我们现在得到 <code>Kubernats</code> 针对 <code>ClusterIP</code> 的处理方式如下</p>
</li>
</ol>
<p><img src="https://i.loli.net/2019/03/24/5c97319c45b83.png" alt="all-in-one"></p>
<p class="image-footer">cluster ip: all in one</p>
<h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#creating-a-deployment">creating a deployment</a></li>
<li><a href="https://kubernetes.io/docs/concepts/services-networking/service/">service</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kubernetes</category>
        <category>network</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 面试散记</title>
    <url>/2020/08/04/kubernetes/kubernetes-interview/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/08/04/bty5E.png" alt="bty5E.png"></p>
<span id="more"></span>
<h1>Kubernetes Cluster Architecture</h1>
<p><img src="https://s3.jpg.cm/2020/08/05/bNpM2.png" alt="bNpM2.png"></p>
<p>设计还是符合直觉的</p>
<ul>
<li>ETCD 作为核心的存储，将所有的状态都置于其中</li>
<li>API-Server 提供 HTTP API 给其他服务</li>
<li>Kube-Scheduler 负责调度POD</li>
<li>Kube-Controller：维护资源状态，和ETCD中的描述的状态进行对比</li>
<li>Kubelet： 作为每一个Node上的管理者，其他组件对其下发指令</li>
<li>KubeProxy：将复杂的网络功能单独提出来的管理组件</li>
</ul>
<h1>Kubernetes的Pause容器有什么用</h1>
<p><code>Pause</code> 作为一个 POD 其他 <code>Continar</code> 的父亲存在，1. 是pod里其他容器共享Linux namespace的基础， 2. 扮演PID 1的角色，负责处理僵尸进程</p>
<h1>镜像分层的技术</h1>
<ul>
<li>AUFS/Overlay/Devicemapper</li>
</ul>
<h1>k8s 创建一个 pod 的详细流程</h1>
<ol>
<li>客户端提交创建请求，可以通过 api-server 提供的 restful 接口，或者是通过 kubectl 命令行工具，支持的数据类型包括 JSON 和 YAML。</li>
<li>api-server 处理用户请求，将 pod 信息存储至 etcd 中。</li>
<li>kube-scheduler 通过 api-server 提供的接口监控到未绑定的 pod，尝试为 pod 分配 node 节点，主要分为两个阶段，预选阶段和优选阶段，其中预选阶段是遍历所有的 node 节点，根据策略筛选出候选节点，而优选阶段是在第一步的基础上，为每一个候选节点进行打分，分数最高者胜出。</li>
<li>选择分数最高的节点，进行 pod binding 操作，并将结果存储至 etcd 中。</li>
<li>随后目标节点的 kubelet 进程通过 api-server 提供的接口监测到 kube-scheduler 产生的 pod 绑定事件，然后从 etcd 获取 pod 清单，下载镜像并启动容器。</li>
</ol>
<h1>kubelet 监控 Node 节点资源使用是通过什么组件来实现的？</h1>
<p>cAdvisor</p>
<h1>k8s 中服务级别，怎样设置服务的级别才是最高的</h1>
<ul>
<li>BestEffort<br>
什么都不设置（CPU or Memory），佛系申请资源。</li>
<li>Burstable<br>
Pod 中的容器至少一个设置了CPU 或者 Memory 的请求</li>
<li>Guaranteed<br>
Pod 中的所有容器必须设置 CPU 和 Memory，并且 request 和 limit 值相等。</li>
</ul>
<h1>Pod 的生命周期</h1>
<p>挂起（Pending）：Pod 已被 Kubernetes 系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度 Pod 的时间和通过网络下载镜像的时间，这可能需要花点时间。<br>
运行中（Running）：该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态。<br>
成功（Succeeded）：Pod 中的所有容器都被成功终止，并且不会再重启。<br>
失败（Failed）：Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止。<br>
未知（Unknown）：因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kubernetes</category>
        <category>interview</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>批判无用论</title>
    <url>/2019/08/21/life/criticize-not-good/</url>
    <content><![CDATA[<p>从业这些年来，从来不觉得批判能给我带来什么，当我去批判某个人或者某件事的时候，我所获得的只是更大的反弹。这仿佛说起来很不政治正确，观点是一个非常容易说出来的事情，尤其是现在的互联网时代，你的每一个论点都会被无限的放大，所有的网友都像你的前女友一样，处处给你挑刺，试图在你微薄的上下文中找到你对话的漏洞，并且将漏洞放大一百倍，然后用高位者的姿态教育你一番，以上论点在任意场景下都适用。这一切的背后都是个人意志的无限放大乃至于失控。</p>
<span id="more"></span>
<h2 id="CASE-1"><a class="header-anchor" href="#CASE-1">¶</a>CASE 1</h2>
<p>作为一个乙方，我经常去甲方处进行开会，而甲方经常会带上另外一个乙方参与会议。<br>
<img src="https://i.loli.net/2019/08/21/6xV2OzN8LcGIsDq.png" alt=""><br>
以前我也经常会有一个疑问，为什么我们讨论一个问题，要带上一个无关紧要的乙方人，以前年轻的我经常在会上和甲方带领的乙方进行一番唇枪舌战。慢慢摸索也发现其中的门道，首先甲方内部也不是钢板一块，术业有专攻，在特定领域，甲方爸爸也需要有个炮火连进行火力支援，而这个事情如果是同事不是特别适合，因此从乙方从选一个头脑机灵的作为一个战力的补充，其次如果这个是判断失误也好找乙方背锅，那谈判的过程中，甲方的诉求是把事情价低的情况下做好，而我们是希望事情越简单越好或者能卖出一个高价，而甲方乙方的利益与甲方相同，与我们相悖，看起来势必是水火不容了？实则不然，从阶级上看，大家都是乙方，我们有个公共的阶级地位，不能因为被当作狗就觉得自己高人一等了，因此我们要团结甲方看中的乙方，我们的目标不是就此事，而是一同把这份钱给赚了，但是总是有些乙方看不开，要杀鸡取卵<code>0元投标</code>。这么做除了能导致这个市场越来越廉价实际上又并无好处。</p>
<h2 id="CASE-2"><a class="header-anchor" href="#CASE-2">¶</a>CASE 2</h2>
<p>在<code>CodeReview</code>会议上，你义正言辞的指出某位同事的代码写的和 /:shit 一样，如果对方是一个全职的开发，你觉得你是在攻击这个人，还是在攻击招聘的同事？没有Linus的能力就不要染Linus的毛病。</p>
<h2 id="CASE-3"><a class="header-anchor" href="#CASE-3">¶</a>CASE 3</h2>
<p>在某次会议上，就某同事的发现的提案，你进行了技术上的批判，但是会后，你发现这个项目依然继续进行了，你猜猜是为什么？因为这个项目背后的驱动者比级别高，并且这个项目的预算关乎着别人明年一整年的预算，断人财路，你说你做的什么事情？所以对于会议上需要推进的事情，很多时候你需要跳出来看看，背后是哪位大佬在推动，并且还需要明白，很多事情不是在技术上缺点很多就在市场就没有生存空间。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年初面试回顾</title>
    <url>/2018/04/11/life/interview-review/</url>
    <content><![CDATA[<p>抱着面一次学一点知识的心态写下此文，知识浅薄忘扶正。大部分的内容都有链接可以点击<br>
面试岗位分别为:</p>
<ul>
<li>阿里巴巴-优酷-视频分发-高级开发</li>
<li>哔哩哔哩-基础架构部</li>
<li>饿了么-基础架构部</li>
<li>蚂蚁金服-国际事业部</li>
<li>阿里云-表格储存</li>
</ul>
<p>3-5年工作经验岗位。</p>
<span id="more"></span>
<h2 id="目录"><a class="header-anchor" href="#目录">¶</a>目录</h2>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3">数据库相关</a></li>
<li><a href="#Java%E7%9B%B8%E5%85%B3">Java相关</a></li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3">项目相关</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86">算法部分</a></li>
<li><a href="#%E6%9D%82%E9%A1%B9">杂项</a></li>
</ul>
<h2 id="数据库相关"><a class="header-anchor" href="#数据库相关">¶</a>数据库相关</h2>
<ol>
<li>
<p><strong>关系型数据库的特性?</strong></p>
<p>这个问题其实问的是 <a href="http://blog.csdn.net/u012440687/article/details/52116108">ACID</a> 这个特性。</p>
</li>
<li>
<p><strong>数据库的索引是否了解？</strong><br>
大家都听过的，之后会追问，索引如何实现的？ <a href="https://www.jianshu.com/p/814c1675361c">B+树的实现</a> 可以参考这篇文章<br>
我觉得一点要注意，可能和我一样忘接了B树是多路的不是二叉树，并且B+树和B树的有个很大的不一样，B+可以通过叶子结点遍历整个一层，而B只能从根节点访问，所以B+在磁盘的上表现更好，因为数据聚合在一起。（阿里的面试官反馈最想知道的其实索引在内存, 比磁盘更快）</p>
</li>
<li>
<p><strong>哪些字段适合增加索引？</strong><br>
这个问题在网上说的也比较的空洞，这里有一个比较好的文章可以看一下 <a href="https://segmentfault.com/a/1190000003072424">数据索引的选择</a><br>
这个问题一定注意索引是有成本的，主要在于第一会大量的增加内存空间，之外每一次的插入，更新，删除都需要重新维护索引。</p>
</li>
<li>
<p><strong>设计一个菜市场系统，每天有不同的供应商在系统上提供报价与库存，采购商会选择购买，每天需要打印报表，请设计。</strong><br>
这个问题，不是很难，面试的时候紧张话可能导致思维受阻，我的回答是</p>
<ul>
<li>用户表(id, name, phone, type)</li>
<li>库存表*(id, user_id, price, stock, category)</li>
<li>需求表(id, user_id, quantity, category)</li>
<li>交易表(id, buyer_id, seller_id, category, quantity)</li>
</ul>
</li>
<li>
<p><strong>设计一个电视剧介绍的数据库，电视剧有名称，描述等信息，考虑分多季，每季有多集？</strong></p>
<ul>
<li>电视剧(id, name, desc…)</li>
<li>季数(id, no,teleplay_id, author…)</li>
<li>集(id, season_id, url, desc)<br>
开始回答这个问题的时候都考虑到认为是多对多的采用关联表，现在觉得其实一对多，使用外键即可。<br>
之后会催问，如何实现针对VIP可看最新一集，或者是使用观影卷，我的设计增加一个额外的信息表。就不展开多说了。</li>
</ul>
</li>
<li>
<p><strong>Redis中的LRU是如何实现的？</strong><br>
看过这个又忘了，我就说了一个暴力的方式，用Array实现，当然Array实现就会CopyArray的开销很慢，面试官当然会问我还有没有更好的方式？那我想了下用Tree自璇吧，面试官懂了，提醒我用 <a href="https://www.cnblogs.com/HarryHook/p/6654773.html">双向链表</a>，好吧，我知道自己错了，这样就很明白LRU的实现了，面试之前还得多看看数据结构相关的。</p>
<p>**总结：**数据库相关的内容大概就是这样的，B站在面试的过程中会考关于数据库设计，这块我觉得我们小公司出身的程序员可能占优吧，因为数据库真的是自己设计的。</p>
</li>
<li>
<p><strong>Redis中的zset原理</strong><br>
跳跃表的实现方式。</p>
</li>
<li>
<p><strong>联合索引</strong><br>
联合索引的最左匹配原则。</p>
</li>
</ol>
<h2 id="Java相关"><a class="header-anchor" href="#Java相关">¶</a>Java相关</h2>
<ol>
<li>
<p><strong>Hashmap的实现原理？</strong><br>
这个问题属于烂大街的问题，就不做描述了（<a href="http://www.importnew.com/16301.html">Hashmap实现</a>），但是除此之外问了一个问题，在高并发的情况下，hashmap 会导致死循环的问题，这个笔者在工作中没有遇见，这个只是在竞争的情况下才会发生，具体的原因 <a href="https://www.cnblogs.com/dongguacai/p/5599100.html">多线程的情况下的扩容导致</a> ，没回答上来的难点。</p>
</li>
<li>
<p><strong>Netty为什么可以提高性能？</strong><br>
这个问题<a href="http://www.importnew.com/15656.html">Netty实现原理浅析</a>，我觉得核心在Reactor上，采用事件的方式减少了BIO的线程等待，不过面试官好像不太满意，额我还是觉得我应该回答的没错……略尴尬</p>
</li>
<li>
<p><strong>JavaComplier的实现原理？</strong><br>
编译原理没学好，我放弃。这个问题是我说我写过JVM虚拟机因伸出来的，至于我记得部分就是抄袭 《自己动手写Java虚拟机》使用Go做了一个简陋的虚拟机。</p>
</li>
<li>
<p><strong>JVM的GC？</strong><br>
这也是一个老生常谈的问题了，但是一时间还真是记不住，推荐一篇好文 <a href="https://www.zybuluo.com/Yano/note/321063">Java 虚拟机面试题全面解析</a>，关于GC的也推荐 <a href="https://www.cnblogs.com/ityouknow/p/5614961.html">GC算法 垃圾收集器</a>，实战推荐 <a href="https://www.cnblogs.com/feiyudemeng/p/8276911.html">从实际案例聊聊Java应用的GC优化</a> 。还是推荐大家背一背，真心会忘，实在能记得大概吧，不然就有点尴尬。补充一个CMS的<a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations/concurrent-mark-and-sweep">细解</a></p>
</li>
<li>
<p><strong>触发Long GC原因可能是？</strong><br>
没有触发过，发个文<a href="https://dzone.com/articles/how-to-reduce-long-gc-pause">How to Reduce Long GC Pauses</a>，简而言之有几个原因</p>
<ol>
<li>大量的对象创建</li>
<li>young和old的比例失调</li>
<li>小内存导致使用大量的交换区</li>
<li>IO堵塞<br>
这里的LongGC应该说的是经常发生GC而不是很长的GC</li>
</ol>
</li>
<li>
<p><strong>字节码操作会使用在哪些地方？</strong><br>
笔者所能够想到了就是 Spring在实现动态代理的地方使用了 Cglib，这里有文 <a href="http://www.infoq.com/cn/articles/Living-Matrix-Bytecode-Manipulation">字节码操纵技术探秘</a> 实际上我觉得使用的地方应该不是特别多。</p>
</li>
<li>
<p><strong>设计模式的使用</strong>	<br>
老生常谈 <a href="http://blog.51cto.com/sihai/2071497">设计模式——开发常用的设计模式梳理</a></p>
</li>
<li>
<p><strong>解释锁的各种特性</strong><br>
推荐一个文章 <a href="https://my.oschina.net/u/1170450/blog/1679424">java 中的锁 – 偏向锁、轻量级锁、自旋锁、重量级锁</a></p>
</li>
</ol>
<h2 id="项目相关"><a class="header-anchor" href="#项目相关">¶</a>项目相关</h2>
<ol>
<li><strong>某项目强依赖Redis，如果Redis挂掉怎么处理？Redis连接变的高延迟怎么处理？</strong></li>
<li><strong>设计一个日志收集系统，2K终端会上传日志压缩包200KB以Gzip的方式上传，架构如何设计，最终能够做数据可视化。</strong></li>
</ol>
<h2 id="算法部分"><a class="header-anchor" href="#算法部分">¶</a>算法部分</h2>
<p>只有在阿里云的一面的时候考验了写代码的能力。</p>
<ol>
<li><strong>3Sum</strong><br>
这是Leetcode很经典的一道题目了，<a href="https://leetcode.com/problems/3sum/description/">leetcode-3sum</a> 关键是会引导你去想出最优解。</li>
<li><strong>最长递增子串</strong><br>
动态规划的经典问题，<a href="https://leetcode.com/problems/longest-increasing-subsequence/description/">longest-increasing-subsequence</a> 写出转移方程还会再问你是否有更优解。</li>
</ol>
<p>整体看来还是DP问题可能因为代码量少，思维强度大，这个应该是面试中最值得注意的题目了。可以同学学习<a href="https://github.com/tianyicui/pack/blob/master/V2.pdf">背包九讲</a></p>
<h2 id="杂项"><a class="header-anchor" href="#杂项">¶</a>杂项</h2>
<ol>
<li>
<p><strong>你认为好代码的代码应该是怎么样的？</strong><br>
关于这个问题，我觉得代码的<em><strong>一致性</strong></em>，我在这四年来的代码经验中，就像是代码大全开篇所言的（隐喻性），就像是一个房子在构建，如果有标准化的工程，那我们在参观每一个房间的时候就会很省心省力，代码如果都是一致的，那阅读的过程中就会很轻松。</p>
</li>
<li>
<p>**你有什么想问我的？  **<br>
这个经久不衰的问题（:-D），我每次都还是喜欢问面试官他工作的难点是什么，和自己的预期进行一个匹配。</p>
</li>
</ol>
<h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2>
<p>大部分的架构部门都会考虑Go，所以都会问下Go学的怎么样，大家如果立志于架构组还需要学习现在更流行的Go语言了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2018关键字</title>
    <url>/2018/09/16/life/keywords-2018/</url>
    <content><![CDATA[<p>刚好有一个朋友，如果用十个词形容自己的现状，我想了想还是写下来，也算是水一篇博客。</p>
<h2 id="1-碌碌无为-遥遥无期"><a class="header-anchor" href="#1-碌碌无为-遥遥无期">¶</a>1. 碌碌无为/遥遥无期</h2>
<p>对于我来说，这一年大概是我觉得最为碌碌无为的一年了，回想起来，不仅仅什么事情都没有做，还搞砸了一堆事情，计划的<code>马拉松</code>,<code>读书计划</code>,<code>减肥计划</code>大概这个计划可以再陪伴一年了，老朋友明年见。</p>
<span id="more"></span>
<h2 id="2-居无定所"><a class="header-anchor" href="#2-居无定所">¶</a>2. 居无定所</h2>
<p>我大概成了一个假的程序员，从去年入职开始，好像我已经踏上了一个售前工程师的职能，我不是在出差地或者就是在出差中，虽然有些夸张，出差倒也没有让我觉得有多痛苦，只是让我越发明白，安定的意义，也可能因为自己也算是奔三的人，也不享受这个免费的旅行了。</p>
<h2 id="3-持鳌下酒"><a class="header-anchor" href="#3-持鳌下酒">¶</a>3. 持鳌下酒</h2>
<p>发现有些事情没啥办法改变就开始逃避了，拖延症也越来越严重了。</p>
<h2 id="4-无的放矢-漫无目的"><a class="header-anchor" href="#4-无的放矢-漫无目的">¶</a>4. 无的放矢/漫无目的</h2>
<p>一方面不心安于这样的状态，但是一方面又没有什么远大的理想，亦可以从身边的朋友那得到的反馈也是，颇有小聪明却无志向，以后也怕是难有什么大成就。只怕又是心比天高而名比纸薄。</p>
<h2 id="5-利己主义"><a class="header-anchor" href="#5-利己主义">¶</a>5. 利己主义</h2>
<p>和大学期间的我完全一样了，并不在这个国家的政治会如何，亦或者 <code>滴滴女乘客死亡</code> 这样的问题，这样的问题即便是发生的举例我这样的近，我却再也关心不起来，本质的原因我觉得是因为自己的生活尚且得过且过，富裕的善良都不足够</p>
<h2 id="6-存在主义"><a class="header-anchor" href="#6-存在主义">¶</a>6. 存在主义</h2>
<p>发现只有 <code>存在先于本质</code> 的哲学思想最为能接受了，现在已经不去想 <code>我是谁，我又在这里的</code> 这样的本质性问题了，还是想想当下的 <code>存在</code> 而我们也亦拥有的选择的自由。</p>
<blockquote>
<p>人没有义务遵守某个道德标准或宗教信仰，却有选择的自由。要评价一个人，要评价他的所作所为，而不是评价他是个什么人物，因为一个人是由他的行动来定义的。 — Jean-Paul Sartre</p>
</blockquote>
<h2 id="7-爵士乐"><a class="header-anchor" href="#7-爵士乐">¶</a>7. 爵士乐</h2>
<p>这个可能算不上 2018 的年度关键字，不过也算是持续到现在了，大致上有 16 年开始我的最爱的音乐类型里面就不存在什么诸如民谣之类的音乐，我所爱的是 <code>爵士乐</code> ，在我看来 <code>爵士乐</code> 是一种既变化又不变的一种音乐，虽然爵士乐的第三秒就知道它的音律，可是每一首都给你不一样自由的感觉，这如同在这城市，我们虽然知道我们每天都会在这两点一线的上班中度过，可是我们也可以为了身边的小花驻留多一分钟，那就是生活的自由。</p>
<h2 id="8-焦虑"><a class="header-anchor" href="#8-焦虑">¶</a>8. 焦虑</h2>
<p>与<code>碌碌无为</code>有且与之相对应的<code>焦虑</code>，焦虑于工作，生活，简直没有什么事情不焦虑，不过焦虑往往随着一杯肥宅快乐水就烟消云散了。大致上我还算是一个天生的乐观者，毕竟焦虑只有在交房贷的那一刻强烈的无比自已。</p>
<h2 id="9-继续"><a class="header-anchor" href="#9-继续">¶</a>9. 继续</h2>
<p>最为困难的是开始，比开始更困难的是坚持，而继续的力量给上帝公平的将时间分配于你，无论生活多么惨淡，我们只得收拾好行李继续上路，长夜漫漫路遥遥。</p>
<h2 id="10-继续等待"><a class="header-anchor" href="#10-继续等待">¶</a>10. 继续等待</h2>
<p>有些事情，只能继续等待。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>在家的一个月我得到了什么</title>
    <url>/2020/03/09/life/rethink-in-spring-festival/</url>
    <content><![CDATA[<p>因为<a href="https://zh.wikipedia.org/zh-hans/2019%E5%86%A0%E7%8B%80%E7%97%85%E6%AF%92%E7%97%85%E7%96%AB%E6%83%85">新冠肺炎</a>，在家度过了自从大学生涯结束之后就不曾再有的超长假期，前前后后含上WFH的时间足足有40余天。大部分的时间也因为在家自我隔离，有了充足的时间进行思考，聊聊这个不一样的假期我在家学到了什么。</p>
<span id="more"></span>
<h1>极简的确是可以的</h1>
<p>因为没有出门的机会，已经前期大部分地区的快递足够漫长，甚至有些货物我收到货的时候已经不觉得有用，与大部分人一样，一整个春节几乎穿着一套睡衣度过了，另外一套户外冬装也仅仅在出门散步时穿，因为是异地工作，仅仅按照一周假期的准备，殊不知在家呆了40天，但是这些日子并没有觉得自己的衣服不足够，当人减少社交属性的时候，仿佛也带来了很低的物质需求。记得以前有一篇新闻 <a href="http://news.sohu.com/20150326/n410357717.shtml">上海夫妻不工作没孩子不交际 全年只花2万元</a> 原来我是不信的，现在无比信服。如果算起来，我们投入在社交上的隐性支出要比宴请这样的显性支出更加的多。</p>
<p>最终发现<strong>健康的身体和充沛的精力是最重要的。</strong></p>
<h1>管理自己的精力，比管理自己的时间更重要</h1>
<p><img src="https://s2.ax1x.com/2020/03/09/8pZqrF.png" alt="8pZqrF.png"></p>
<p>在家期间有了大量的时间，无论是睡觉还是学习，都有自己充足的时间，而这些时间并没有严格的按照自己的期望进行运转，包括了晚睡这些习惯，而我发现如果时间表这样的方式进行生活，最大的问题依然是没有办法完全控制自己的时间，甚至于一个快递电话都会将自己的时间线打乱。而我觉得更好的方式是【精力管理】，不要求在具体的时间线上做出什么妥协，你需要的是将自己的精力有效的利用起来，我也倾向于认为人的精力是有限的，我们应该做的是锻炼自己的精力，并且将自己有限的精力放在重要的事情上。</p>
<h2 id="精力之外的题外话"><a class="header-anchor" href="#精力之外的题外话">¶</a>精力之外的题外话</h2>
<ul>
<li>无论是重脑力的上班还是在办公室闲待一天，都是一种消耗性的工作，倒是我们晚上几乎无法把自己的精力再次汇聚起来</li>
<li>因为精力被耗尽之后，我们更容易被网络吸引，包括无聊的刷抖音，购物等</li>
</ul>
<h1>未雨绸缪</h1>
<p>新冠疫情来的突然，对于房租，房贷等刚性支出都是一笔不小的数量，如果是服务员之类的工作，在未开工期间，我们就不得不去动用存款，因此对于大部分的人来说，我们都应该准备半年左右的备用金，半年之内都无好转的话可能就是一个系统性的风险了，就听天由命吧。</p>
<h1>学习不止</h1>
<p><img src="https://s2.ax1x.com/2020/03/09/8pm60g.png" alt="8pm60g.png"><br>
在家的时候我常常帮助我们调电视，自从搬进了新房子，切断了以前的有线电视，使用了互联网电视，无论是极为简单的小米电视还是康佳电视，我发现对于我妈来说都是非常困难的，对于我爸来说也是在有限的范围内可学的，而至于给电视安装软件都是超过他们的能力范围的，为什么会导致这样的？我认为是思维的固化已经对新事物的排次，在<br>
<a href="https://www.bilibili.com/video/av33979970/">学习观</a> 中，我们也可以理解，我们对于已有知识和未有知识有冲突的时候，是优先会站在已有知识这边的，那些被验证的知识是无比珍贵的，因此我们也会变的顽固，对于互联网电视这种以搜索和推送的为方式的新视频方式是不怎么接受的，而如何面对层出不穷的新事物，只有保持好学的姿势，可能还不会被这个时代给冲击灭迹。</p>
<h1>身体力行</h1>
<p>在家看了一个还蛮治愈的日剧《日日是好日》，剧中的茶艺导师让其使用身体记住茶道而不是脑子，这也是现代人常常犯的错，我们总是以为用思考就可以取缔一切，而早在1937年<a href="https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-193707.htm">论认识和实践的关系——知和行的关系</a>，毛主席也说明这一观点，我们总是需要在真实的世界进行实践动作，而仅仅留在脑子中的想法那些都是流于表面的，也就是为什么现在的键盘侠甚多的原因。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>克市与乌市随记</title>
    <url>/2019/02/27/life/something-about-it-in-karamay/</url>
    <content><![CDATA[<p>机缘巧合之下，能够到<a href="https://baike.baidu.com/item/%E5%85%8B%E6%8B%89%E7%8E%9B%E4%BE%9D/36972"><code>克拉玛依</code></a>这里和 <a href="http://www.hongyousoft.com.cn/"><code>红有软件</code></a>的前后进行过为了 3 周的<code>IT咨询</code>功能在，从一个<code>IT</code>从业者的眼中看<code>克拉玛依</code>这个依靠油田拔地而起的城市，按照当地人的说法，这个城市几乎都围绕着<code>石油</code>，<code>IT</code>也不例外，<code>数字油田建设</code>是<code>IT</code>发展的核心。</p>
<span id="more"></span>
<p>以实施咨询的<code>红有软件</code>公司为例，前身是石油勘探院下属的一个研究性科室，在改革的浪潮下，<code>1996</code>年的时候从石油勘探院的剥离成立一个独立公司<code>红有软件</code>，凭借着多年在石油系统的专研，为石油系统提供了一系列优秀的程序，在多年的实践过程中，在大力出奇迹的情况下，搞了一个平台系统，用户只需要在页面点点，配合一点数据源之类的就可以生成报表等，对这玩意就是一个简单的<code>ERP</code>系统。这个平台在 <code>2017</code> 的时候准备过渡到<code>第三代</code>基于微服务重构。虽然至今(<code>2019</code>)也是只是完成了一点点，实际上这个进度和大部分的国企单位的进度是类似的。</p>
<p>当然克市也面临着一系列的问题，整个城市地处边陲，<code>IT</code>虽然理论上是不以地理为核心，然后过于遥远的地理位置，导致这里的<code>IT</code>人才往往留不住，年轻人还行向往去<code>北京</code>这样的一线城市，哪怕是因为<code>北京</code>的高房价，也会选择去<code>西安</code>这样的中部城市，这和国内大部分的城市一样，产业往往过于单一，年轻人并没有什么建设家乡的机会，公务员/事业单位是城市主任，产业往往也以支撑的工业和农业为主，并且因为克市作为一个资源城市，整体的收入也不算低，所以克市很多富裕的家庭也希望自己的孩子下一代不在这个城市，而<code>克市</code>的软件从业者多以<code>35+</code>的中年人为主，在这里可能就没有中年危机了，软件公司依附于国企，工作风格也与国企类似。</p>
<p>当地的<code>IT</code>多半依靠的强大的商务关系，相对于<code>克拉玛依</code>这个政企不分的城市（17 年开始分市长和石油公司总经理，原来是不做区分的），大部分的系统算是一个定制化开发点单页应用的，关于核心的生产系统，也是当地的 IT 企业所接触不到的，这些系统大部分和硬件绑定的极为紧密。</p>
<p>当地的网络环境也是影响程序员一个重要的因素，毕竟一个不能够访问<code>Github</code>的地方，会让你无限的头疼。</p>
<p>最后附上边陲小镇程序员的合影：</p>
<p><img src="https://ws1.sinaimg.cn/large/eddc95fcgy1g0q04qnk3pj21400u0wgy.jpg" alt=""></p>
<hr>
<p>除了<code>IT</code>之外，这里的物价真是不便宜，餐饮成本与上海持平，就谈不上和北京做些比较了。不过倒是本地的晚上正式的饭局价格尚且可以，人均<code>100</code>出口已经可以算的上是大鱼大肉了，无理由的猜猜应该是因为<code>红肉的成本略低</code>。</p>
<p><img src="https://ws1.sinaimg.cn/large/eddc95fcgy1g0q03eanzwj21400u0dk9.jpg" alt=""></p>
<p>的确是因为靠山吃山靠水吃水，当地的饮食以<code>牛羊肉</code>为主，蔬菜并不多样，常见的是<code>胡萝卜</code>，<code>洋葱（皮牙子）</code>，当地如果吃上几天吃腻了，还是得吃点<code>皮辣红</code>解解腻，不过当地的羊肉的确是一句，味道极为美味。</p>
<p>乌鲁木齐相较于克拉玛依更像一个沿海的城市，除了低气温和一些民族饭馆，和大部分的城市一样，高架桥，硕大的高铁站，有个 3 个航站楼的机场，友谊商城开着各种熟悉名字的饭馆和品牌店，路上的也以汉人为主，城市中的外来务工者，<code>四川</code>，<code>山东</code>的也不少和其他如出一辙。</p>
<hr>
<p>PS：国企同学们依然保留着打乒乓球的优良传统，上一次看到乒乓球桌是在<code>南方电网</code>。</p>
<p><img src="https://ws1.sinaimg.cn/large/eddc95fcgy1g0pzz1cxhpj20sm0mqwxm.jpg" alt=""></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>面试拾遗：Epoll 之下的线程模型 / Envoy 快速之谜</title>
    <url>/2020/08/10/networking/epoll-thread/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/08/11/bgfwp.png" alt="bgfwp.png"></p>
<span id="more"></span>
<h1>多核之下的 Epoll</h1>
<p>对于 <code>Epoll</code> 来说，我们为了利用多核能力，其实有两种办法</p>
<ul>
<li>负载均衡 <code>accept()</code></li>
<li>负载均衡 <code>read()</code></li>
</ul>
<h2 id="负载均衡-accept"><a class="header-anchor" href="#负载均衡-accept">¶</a>负载均衡 <code>accept()</code></h2>
<p>对于<strong>高频</strong>建立<strong>短连接</strong>的，我们要快速处理 <code>accept()</code></p>
<h3 id="水平触发情况下一种无效的唤醒：-Level-triggered"><a class="header-anchor" href="#水平触发情况下一种无效的唤醒：-Level-triggered">¶</a>水平触发情况下一种无效的唤醒： Level triggered</h3>
<ol>
<li>Kernel: 接收到请求</li>
<li>Kernel: 唤醒通知两个线程</li>
<li>Thread A: 完成 epoll_wait().</li>
<li>Thread B: 完成 epoll_wait().</li>
<li>Thread A: 执行 accept() 成功</li>
<li>Thread B: 执行 accept() 失败，对于 B 的唤醒无效</li>
</ol>
<h3 id="边缘触发情况下一种无效的唤醒：-Edge-triggered"><a class="header-anchor" href="#边缘触发情况下一种无效的唤醒：-Edge-triggered">¶</a>边缘触发情况下一种无效的唤醒： Edge triggered</h3>
<ol>
<li>Kernel: 接收到请求，唤醒A/B，这里假设是 A</li>
<li>Thread A: 完成 epoll_wait().</li>
<li>Thread A: 执行 accept() 成功</li>
<li>Kernel: 接收到请求</li>
<li>Kernel: 唤醒B来接收（A在处理）</li>
<li>Thread A: 执行了 <code>accept()</code> 成功</li>
<li>Thread B: 执行了 <code>accept()</code> 失败了，被<code>无效唤醒</code></li>
</ol>
<hr>
<p>当上述的线程从 2个变成 1000 个，我们就可能唤醒很多线程而无效。对于 <code>Linux 4.5</code> 增加了 <code>EPOLLEXCLUSIVE</code> 标记，只会唤醒一个 <code>epoll_wait()</code> 状态的线程。</p>
<h3 id="Netty"><a class="header-anchor" href="#Netty">¶</a>Netty</h3>
<p>对于 <code>Netty</code> 来说， <code>accept()</code> 的工作是放在 <code>Bossgroup</code> 中执行的，因此，如果我们需要处理大量高频的请求，我们应该尽可能的将 <code>bossGroup</code> 多分配一些，对于 <code>Netty</code> 来说是无法禁止使用 <code>childGroup</code> 的。</p>
<figure class="highlight java"><figcaption><span>Server构造器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ServerBootstrap <span class="title function_">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.group(parentGroup);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.childGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;childGroup set already&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.childGroup = ObjectUtil.checkNotNull(childGroup, <span class="string">&quot;childGroup&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们势必会涉及到 <code>BossGroup</code> -&gt; <code>WorkerGroup</code> 的开销。</p>
<h2 id="负载均衡-read"><a class="header-anchor" href="#负载均衡-read">¶</a>负载均衡 <code>read()</code></h2>
<p>对于裸用 <code>Epoll</code> 来说，我们会出现以下2个问题，都会出现两个不同的进程处理同一个 Socket 的数据</p>
<h3 id="LT-模式下"><a class="header-anchor" href="#LT-模式下">¶</a>LT 模式下</h3>
<ol>
<li>Kernel: 接收到 <code>2047</code> 字节数据</li>
<li>Kernel: 唤醒A处理</li>
<li>Thread A: 完成 <code>epoll_wait()</code></li>
<li>Kernel: 接收到 <code>2</code> 字节</li>
<li>Kernel: 唤醒 B 处理</li>
<li>Thread A: 执行 <code>read(2048)</code> 获得 <code>2048</code> 字节数据</li>
<li>Thread B: 执行 <code>read(2048)</code> 获得 <code>1</code> 字节数据</li>
</ol>
<h3 id="ET-模式下"><a class="header-anchor" href="#ET-模式下">¶</a>ET 模式下</h3>
<ol>
<li>Kernel: 接收到 <code>2048</code> 字节数据</li>
<li>Kernel: 唤醒A处理</li>
<li>Thread A: 完成 <code>epoll_wait()</code></li>
<li>Thread A: 执行 <code>read(2048)</code> 获得 <code>2048</code> 字节数据</li>
<li>Kernel: 接收到 <code>1</code> 字节数据</li>
<li>Kernel: 唤醒B处理</li>
<li>Thread B: 完成 <code>epoll_wait()</code></li>
<li>Thread B: 执行 <code>read(2048)</code> 获得 <code>1</code> 字节数据</li>
<li>Thread A: 重试 <code>read(2048)</code>, 什么都没获得</li>
</ol>
<hr>
<p>针对上述的情况， <code>Linux</code> 加入了 <code>EPOLLONESHOT</code> 只允许一个线程注册唯一的回调事件。</p>
<figure class="highlight cpp"><figcaption><span>epolloneshot</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Eepoll::ResetOneShot</span><span class="params">(intepollfd,SOCKET fd,<span class="type">bool</span> bOne)</span></span>&#123;</span><br><span class="line">    epoll_eventevent;</span><br><span class="line">    event.data.fd= fd;</span><br><span class="line">    event.events= EPOLLIN | EPOLLET ;</span><br><span class="line">    <span class="keyword">if</span>(bOne)&#123;</span><br><span class="line">            event.events |=EPOLLONESHOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">epoll_ctl</span>(epollfd,EPOLL_CTL_MOD,fd,&amp;event))&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;resetoneshotepoll_ctl error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Netty-v2"><a class="header-anchor" href="#Netty-v2">¶</a>Netty</h3>
<p>这种一般服务于 <code>大量</code>长时间连接的，需要及时处理接收到的请求，这种情况下需要单 <code>Boss</code> 而需要多个 <code>Worker</code></p>
<p><img src="https://s3.jpg.cm/2020/08/11/bz6Nu.png" alt="bz6Nu.png"></p>
<h4 id="Workgroup-default-value"><a class="header-anchor" href="#Workgroup-default-value">¶</a>Workgroup default value</h4>
<p><code>Workgroup</code> 的默认值是 <code>CPU Core</code> 的 <code>2</code> 倍，昨天也被问了这个事情，查了一下 <code>Google</code> 也没有找到适合的答案，我估计这是应该是一个实验数据，在大部分的情况下这个 <code>2</code> 应该可以发挥最大的作用。（有空测试一下）</p>
<h2 id="Why-Envoy-So-Fast"><a class="header-anchor" href="#Why-Envoy-So-Fast">¶</a>Why Envoy So Fast</h2>
<p>这方面的资料比较少，并且作者在阅读 <code>Envoy</code> 源码的时候的确也没发现什么特别之处，从设计上尝试回答一下这个问题</p>
<h3 id="Envoy-Thread-Model"><a class="header-anchor" href="#Envoy-Thread-Model">¶</a>Envoy Thread Model</h3>
<p><code>Envoy</code> 的线程模式是对等设计，在HTTP转发模式下，因为每一个线程和下游的服务[<code>另外一个Envoy</code>]连接的时候会创建一个 <code>HTTP/2</code> 的连接[基于 <code>Host:Port</code> 区分]，这些连接被缓存在一个 <code>连接池内</code>，此时可以利用 <code>Http2</code> 多路复用的能力节约很多时间。</p>
<blockquote>
<p>Each worker thread maintains its own connection pools for each cluster, so if an Envoy has two threads and a cluster with both HTTP/1 and HTTP/2 support, there will be at least 4 connection pools.</p>
</blockquote>
<div>
    <label class="author-mark-label">作者注</label>
    <p class="author-mark">连接池功效，Nginx也有，这块我觉得互有胜负吧，应该算是很常见的优化手段。</p>
</div>
<p>除此之外，<code>non-blocking</code> 是最核心的部分。对于一个热更新系统，我们可以很自然的想到我们需要共享一部分的数据在不同的线程之间，常见的是使用 <code>ReadWriterLock</code>，<code>Envoy</code> 用了一种特别的设计办法 <code>Thread Local Storage (TLS) system</code>：</p>
<p><img src="https://s3.jpg.cm/2020/08/11/b2MF6.png" alt="b2MF6.png"></p>
<p>类似于 <code>RCU</code> 的机制，所有的 <code>Worker</code> 仅仅进行读取的操作。</p>
<h3 id="Envoy-Filter"><a class="header-anchor" href="#Envoy-Filter">¶</a>Envoy Filter</h3>
<p><code>Envoy Filter</code> 是动态生成的，这和大部分的传统 <code>Filter</code> 不太一样，对于大多数的实现，比如 <code>Spring WebMVC</code> 的 <code>Filter</code> 对于所有的请求都是相同的，我们可以在函数的入口判断是否需要处理，或者是直接调用下一个 <code>Filter</code> 而 <code>Envoy</code> 的 <code>Filter</code> 构成的 <code>FilterChain</code> 是由配置生成的，因此比如我们只需要 <code>2</code> 步操作的话，我们在 生成的<code>FilterChain</code> 中也只有 <code>2</code> 个 <code>Filter</code>，减少了很多的函数调用栈的成本。</p>
<h3 id="负债均衡-Accept"><a class="header-anchor" href="#负债均衡-Accept">¶</a>负债均衡 Accept</h3>
<p>对于 <code>Envoy</code> 来说， Run as <code>Sidecar</code> 针对同 <code>Pod</code> 的请求多半是高频的短连接 <code>HTTP</code>，这种模式下，我们 <code>负债均衡 Accept</code> 是最佳的选择，因此 <code>Envoy</code> 在设计的时候，就是使用负债均衡 <code>Accept</code> 的设计。</p>
<h1>参考</h1>
<ul>
<li><a href="https://idea.popcount.org/2017-02-20-epoll-is-fundamentally-broken-12/">Epoll is fundamentally broken</a></li>
<li><a href="https://blog.envoyproxy.io/envoy-threading-model-a8d44b922310">threading model</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>networking</category>
        <category>epoll</category>
      </categories>
      <tags>
        <tag>networking</tag>
        <tag>epoll</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟内存杂谈</title>
    <url>/2020/09/22/os/mmu/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/09/22/H0y9L.png" alt="H0y9L.png"></p>
<blockquote>
<p>MMU是Memory Management Unit的缩写，中文名是内存管理单元，有时称作分页内存管理单元（英语：paged memory management unit，缩写为PMMU）。它是一种负责处理中央处理器（CPU）的内存访问请求的计算机硬件。</p>
</blockquote>
<span id="more"></span>
<h2 id="引言"><a class="header-anchor" href="#引言">¶</a>引言</h2>
<p><code>MMU</code> 对于软件工程师来说并不容易理解，至少笔者在学完了 <code>OS</code> 之后的很长一段时间内都搞不清楚这个玩意到底怎么和操作系统配合使用的，趁着有空将其彻底的梳理清楚。对于操作系统来说 <code>Virtual Memory</code> 并不是一个必要的概念，在学习计算机原理的时候，我们采用 <code>C51</code> <code>Stm32</code> 入门都是可以的，对于常见的 <code>real-time operating system (RTOS)</code> 来说，没有 <code>MMU</code> 的硬件支持，我们依然可以实现 <code>OS</code> 的进程调度等工作，而引入 <code>MMU</code> 硬件和 <code>Virtual Memory</code> 内存的概念我认为是一次软硬件工程师的共同协助，<code>Virtual Memory</code> 的收益很多：定义了一个连续的虚拟地址空间，使得程序的编写难度降低，对于进程也可以进行硬件级别的隔离。</p>
<blockquote>
<p>代码分析选择是 Linux 0.12 的版本，简单简短直接展示出最基础的实现</p>
</blockquote>
<div>
    <label class="author-mark-label">小声比比</label>
    <p class="author-mark">学习进程调度的时候基于 RTOS 学习会更为的简单且高效。</p>
</div>
<h2 id="CPU-寻址"><a class="header-anchor" href="#CPU-寻址">¶</a>CPU 寻址</h2>
<p>对于 <code>16</code> 位时代都是 <code>实模式</code>，我们访问的都是真实的物理地址。</p>
<p><img src="https://s3.jpg.cm/2020/09/22/H0aSU.png" alt="H0aSU.png"></p>
<p>对于 <code>8086</code> 型号的 <code>CPU</code> 来说，我们采用了<code>偏移地址</code>技术。<code>段地址</code> * <code>16</code> + <code>偏移地址</code> = <code>实际的物理地址</code>，总之我们可以直接访问到物理内存，这样对于所有的程序来说我们共享了一份真实内存。而对于之后时代，进入了 <code>保护模式</code> 我们访问的都是虚拟地址。处理方式有所变化：</p>
<p><img src="https://s3.jpg.cm/2020/09/22/H0i2O.png" alt="H0i2O.png"></p>
<p>现代处理器使用的是一种称为虚拟寻址（Virtual Addressing）的寻址方式。使用虚拟寻址，CPU需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。虚拟寻址需要硬件与操作系统之间互相合作。CPU中含有一个被称为内存管理单元（Memory Management Unit, MMU）的硬件，它的功能是将虚拟地址转换为物理地址。MMU需要借助存放在内存中的页表来动态翻译虚拟地址，该页表由操作系统管理。</p>
<blockquote>
<p>ℹ️ : <strong>重点</strong>: 转换的工作是由 MMU 进行控制，而页表是由 OS 控制的，这是软硬件的一次配合。</p>
</blockquote>
<h3 id="页表-PTE"><a class="header-anchor" href="#页表-PTE">¶</a>页表 (PTE)</h3>
<p>首先真实的物理内存资源是有限的，比如 <code>4G</code> <code>10G</code> 决计不是无限的，虚拟内存对于所有进程都是从 <code>0</code> 开始到 <code>2 ^ N</code> N是常见的 32/64 位，那涉及到虚拟内存和真实内存的映射关系。</p>
<p><img src="https://s3.jpg.cm/2020/09/22/H0DPw.png" alt="H0DPw.png"></p>
<blockquote>
<p>虚拟内存：下称 VM， 真实内存：下称 PM</p>
</blockquote>
<p>首先，VM 和 PM 对应并非是整块的，操作系统通过将虚拟内存分割为大小固定的块来作为硬盘和内存之间的传输单位，这个块被称为虚拟页（Virtual Page, VP），每个虚拟页的大小为P=2^p字节。物理内存也会按照这种方法分割为物理页（Physical Page, PP），大小也为P字节。</p>
<p>也就是说对于 <code>VM</code> 是由许多个 <code>VP</code> 构成的，<code>PM</code> 也是由许多个 <code>PP</code> 构成的。 将 <code>PP</code> 和 <code>VP</code> 关联来一起的是就是 <code>页表(PET)</code></p>
<p><img src="https://s3.jpg.cm/2020/09/22/H0Mu8.png" alt="H0Mu8.png"></p>
<p>由于 <code>CPU</code> 每次进行寻址时候都需要使用 <code>PTE</code>，所以如果想控制内存系统的访问，可以在 <code>PTE</code> 上添加一些额外的许可位（例如读写权限、内核权限等），这样只要有指令违反了这些许可条件，<code>CPU</code> 就会触发一个一般保护故障，将控制权传递给内核中的异常处理程序。一般这种异常被称 <code>段错误（Segmentation Fault）</code>。</p>
<p>因涉及到转换，就会出现两种情况：</p>
<ul>
<li>页命中: MMU根据虚拟地址在页表中寻址到了地址，就返回物理地址了</li>
<li>缺页: 对应的就是没有找到相对于的物理地址，会触发一个缺页异常，缺页异常将控制权转向操作系统内核，然后调用内核中的缺页异常处理程序</li>
</ul>
<p>对于一个 <code>32</code> 位的操作系统，大概我们可以访问到 2^32 = 4GB 的空间，一个 PET 为 <code>4bytes</code>，那我们 4MB 个 <code>PTE</code>才能满足所有的寻址需求，那这样 PTE 实在太大，因此真实的环境下，我们会采用 <code>多级页表</code> 技术。</p>
<h3 id="多集页表"><a class="header-anchor" href="#多集页表">¶</a>多集页表</h3>
<p><img src="https://s3.jpg.cm/2020/09/22/H0O4i.png" alt="H0O4i.png"></p>
<p>采用多级页表最明显的有2个好处</p>
<ul>
<li>如果一个一级页表的一个PTE是空的，那么相应的二级页表也不会存在。这代表一种巨大的潜在节约（对于一个普通的程序来说，虚拟地址空间的大部分都会是未分配的）。</li>
<li>只有一级页表才总是需要缓存在内存中的，这样虚拟内存系统就可以在需要时创建、页面调入或调出二级页表（只有经常使用的二级页表才会被缓存在内存中），这就减少了内存的压力。</li>
</ul>
<h2 id="物理页"><a class="header-anchor" href="#物理页">¶</a>物理页</h2>
<p><code>PET</code> 是我们的映射关系，因此对于物理地址的管理，早期的内核中直接用一个数组 <code>mem_map</code> 来表示，这是我们物理页的集合。在内核中的定义为</p>
<figure class="highlight c"><figcaption><span>mm/memory.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> mem_map [ PAGING_PAGES ] = &#123;<span class="number">0</span>,&#125;;</span><br></pre></td></tr></table></figure>
<p>我们在启动的时候时候进行初始化</p>
<figure class="highlight c"><figcaption><span>mm/memory.c:mem_init</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mem_init</span><span class="params">(<span class="type">long</span> start_mem, <span class="type">long</span> end_mem)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	HIGH_MEMORY = end_mem;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;PAGING_PAGES ; i++)</span><br><span class="line">		mem_map[i] = USED;</span><br><span class="line">	i = MAP_NR(start_mem);</span><br><span class="line">	end_mem -= start_mem;</span><br><span class="line">	end_mem &gt;&gt;= <span class="number">12</span>;</span><br><span class="line">	<span class="keyword">while</span> (end_mem--&gt;<span class="number">0</span>)</span><br><span class="line">		mem_map[i++]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照下标的方式将系统划分成 <code>PAGING_PAGES</code> 段，其中为 0 值的下标对象即是可用的区域。</p>
<h2 id="地址翻译"><a class="header-anchor" href="#地址翻译">¶</a>地址翻译</h2>
<p><img src="https://s3.jpg.cm/2020/09/22/H2Cqt.png" alt="H2Cqt.png"></p>
<p>地址翻译这个事情，就是如何从 <code>线性地址</code> 翻译成 <code>物理地址</code>，这个事情还是比较直观的。 将虚拟地址的 前 N 位作为页表目录， (N+1) ~ (2N) 作为页表1，以此类推我们就可以结合在 <code>PET</code> 的数据得到我们真实的地址。</p>
<p><img src="https://s3.jpg.cm/2020/09/22/H2KHR.png" alt="H2KHR.png"></p>
<h3 id="Page-allocator"><a class="header-anchor" href="#Page-allocator">¶</a>Page allocator</h3>
<p>每一个进程的 <code>PET</code> 都是独立的，还记得 <code>CR3</code> 寄存器吗？</p>
<p><img src="https://s3.jpg.cm/2020/09/22/H3php.png" alt="H3php.png"></p>
<p>对于 <code>Linux</code> 来说，我么对于任务的定义包含了很多数据，如下定义</p>
<figure class="highlight c"><figcaption><span>task_struct</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> state;	<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">	<span class="type">long</span> counter;</span><br><span class="line">	<span class="type">long</span> priority;</span><br><span class="line">	<span class="type">long</span> signal;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigaction</span>[32];</span></span><br><span class="line">	<span class="type">long</span> blocked;	<span class="comment">/* bitmap of masked signals */</span></span><br><span class="line"><span class="comment">/* tss for this task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>tss</code> 的数据结构中就保存了我们的  <code>cr3</code> 的寄存器的值，在我们调度进程的时候，就可以将 <code>cr3</code>的寄存器恢复即可。在后续的版本中单独使用 <code>pdg</code> 指向我们一级页表的基址。<br>
对于所有的进程在创建之后，我们都要为其开辟一个单独的页表空间，都是通过 <code>copy_page_tables</code> 函数进行创建对象的 <code>page_tables</code> 空间。因此开辟一个任务并非是 <code>Free</code> 的，我们至少要付出一些代价。而这仅仅是我们开辟了存储空间，想象一下 <code>malloc</code> 函数的场景：</p>
<figure class="highlight c"><figcaption><span>malloc</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> *str;</span><br><span class="line">   str = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="number">15</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>(str, <span class="string">&quot;runoob&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;String = %s,  Address = %u\n&quot;</span>, str, str);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要开辟一个新的内存空间这是实实在在的对于物理空间的占用，因此我们要在我们的 <code>PET</code> 中增加一个对于 <code>User</code> 的虚拟内存地址，也增加一个对于 <code>PET</code> 和真实空间的映射关系，因此会发生如下故事。</p>
<figure class="highlight c"><figcaption><span>get_free_page</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 循环的找到一个可用的物理页，然后标记成已用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_free_page</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">unsigned</span> <span class="type">long</span> __res <span class="title function_">asm</span><span class="params">(<span class="string">&quot;ax&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">	__asm__(<span class="string">&quot;std ; repne ; scasb\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;jne 1f\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;movb $1,1(%%edi)\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;sall $12,%%ecx\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;addl %2,%%ecx\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;movl %%ecx,%%edx\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;movl $1024,%%ecx\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;leal 4092(%%edx),%%edi\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;rep ; stosl\n\t&quot;</span></span><br><span class="line">		<span class="string">&quot;movl %%edx,%%eax\n&quot;</span></span><br><span class="line">		<span class="string">&quot;1:&quot;</span></span><br><span class="line">		:<span class="string">&quot;=a&quot;</span> (__res)</span><br><span class="line">		:<span class="string">&quot;0&quot;</span> (<span class="number">0</span>),<span class="string">&quot;i&quot;</span> (LOW_MEM),<span class="string">&quot;c&quot;</span> (PAGING_PAGES),</span><br><span class="line">		<span class="string">&quot;D&quot;</span> (mem_map+PAGING_PAGES<span class="number">-1</span>)</span><br><span class="line">		:<span class="string">&quot;di&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (__res &gt;= HIGH_MEMORY)</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	<span class="keyword">if</span> (!__res &amp;&amp; swap_out())</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	<span class="keyword">return</span> __res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="杂项"><a class="header-anchor" href="#杂项">¶</a>杂项</h2>
<p>很多初学者会被 <code>GDT</code> 和 <code>LDT</code> 卡住，其实对于 <code>Linux</code> 来说这两部分完全只是白色，所有的段都使用了全部内存，因此对于 <code>Linux</code> 并没有太多的价值。在 Linux Programming Interface那本书里就谈到</p>
<blockquote>
<p>Linux uses segmentation in a very limited way. In fact, segmentation and paging are somewhat redundant, because both can be used to separate the physical address spaces of processes: segmentation can assign a different linear address space to each process, while paging can map the same linear address space into different physical address spaces.</p>
</blockquote>
<p>通过将 cs (代码段) 和 ds (数据段) 寄存器的值设为0，Linux实际没有使用分段而只使用了分页。因为这样内存管理会更加简单，并且由于像RISC架构的处理器只对分段提供了非常有限的支持，不使用分段会提高Linux操作系统在不同CPU架构上的可移植性。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://sylvanassun.github.io/2017/10/29/2017-10-29-virtual_memory/">虚拟内存的那点事儿</a></li>
<li><a href="https://courses.engr.illinois.edu/cs241/sp2014/lecture/09-VirtualMemory_II_sol.pdf">Virtual Memory and Paging</a></li>
<li><a href="https://www.kernel.org/doc/gorman/html/understand/understand009.html">Physical Page Allocation</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>os</category>
        <category>mmu</category>
      </categories>
      <tags>
        <tag>os</tag>
        <tag>mmu</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 QEMU 运行 Linux kernel</title>
    <url>/2023/01/22/os/run-linux-in-qemu/</url>
    <content><![CDATA[<p><img src="https://images.upyun.yanick.site/2022/202301222056140.png" alt=""></p>
<p>让我们使用 qemu 来运行 Linux 吧。</p>
<span id="more"></span>
<h2 id="安装-QEMU"><a class="header-anchor" href="#安装-QEMU">¶</a>安装 QEMU</h2>
<p>首选安装 QEMU，如果不是 x86 就改成自己的架构。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gqemu-system-x86</span><br></pre></td></tr></table></figure>
<h2 id="下载-Linux-Kernel-和编译"><a class="header-anchor" href="#下载-Linux-Kernel-和编译">¶</a>下载 Linux Kernel 和编译</h2>
<ol>
<li>先下载 Linux，这里选择一个自己的版本</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.54.tar.xz</span><br><span class="line">tar xvf linux-5.10.54.tar.xz</span><br><span class="line"><span class="built_in">cd</span> linux-5.10.54</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>构建linux</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make defconfig <span class="comment"># 创建默认配置</span></span><br><span class="line">make kvmconfig <span class="comment"># 设置 QEMU 相关的编译配置</span></span><br><span class="line">make olddefconfig</span><br><span class="line"></span><br><span class="line">make -j`<span class="built_in">nproc</span>` <span class="comment"># nproc 使用的编译线程</span></span><br></pre></td></tr></table></figure>
<p>最终执行完成之后，就会有一个内核镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> <span class="built_in">arch</span>/x86_64/boot/bzImage</span><br></pre></td></tr></table></figure>
<h2 id="RootFS"><a class="header-anchor" href="#RootFS">¶</a>RootFS</h2>
<p>这有一个 <a href="https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md">https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md</a> 构建博客指导。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install debootstrap</span><br><span class="line"><span class="built_in">mkdir</span> image &amp;&amp; <span class="built_in">cd</span> image</span><br><span class="line">wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh</span><br><span class="line"><span class="built_in">chmod</span> +x create-image.sh</span><br><span class="line">./create-image.sh</span><br></pre></td></tr></table></figure>
<p>这里默认去默认的源下载，这里如果在国内，修改 <a href="http://create-image.sh">create-image.sh</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># riscv64 is hosted in the debian-ports repository</span></span><br><span class="line"><span class="comment"># debian-ports doesn&#x27;t include non-free, so we exclude firmware-atheros</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$DEBARCH</span> == <span class="string">&quot;riscv64&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    DEBOOTSTRAP_PARAMS=<span class="string">&quot;--keyring /usr/share/keyrings/debian-ports-archive-keyring.gpg --exclude firmware-atheros <span class="variable">$DEBOOTSTRAP_PARAMS</span> http://deb.debian.org/debian-ports&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">sudo debootstrap <span class="variable">$DEBOOTSTRAP_PARAMS</span> &lt;这里填入相对应的Mirrors地址&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo debootstrap <span class="variable">$DEBOOTSTRAP_PARAMS</span> https://mirrors.ustc.edu.cn/debian/</span><br></pre></td></tr></table></figure>
<h2 id="运行-Kenerl"><a class="header-anchor" href="#运行-Kenerl">¶</a>运行 Kenerl</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">        -m 2G \</span><br><span class="line">        -smp 2 \</span><br><span class="line">        -kernel <span class="variable">$1</span>/arch/x86/boot/bzImage \</span><br><span class="line">        -append <span class="string">&quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0 nokaslr&quot;</span> \</span><br><span class="line">        -drive file=<span class="variable">$2</span>/stretch.img,format=raw \</span><br><span class="line">        -net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \</span><br><span class="line">        -net nic,model=e1000 \</span><br><span class="line">        -enable-kvm \</span><br><span class="line">        -nographic \</span><br><span class="line">        -pidfile vm.pid </span><br></pre></td></tr></table></figure>
<p>如果在虚拟机中执行，去除 <code>-enable-kvm</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x run.sh</span><br><span class="line">./run.sh . image/</span><br></pre></td></tr></table></figure>
<h2 id="从外部访问"><a class="header-anchor" href="#从外部访问">¶</a>从外部访问</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在QEMU 内</span></span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure>
<p>然后在本机执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -i image/stretch.id_rsa -p 10021 -o <span class="string">&quot;StrictHostKeyChecking no&quot;</span> root@localhost</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://vccolombo.github.io/cybersecurity/linux-kernel-qemu-setup/">Linux kernel QEMU setup</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>linux</category>
        <category>os</category>
        <category>qemu</category>
      </categories>
      <tags>
        <tag>os</tag>
        <tag>linux</tag>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>chameleon项目安利</title>
    <url>/2016/12/07/other/about-chameleon/</url>
    <content><![CDATA[<p>chameleon(变色龙) 是一个Java的Bean Converter轮子，实现注解化类型转换。</p>
<p><a href="https://github.com/yannxia/chameleon">Github地址</a></p>
<span id="more"></span>
<h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2>
<p>经常在业务里写 A -&gt; B 这样的转换方法，每次都需要手动调用极其的麻烦，而且每次这种代码复用起来又是比较麻烦的，最初尝试过使用 com.google.common.base.Converter的这个转换接口，<br>
包括 Spring的org.springframework.core.convert.converter.Converter，虽然从接口层面定义了 A -&gt; B 问题，但是没有发现ConverterFacotory这样可用的轮子，只能自己尝试制造一个。</p>
<h2 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h2>
<p>需要解决的是 A -&gt; B 的问题。我们也有 Converter Interface， 那我们只缺少一个 ConverterFacotory。那问题的解决方案就也有啦，我们就是要去写一个ConverterFacotory。<br>
现在的Java注解使用的更多些，尤其在SpringBoot中，那Converter Interface其实也不是必须的，使用Annonation也可以，最终还是选择使用注解。</p>
<h2 id="编码分析"><a class="header-anchor" href="#编码分析">¶</a>编码分析</h2>
<p>从SpringCotext从得到的思路，那核心应该是一个HashMap. Key应该是 From（转换方法入参数）+To（转换方法的出参）， Value是Method（具体的转换方法） 和 Object（具体的类）。<br>
那我们可以大致上确定数据结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//核心容器的Key</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConvertKey</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Class&gt; froms;</span><br><span class="line">    <span class="keyword">private</span> Class to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConvertKey</span><span class="params">(Class to, Class... froms)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.froms = Arrays.asList(froms);</span><br><span class="line">        <span class="built_in">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> to.getName().hashCode();</span><br><span class="line">        <span class="keyword">for</span> (Class from : froms) &#123;</span><br><span class="line">            hashCode &amp;= from.getName().hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ConvertKey) &#123;</span><br><span class="line">            <span class="type">ConvertKey</span> <span class="variable">other</span> <span class="operator">=</span> (ConvertKey) obj;</span><br><span class="line">            <span class="keyword">return</span> other.froms.equals(<span class="built_in">this</span>.froms) &amp;&amp; other.to.equals(<span class="built_in">this</span>.to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//核心容器的Value</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CovertInstant</span> &#123;</span><br><span class="line">    Object convertObj;</span><br><span class="line">    Method covertMethod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CovertInstant</span><span class="params">(Object convertObj, Method covertMethod)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.convertObj = convertObj;</span><br><span class="line">        <span class="built_in">this</span>.covertMethod = covertMethod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//核心容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractConvertFactory</span> <span class="keyword">implements</span> <span class="title class_">ConvertFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ConcurrentHashMap&lt;ConvertKey, CovertInstant&gt; keyCovertInstantConcurrentHashMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(); <span class="comment">//存储核心</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">convert</span><span class="params">(Class&lt;T&gt; expect, Object... params)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从三个实体定义差不多就可以确定出，我们的代码了，整体设计就是把可以转换的方法放入这个核心容器内。</p>
<h2 id="编码"><a class="header-anchor" href="#编码">¶</a>编码</h2>
<p>我们额外定义一个注解，用来标记是否为一个转换方法 <a href="https://github.com/yannxia/chameleon/blob/master/src/main/java/info/yannxia/java/chameleon/annonation/Convertor.java">Convertor注解</a></p>
<p>我们需要实现一个具体的ConvertFactory。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConvertFactoryImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractConvertFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ConvertFactoryImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConvertFactoryImpl <span class="title function_">build</span><span class="params">(Object... objects)</span> &#123;</span><br><span class="line">        <span class="type">ConvertFactoryImpl</span> <span class="variable">convertFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConvertFactoryImpl</span>();</span><br><span class="line">        Arrays.stream(objects)</span><br><span class="line">                .forEach(convertFactory::setupObject); <span class="comment">//JDK8 就是好，安利</span></span><br><span class="line">        <span class="keyword">return</span> convertFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setupObject</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        Method[] methods = object.getClass().getMethods(); <span class="comment">//遍历每一个方法，这里仅仅支持Public方法，防止Private的滥用。</span></span><br><span class="line">        Arrays.stream(methods)</span><br><span class="line">                .filter(AbstractConvertFactory::isConvertorMethod)</span><br><span class="line">                .forEach(method -&gt; &#123;</span><br><span class="line">                    Class[] froms = method.getParameterTypes();</span><br><span class="line">                    <span class="type">Class</span> <span class="variable">to</span> <span class="operator">=</span> method.getReturnType();</span><br><span class="line">                    <span class="type">ConvertKey</span> <span class="variable">convertKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConvertKey</span>(to, froms);</span><br><span class="line">                    <span class="type">CovertInstant</span> <span class="variable">covertInstant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CovertInstant</span>(object, method);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.keyCovertInstantConcurrentHashMap.containsKey(convertKey)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;already has [%s] -&gt; [%s] method&quot;</span>, froms, to));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>.keyCovertInstantConcurrentHashMap.put(convertKey, covertInstant);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isConvertorMethod</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method.getAnnotation(Convertor.class) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a class="header-anchor" href="#补充">¶</a>补充</h2>
<p>关于Spring的集成见 <a href="https://github.com/yannxia/chameleon/blob/master/src/main/java/info/yannxia/java/chameleon/SpringConvertFactoryImplLoader.java">SpringConvertFactoryImplLoader.java</a></p>
<p>Spring集成的核心在于，如何从构造好的ApplicationContext中取出那些注册好的Bean，然后构建我们自己的ConvertFactory，不过整体实现难度很低就不去贴代码了。</p>
<h2 id="测试"><a class="header-anchor" href="#测试">¶</a>测试</h2>
<p><a href="https://github.com/yannxia/chameleon/blob/master/src/test/java/info/yannxia/java/chameleon/ConvertFactoryTest.java">CovertFacotry测试</a><br>
<a href="https://github.com/yannxia/chameleon/blob/master/src/test/java/info/yannxia/java/chameleon/SpringConvertFactoryTest.java">SpringConvertFactoryTest测试</a></p>
<h2 id="PS"><a class="header-anchor" href="#PS">¶</a>PS</h2>
<p>写博客的时候搜索了下，发现了Spring有个这么个玩意 <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/validation.html#core-convert">Spring</a><br>
那就算是自己造了一个轮子吧。</p>
<p><strong>预定下一篇博客去研究下Spring的convert机制。</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Convert</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL CA HTTPS</title>
    <url>/2020/11/28/other/ca/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201128222900.png" alt=""></p>
<p>CA，Catificate Authority，它的作用就是提供证书（即服务器证书，由域名、公司信息、序列号和签名信息组成）加强服务端和客户端之间信息交互的安全性，以及证书运维相关服务。</p>
<span id="more"></span>
<h2 id="HTTPS证书"><a class="header-anchor" href="#HTTPS证书">¶</a>HTTPS证书</h2>
<p>说 <code>CA</code> 之前，我们不得不去先聊聊 <code>SSL</code>，因为 <code>HTTP</code> 传输数据的明文性质，导致了后续社区提出了加密方案，也就是 <code>SSL</code>(Secure Socket Layer) 在原有的 <code>Socket</code> 之上增加一层加密传输，<code>HTTPS</code> 也就是 <code>HTTP</code> + <code>SSL</code>, <code>TLS</code> 是被 <code>IETF</code> 标准化的 <code>SSL</code> -&gt; <code>Transport Layer Security</code></p>
<p><code>SSL</code> 本身也不是很复杂，在建立好 TCP 协议之后，我们通过 <code>SSL</code> 协议协商，完成加密。</p>
<ul>
<li>客户端先向服务器发出加密通信的请求，这被叫做ClientHello请求。</li>
<li>服务器收到客户端请求后，向客户端发出回应，这叫做ServerHello</li>
<li>客户端回应</li>
<li>服务器的最后回应</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201128215700.png" alt=""></p>
<p>其中比较复杂的就是 RSA 非对称加密技术了，这里就不做展开，可以参考 <a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法原理</a></p>
<h2 id="CA"><a class="header-anchor" href="#CA">¶</a>CA</h2>
<p>在上一节中，我们知道了服务器之间是需要交换公私钥的，因此其实有被串改的风险的，因为其实我们是没办法辨别对方是否是真实性，因此我们在此加入了一个中间公正机构，也就是 CA 提供商，因此我们访问一些自定义的服务SSL会导致如下</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201128220120.png" alt=""></p>
<p>就是因为 RSA 证书不受信任，因此CA提供商，提供了有偿服务，在服务器上维护了大量公私钥，不过有人会问，为什么CA本身不能是假的呢？其实这个也是可以的，不过在绝大多数的系统中，会提供默认的证书提供商的公钥，只要不去恶意的替换就不存在被替换的风险。</p>
<h3 id="Root-根证书"><a class="header-anchor" href="#Root-根证书">¶</a>Root 根证书</h3>
<p>为什么需要根证书呢？这就是和上面信任的问题，我们知道绝大多数的系统会内置一些 <code>CA</code> 提供商的证书，这些证书就是根证书，此时我们去访问一个 <code>HTTPS</code> 服务器的时候，那我们怎么知道它的证书是可靠的呢？解决之道就是 <code>证书链</code></p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201128220630.png" alt=""></p>
<p><code>证书链</code> 在生成证书的时候就会生产出来，一般来说就就是三级</p>
<ul>
<li>end-user：即 <a href="http://www.google.com">www.google.com</a>，是该网站使用 HTTPS 安装的数字证书</li>
<li>intermediates：即 Google Internet Authority G3，是给 end-user 签发证书的中间 CA 的证书，中间 CA 可能不止一个</li>
<li>root：即 Google Trust Services - GlobalSign Root CA-R2，是根 CA 的证书，它给中间 CA 签发证书</li>
</ul>
<p>为什么需要证书链，并不是担心 <code>end-user</code> 的私钥丢失，丢失了再生成就好了，主要担心的是 <code>intermediates</code> 的私钥丢失，这样会影响所有下游系统，因此当 <code>intermediates</code> 的私钥丢失，<code>root</code> 会放弃这个 <code>intermediates</code> 的证书，认为不合法，然后换一个CA给所有的 <code>end-user</code> 生产一个人新的证书，这样<code>中间CA</code> 产生的不安全被隔离了。</p>
<h3 id="Real-World"><a class="header-anchor" href="#Real-World">¶</a>Real World</h3>
<p>一般我们生成自签名的系统的时候，第一步都是生产自签名的 ROOT 证书</p>
<ul>
<li>root-cert.pem: root 证书</li>
<li>root-key.pem: root 私钥</li>
</ul>
<p>然后根据我们的 ROOT 证书生成  intermediates 证书</p>
<ul>
<li>ca-cert.pem: intermediate 证书</li>
<li>ca-key.pem: intermediate 私钥</li>
<li>cert-chain.pem: 证书链</li>
</ul>
<p>因此我们到时候直接需要把 root-cert 加入我们的系统之中，这些 IMT 证书就可以直接使用了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>ca</category>
      </categories>
      <tags>
        <tag>ca</tag>
      </tags>
  </entry>
  <entry>
    <title>Log-structured File System</title>
    <url>/2020/10/15/other/lfs/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/10/15/tTm8U.png" alt="tTm8U.png"></p>
<p><a href="https://people.eecs.berkeley.edu/~brewer/cs262/LFS.pdf">The Design and Implementation of a Log-Structured File System</a> 是 Mendel Rosenblum 和 John K. Ousterhout 在90年代初发表的一篇经典论文，作者认为随机读不是 主要问题：随着越来越大的内存，大部分的读操作都能被 cache，因此 LFS 主要要解决的是减少对硬盘的随机写操作。</p>
<span id="more"></span>
<blockquote>
<p>作者在论文中用一个 <code>Sprite LFS</code> 来描述。</p>
</blockquote>
<h2 id="File-System-As-Log"><a class="header-anchor" href="#File-System-As-Log">¶</a>File System As Log</h2>
<p><img src="https://s3.jpg.cm/2020/10/15/t9Jzy.png" alt="t9Jzy.png"></p>
<p>对于文件的写入，也是类似通过 <code>append log</code> 的方式进行追加数据。大家如果记得话 <code>Kafka</code> 的话， <code>Kafka</code> 基于 <code>顺序写</code> 的方式提高了写入的吞吐量。 <code>想法</code>非常的朴质，但是有两点需要解决：1. 如何通过日志读取最终文件，这个很容易理解。2. 如何管理空闲的数据段。</p>
<p>管理空闲的数据段就会涉及到如下状态的处理，假如某个值为 <code>A</code>, <code>A'</code>,<code>A''</code>,<code>A'''</code> 的顺序写入，我们最终只需要 <code>A'''</code> 的状态，而其他的并不需要。</p>
<h2 id="名词列表"><a class="header-anchor" href="#名词列表">¶</a>名词列表</h2>
<table>
<thead>
<tr>
<th>名词</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>Inode</td>
<td>定位文件块，包含存储保护位、更新时间等</td>
</tr>
<tr>
<td>Inode map</td>
<td>定位log中inode的位置，包含最近访问时间和版本号</td>
</tr>
<tr>
<td>Indriect block</td>
<td>定位大容量数据块</td>
</tr>
<tr>
<td>Segement summary</td>
<td>标识segment的内容(文件数量以及每个block的偏移量)</td>
</tr>
<tr>
<td>Segement usage table</td>
<td>计算segments中存活的bytes数，并为segement中的数据存储的写 时间</td>
</tr>
<tr>
<td>Super Block</td>
<td>存储静态配置信息，包括segements的数量和大小</td>
</tr>
<tr>
<td>Checkpoint region</td>
<td>定位inode map、segment useage table所在的block，并标识log中上一个check point的位置</td>
</tr>
<tr>
<td>Directory  change log</td>
<td>记录目录操作，从而保证inode 中的引用数量一致性</td>
</tr>
</tbody>
</table>
<h2 id="文件读取"><a class="header-anchor" href="#文件读取">¶</a>文件读取</h2>
<p>常规的 <code>log-structured</code> 的数据格式，显然我们需要从零开始一直读取到最后的日志。那显然太慢了，<code>Sprite LFS</code> 为了提高性能，每个文件都有一个 <code>inode</code> 的数据结构，保存一些元数据与 前十个<code>10</code> 个 <code>数据Blocks</code> ，对于大文件来说 <code>10</code> 个数据块显然不够，<code>inode</code> 还包含一个或多个 <code>indirect blocks</code> 的磁盘地址，每个 <code>indirect blocks</code> 包含更多数据或间接块的地址。</p>
<p><img src="https://s3.jpg.cm/2020/10/15/t9aof.png" alt="t9aof.png"></p>
<p>因为 <code>Inode</code> 非确定的出现在任意一个位置，因此我们还需要定位 <code>Inode</code> 本身。<code>LFS</code> 里面用了一种 <code>Inode map</code> 去存 <code>Inode</code> 的地址。</p>
<p><img src="https://s3.jpg.cm/2020/10/15/t9iDU.png" alt="t9iDU.png"></p>
<p>但是 <code>Inode map</code> 也是按照 <code>Block</code> 的方式写入日志中的，因此我们势必需要一个固定的区域来定位，那就有两种方式， <code>Inode Map</code> 存在固定的位置，或者再间接引用。在 <code>LFS</code> 中是有一个固定的 <code>checkpoint</code> 区域来储存 <code>inode map</code> 的位置。</p>
<p><img src="https://s3.jpg.cm/2020/10/15/tTRLy.png" alt="tTRLy.png"></p>
<h2 id="空间管理"><a class="header-anchor" href="#空间管理">¶</a>空间管理</h2>
<p><code>Sprite LFS</code> 将磁盘分成了很多个 <code>segment</code></p>
<p><img src="https://s3.jpg.cm/2020/10/15/t9K5S.png" alt="t9K5S.png"></p>
<p><code>segment</code> 是在内存中，当储存的数据量超过 <code>限制大小</code> 之后才会向磁盘落盘。</p>
<h3 id="垃圾回收"><a class="header-anchor" href="#垃圾回收">¶</a>垃圾回收</h3>
<p>日志系统最大的问题显然是需要回收那些不需要的空间的，为了压缩空间，加入了 <code>segment cleaning</code> 技术，<code>Sprite LFS</code> 分了三步来处理这个问题：1. 读取一部分 segments 到内存 2. 标记还存活的数据  3. 将活着的数据写入较少的 segments</p>
<p><img src="https://s3.jpg.cm/2020/10/15/tTUM6.png" alt="tTUM6.png"></p>
<p>为了确定哪些 <code>Block</code> 已经无效了，<code>LFS</code> 在 <code>Segment</code> 开头处中储存了一种 <code>Segment Summary</code> 数据体，<code>Segment Summary</code> 中存储了段中每个 <code>Data Block</code> 的地址，和这个 <code>Data Block</code> 的 <code>Inode Number （文件号）</code>，以及该 <code>Block</code> 在文件中的 <code>offset</code>。对于任意 <code>Block</code>，只要对比该 <code>Block</code> 的地址，和通过 <code>Inode Map</code> 查询这个 <code>Block</code> 的地址是否相同，就能判断这个 <code>Block</code> 是否过期。</p>
<p><img src="https://s3.jpg.cm/2020/10/15/tTx1X.png" alt="tTx1X.png"></p>
<p>如上图中，我们 <code>Inode Map</code> 中储存的 <code>Inode2</code> 的版本是 <code>2</code>，而在 <code>Segment Summary</code> 中 <code>Inode2</code> 的版本是 <code>1</code> 因此这部分的数据就是无效的。</p>
<h2 id="故障恢复"><a class="header-anchor" href="#故障恢复">¶</a>故障恢复</h2>
<ul>
<li><code>LFS</code> 的每个 <code>Segment</code> 都存储了下一个 <code>Segment</code> 的地址，像链表一样。</li>
<li>在 <code>Checkpoint</code> <code>中，LFS</code> 存储了这个链表的第一个 <code>Segment</code> 和最后一个 <code>Segment</code> 的地址，因此只要读取 <code>Checkpoint</code> 就能恢复出整个文件系统。</li>
<li><code>LFS</code> 每 <code>30</code> 秒更新一次 <code>Checkpoint</code> 中的数据。</li>
</ul>
<p><img src="https://s3.jpg.cm/2020/10/15/tTMOp.png" alt="tTMOp.png"></p>
<ol>
<li>当我们更新 <code>Checkpoint</code> 的出现问题，如果 <code>Head</code> <code>Tail</code> 都没有更新，等于没有创建，再来一次即可。</li>
<li>当我们更新 <code>Checkpoint</code> 的出现问题，如果 <code>Head</code> 更新，<code>Tail</code> 没有更新的话
<ul>
<li><code>LFS</code> 在硬盘的头部和尾部存储了两个 <code>Checkpoint</code>，每次 <code>Checkpoint</code> 时 <code>LFS</code> 交替地存储在头部或是尾部的 <code>Checkpoint</code> 中。 这样即使写入一个 <code>Checkpoint</code> 失败， <code>LFS</code> 也能恢复到上一个 <code>Checkpoint</code></li>
<li>同时 <code>LFS</code> 利用时间戳来检测 <code>Checkpoint</code> 的失败：在写入 <code>Checkpoint</code> 时，先更新头指针和对应的时间戳，再更新 <code>Checkpoint</code> 中的其它内容，最后更新尾指针和相同的时间戳。如果 LFS 在读取 <code>Checkpoint</code> 时发现头指针和尾指针的时间戳不一致，就知道这个 <code>Checkpoint</code> 并没有完成。</li>
</ul>
</li>
</ol>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>为什么 <code>LFS</code> 被大家喜欢，<code>LFS</code> 将文件系统按照日志的方式进行储存，假设大部分<code>读</code>都可以在 <code>Buffer Cache</code> 中完成，而写入速度是更高优先级，通过 <code>Segment</code> 的机制让随机写入变成顺序写入，并且很容易的完成快速恢复。</p>
<p>但是 <code>LFS</code> 并非是没有缺点，在 <a href=""><code>compared FFS to a BSD port of Sprite’s LFS</code></a> 论文提及到：</p>
<ul>
<li>磁盘常常是满的（回收器需要在大量的Segment中才能找到一点点可以回收的空间）</li>
<li>写操作随机（因为空闲空间将均匀地分布在各个段中，迫使回收器读取许多段以释放空间）</li>
</ul>
<p>类似于 <code>Java</code> 如何控制垃圾回收反而是一个更复杂的问题，大概也是从 <code>1991</code> 诞生之后并没有大规模的普及，但是对后世的很多系统都产生了深远的影响。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>lsf</category>
        <category>file-system</category>
      </categories>
      <tags>
        <tag>lsf</tag>
        <tag>file-system</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenAPI（Swagger）快速入门</title>
    <url>/2018/08/13/other/swagger/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2018/08/13/Pg2TYD.png" alt="banner"></p>
<h2 id="Swagger-是什么"><a class="header-anchor" href="#Swagger-是什么">¶</a>Swagger 是什么</h2>
<p><code>Swagger</code>是使用<code>OpenAPI</code>规范（OAS）开发 API 的最广泛使用的工具生态系统。2015 年，<code>SmartBear Software</code>将<code>Swagger</code>规范捐赠给<code>Linux Foundation</code>，并将规范重命名为<code>OpenAPI</code>规范。 <code>SmartBear</code>还成为<code>OpenAPI Initiative（OAI）</code>的创始成员，该机构以开放和透明的方式管理<code>OAS</code>的发展。</p>
<blockquote>
<p>简而言之 Swagger 包含了一套 API 规范，并且提供一系列的生态组件<br>
OpenAPI = 规范<br>
Swagger = 实现规范的组件</p>
</blockquote>
<span id="more"></span>
<h2 id="Swagger-有什么用"><a class="header-anchor" href="#Swagger-有什么用">¶</a>Swagger 有什么用</h2>
<p><code>Swagger</code> 围绕着 <code>API</code> 诞生，它的用途也就是围绕着 <code>API</code></p>
<ul>
<li>作为 Rest API 的交互式文档</li>
<li>作为 Rest API 的形式化的接口描述</li>
<li>作为 Mock 服务的规范</li>
<li>作为调试文档生成测试页面 <a href="http://petstore.swagger.io/?_ga=2.171779168.1722816637.1534168865-221653252.1534168865#/">Petstore</a></li>
</ul>
<h2 id="Swagger-怎么用"><a class="header-anchor" href="#Swagger-怎么用">¶</a>Swagger 怎么用</h2>
<h3 id="YAML-编写"><a class="header-anchor" href="#YAML-编写">¶</a>YAML 编写</h3>
<p>最为原始也最为可靠的方式就是人工编辑。<code>Swagger</code> 为我们提供了 <code>Swagger 编辑器</code>，在线环境 <a href="https://editor.swagger.io">Swagger Editor</a></p>
<h4 id="OpenAPI-数据类型"><a class="header-anchor" href="#OpenAPI-数据类型">¶</a>OpenAPI 数据类型</h4>
<table>
<thead>
<tr>
<th>常见数据类型</th>
<th>type</th>
<th>format</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>integer</td>
<td>integer</td>
<td>int32</td>
<td>32 位有符号数</td>
</tr>
<tr>
<td>long</td>
<td>integer</td>
<td>int64</td>
<td>64 位有符号数</td>
</tr>
<tr>
<td>float</td>
<td>number</td>
<td>float</td>
<td></td>
</tr>
<tr>
<td>double</td>
<td>number</td>
<td>double</td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>string</td>
<td></td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td>string</td>
<td>byte</td>
<td>Base64 编码</td>
</tr>
<tr>
<td>binary</td>
<td>string</td>
<td>binary</td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td>boolean</td>
<td></td>
<td></td>
</tr>
<tr>
<td>date</td>
<td>string</td>
<td>date</td>
<td>RFC3339 格式</td>
</tr>
<tr>
<td>dateTime</td>
<td>string</td>
<td>date-time</td>
<td>RFC3339 格式</td>
</tr>
<tr>
<td>password</td>
<td>string</td>
<td>password</td>
<td>页面隐藏输入</td>
</tr>
<tr>
<td>object</td>
<td>object</td>
<td></td>
<td>由上面的数据构成</td>
</tr>
</tbody>
</table>
<h4 id="OpenAPI-根对象"><a class="header-anchor" href="#OpenAPI-根对象">¶</a>OpenAPI 根对象</h4>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>openapi</td>
<td>string</td>
<td><code>必须</code>：版本号</td>
</tr>
<tr>
<td>info</td>
<td>Info Object</td>
<td><code>必须</code>：API 定义的元数据</td>
</tr>
<tr>
<td>servers</td>
<td>[Server Object]</td>
<td>服务器的列表信息</td>
</tr>
<tr>
<td>paths</td>
<td>Paths Object</td>
<td>API 路由配置</td>
</tr>
<tr>
<td>components</td>
<td>Components Object</td>
<td>组件</td>
</tr>
<tr>
<td>security</td>
<td>[Security Requirement Object]</td>
<td>安全</td>
</tr>
<tr>
<td>tags</td>
<td>[Tag Object]</td>
<td>标签信息</td>
</tr>
<tr>
<td>externalDocs</td>
<td>External Documentation Object</td>
<td>额外文档</td>
</tr>
</tbody>
</table>
<p>关于对象的定义在 <a href="https://swagger.io/specification/">specification</a> 处进行查看</p>
<h4 id="编写API文档"><a class="header-anchor" href="#编写API文档">¶</a>编写API文档</h4>
<p><code>Swagger</code> 有两种编写格式，分别是 <code>Json</code> 和 <code>Yaml</code> 格式，个人更偏爱于 <code>Yaml</code> 格式，所以下文使用 <code>Yaml</code> 作为案例。</p>
<h5 id="定义接口元信息"><a class="header-anchor" href="#定义接口元信息">¶</a>定义接口元信息</h5>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">这是标题</span> <span class="string">【必填】</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">这里是一段描述</span></span><br><span class="line"><span class="attr">termsOfService:</span> <span class="string">API可以测试地址</span></span><br><span class="line"><span class="attr">contact:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">联系人</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">http://www.example.com/support</span>  <span class="string">联系人地址</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">support@example.com</span>  <span class="string">联系人邮箱</span></span><br><span class="line"><span class="attr">license:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Apache</span> <span class="number">2.0</span> <span class="string">授权信息</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://www.apache.org/licenses/LICENSE-2.0.html</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.0</span><span class="number">.1</span>  <span class="string">OpenAPI的版本号【必填】</span></span><br></pre></td></tr></table></figure>
<h5 id="定义请求接口"><a class="header-anchor" href="#定义请求接口">¶</a>定义请求接口</h5>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 元信息略</span></span><br><span class="line"><span class="string">/pets:</span>  <span class="comment"># 路径，如果需要 path value 可以使用形如 /pets/&#123;petId&#125;</span></span><br><span class="line">  <span class="attr">get:</span>  <span class="comment"># get 请求，同理还有 put，post，delete，options 等方法</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">这是一段描述信息</span></span><br><span class="line">    <span class="attr">responses:</span>  <span class="comment"># 响应部分定义</span></span><br><span class="line">      <span class="attr">&#x27;200&#x27;:</span>  <span class="comment"># 200 的响应码</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">又是一段描述</span> </span><br><span class="line">        <span class="attr">content:</span> <span class="comment">#内容</span></span><br><span class="line">          <span class="attr">application/json:</span>  <span class="comment"># context-type</span></span><br><span class="line">            <span class="attr">schema:</span></span><br><span class="line">              <span class="attr">type:</span> <span class="string">array</span>  <span class="comment"># 类型</span></span><br><span class="line">              <span class="attr">items:</span>  <span class="comment"># array 所包含的 元素</span></span><br><span class="line">                <span class="string">$ref:</span> <span class="string">&#x27;#/components/schemas/pet&#x27;</span>  <span class="comment">#每个元素是一个组件，下文详细说明</span></span><br></pre></td></tr></table></figure>
<p>从一个简单的请求接口定义，我们就看出来，最为核心的<code>OPENAPI</code> 包含的是 <code>路径 /pets</code>，<code>请求方式 get</code>, <code>请求响应 responses</code>，但是好像缺少了点什么？对的，我们还不知道怎么去定义 <code>请求参数</code>。</p>
<h6 id="定义请求参数"><a class="header-anchor" href="#定义请求参数">¶</a>定义请求参数</h6>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 Header 中添加参数</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">token</span></span><br><span class="line"><span class="attr">in:</span> <span class="string">header</span> <span class="comment">#这里是固定值</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">token</span> <span class="string">to</span> <span class="string">be</span> <span class="string">passed</span> <span class="string">as</span> <span class="string">a</span> <span class="string">header</span> <span class="comment">#描述信息</span></span><br><span class="line"><span class="attr">required:</span> <span class="literal">true</span> <span class="comment"># 是否必需</span></span><br><span class="line"><span class="attr">schema:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">array</span> <span class="comment">#类型</span></span><br><span class="line">  <span class="attr">items:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 PATH 中添加参数</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">username</span></span><br><span class="line"><span class="attr">in:</span> <span class="string">path</span> <span class="comment">#这里是固定值</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">username</span> <span class="string">to</span> <span class="string">fetch</span></span><br><span class="line"><span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">schema:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Query 中添加参数</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">id</span></span><br><span class="line"><span class="attr">in:</span> <span class="string">query</span> <span class="comment"># 这里是固定值</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">ID</span> <span class="string">of</span> <span class="string">the</span> <span class="string">object</span> <span class="string">to</span> <span class="string">fetch</span></span><br><span class="line"><span class="attr">required:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">schema:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">array</span></span><br><span class="line">  <span class="attr">items:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">style:</span> <span class="string">form</span></span><br><span class="line"><span class="attr">explode:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        整合在一起
    </div>
    <div class='spoiler-content'>
        <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">/pets:</span>  <span class="string">/#</span> <span class="string">路径，如果需要</span> <span class="string">path</span> <span class="string">value</span> <span class="string">可以使用形如</span> <span class="string">/pets/&#123;petId&#125;</span></span><br><span class="line">  <span class="attr">get:</span>  <span class="string">/#</span> <span class="string">get</span> <span class="string">请求，同理还有</span> <span class="string">put，post，delete，options</span> <span class="string">等方法</span></span><br><span class="line">    <span class="attr">parameters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">token</span></span><br><span class="line">        <span class="attr">in:</span> <span class="string">header</span> <span class="comment">#这里是固定值</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">token</span> <span class="string">to</span> <span class="string">be</span> <span class="string">passed</span> <span class="string">as</span> <span class="string">a</span> <span class="string">header</span> <span class="comment">#描述信息</span></span><br><span class="line">        <span class="attr">required:</span> <span class="literal">true</span> <span class="comment"># 是否必需</span></span><br><span class="line">        <span class="attr">schema:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">array</span> <span class="comment">#类型</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">            <span class="attr">format:</span> <span class="string">int64</span></span><br><span class="line">     <span class="bullet">-</span>  <span class="attr">name:</span> <span class="string">username</span></span><br><span class="line">        <span class="attr">in:</span> <span class="string">path</span> <span class="comment">#这里是固定值</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">username</span> <span class="string">to</span> <span class="string">fetch</span></span><br><span class="line">        <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">schema:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">     <span class="bullet">-</span>  <span class="attr">name:</span> <span class="string">id</span></span><br><span class="line">        <span class="attr">in:</span> <span class="string">query</span> <span class="comment">#这里是固定值</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">ID</span> <span class="string">of</span> <span class="string">the</span> <span class="string">object</span> <span class="string">to</span> <span class="string">fetch</span></span><br><span class="line">        <span class="attr">required:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">schema:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">array</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">style:</span> <span class="string">form</span></span><br><span class="line">        <span class="attr">explode:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">这是一段描述信息</span></span><br><span class="line">    <span class="attr">responses:</span>  <span class="comment"># 响应部分定义</span></span><br><span class="line">      <span class="attr">&#x27;200&#x27;:</span>  <span class="comment"># 200 的响应码</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">又是一段描述</span> </span><br><span class="line">        <span class="attr">content:</span> <span class="comment">#内容</span></span><br><span class="line">          <span class="attr">application/json:</span>  <span class="comment"># context-type</span></span><br><span class="line">            <span class="attr">schema:</span></span><br><span class="line">              <span class="attr">type:</span> <span class="string">array</span>  <span class="comment"># 类型</span></span><br><span class="line">              <span class="attr">items:</span>  <span class="comment"># array 所包含的 元素</span></span><br><span class="line">                <span class="string">$ref:</span> <span class="string">&#x27;#/components/schemas/pet&#x27;</span>  <span class="comment">#每个元素是一个定义，下文详细说明</span></span><br></pre></td></tr></table></figure>
    </div>
</div>
<h6 id="定义请求体"><a class="header-anchor" href="#定义请求体">¶</a>定义请求体</h6>
<p>我们使用 <code>requestBody</code> 作为请求体</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">description:</span> <span class="string">user</span> <span class="string">to</span> <span class="string">add</span> <span class="string">to</span> <span class="string">the</span> <span class="string">system</span> <span class="comment"># 描述信息</span></span><br><span class="line"><span class="attr">content:</span>  <span class="comment"># 定义请求体</span></span><br><span class="line">  <span class="attr">&#x27;application/json&#x27;:</span> <span class="comment"># context-type</span></span><br><span class="line">    <span class="attr">schema:</span> <span class="comment"># 请求的格式</span></span><br><span class="line">      <span class="string">$ref:</span> <span class="string">&#x27;#/components/schemas/User&#x27;</span> <span class="comment"># 组件</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="comment"># 例子</span></span><br><span class="line">      <span class="attr">user:</span></span><br><span class="line">        <span class="attr">summary:</span> <span class="string">User</span> <span class="string">Example</span></span><br><span class="line">        <span class="attr">externalValue:</span> <span class="string">&#x27;http://foo.bar/examples/user-example.json&#x27;</span></span><br><span class="line">  <span class="attr">&#x27;application/xml&#x27;:</span> <span class="comment"># context-type</span></span><br><span class="line">    <span class="attr">schema:</span></span><br><span class="line">      <span class="string">$ref:</span> <span class="string">&#x27;#/components/schemas/User&#x27;</span></span><br><span class="line">    <span class="attr">examples:</span></span><br><span class="line">      <span class="attr">user:</span></span><br><span class="line">        <span class="attr">summary:</span> <span class="string">User</span> <span class="string">Example</span> <span class="string">in</span> <span class="string">XML</span></span><br><span class="line">        <span class="attr">externalValue:</span> <span class="string">&#x27;http://foo.bar/examples/user-example.xml&#x27;</span></span><br><span class="line">  <span class="attr">&#x27;text/plain&#x27;:</span> <span class="comment"># context-type</span></span><br><span class="line">    <span class="attr">examples:</span></span><br><span class="line">      <span class="attr">user:</span></span><br><span class="line">        <span class="attr">summary:</span> <span class="string">User</span> <span class="string">example</span> <span class="string">in</span> <span class="string">text</span> <span class="string">plain</span> <span class="string">format</span></span><br><span class="line">        <span class="attr">externalValue:</span> <span class="string">&#x27;http://foo.bar/examples/user-example.txt&#x27;</span></span><br><span class="line">  <span class="string">&#x27;*/*&#x27;</span><span class="string">:</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="comment"># context-type</span></span><br><span class="line">      <span class="attr">user:</span> </span><br><span class="line">        <span class="attr">summary:</span> <span class="string">User</span> <span class="string">example</span> <span class="string">in</span> <span class="string">other</span> <span class="string">format</span></span><br><span class="line">        <span class="attr">externalValue:</span> <span class="string">&#x27;http://foo.bar/examples/user-example.whatever&#x27;</span></span><br></pre></td></tr></table></figure>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        整合在一起
    </div>
    <div class='spoiler-content'>
        <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">/pets:</span>  <span class="string">/#</span> <span class="string">路径，如果需要</span> <span class="string">path</span> <span class="string">value</span> <span class="string">可以使用形如</span> <span class="string">/pets/&#123;petId&#125;</span></span><br><span class="line">  <span class="attr">get:</span>  <span class="string">/#</span> <span class="string">get</span> <span class="string">请求，同理还有</span> <span class="string">put，post，delete，options</span> <span class="string">等方法</span></span><br><span class="line">    <span class="attr">parameters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">token</span></span><br><span class="line">        <span class="attr">in:</span> <span class="string">header</span> <span class="comment">#这里是固定值</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">token</span> <span class="string">to</span> <span class="string">be</span> <span class="string">passed</span> <span class="string">as</span> <span class="string">a</span> <span class="string">header</span> <span class="comment">#描述信息</span></span><br><span class="line">        <span class="attr">required:</span> <span class="literal">true</span> <span class="comment"># 是否必需</span></span><br><span class="line">        <span class="attr">schema:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">array</span> <span class="comment">#类型</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">            <span class="attr">format:</span> <span class="string">int64</span></span><br><span class="line">     <span class="bullet">-</span>  <span class="attr">name:</span> <span class="string">username</span></span><br><span class="line">        <span class="attr">in:</span> <span class="string">path</span> <span class="comment">#这里是固定值</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">username</span> <span class="string">to</span> <span class="string">fetch</span></span><br><span class="line">        <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">schema:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">     <span class="bullet">-</span>  <span class="attr">name:</span> <span class="string">id</span></span><br><span class="line">        <span class="attr">in:</span> <span class="string">query</span> <span class="comment">#这里是固定值</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">ID</span> <span class="string">of</span> <span class="string">the</span> <span class="string">object</span> <span class="string">to</span> <span class="string">fetch</span></span><br><span class="line">        <span class="attr">required:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">schema:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">array</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">style:</span> <span class="string">form</span></span><br><span class="line">        <span class="attr">explode:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">requestBody:</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">user</span> <span class="string">to</span> <span class="string">add</span> <span class="string">to</span> <span class="string">the</span> <span class="string">system</span> <span class="comment"># 描述信息</span></span><br><span class="line">        <span class="attr">content:</span>  <span class="comment"># 定义请求体</span></span><br><span class="line">        <span class="attr">&#x27;application/json&#x27;:</span> <span class="comment"># context-type</span></span><br><span class="line">            <span class="attr">schema:</span> <span class="comment"># 请求的格式</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">&#x27;#/components/schemas/User&#x27;</span> <span class="comment"># 组件</span></span><br><span class="line">            <span class="attr">examples:</span> <span class="comment"># 例子</span></span><br><span class="line">            <span class="attr">user:</span></span><br><span class="line">                <span class="attr">summary:</span> <span class="string">User</span> <span class="string">Example</span></span><br><span class="line">                <span class="attr">externalValue:</span> <span class="string">&#x27;http://foo.bar/examples/user-example.json&#x27;</span></span><br><span class="line">        <span class="attr">&#x27;application/xml&#x27;:</span> <span class="comment"># context-type</span></span><br><span class="line">            <span class="attr">schema:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">&#x27;#/components/schemas/User&#x27;</span></span><br><span class="line">            <span class="attr">examples:</span></span><br><span class="line">            <span class="attr">user:</span></span><br><span class="line">                <span class="attr">summary:</span> <span class="string">User</span> <span class="string">Example</span> <span class="string">in</span> <span class="string">XML</span></span><br><span class="line">                <span class="attr">externalValue:</span> <span class="string">&#x27;http://foo.bar/examples/user-example.xml&#x27;</span></span><br><span class="line">        <span class="attr">&#x27;text/plain&#x27;:</span> <span class="comment"># context-type</span></span><br><span class="line">            <span class="attr">examples:</span></span><br><span class="line">            <span class="attr">user:</span></span><br><span class="line">                <span class="attr">summary:</span> <span class="string">User</span> <span class="string">example</span> <span class="string">in</span> <span class="string">text</span> <span class="string">plain</span> <span class="string">format</span></span><br><span class="line">                <span class="attr">externalValue:</span> <span class="string">&#x27;http://foo.bar/examples/user-example.txt&#x27;</span></span><br><span class="line">        <span class="string">&#x27;*/*&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">examples:</span> <span class="comment"># context-type</span></span><br><span class="line">            <span class="attr">user:</span> </span><br><span class="line">                <span class="attr">summary:</span> <span class="string">User</span> <span class="string">example</span> <span class="string">in</span> <span class="string">other</span> <span class="string">format</span></span><br><span class="line">                <span class="attr">externalValue:</span> <span class="string">&#x27;http://foo.bar/examples/user-example.whatever&#x27;</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">这是一段描述信息</span></span><br><span class="line">    <span class="attr">responses:</span>  <span class="comment"># 响应部分定义</span></span><br><span class="line">      <span class="attr">&#x27;200&#x27;:</span>  <span class="comment"># 200 的响应码</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">又是一段描述</span> </span><br><span class="line">        <span class="attr">content:</span> <span class="comment">#内容</span></span><br><span class="line">          <span class="attr">application/json:</span>  <span class="comment"># context-type</span></span><br><span class="line">            <span class="attr">schema:</span></span><br><span class="line">              <span class="attr">type:</span> <span class="string">array</span>  <span class="comment"># 类型</span></span><br><span class="line">              <span class="attr">items:</span>  <span class="comment"># array 所包含的 元素</span></span><br><span class="line">                <span class="string">$ref:</span> <span class="string">&#x27;#/components/schemas/pet&#x27;</span>  <span class="comment">#每个元素是一个组件，下文详细说明</span></span><br></pre></td></tr></table></figure>
    </div>
</div>
<p>直到这里，我们已经见过了  <code>Request部分 header,query,path,body</code> 如何组装。但是留在我们面前有一个小小的疑问，组件是什么？我们从下一章一窥究竟。</p>
<h6 id="Schema-定义"><a class="header-anchor" href="#Schema-定义">¶</a>Schema 定义</h6>
<p>我们知道我们的请求经常是特定的<code>Json</code>格式，这个 <code>Json</code> 会出现在我们的 <code>API</code> 定义的各个部分，<code>OPENAPI</code> 为了解决我们需要不断的重写相同的 <code>Json</code>定义，我们就有了<code>Schema</code>的概念(当然也包含Map定义等)。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">object</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">required:</span> <span class="comment"># 是否必需</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">name</span></span><br><span class="line"><span class="attr">properties:</span> <span class="comment"># 内部属性定义</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">address:</span></span><br><span class="line">    <span class="string">$ref:</span> <span class="string">&#x27;#/components/schemas/Address&#x27;</span></span><br><span class="line">  <span class="attr">age:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">int32</span></span><br><span class="line">    <span class="attr">minimum:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        整合在一起
    </div>
    <div class='spoiler-content'>
        <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">components:</span></span><br><span class="line">  <span class="attr">schemas:</span></span><br><span class="line">    <span class="attr">ErrorModel:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">object</span></span><br><span class="line">      <span class="attr">required:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">message</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">properties:</span></span><br><span class="line">        <span class="attr">message:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">code:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">          <span class="attr">minimum:</span> <span class="number">100</span></span><br><span class="line">          <span class="attr">maximum:</span> <span class="number">600</span></span><br><span class="line">    <span class="attr">ExtendedErrorModel:</span></span><br><span class="line">      <span class="attr">allOf:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$ref:</span> <span class="string">&#x27;#/components/schemas/ErrorModel&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">object</span></span><br><span class="line">        <span class="attr">required:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">rootCause</span></span><br><span class="line">        <span class="attr">properties:</span></span><br><span class="line">          <span class="attr">rootCause:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">string</span></span><br></pre></td></tr></table></figure>
    </div>
</div>
<h4 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h4>
<p>由于 <code>OpenApi</code> 的文档浩如烟海，这里就举了一个简单的例子，更多的时候还只能大家按图索骥的去查找自己想要的部分了。</p>
<h3 id="Swagger-插件"><a class="header-anchor" href="#Swagger-插件">¶</a>Swagger 插件</h3>
<p>最近的使用方式是使用 <code>Swagger 插件</code> 从代码直接生成，举个最为简单的例子，我们在 <code>SpringBoot</code> 项目中增加一个依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>并且在添加一个配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">api</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">          .select()</span><br><span class="line">          .apis(RequestHandlerSelectors.any())</span><br><span class="line">          .paths(PathSelectors.any())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候我们访问 <code>api-docs</code> 我们就可以获得文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8080/spring-security-rest/api/v2/api-docs</span><br><span class="line">&#123;</span><br><span class="line">    //略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当是我们有了文档，一点都不具有可读性。很高兴的官方也提供了 <code>UI</code>,继续添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个时候我们访问 <code>http://localhost:8080/your-app-root/swagger-ui.html</code> 我们就可以获得 页面了。<br>
<img src="https://s1.ax1x.com/2018/08/13/PgRkXn.png" alt="pic"></p>
<h2 id="生态工具"><a class="header-anchor" href="#生态工具">¶</a>生态工具</h2>
<ul>
<li><a href="https://swagger.io/tools/">SwaggerHub</a><br>
使用<code>OpenAPI</code>规范的设计和文档平台</li>
<li><a href="https://swagger.io/tools/swagger-inspector/">Swagger Inspector</a><br>
基于<code>OpenAPI</code>规范的测试平台</li>
<li><a href="https://swagger.io/tools/swagger-codegen/">swagger-codegen</a><br>
基于<code>OpenAPI</code>规范生成代码工具</li>
<li><a href="https://swagger.io/tools/swagger-editor/">swagger-editor</a><br>
<code>OpenAPI</code>的在线编辑器</li>
<li><a href="https://swagger.io/tools/swagger-ui/">swagger-ui</a><br>
<code>OpenAPI</code>的UI展示</li>
<li><a href="https://github.com/Rebilly/ReDoc">ReDoc</a><br>
更好看的<code>OpenAPI</code>的UI展示</li>
</ul>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ul>
<li><a href="https://www.baeldung.com/swagger-2-documentation-for-spring-rest-api">swagger-2-documentation-for-spring-rest-api</a></li>
<li><a href="https://swagger.io/specification/">specification</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>api</category>
        <category>swagger</category>
      </categories>
      <tags>
        <tag>doc</tag>
        <tag>swagger</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么JetBrains需要Kotlin [译]</title>
    <url>/2017/01/05/other/why-jetbrains-needs-kotlin/</url>
    <content><![CDATA[<p><a href="https://blog.jetbrains.com/kotlin/2011/08/why-jetbrains-needs-kotlin/">原文链接</a></p>
<p>当人们需要学习使用一门新的工作语言的时候，往往第一个问题就是为什么我们需要它。<br>
Kotlin的文档中详细的阐述了为何Kotlin会存在。尽管如此，我们仍想清晰的知道JetBrains希望从中得到什么。显然我们在其中投入了长期的经历，花费多年的时间希望达成我的期望。<br>
在此我将解释为何我们乐意投入。</p>
<span id="more"></span>
<p>第一并且最重要的原因是，这关乎到我们的生产力。尽管我们已经有了数个基于JVM的编程语言，可至今我们所有基于IntelliJ的IDEs都几乎全部还是使用Java来编写的。<br>
IntelliJ的构建系统基于Groovy 和 Gant，Groovy适用于一些测试代码，有些JRuby代码在RubyMine中，仅仅如此。但是我们想要通过切换一门编程语言从而获得更高的生产力。<br>
于此同时，有两件需求是我们必须要满足的，Java代码的兼容系（这个语言必须是渐进的，能够良好的Java代码兼容）和编译速度的提高（我们现在的代码已经非常的慢，不能给再慢了）。</p>
<p>第二点原因也非常的明确：我们期望Kotlin能够提高IntelliJ IDEA的销量，我们完全在一个新语言上工作，但是我们不准备把整个JVM的生态给替换掉，所以你可以继续使用Spring，Hibernate，或者其他的一切。<br>
如果你的项目使用Kotlin构建，Kotlin的开发工具免费，并且即将开源(译者注：此项目已经开源 <a href="https://github.com/JetBrains/kotlin">kotlin</a>)，剩下的对于企业级开发的部分，仍会<br>
保留在IntelliJ IDEA Ultimate版本中，而社区版本的IDE依然会支持与Kotlin的集成。</p>
<p>最后的原因比重较小，但是也是极为重要的：一个新的语言总是人们所热衷讨论的话题，在我们推出Kotlin的第一天就得到了证明。我们看见人们已经非常熟悉JetBrains并且相信我们可以将此项目做的越来越好，<br>
因此，我们相信这份用户对我们的信任与JetBrains的社区品牌意识，不仅仅可以驱动公司的业务，甚至与吸引更多的人加入我们的开发，让我们都享受开发的乐趣。</p>
<p>最重特别重申，我们对Kotlin的投入并不会影响任何关于我们去其他开发工具的开发，特别是Scala的插件，如果你已经选择Scala而不需要其他语言，我们仍会竭尽全力的为你提供一流的Scala开发工具。</p>
<p><strong>译者</strong> <a href="https://github.com/yannxia">yannxia</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>从 Marty Cagan 那获得启示</title>
    <url>/2020/02/29/pm/enlightenment-from-a-vedio/</url>
    <content><![CDATA[<p><img src="https://s2.ax1x.com/2020/02/29/3ySjTf.png" alt="3ySjTf.png"></p>
<p>周末的时候看了一篇好文 <a href="https://coffee.pmcaff.com/article/G2Qd2GR5kZ">做产品真的难于上天！</a> 从文后的链接听了一遍 Marty Cagan 的演讲，受益良多因此记录一下。</p>
<span id="more"></span>
<h1>frustration with Lean And Agile</h1>
<p>对于「精益」 (Lean) 和「敏捷」 (Agile) 方法的挫败感。从我的角度上也是对敏捷最终留下了一个站会的形式，从剥离的外在的敏捷看来只有2个核心点。</p>
<ul>
<li>
<p>「要频繁的发布」，频繁的意思是「至少每两周发布一次」。如果你每月或每季才发布一次，就算你自称敏捷，你其实没有获得任何敏捷的好处。好的产品团队甚至每天发布好几次，就是所谓的「持续交付」 (Continuous Delivery)。也不是说大家都要做持续交付，但若你不是每两周发布一次，这会是很大的问题。</p>
</li>
<li>
<p>「团队要被赋权且被问责」，被赋权的意思是「交由团队来找解决问题的最佳方法」。举例来说，不是由管理层告知团队「请串接日本当地LN 公司的行动支付」，而是告诉团队「我们眼前看到的问题，是太少日本当地人购买我们的产品，海外转换率实在太低了，请你们解决这个问题」。如果串接了日本当地LN 公司的行动支付，没有解决这个问题，团队就要继续探索其他方案。</p>
</li>
</ul>
<p>第一点毋庸置疑，从 <a href="https://wiki.mbalib.com/wiki/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91">Wiki-敏捷开发</a> 也可以轻易的发现，但是对于第二点是一个极为隐藏的问题，敏捷区别于其他方法的最为本质的区别是从<code>面向项目</code>的方式变化为<code>面向人</code>的方式。</p>
<p>从敏捷宣言中</p>
<blockquote>
<blockquote>
<p>个体和互动 高于 流程和工具<br>
工作的软件 高于 详尽的文档<br>
客户合作 高于 合同谈判<br>
响应变化 高于 遵循计划</p>
</blockquote>
</blockquote>
<p>我们也发现了，敏捷对于人的价值更为重视。而人的价值就伴随着权利与责任，很多团队被告知要更加敏捷，但其实管理层一直给团队「待完成的功能清单」（传统意义上的产品路线图Product Roadmap），每月或每季都跟团队说「请做这些功能」，这在任何意义上来说都不是敏捷。</p>
<hr>
<p>说完了敏捷，再看看《精益》</p>
<p>Lean 有五大原则</p>
<ol>
<li>Identify Value识别价值：从顾客的角度定义什么是价值（顾客愿意花钱的）</li>
<li>Identify ValueStream识别价值流：找到那些增值的步骤（往往一个公司只有5%）</li>
<li>Create Flow流动起来：让价值流动起来（通过消除浪费）</li>
<li>Respond toCustomer Pull根据顾客的需求时间、量来生产（拉动式生产）</li>
<li>Pursue Perfection不断完善以上过程（PDCA）</li>
</ol>
<p>而 <code>Marty</code> 的总结为</p>
<ul>
<li>
<p>「我们要快速学习才能创新」，创新源自于我们能够尝试多少点子，因为我们知道大部分的点子都行不通。（这里对应着是识别价值）</p>
</li>
<li>
<p>「我们得要消除浪费」，所谓的浪费就是花了4 个月才发现「这不是解决问题的好方法」，这就是浪费。在创业阶段我常看见的浪费就是「我们正在做一个MVP 」(Minimum Viable Product 最小可行性产品)。然后我就会问「太好了，那可以让我看看MVP 吗？」结果他们就说「正在做了，还要4 个月」。坦白说，这根本不是MVP，只是个半成品、是不成熟的产品。真正的MVP 只需要4 小时或4 天，不是4 个月。</p>
</li>
</ul>
<h1>不同周期的产品研发</h1>
<h2 id="探索阶段"><a class="header-anchor" href="#探索阶段">¶</a>探索阶段</h2>
<p>此阶段我们要搞清楚「探索该打造的产品」，我称之为「产品探索」(Product Discovery)。这个意思是要找到一个产品方案，符合以下四个条件：</p>
<ul>
<li>对用户有价值(valuable)：就是顾客会买单</li>
<li>易于使用(usable)：意思就是顾客能自己搞懂如何使用</li>
<li>可被打造(feasible)：是我们知道如何打造</li>
<li>商业上可行(viable)：有市场可行性，包括这个产品，包含宣传、销售、客服，也有收益</li>
</ul>
<p>在这个阶段，我们交付 「原型」 (prototypes)，而不是「产品」 (products)。</p>
<h2 id="产品交付阶段"><a class="header-anchor" href="#产品交付阶段">¶</a>产品交付阶段</h2>
<p>交付工程师有自信的产品，让我们可以真正开始运营这个产品。这个最终产品要符合的条件是：</p>
<ul>
<li>稳定(reliable)</li>
<li>可扩展(scalable)</li>
<li>高效能(performant)</li>
<li>可维护(maintainable)</li>
<li>支援多国语言且本地化(internationalized and localized)</li>
</ul>
<p><strong>作者注：</strong> 就我的经验看来，国内的研发经常会混合着这两种模式，同时需要满足以上两点的产品对于传统命令式的软件开发为主（其实也不存在探索阶段），对于创业公司，第一种情况是团队小心谨慎的闭门工作了4个月，发布产品后发现这是错误的产品。第二种情况是团队超级迅速的发布了好几次产品，其中有些成功了，但也创造了极大的技术成本，打造了难以维护、难以扩张、很低效能的产品，得再花4个月重构，令团队无法继续迅速发布。</p>
<p>探索阶段就是build the right thing，然后交付阶段是build the thing right。失败的软件总是有类似的状况,Marty Cagan在INSPIRED书中，介绍了产品失败的4大风险，分别是:</p>
<ol>
<li>实行性风险(Feasibility Risk)：团队明确需求，但手边并没有解决问题的技术，或技术尚未成熟，就是「我们知道要做什么产品，但是做不出来」的状况</li>
<li>易用性风险(Usability Risk)：顾客想用这个产品，但不知如何使用，或太少人克服使用门槛，就是「产品做出来了，但是好多顾客看不懂、不会用」的状况</li>
<li>价值风险(Value Risk)：这个产品并没有解决顾客需求，为顾客带来价值，就是「产品做出来了，某些顾客也会用了，但后来都不继续用，因为没有满足需求」的状况</li>
<li>商业可行性风险(Business Viability Risk)：这个产品对公司没有商业价值，或无法在市场竞争中存活，就是「产品做出来了，顾客也爱用，但是无法赚钱，或拿不到更多预算与资金，或无法赢过竞争者」的状况。</li>
</ol>
<h2 id="一些问题"><a class="header-anchor" href="#一些问题">¶</a>一些问题</h2>
<h3 id="怎样让老板们信任Product-Team"><a class="header-anchor" href="#怎样让老板们信任Product-Team">¶</a>怎样让老板们信任Product Team</h3>
<blockquote>
<blockquote>
<blockquote>
<p>我试着跟产品团队说，你们的工作不只是告诉大家「为何这些不可行」，你们的工作还必须告诉大家「这些构想更能解决问题、更有机会成功」。如果今天的课题是「国际交易支付量过低」，产品团队除了告诉大家「串接PayPal 不是个好方法」，还必须告诉大家「PayPal 以外还有哪些方法」可以解决问题，这才是优良产品团队和新手产品团队的差别。优良的产品团队知道，自己还必须提出可行的方案，而且这些方案要更有机会成功。</p>
</blockquote>
</blockquote>
</blockquote>
<p>产品不仅仅要告诉老板们，为何我们觉得这些不行，重要的是为了解决问题，我们还要一些其他办法。</p>
<blockquote>
<blockquote>
<blockquote>
<p>我们可以在很多公司，见证这种做法的影响力。因为，只要产品团队开始展现这些能力，高管们开始认定这些团队是「问题排除者」 (Problem Solver)，而不是「阻碍者」 (Blocker)。只会验证点子(validating ideas) 的团队是阻碍者，你可以在很多公司看到这样的症状。</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="满脑子只有单一方案？"><a class="header-anchor" href="#满脑子只有单一方案？">¶</a>满脑子只有单一方案？</h3>
<blockquote>
<blockquote>
<blockquote>
<p>很多团队接着采取的行动，就是继续制作原型(prototyping)、继续20、30、50 次迭代，直到他们用完所有的时间，或直到放弃。其实，你真正想要理解的是「总是有很多种解决问题的方法」，所以当你在做少量规划的时候，你要确保自己记得「这里有5种解决问题的方法」，至少要把这件事记在心上。我们认为其中一个方法最好，所以从这里开始，但如果我们没获得成果，我们就要尝试下一个。</p>
</blockquote>
</blockquote>
</blockquote>
<p>对于产品的解决之道可以有多种渠道，而对于软件的解决之道？倒是存疑。</p>
<h3 id="只有无尽的产品优化？"><a class="header-anchor" href="#只有无尽的产品优化？">¶</a>只有无尽的产品优化？</h3>
<blockquote>
<blockquote>
<blockquote>
<p>他们只在做这件事情。我可以告诉你，如果这是你唯一做的事情(指不断的优化产品)，你正在一个缓慢死亡的道路上，因为这只是「捕捉价值」 (value capture) 的行为，就像提高价格一样。这是件好事，没什么不对，但如果你只做这件事，你只是逐渐消耗价值而已。我们身为产品人的工作，是要创造更多价值，大余我们捕捉到的价值。产品探索(Product Discovery) 就为了「创造价值」 (value creation)，产品优化(Product Optimization) 只为了放大价值。</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="产品管理的核心能力"><a class="header-anchor" href="#产品管理的核心能力">¶</a>产品管理的核心能力</h3>
<ul>
<li>对用户和顾客的深入研究</li>
<li>对用户操作的深入研究</li>
<li>对生意/商业模式的深入研究</li>
<li>对产业的深入研究</li>
</ul>
<h1>终章</h1>
<p>这一篇讲产品为主，然后在我的观点中，我认为复合型的人才是未来的发展的主要方向，当程序员准备去生产产品的时候，我们也应该从产品的角度去了解这个产品为何是现在这番模样。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么开发者的文档总是无法让人满足</title>
    <url>/2020/01/06/pm/why-docs-make-me-fuzzy/</url>
    <content><![CDATA[<h2 id="知识的传递需要基础"><a class="header-anchor" href="#知识的传递需要基础">¶</a>知识的传递需要基础</h2>
<p><img src="https://s2.ax1x.com/2020/01/07/l6DySf.png" alt="l6DySf.png"><br>
在认知学里面有一个很著名的名字 <strong>知识的诅咒(Curse of knowledge)</strong></p>
<blockquote>
<p>知识的诅咒（Curse of knowledge）是一种认知偏差，形容专家常以术语交谈，但是丧失与非专业人士沟通的能力。 Robin Hogarth首先提出该名词 。知识的诅咒也是教育的重大阻碍之一。</p>
</blockquote>
<span id="more"></span>
<p>我更喜欢另外一种说法，当存在信息差的时候，知晓信息多的人是无法将信息完整的传递至其他人的。想想一下，你和你的朋友在玩你画我猜的时候的感觉，就是那种我明明已经画的这么清晰了，为什么你们还是看不出来的憋屈感。</p>
<p>在给同事写的文档中，也如果这般，往往你觉得你需要传递的一切信息都已经摆在那里了，为什么你还是看不懂，这背后的种种原因是因为你觉得看这篇文档的人知识储备是和你一样的，所以你写出的文档往往会成为以信息传递作为目标的通讯稿，就像是执行飞行任务的机长，向地面控制台传递着信息，但是这样的信息往往需要非常统一共识的基础。</p>
<p>举个例子：笔者最近所在阅读的(Envoy-Building)[<a href="https://www.envoyproxy.io/docs/envoy/latest/install/building">https://www.envoyproxy.io/docs/envoy/latest/install/building</a>]，这篇文档是在说明安装的过程，然而这背后的信息基础是</p>
<ul>
<li>Bazel：一个打包构建工具</li>
<li>Linux：熟练的Linux命令使用<br>
当你出现问题的时候，你更需要如何调试 C++ 的基础知识，而这些知识并非是一日之内可以掌握的，因此对于编写文档者，这些隐含的问题应该如何说明，说明到什么程度都是难以量化的。</li>
</ul>
<h2 id="开发缺乏编纂能力"><a class="header-anchor" href="#开发缺乏编纂能力">¶</a>开发缺乏编纂能力</h2>
<p><img src="https://s2.ax1x.com/2020/01/07/l6Ddwd.png" alt="l6Ddwd.png"></p>
<p>开发者所擅长的是写博文，针对某一个特定的问题进行分析，一份好的文档可能是不需要整理的，而一份完整的文档是需要分门别类的进行规整的，笔者所在的公司也算是一个在也业内非常爱写文档的公司了，我们的公司文档服务器已经进行过数次的升级了。</p>
<p>公司的文档更像是一个巨大的博客网站，开发者们已经被适应了写一些说明性或者原理性的文档，但是这些文档往往被散落在各处，依赖着不怎么靠谱的内置搜索引擎进行查到，这一切都是非常的痛苦的，且不问大部分的内容都是没有打Tag的，不同的产品之间往往有相似的概念，文档往往又是已项目组分类的，如果你希望找到一篇对于你现在的工作非常有意义的文档，大致上需要经过查询之后点开数个页面再去判断哪些才是你想要的，一点又不高效（但是总比没有的好），当老板在会议上和你要一个东西的说明的时候就发现这个的方式多么的愚蠢。</p>
<p>因此一个好的文档是需要有专业的编纂者的，用户手册部分显然是产品经理更为的适合，而在技术系列中，我认为最好以产品先一个独立的区域，尽可能的带上Tag的方式，零散的存放也可，不过需要注意的是文档一定要注明适用的版本号，当进行过一段时间的开发之后，对于一些明显 OutDate 的文档进行集中的归档。</p>
<h2 id="文档本身也是一种误解"><a class="header-anchor" href="#文档本身也是一种误解">¶</a>文档本身也是一种误解</h2>
<p><img src="https://s2.ax1x.com/2020/01/07/l6s95n.png" alt="l6s95n.png"></p>
<p>最后也就是一种特别需要小心的现状了，部分开发者希望碎碎叨叨的来描述一些问题，尤其是在一些复杂的问题上，举一个例子：在讲操作系统的时候，我们会涉及到虚拟内存和物理内存的映射，有一些开发者不知道从哪里看来了一个新的名词 <strong>线性内存</strong>，然后高声阔斧的讲了一大通，然后读者冥思苦想还是不买明白，最终才明白，原来这里说的就是虚拟内存，只不过对于应用来说看起来是一个线性从0增长的概念，对于企业的内部的文档也是如此，尤其在一些老旧的系统中有一些艰深晦涩的概念，这些概念在最初的开发者手中进行了解释，可能解释的并不到位，后续又有千千万万的开发者为此段解释加注解，最终导致内容偏颇，在此笔者还是告诫诸位开发者假如不是很懂的概念的话，切不可望文生义，更不要留下什么著作，在搜索引擎的帮助下，怕不是会带歪诸多人。</p>
<h2 id="尾声"><a class="header-anchor" href="#尾声">¶</a>尾声</h2>
<p>笔者强烈建议将文档要区分为内部文档和外部可见的文档，对于外部可见的文档通过文档审核委员会的同意进行发布，而内部文档建议仅对熟悉项目或相关的人进行开发，也尽可能的避免不相干人的二次创作。内部文档可以简化格式，最为重要的还是内容的时效性和准确性。</p>
<blockquote>
<p>愿大家在新的一年里都可以写出好的文档。</p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Rank N Types</title>
    <url>/2021/02/09/proggramming/Rank-N-Types/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210209163003.png" alt=""></p>
<p>前几日在和朋友讨论一个 <code>Rust</code> 的编程问题。</p>
<span id="more"></span>
<figure class="highlight rust"><figcaption><span>https://play.rust-lang.org/?version</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sort</span>&lt;T: <span class="built_in">Ord</span>&gt;(arr: &amp;<span class="keyword">mut</span> [T]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sort2</span>&lt;T: <span class="built_in">Ord</span>&gt;(arr: &amp;<span class="keyword">mut</span> [T]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">functions</span>&lt;T: <span class="built_in">Ord</span>&gt;() <span class="punctuation">-&gt;</span> HashMap&lt;<span class="type">String</span>, <span class="title function_ invoke__">fn</span>(&amp;<span class="keyword">mut</span> [T])&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sorts</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// not working</span></span><br><span class="line">        sorts.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;sort&quot;</span>.<span class="title function_ invoke__">to_string</span>(), sort);</span><br><span class="line">        sorts.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;insert&quot;</span>.<span class="title function_ invoke__">to_string</span>(), sort2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// it&#x27;s working </span></span><br><span class="line">        <span class="comment">// sorts.insert(&quot;sort&quot;.to_string(), sort as fn(&amp;mut [T]));</span></span><br><span class="line">        <span class="comment">// sorts.insert(&quot;insert&quot;.to_string(), sort2 as fn(&amp;mut [T]) );</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sorts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刚好遇见之前在 <code>Java</code> 不会遇见的 <code>Rank N Types</code> 问题，我们来掰扯一下。</p>
<h2 id="泛型函数"><a class="header-anchor" href="#泛型函数">¶</a>泛型函数</h2>
<p>我们声明一个 <code>chooseString</code> 函数，我们可以很简单的随机获得一个 <code>String</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">chooseString</span><span class="params">(String head, String tail)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为不够通用，我们将其改为泛型函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">chooseValue</span><span class="params">(T head, T tail)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译完成之后，函数签名会变成 <code>com.example.demo.Function.chooseValue(Object, Object) : Object</code> 我们此时的 <code>T</code> 类型早已被擦拭。在 <code>Java</code> 中函数还不是一等公民尚且没有更多的问题，我们来用 <code>Rust</code> 模拟下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">func</span> = chooseValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">chooseValue</span>&lt;T&gt;(one: T, two: T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">return</span> one</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将 <code>chooseValue</code> 作为一个变量 <code>func</code>，此时编译器会报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--&gt; src/main.rs:2:24</span><br><span class="line">  |</span><br><span class="line">2 |     <span class="built_in">let</span> mut func = chooseValue;</span><br><span class="line">  |         ------------   ^^^^^^^^^^^ cannot infer <span class="built_in">type</span> <span class="keyword">for</span> <span class="built_in">type</span> parameter `T` declared on the func `chooseValue`</span><br><span class="line">  |         |</span><br><span class="line">  |         consider giving `func` the explicit <span class="built_in">type</span> `fn(T, T) -&gt; T`, <span class="built_in">where</span> the <span class="built_in">type</span> parameter `T` is specified</span><br></pre></td></tr></table></figure>
<p>因为对于类型语言来说，我们此时不知道这个函数的入参类型 (<code>one</code> <code>two</code>)，因此我们也不知道这个函数的真正的类型。由于 <code>Rust</code> 是一个静态的强类型语言<br>
因此对于编译时期我们就需要获得这个类型，我们只能这样去操作。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">func</span> = chooseValue::&lt;<span class="type">String</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">chooseValue</span>&lt;T&gt;(one: T, two: T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">return</span> one</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Higher-rank-types"><a class="header-anchor" href="#Higher-rank-types">¶</a>Higher-rank types</h2>
<p><code>Higher-rank types</code> 的目标就是让多态函数也可以变成一等公民。</p>
<h3 id="Rank-1-polymorphism"><a class="header-anchor" href="#Rank-1-polymorphism">¶</a>Rank-1 polymorphism</h3>
<p>我们申明一个函数 <code>length</code></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">length</span> :: [a] -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure>
<p>将 <code>a</code> 原样返回，这个 <code>a</code> 也是一个类型，不过可以代指所有的类型。<br>
因此我们可以在这里返回任意数组的长度。这其实是</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">length</span> :: <span class="keyword">forall</span> a. [a] -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure>
<p>的一种隐性声明。</p>
<h3 id="Rank-2-polymorphism"><a class="header-anchor" href="#Rank-2-polymorphism">¶</a>Rank-2 polymorphism</h3>
<p>我们继续声明函数在 <code>Haskell98</code> 中</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">bar</span> :: (a -&gt; a) -&gt; (<span class="type">Char</span>, <span class="type">Bool</span>) # 等价于 bar :: <span class="keyword">forall</span> a. ((a -&gt; a) -&gt; (<span class="type">Char</span>, <span class="type">Bool</span>))</span><br><span class="line"><span class="title">bar</span> f = (f &#x27;c&#x27;, f <span class="type">True</span>)</span><br></pre></td></tr></table></figure>
<p>此时的声明式会编译错误，因为 <code>f</code> 的类型是多态的，可以接受 <code>Char</code> 也可以接受 <code>Bool</code> 并不满足 (forall a. a -&gt; a) 的要求<br>
而正确的处理姿势是</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foo</span> :: (<span class="keyword">forall</span> a. a -&gt; a) -&gt; (<span class="type">Char</span>,<span class="type">Bool</span>)</span><br><span class="line"><span class="title">foo</span> f = (f &#x27;c&#x27;, f <span class="type">True</span>)</span><br></pre></td></tr></table></figure>
<p>我们把这里的 <code>bar</code> 称之为 <code>rank-1 type</code>，<code>foo</code> 称为 <code>rank-2 type</code>，那么就好理解对于 <code>rank-N type</code>了，可以支持任意类型的即可。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://www.stephanboyer.com/post/115/higher-rank-and-higher-kinded-types">Higher-rank and higher-kinded types</a></li>
<li><a href="https://ocharles.org.uk/guest-posts/2014-12-18-rank-n-types.html">24 Days of GHC Extensions: Rank N Types</a></li>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Polymorphism">Haskell/Polymorphism</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>proggramming</category>
      </categories>
      <tags>
        <tag>proggramming</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年第4周推荐阅读</title>
    <url>/2019/01/28/recommend/2019-week-4-recommend/</url>
    <content><![CDATA[<ol>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/49947103">MySQL索引及其实现原理(基于MyISAM及InnoDB引擎)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/zhongwencool/p/timing_wheel.html">惊艳的时间轮定时器</a></p>
</li>
<li>
<p><a href="http://www.chanpin100.com/article/107449">教你建立后台通用权限管理系统</a></p>
</li>
</ol>
<hr>
<h2 id="Github项目"><a class="header-anchor" href="#Github项目">¶</a>Github项目</h2>
<ol>
<li><a href="https://github.com/Microsoft/monaco-editor">巨硬VS Code内置编辑器</a></li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>2019年第5周推荐阅读</title>
    <url>/2019/01/28/recommend/2019-week-5-recommend/</url>
    <content><![CDATA[<h2 id="好文共享"><a class="header-anchor" href="#好文共享">¶</a>好文共享</h2>
<ol>
<li><a href="https://linux.cn/article-10469-1.html?utm_source=rss&amp;utm_medium=rss">你（多半）不需要 Kubernetes</a><br>
Kubernetes 的调试难度应该和抓包是一个级别上的。</li>
<li><a href="https://bh.sb/post/41949/">德国工人为什么愿意干到退休？因为他们站着把钱挣了</a><br>
今年我对Team的目标也是能够站在把钱给赚了，这个才是让员工觉得舒服的方式</li>
</ol>
<h2 id="好书推荐"><a class="header-anchor" href="#好书推荐">¶</a>好书推荐</h2>
<ol>
<li><a href="https://book.douban.com/subject/30128204/">莫斯科绅士</a><br>
往往最不自由的人却拥有最为自由的灵魂。</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>我的推荐书单 [草稿]</title>
    <url>/2018/04/21/recommend/what-is-my-recommend-books/</url>
    <content><![CDATA[<p>每次公司有新同事，总是会问应该学点什么，每次都回答一遍才挺费力的，索性找个时间把之前看过的东西都好好的整理一下，也权当是回归。</p>
<span id="more"></span>
<h2 id="职业相关"><a class="header-anchor" href="#职业相关">¶</a>职业相关</h2>
<blockquote>
<p>因为笔者只是一个Java程序员，可能涉及只有Java相关的</p>
</blockquote>
<ul>
<li>
<p><a href="">* In Action</a><br>
所有的 inAction 系列都不是很糟糕，刚刚好满足工作的第一步，从0到1的步骤，如果想要深入的话，那这些书可能就不适合你了。</p>
</li>
<li>
<p><a href="https://read.douban.com/ebook/15233695/">深入理解Java虚拟机：JVM高级特性与最佳实践</a><br>
对JVM讲的通俗易懂的也就这一本了，国人的经典之作。</p>
</li>
<li>
<p><a href="https://book.douban.com/subject/10746113/">HTTP权威指南</a><br>
HTTP 当然懂一点总是有用的，毕竟是网络的时代了，配了很多图，讲的很清楚。</p>
</li>
<li>
<p><a href="https://book.douban.com/subject/1951158/">代码大全</a><br>
我并非是代码大全的推荐者，这本书更像一本字典，可以先看一眼目录找到自己需要的部分，下次用到的时候再去看，实际上我虽然读完了，我对这本书也没什么印象了。</p>
</li>
</ul>
<h2 id="生涯相关"><a class="header-anchor" href="#生涯相关">¶</a>生涯相关</h2>
<ul>
<li>
<p><a href="https://book.douban.com/subject/1896753/">深入理解计算机系统</a><br>
可能大家都听说过这本书，这本书最大的优点是帮助你去打好程序基础，比如说编码是什么，CPU又是做什么的，这本书应该是每个程序员在自己的职业生涯中最应该读的书，最好也把课后习题做一遍。</p>
</li>
<li>
<p><a href="https://book.douban.com/subject/3227098/">编程珠玑</a><br>
很少有书会给你讲算法的思路，这本书就恰到好处。</p>
</li>
<li>
<p><a href="https://book.douban.com/subject/19952400/">算法（第4版</a><br>
这本书最为实用，算导有时候读起来和数学书一样，而算法更多的从程序员的角度去看待算法本身。而且里面的代码是真的有实现，而且在公网上可以参考。</p>
</li>
<li>
<p><a href="https://book.douban.com/subject/1139336/">C语言程序设计 K&amp;R</a><br>
不仅仅是一本讲C语言的书，更告诉我们什么书才是好书，没有很多外文书的废话，课后习题都算是经典。当然人人都需要一点C语言。</p>
<ul>
<li><a href="https://book.douban.com/subject/3012360/">C和指针</a></li>
<li><a href="">C专家编程</a><br>
我觉得上面2本书有时间可以翻看下，从中学的东西并不是很多。</li>
<li><a href="https://book.douban.com/subject/2778632/">C陷阱与缺陷 : C语言调试指南</a><br>
避雷手册。</li>
</ul>
</li>
<li>
<p><a href="https://book.douban.com/subject/4262627/">重构</a><br>
值得翻来覆去阅读的一本书，不过重构本身很需要实践的精神，建议在CodeReview之后再按图索骥。</p>
</li>
<li>
<p><a href="https://book.douban.com/subject/2230248/">人月神话</a><br>
项目经理眼中的软件开发不是0和1的问题，更是一个工程的问题，一旦到了团队超过5个人，我觉得这本书的意义就不言而喻。</p>
</li>
<li>
<p><a href="https://book.douban.com/subject/1052241/">设计模式</a><br>
和重构一样，如果你会不断的锤炼自己的代码，你就会发现原来前人们已经提出了这么好的解决问题的思路。</p>
</li>
</ul>
<h2 id="杂项"><a class="header-anchor" href="#杂项">¶</a>杂项</h2>
<ul>
<li>
<p><a href="https://book.douban.com/subject/6860890/">黑客</a><br>
从这本书中的人物身上，我们可以看见计算机的最初是由怎么样的一拨人开天辟地的，虽然那段历史已经远去，读起来的时候依然能够感觉到那些前辈们的高光时刻，简直是自带BGM的一本书。</p>
</li>
<li>
<p><a href="https://book.douban.com/subject/3224524/">代码之美</a><br>
发现程序之美。</p>
</li>
</ul>
<h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2>
<ul>
<li>
<p><a href="https://book.douban.com/subject/4822685/">编码</a><br>
如果你有一个女朋友，可以作为她的睡前故事。</p>
</li>
<li>
<p><a href="https://book.douban.com/subject/3852290/">现代操作系统（第3版</a><br>
不是很喜欢这本书，感觉站在了一个很高的角度去看问题，可能我先看了CSAPP，之后读这本书不是很有感触。</p>
<ul>
<li><a href="https://book.douban.com/subject/1422377/">自己动手写操作系统</a><br>
蛮不错的一本书，很适合自己撸，不过我不建议在Boot那部分消磨太久，因为真的会卡主过不去。</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>书单</category>
        <category>草稿</category>
      </categories>
  </entry>
  <entry>
    <title>死亡行军与自我革命</title>
    <url>/2020/03/31/rethink/another-hard-way-to-die/</url>
    <content><![CDATA[<p>在二战时期，除了直接杀死的方式之外还要一个处理战俘的办法，强迫行军，旨在令他们死在途中，这种方式就是<strong>死亡行军</strong>。在软件工程领域可能不是因为主观上希望整个团队崩溃，但是却在一个又一个的失败之中导致研发团队死亡也被称作为一种死亡行军。而笔者恰好在 2017年底开始经历过这样完整的一个项目，刚好可以聊一聊。</p>
<span id="more"></span>
<h1>虽有雄心，无力实现</h1>
<p>笔者所参与的项目，大致上是一个可交互的服务管理系统，其实比较像 vmware 的一个软件，我们管理的对象是应用本身，但是在设计的过程中，我们不仅仅在技术层面上有所创新，更加在业务层面上也有限制，这时候反而带来了一个很复杂的问题。<code>技术工具</code> 与 <code>业务工具</code> 本质上是有很强的矛盾点的。<code>技术工具</code>的目标是帮助开发者，运维等方便快捷的完成任务，侧重在自由灵活的实现某种能力：比如Jenkins，K8s此类的工具，而 <code>业务工具</code> 是为管理者管理所使用的，更多的是严格的规范管理。举一个这两者交界比较多的软件而言，比如数据分析工具BI等，工具本身提供的是对于多数据源的支持，可视化的支持，这些是开发者所需要的，管理者需要的是开发者最终产生的报表内容，因此我们最终只能选择满足一个客户（当然也可以产生多个产品满足不一样的客户）。因为这样的背景，我们在后续的工作中却发现，我们不仅仅针对管理者的功能没做好（因为企业的管理维度是千变万化的，而所开发的产品只能满足一部分的需求），对于开发者部分的功能也没有做好（因为包含的业务属性，在灵活性方面不得不去做一个妥协）</p>
<p><img src="https://s1.ax1x.com/2020/03/31/GMeNLQ.png" alt="GMeNLQ.png"><br>
如图所示，你最终的落脚处一定是: Win-win / Lose-lose 绝非有第三种的可能。</p>
<h1>To be or not to be</h1>
<p>生活总是充满了苦难，并非我们需要苦难帮助我们成长，只是生活缺少不了苦难。做了一段时间的产品之后，我们也渐渐的发现，整个DMP的产品体系内有一部分的<strong>组件</strong>是价值较低，但是依然需要有人投入精力进行维护的。我认为这一部分的组件，我认为是低价值的，比如<strong>配置中心</strong>，用户中心，增强的Eureka等，这些组件依然存在着或多或少的问题，我们无法抛弃他们（还是我们舍不得抛弃它们），梭罗如言：牧羊人继承了羊栏的代价是他的自由。我们也为了这些组件从一个灵动飘逸的团队慢慢的变的沉重和笨拙。</p>
<blockquote>
<p>无产者在这个革命中失去的只是锁链。他们获得的将是整个世界。</p>
</blockquote>
<p>我们也到了为自己革命的时刻，放弃幻想从新起航。扔掉那些低价值意义不明的组件，深耕于高价值有意义的组件，吾辈亦继承DMP之名，简装上阵。</p>
<h1>Make customers succes</h1>
<p>如何定义成功，从一个ToB企业的角度，我们的成功显然是建立在成功的帮助客户，亦证：让客户成功是让我们成功的途径。而让客户成功的最重要的因素是找到客户需求，并且帮他满足他的需求，这里面困难之处不能一一道明，不仅仅有客户不知道自己的需求，需求怎么样才算是满足，还有就是如何满足客户的需求。</p>
<h2 id="产品-or-方案"><a class="header-anchor" href="#产品-or-方案">¶</a>产品 or 方案</h2>
<p>从旧日的经验看来，强推一个通用的产品是可以满足客户的80%的需求，但是这剩下来的20%，我们却不得不花整个项目过半的时间去满足，从客户的角度也会反馈为响应时间过长，而选择一个恰当的开源产品，满足客户的50%的需求，这剩下来的50%的需求可能会花更少的时间来迎合此类客户特定的场景，因此在真正的去客户进行交付的时候，我们的选择不是单一的，如何保质保量的交付才是我们需要考虑的。因此交付的是我们的产品？还是我们的方案？我认为都是可以的。</p>
<h2 id="ToB-即服务"><a class="header-anchor" href="#ToB-即服务">¶</a>ToB 即服务</h2>
<p>toB 的主战场并非是产品本身如何，而且围绕着产品的交付过程和最终的运维阶段如何保证客户的业务连续性。交付Jenkins亦或者DCS这并非是问题的关键，此两者皆为工作，在充分的考虑之下，我们选择一个更容易交付工具，而客户所期待的并非是我们交付的工具，此基于工具我们究竟可以完成多么完美流程的CICD过程，而我们研发产品的初心不也是因为拓展开源产品所不足，而在此之前，我们应该多加反思，这个项目真的需要使用我们自研的产品吗？</p>
<h1>Do not follow your passion</h1>
<p>Ben Horowitz 在哥伦比亚大学2015届毕业典礼上的演讲：在你热爱的和你擅长的中，你应该选择哪一个呢？<a href="https://a16z.com/2015/05/28/some-career-advice-for-all-you-recent-graduates/">原文链接</a> 且不论其他的同事做的怎么样，对于我来说 <strong>kubernetes</strong> 在很长的一段时间内都是我的噩梦（至今我的github的status依然是：🖕Fucking Kubernetes），并非是 k8s 做的不够好，而是我并不擅长于此，而在这之中摸爬滚打就变成了在焦油坑中煎熬。</p>
<h2 id="在自己擅长的地方深耕"><a class="header-anchor" href="#在自己擅长的地方深耕">¶</a>在自己擅长的地方深耕</h2>
<p>在网关做到2.x版本的时候，我和何晶都有一段时间不知道给网关增加什么新功能，在之后我们可能选择增加一些额外的功能（当然最终并非是我们在构建），现在回想起来，我觉得这并不是一个好的方式，我们试图在培养同事在不同的技术栈上，比如Skywalking，对于他来说围绕着SW的APM可以做非常多的事情，此时让他再去深入理解k8s，显然是不合适的。围绕着API我们依然可以做很多有趣的尝试，因此让擅长的同事做擅长的事情，这是很重要的一件事情。</p>
<p>因此我们今年也有了 <a href="https://dwiki.daocloud.io/pages/viewpage.action?pageId=60898721">女娲计划</a> ，并且相较于从前，我们不再是以产品作为唯一的方向，以领域作为方向，这一领域内的知识与工具皆可为我所用。</p>
<h2 id="善假于物也"><a class="header-anchor" href="#善假于物也">¶</a>善假于物也</h2>
<p>但是我们总归是有不擅长的领域，而又不得不去做的，我认为此时寻求下外援也不是什么错误，比如K8S可以咨询Kay的团队，倘若真是有所不得，那从外部借助一些力量也是可以的。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rethink</category>
      </categories>
  </entry>
  <entry>
    <title>给客户提供的服务</title>
    <url>/2020/05/08/rethink/different-way-for-cosumer/</url>
    <content><![CDATA[<p>自古甲方是大爷，甲方选乙方如同青楼点小姐，甲方亦然自己的口味也要看小姐能提供什么类型，好御姐这口就不能找一个萝莉妹子陪。那就聊聊这几年看过的客户所需要的服务：</p>
<span id="more"></span>
<h1>万事俱备就差程序员系列</h1>
<p>一般这么说的客户，可能就是差点干活的，也就是当个乙方人力外包的命，这种服务最累又赚不到什么钱，流水的程序员铁打的甲方，固定的预算，一般也就是干着最脏最累的活。</p>
<h1>我有一个想做的东西</h1>
<p>这种客户是最多的，甲方内部立项某一个前沿性的项目【ServiceMesh】之类的，客户大概知道这玩意能做啥，但是并没有想好项目的形态，此类项目普遍存在着一种状况 <strong>期望过大，而预算过低</strong>，因为这些年的程序员的人力成本增长，一个前沿性的项目可能投入100W并不能得到什么回报，因此对于这样的项目，控制住客户的期望，和降低自己的成本是项目的重中之重。</p>
<h2 id="降低期望"><a class="header-anchor" href="#降低期望">¶</a>降低期望</h2>
<p>如果此类项目/产品 在市面上未有什么开源产品或者是商业产品，此时还是比较好控制用户的欲望的，然而如果市场上已经有同类产品，那就很容易变成如下情况 <code>100W的预算帮我做一个[网易轻舟](https://www.163yun.com/product-nsf)</code>，客户常常觉得吧，不就是把开源的产品这样再这样，然后这样揉在一起就可以了？</p>
<h2 id="降低成本"><a class="header-anchor" href="#降低成本">¶</a>降低成本</h2>
<p>在施工的时候，传统的构建方式是在现场构建，但是有一种比较降低成本的方式：<a href="https://zhuanlan.zhihu.com/p/64324537">装配式建筑PC构件</a> 对于软件实施的过程中我们也可以参考这样的模式，将大部分的重叠功能作为预制件交付出去。在这种的情况下，我们可以在内部培养较为高级且专精的研发团队，可以攻坚复杂的部分。</p>
<blockquote>
<p>其实和传统的企业，需要中间件部门一样，对于大部分业务研发部门不可能做到对于中间件熟悉，因此需要独立的团队进行研发与维护。</p>
</blockquote>
<p>但是对于降低成本更重要的是市场的规模化，因此在这个产品开始孵化之前就需要做一次<code>项目尸检</code>，这个项目真的可以规模化吗？</p>
<h1>依赖性质</h1>
<p>还有一种就是，客户因为研发力量薄弱，对于乙方特别看中的类型，甚至于把乙方当做一个亲儿子看待，这种客户可遇而不可求。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rethink</category>
      </categories>
  </entry>
  <entry>
    <title>警惕从开发转变为运维</title>
    <url>/2020/07/03/rethink/do-be-a-ops-from-a-developer/</url>
    <content><![CDATA[<p>在这有限的三年工作中，我们尝试着从传统的开发|运维分离的体系转换为 <code>Devops</code> 的体系，收益很多：有且不限于</p>
<ul>
<li>如何编写更易于部署的代码</li>
<li>了解K8S这样的运行支撑层的工作原理</li>
<li>促进团队的产能</li>
</ul>
<p>但是在这过程之中我们也发现了很糟糕之处，今天就这些糟糕的情况讲一讲。</p>
<span id="more"></span>
<h1>作为 Ops 的 Dev</h1>
<p>大概没有比现在做开发更糟糕的事情了，开发者的心情大致上是这么波动的</p>
<p><code>好爽，这么可以玩的</code> -&gt; <code>好烦，为什么做这么多</code> -&gt; <code>老子再也不碰了</code></p>
<h2 id="阶段1：-看上去美好的初次接触"><a class="header-anchor" href="#阶段1：-看上去美好的初次接触">¶</a>阶段1： 看上去美好的初次接触</h2>
<p>糟糕的交付速度，老旧的运维技术，大概就是开发者对于运维的刻板印象，因此在 <code>Devops</code> 的初期阶段，开发者托管了这一切时候，世界真是美好，我们上了最新的 <code>CICD</code> 工具，我们用上了最酷炫的 <code>Dashboard</code>，我们还有最潮的在线 <code>Profiler</code>，新世界正在冉冉升起。</p>
<p><a href="https://imgchr.com/i/NXyj1O"><img src="https://s1.ax1x.com/2020/07/03/NXyj1O.md.png" alt="NXyj1O.md.png"></a></p>
<h2 id="阶段2：-糟心的运维阶段"><a class="header-anchor" href="#阶段2：-糟心的运维阶段">¶</a>阶段2： 糟心的运维阶段</h2>
<p>当迈过了内部的测试阶段，开始了正式的运维阶段，Dev 开始明白起来所谓的 <code>自愈平台</code> <code>HA</code> 都不是完全的自动化，经常需要人员的介入，也就是传统运维经常做的事情，一般这个时候我们不得不一边进行运维，一边进行新业务的开发，如果拖着重重的行李。</p>
<p>正如在 <a href="https://www.reddit.com/r/devops/comments/5z93al/what_is_shitty_about_devops/">What is shitty about DevOps?</a> 中吐槽的一样</p>
<blockquote>
<p>What I don’t love:<br>
I’m on a dev team as the only ops guy: 我变成开发团队内的唯一的运维BOY<br>
Management layout is so awkward. I report to a dev guy, take orders from an infrastructure guy： 管理模式如此的糟糕，我向一个开发主管索取运维资源<br>
lots of hours： 失去了大量的时间<br>
Some days I just want to drink： 有些日子我只想灌醉自己</p>
</blockquote>
<p>更多的例子可以阅读 (参考2: #What is shitty about DevOps?)</p>
<p><a href="https://imgchr.com/i/NXIYJH"><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_a8176e393e45b0325ddbeae737066a43.png" alt="NXIYJH.md.png"></a></p>
<h2 id="阶段3：-痛苦的挣扎"><a class="header-anchor" href="#阶段3：-痛苦的挣扎">¶</a>阶段3： 痛苦的挣扎</h2>
<p>此时的研发新的任务已经下放，在一边开发新功能，一边对已有功能进行维护，研发任务变成了运维的消遣。</p>
<h1>作为 Dev 的 Ops</h1>
<p>这倒是一个蛮不错的趋势，对于一些比较新潮的运维工程师来说，<code>Shell</code> 早就不能满足他们对于运维工具/语言的需求了，在早期已经使用 <code>Python</code> 来替代 <code>Bash</code> 来进行运维脚本的开发。直到 <code>Cloud Native</code> 时期，出现的 <code>Go</code> 就比Python更适合作为运维的工具，因此在此时期，我们也诞生了比如 <code>Google SRE</code> 这样的新型职位。</p>
<h1>国内的 Devops 现状</h1>
<p>不可置否的说，国内的 <code>DevOps</code> 现状和 <code>DevOps</code> 初衷是相悖的。<code>DevOps</code>的初衷是打破团队的隔阂，提高流程速度，而在国内这一切都被减本增效所掩盖，<code>DevOps</code>只是一个披着技术实则是管理手段。<code>DevOps</code> 工程师是一个人打两份工而拿1.5份工资的可怜角色。</p>
<p>在百度中搜索 <a href="https://www.baidu.com/s?wd=devops&amp;rsv_spt=1&amp;rsv_iqid=0xd71be3e800153838&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=1&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=239&amp;rsv_sug4=239">devops</a> 在可怜的前几页都发现不了任何关于 <code>DevOps</code> 的缺点，世间难道会有如此优秀的理论吗？真是值得怀疑。</p>
<p>总而言之，我也更赞成 <code>Devops</code> 是一种文化而绝非是工作的定义，<code>Devops</code> 的目标是将原本的 <code>研发/运维/运营</code> 体系打通换成一个环路，而这中并非只有一种角色，我们更应该让团队进行良好的融合，而绝非让某一类角色替代某一类。</p>
<h1>参考</h1>
<ul>
<li><a href="https://www.infoq.cn/article/6*BhOVwJrL1utl1wX90i">DevOps 日常：别人家的运维这样过</a></li>
<li><a href="https://www.reddit.com/r/devops/comments/5z93al/what_is_shitty_about_devops/">What is shitty about DevOps?</a></li>
<li><a href="https://lionfacelemonface.wordpress.com/2015/03/08/devops-is-bullshit-why-one-programmer-doesnt-do-it-anymore/">DevOps Is Bullshit: Why One Programmer Doesn’t Do It</a></li>
<li><a href="http://devana.rs/blog/devops-is-a-culture-not-a-job-description/">DevOps is a culture, not a job description</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rethink</category>
      </categories>
  </entry>
  <entry>
    <title>基于开源构建自己的产品</title>
    <url>/2019/12/30/rethink/how-build-product-on-opensource/</url>
    <content><![CDATA[<p>从 <code>2017.12</code> 开始，我们就一直在基于 <code>SpringCloud</code>(下称SC) 这套产品在构建我们自己的商业产品，说不起有一些成功，但却有一些反思。</p>
<span id="more"></span>
<h2 id="如何基于开源做产品"><a class="header-anchor" href="#如何基于开源做产品">¶</a>如何基于开源做产品</h2>
<p>如何基于开源做产品，让我们聊一聊这个话题。在大部分的中小型公司，我们都会基于某一个开源产品进行二次开发，直到最后这个开源产品被吸收殆尽，融入我们的产品，但这是一个漫长的过程。</p>
<h3 id="找到方向"><a class="header-anchor" href="#找到方向">¶</a>找到方向</h3>
<p>无论你怎么在技术市场中嗅探到一股新技术的清香味，比如 <code>Docker</code>或<code>SpringCloud</code>，我们最应该了解的都是这个技术背后是怎么样的需求在推进它前进。</p>
<ul>
<li><code>Hadoop</code> 的背后是企业对于海量数据需要存储的需求，更深层的是企业的IT从功能化向数据化转型。</li>
<li><code>Docker</code> 的背后是大规模虚拟机集群管理的困难，更深层是企业的IT的规模化，不再是以前几台机器跑天下的时代。</li>
<li><code>SpringCloud</code> 的背后是企业应用巨型化，迭代困难导致。</li>
</ul>
<p>而这些技术的背后的内驱力，我们的方向，那我们找的方向显然应该是</p>
<ul>
<li><code>以海量数据为方向</code>：为企业提供可以简单运维的集群，更大的存储量，更快的查询速度……</li>
<li><code>以海量机器为方向</code>：为企业提供不可变基础设施，完善的监控体系，简化的部署……</li>
<li><code>以巨大应用为方向</code>：为企业提供敏捷开发，应用的拆分化方案，基础设施的模式化……</li>
</ul>
<h3 id="划定自己的范围"><a class="header-anchor" href="#划定自己的范围">¶</a>划定自己的范围</h3>
<p>上述说的每一块都是巨大的市场，如若非巨头实难将这一切都啃下来，因此我们下一步是划定自己的范围。假设我们是以<code>以巨大应用为方向</code>为产品的方向，我们可以将产品拆解为</p>
<ul>
<li><code>应用框架</code>：客户既有代码如何使用我们的整个产品。</li>
<li><code>平台支撑</code>：我们所提供的产品的范围
<ul>
<li><code>服务发现</code>：如何进行服务发现
<ul>
<li><code>服务注册</code>：服务注册的信息包含哪些</li>
<li><code>服务管理</code>：是否包含服务的管理属性
<ul>
<li><code>服务下线</code>：是否能够手动将服务下线</li>
</ul>
</li>
</ul>
</li>
<li><code>配置中心</code>：如何进行配置管理
<ul>
<li><code>配置侧</code>：是否需要进行数据隔离</li>
<li><code>读取侧</code>：读取侧是否需要进行缓存等</li>
</ul>
</li>
<li><code>系统监控</code>：如何进行系统监控</li>
<li><code>其他</code></li>
</ul>
</li>
</ul>
<p>正如上文的列表，我们需要将系统的功能点列出来，这里有着整个产品最大的一个陷阱 <a href="#%E5%BF%98%E8%AE%B0%E4%BD%A0%E7%9A%84%E5%BC%80%E6%BA%90%E5%AE%9E%E7%8E%B0">反思1：忘记你的开源实现</a>，此时的你应该可以输出产品的功能清单，尽可能的详尽，在后续的迭代中也也是至为重要的指导纲领。</p>
<h3 id="慎重考察你的开源实现"><a class="header-anchor" href="#慎重考察你的开源实现">¶</a>慎重考察你的开源实现</h3>
<p>开源实现的代码质量都算不上太差，而我们最为重要的是考察开源的代码里的关于设计理念部分，如果你需要一个 <code>CP</code> 的系统，自然就不要考虑 <code>AP</code> 的Eureka这样的事情，为了要把这一步放在设计之后，也是因为千万不要因为别人的实现干扰了你自己对于产品的理解。</p>
<h3 id="设计你的架构"><a class="header-anchor" href="#设计你的架构">¶</a>设计你的架构</h3>
<p>也没什么值得要说的，尽可能的在你的代码和开源之间增加一层适配层，重度的耦合只会让你摔的更疼。<br>
<img src="https://s2.ax1x.com/2019/12/30/lQBSyt.png" alt="lQBSyt.png"><br>
哪怕你只有一个实现的时候也是值得的。至少让你们的开发者更容易理解你们自己的设计。</p>
<blockquote>
<p>tips: 大部分的时候你都会适配其他的实现，如果这个市场只有一家产品，那很可能并不是一个好消息</p>
</blockquote>
<h3 id="坚持你的设计"><a class="header-anchor" href="#坚持你的设计">¶</a>坚持你的设计</h3>
<p>哪怕是你发现底层的开源实现无法满足你的需求的时候，你可以使用很复杂的方式实现你的设计，也不要轻易的改变你的设计。改变那些无关紧要的部分，对于核心的理解是切记不能改变的，不然你就很快会变成下面这样</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">你的产品：100%    别人的产品： 0%</span><br><span class="line">------- 因为难以实现的功能 --------</span><br><span class="line">你的产品： 80%    别人的产品： 20%</span><br><span class="line">------- 因为难以实现的功能 * 2 --------</span><br><span class="line">你的产品： 60%    别人的产品： 40%</span><br><span class="line">------- 因为难以实现的功能 * 3 --------</span><br><span class="line">你的产品： 40%    别人的产品： 60%</span><br></pre></td></tr></table></figure>
<p>此时的你需要增加自己的设计的时候，你就会发现你自己的概念是极其难以加入的，为什么？因为这个产品的主体已经不是你设计的产品了，已经变成一个开源产品的发行版 (注：<a href="#%E4%BD%A0%E7%A9%B6%E7%AB%9F%E5%81%9A%E7%9A%84%E6%98%AF%E5%8F%91%E8%A1%8C%E7%89%88%E8%BF%98%E6%98%AF%E4%BA%A7%E5%93%81">反思2:你究竟做的是发行版还是产品</a>)</p>
<h3 id="专注"><a class="header-anchor" href="#专注">¶</a>专注</h3>
<p>每个产品都可能包含很多组件，在刚开始的阶段，我们可能处处完善，更应该专注于某一块，对于一个商业产品可以先从数据的展示的方面进行设计，比如在微服务设计中，对于监控数据的展示，投入更多的精力在 <code>APM</code>，切莫贪大导致的每一块都做的不怎么样。</p>
<blockquote>
<p>Tips: 对于我们的组件是可以融合的，更应该能够拆分，产品的某一部分都是独立的产品，用开源的方式去做一个独立的产品会让你的产品走的更远。</p>
</blockquote>
<h3 id="保持关注"><a class="header-anchor" href="#保持关注">¶</a>保持关注</h3>
<p>在一个新的方向上，经常会出现全面性的风向转变，就比如容器技术就经历了 <code>Swam</code> 转至 <code>K8S</code>，因为上面的概念解耦，我们也需要耗费一些精力进行下层的适配，而有些技术可能天生就是冲突的，比如 <code>SpringCloud</code> 所基于的 <code>REST</code> 和 <code>Dubbo</code> 所基于非透明的 <code>RPC</code> 在使用的过程就是完全不一样的，在选择的过程中可能会面领着市场的完全方向转变，甚至于被 <code>ServicsMesh</code> 这样的新的技术革命掉。因此产品在自己的概念中也时刻关注是否有一些已经 <code>outdate</code> 了。</p>
<p>比如说在传统的微服务领域中的给服务外挂Sidecar的方式完全在后续的迭代版本中会被 <code>isito</code> 此类的方案取缔，甚至于服务发现也会随之消失。</p>
<h2 id="反思"><a class="header-anchor" href="#反思">¶</a>反思</h2>
<h3 id="反思1：忘记你的开源实现"><a class="header-anchor" href="#反思1：忘记你的开源实现">¶</a>反思1：忘记你的开源实现</h3>
<p>这大概是我们在这两年内犯过最大的错误，这个错误的影响一直至今。此话怎么讲，且听我细细分析。<br>
因为我们这套产品是基于 <code>SpringCloud</code> 此时便有 <code>SpringCloud</code> 先入为主的印象，这就让我们在后续的设计中，很多都因实现而设计。</p>
<p><img src="https://s2.ax1x.com/2019/12/30/lQ1Tqs.png" alt="lQ1Tqs.png"></p>
<p>举个例子：我们在设计服务发现的时候，因为<code>SC</code>在实现之处是基于<code>Eureka</code>，<code>Eureka</code>对于服务的分组的非常的简单只有<code>服务</code>和<code>实例</code>这两个维度，因此我们在后续的系统设计中，我们便按照<code>服务</code>和<code>实例</code>这两个维度进行诸多的设计，比如流量的监控，服务的转发等等功能，而这些功能在实现的过程中，也作为了<code>HardCode</code>部分存在，直至后期我们需要增加额外的维度的时候就吃了一个大亏。因此在这两年的摸索中，渐渐明白了一个道理，你在实现自己的产品的时候，首先应该满足是自己产品的特性！就比如在 Spring 的实现中，<code>WebMVC</code> 可以基于 <code>Tomcat</code> <code>Netty</code> <code>Jboss</code> 其中任一种实现，Spring将那些他所需要的特性功能比如 <code>server.port</code> 作为了产品的属性，而 <code>tomcat.max-connect</code> 是作为额外的配置项存在的。</p>
<h3 id="反思2：你究竟做的是发行版还是产品"><a class="header-anchor" href="#反思2：你究竟做的是发行版还是产品">¶</a>反思2：你究竟做的是发行版还是产品</h3>
<p><img src="https://s2.ax1x.com/2019/12/30/lQl23F.png" alt="lQl23F.png"> <code>Linux</code> 有发行版的概念，不同的发行版之间可能是有不同的包管理工具，不同的启动机制等等，但是大部分是一直的，但是产品不一样，产品不应该将自己的内核实现暴露给用户，因此Windows只有Windows，并没有Windows的发行版，一部分是自己没有开源，另外一方面产品的内核逻辑是产品的主要竞争力。<br>
比如某竞品的设计如此 <img src="https://s2.ax1x.com/2019/12/30/lQMSEV.png" alt="lQMSEV.png"> 当你融入自己的想法之后，你可以清晰的将原来所开源产品的组件转为你所拥有的概念，可能这样说起来有些不清晰，在我看来，一个产品如果在客户在使用的过程中，不是非常明显的感受你的实现是基于某个产品的就算是成功了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rethink</category>
      </categories>
  </entry>
  <entry>
    <title>我的2019</title>
    <url>/2019/12/29/rethink/look-back-2019/</url>
    <content><![CDATA[<p>尚且记得写下2018的时候，转念已2019已逝去。尤为可怕的是不曾记得2019做了哪些，又发生了哪些的改变，在这这个时间点上让你无法反思到究竟发生了什么在2019。</p>
<p>如果非要说今年有什么变化，大概开始明白人和人之间的视野是有极大的差距的，很多事情是自己所不能洞察的而别人的确可以察觉到，并且可以利用之。</p>
<h2 id="倦怠"><a class="header-anchor" href="#倦怠">¶</a>倦怠</h2>
<p>我觉得已经没有什么比<code>倦怠</code>更适合现在的我，在上海都差不多也要5年有余，尚未成家，尚未有房，工作尚未有所质变，这一切不变都又在无时不刻的在刺痛着我的内心，直到你开始麻木，而麻木的代价乃就是倦怠，对所有的事情得过且过，这大概已经是一个再为糟糕不过的状态，无论你怎么想，人做所有的事情都希望有所达成，而现在的我却已经无法达成什么，内心的倦怠感已在崩溃的边缘。</p>
<span id="more"></span>
<h2 id="困境"><a class="header-anchor" href="#困境">¶</a>困境</h2>
<p>未尝如现在对明天无所期待，一方面不知道所期待是什么，求之不得是一种苦，不知所求亦是一种苦，人如困于圆中。</p>
<h2 id="平凡"><a class="header-anchor" href="#平凡">¶</a>平凡</h2>
<p>2019年可能是最为平凡的一年了，<a href="https://www.huxiu.com/article/333792.html">2019，中国互联网让人失望的一年</a> 作为一个互联网人，这一年我所参与的产品没有卖的太出色，以至于到了年底的时候都如同活在年初之中。还记得过完年刚去的克拉玛依，不知道他们的系统开发的怎么样了，又一年过去了，那些车马慢的城市，他们都还好吗？</p>
<h2 id="接受"><a class="header-anchor" href="#接受">¶</a>接受</h2>
<p>慢慢的也开始接受自己的平凡，当一个平凡的人可以从厨艺中获得乐趣。</p>
<hr>
<p>还好这一切都不算太糟糕，慢慢的来，总是一切来得及。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rethink</category>
      </categories>
  </entry>
  <entry>
    <title>微服务2019的新趋势</title>
    <url>/2019/03/06/rethink/microservice-trend-in-2019/</url>
    <content><![CDATA[<p>微服务在<code>2019</code>的新趋势，势必是基础设施下行，应用支撑上行。下文展开了说。<br>
<img src="https://ws1.sinaimg.cn/large/eddc95fcly1g0sv992p3pj219s0ygh35.jpg" alt=""></p>
<span id="more"></span>
<h2 id="基础组件下线"><a class="header-anchor" href="#基础组件下线">¶</a>基础组件下线</h2>
<p><code>2019</code> 应该是 <code>service mesh</code> 的元年，随着 <code>kubernetes</code> 的普及，<code>kubernetes</code>让<code>PAAS</code>成了开发者也需要关系的地方，其中最为复杂的就应该是 <code>网络部分</code>，基于<code>kubernetes</code>的网络标准，可以实现大量原本需要 <code>sidecar</code> 才能做到的微服务流量管理。</p>
<h2 id="应用支撑上行"><a class="header-anchor" href="#应用支撑上行">¶</a>应用支撑上行</h2>
<p>微服务已经发展了有一些时间了，比如网关，熔断这些相对单一的组件的已经大部分进入了成熟的维护阶段，现阶段大家对微服务平台的诉求已经变成整合性的。</p>
<ul>
<li>APM：传统基于虚拟机的监控已经不满足现在的微服务的监控需求，需要改造，这个 APM 又如何和微服务系统深入集成又是需要注意的</li>
<li>分布式事务：分布式事务总是需要的，避免不开的选择。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rethink</category>
      </categories>
  </entry>
  <entry>
    <title>年轻的程序员请尽量减少抽象</title>
    <url>/2020/12/25/rethink/not-more-abstraction/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201228145412.png" alt=""></p>
<blockquote>
<p>Abstraction is the purposeful suppression, or hiding, of some details of a process or artifact, in order to bring out more clearly other aspects, details, or structure. 抽象是有目的的隐藏过程中的某些细节，以便更清楚地展现其他方面的细节。</p>
</blockquote>
<span id="more"></span>
<h2 id="抽象的价值"><a class="header-anchor" href="#抽象的价值">¶</a>抽象的价值</h2>
<p>为什么需要抽象，一方面我们需要将不重要的细节隐藏起来，另外一方面因为我们每个人都不是全知全能之神，我们需要站在别人的肩膀之上完成更高层级的事情。</p>
<blockquote>
<p>比如我们需要在城市中投递快递，无论是 <code>中通快递</code> <code>申通快递</code> <code>顺丰快递</code> 对于快递的抽象就是将某个物品从 <code>A</code> 传输到 <code>B</code>，因此对于我们来说，快递就是一个传递性的协议。</p>
</blockquote>
<p>但是值得注意的是</p>
<blockquote>
<p>The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.<br>
抽象不是模糊不清的复用，而是创建一个绝对精准的新语义层</p>
</blockquote>
<p>如果现在没有出现的抽象，绝大多数的时候我们不需要再继续抽象。因为我的抽象往往作为别者的依赖，如果出现 <code>坏抽象</code> 的时候，<code>坏抽象</code> 会变成病毒般的传播起来，而坏抽象往往会有这么几个味道</p>
<h2 id="坏抽象"><a class="header-anchor" href="#坏抽象">¶</a>坏抽象</h2>
<blockquote>
<p>You thought that the abstraction world was made of rivers of honey, roads of chocolate and clouds of marshmallow? Everything has a cost: using abstractions should be a thoughtful decision.</p>
</blockquote>
<h3 id="为了解决重复的抽象"><a class="header-anchor" href="#为了解决重复的抽象">¶</a>为了解决重复的抽象</h3>
<blockquote>
<p>Duplication is far cheaper than the wrong abstraction. [重复比糟糕的抽象好得多]</p>
</blockquote>
<ul>
<li>程序员 A 看到一段重复的代码。</li>
<li>程序员 A 将其提出出来并给他起了一个名字。</li>
</ul>
<p><code>此时创建了一个新的抽象，也许是函数/类/模块</code></p>
<ul>
<li>程序员 A 基于新的抽象将代码进行了重构。</li>
</ul>
<p><code>此时的代码看其里非常的完美</code></p>
<p><em><strong>一段时间之后</strong></em></p>
<p><code>新的需求产生，现在的抽象几乎是满足需求的</code></p>
<ul>
<li>程序员 B 被安排来实现这个任务</li>
<li>程序员 B 由于并非每种情况都完全相同，因此他们更改代码以采用一个参数，然后添加逻辑以根据该参数的值有条件地做正确的事情。</li>
</ul>
<p><code>原本一样的抽象开始有点不一样</code></p>
<ul>
<li>另一个新要求到来了。</li>
<li>程序员 X<br>
<code>另一个附加参数</code> <code>另一个新的条件</code> <code>循环直到代码变得令人费解</code></li>
</ul>
<p>既有的系统代码代表了正确，不幸的是随着复杂度的上升，保留的压力会越来越大，那些正确的代码让你小心翼翼，你只能加上 <code>more &amp; more</code> 的条件 <code>flag</code> 来完成你的新任务，在 <code>梭罗</code> 的 《瓦尔登湖》 中指出，剥夺你人生自由的恰好就是那些你拥有的。</p>
<div>
    <label class="author-mark-label">小声比比</label>
    <p class="author-mark">尤其是在一些抽象能力比较弱的语言 (说的就是你Go) 上，基于反射的抽象只会让你更加难理解</p>
</div>
<h3 id="糟糕的命名"><a class="header-anchor" href="#糟糕的命名">¶</a>糟糕的命名</h3>
<blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things.</p>
</blockquote>
<p>想想当你定义了一个 <code>deleteUser</code> 函数的时候，在执行这个函数的时候，我们将这个 <code>User</code> 置为 <code>Disable</code> 并且将其账号余额给清空了，拜托，下一个接手的程序员如果能从 <code>deleteUser</code> 里面读到这些就有鬼了。</p>
<h3 id="简化问题"><a class="header-anchor" href="#简化问题">¶</a>简化问题</h3>
<p>让你设计一个 <code>Json</code> 转换成 <code>Xml</code> 的神奇函数，你想要这个函数简单通俗易懂。你定义了一个 <code>Parser</code> Class，然后给他一个万能的 <code>Parser::parse(String json)</code> 函数，这个糟糕的设计没有任何参数，我试图在转换的过程中将某些字段忽略，我们就不得不去破坏抽象了。</p>
<p>过渡简化问题就好像只有一个旋钮的洗衣机，我们可以用 <code>旋转</code> + <code>按下</code> 来完成我的任务，但是多放几个按钮也许更高效的多。</p>
<h3 id="脱离现实的OOP"><a class="header-anchor" href="#脱离现实的OOP">¶</a>脱离现实的OOP</h3>
<p><code>OOP</code> 是一个很不错的工具，但并不是灵丹妙药，在使用 <code>OOP</code> 之前考虑下是不是用简单的函数就可以满足你的需求，这也是为什么现在大量的语言都在将 <code>FP</code> 的精华融入系统之中。</p>
<p>创建一个 <code>class</code> 的时候，考虑一下三点：</p>
<ol>
<li>简化和消除复杂性。</li>
<li>其他的类可以使用它，但他不需要是一个全局的 <code>magic class</code>。</li>
<li>将数据和作用于数据的函数封装在一起。</li>
</ol>
<h3 id="面向未来"><a class="header-anchor" href="#面向未来">¶</a>面向未来</h3>
<blockquote>
<p>premature optimization is the root of all evil</p>
</blockquote>
<p>这简直就是 <code>Java</code> 程序员的重灾区，一大堆单一实现的 <code>interface</code>，当在 <code>codereview</code> 的时候，每一个人都抱着我这是为了未来的可拓展性，<code>面向未来</code> 只会带来复杂性，在需要抽象时使用抽象。</p>
<p><code>programming to interfaces(面向接口编程)</code> 显然不是你的接口，你的 <code>Customer</code> 只有唯一的一个实现类 <code>CustomerImpl</code> 实际上并没有多态性和可替换性，这里就是一个虚假的多态。</p>
<h2 id="抽象泄露"><a class="header-anchor" href="#抽象泄露">¶</a>抽象泄露</h2>
<blockquote>
<p>all non-trivial abstractions, to some degree, are leaky. [在某种程度上，所有非平凡的抽象都是泄漏的]</p>
</blockquote>
<p>首先想一想抽象会是完美的吗？<br>
如果我们将汽车抽象成一个带方向盘和四个轮子的大铁盒子，会导致什么，当我们的车正常行驶的时候一切刚刚好，但是车出现故障的，我们并不会知道车发生了什么，因为这一切都在你的抽象范围呢，我们为这个车加上一个中控，然后显示故障码？相信我在真实的世界里面，故障是无可穷举的。而恰到好处的抽象并不意味着滴水不漏，<code>Leaky Abstraction</code> 也是一个可选项。<br>
但是 <code>Leaky Abstraction</code> 有些时候就是对操作者有益，而有些时候是非常糟糕的。比如  <code>NFS</code> 这样的远程文件系统，可以让用户如同操作本地文件一般操纵远程的文件，对于用户来说会出现 <code>Connection Error</code> 这是本地文件从来不会发生的错误，这就是一种抽象泄露，所幸这种泄露并没有什么糟糕之处。<br>
但是另外一种当你在教导某人在编写一个 <a href="http://www.gwtproject.org/"><code>GWT</code></a> 系统，<code>GWT</code> 目的就是用 <code>Java</code> 来编写 <code>JS+HTML</code> 的系统，隐藏了 <code>JS</code> 的实现，此时如果用户将 <code>JS</code> 禁用了，<code>Java</code> 程序员就面临着一无所知的境地。</p>
<blockquote>
<p>The law of leaky abstractions means that whenever somebody comes up with a wizzy new code-generation tool that is supposed to make us all ever-so-efficient, you hear a lot of people saying “learn how to do it manually first, then use the wizzy tool to save time.” Code generation tools which pretend to abstract out something, like all abstractions, leak, and the only way to deal with the leaks competently is to learn about how the abstractions work and what they are abstracting. So the abstractions save us time working, but they don’t save us time learning.</p>
</blockquote>
<p>我们拥有越来越高的编程工具并具有越来越好的抽象性，反而成为熟练的程序员也变得越来越困难。每一层都不是完美的抽象，总是存在着泄露。</p>
<p>抽象泄露也不一定都坏的，我们在汽车的抽象中，我们将离合，控制盘，刹车，油门泄露给用户，一个老道的用户可以根据油门的感觉，刹车的时间都可以判断车出现了什么故障，这样的泄露也不全是缺点，就好像电视机的遥控器总不是按键越少越好。</p>
<p>编程中的 <code>ORM</code> 总是处于如此糟糕的境地，无论你花了多少的努力想要把 <code>SQL</code> 隐藏在 <code>Proggraming</code> 之下，<a href="https://hibernate.org/orm/"><code>hibernate</code></a> 用了 500 多页的教程来教导你如何用代码规避一个复杂的 <code>SQL</code>，而用户只会选择将 SQL 写在代码之中。</p>
<hr>
<p>谨记：<br>
所有的抽象</p>
<ul>
<li>当脱离上下文的时候就变的无效</li>
<li>并不完美</li>
<li>与现实世界关联</li>
</ul>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="http://sriku.org/blog/2019/08/11/abstraction-is-the-root-of-all-evil/">abstraction is the root of all evil</a></li>
<li><a href="https://wiki.c2.com/?TooMuchAbstraction">TooMuchAbstraction</a></li>
<li><a href="https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction">the wrong abstraction</a></li>
<li><a href="http://www.codemanship.co.uk/parlezuml/blog/?postid=934">Reused Abstractions Principle (RAP)</a></li>
<li><a href="https://hackernoon.com/abstract-programmers-acada09df860">‘Abstraction’ is a dirty word.</a></li>
<li><a href="https://thevaluable.dev/abstraction-type-software-example/">A Detailed Guide to Abstraction in Software with Examples</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rethink</category>
      </categories>
      <tags>
        <tag>rethink</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务之痛</title>
    <url>/2018/09/01/rethink/pain-of-microservice/</url>
    <content><![CDATA[<p>笔者在最近的2年内，一直从事微服务咨询工作，帮助两位数的企业改造项目至微服务架构，然而这一切并非如想象中的一帆风顺，写下此篇也意在反思微服务的一些伤痛。</p>
<span id="more"></span>
<h2 id="系统结构之痛"><a class="header-anchor" href="#系统结构之痛">¶</a>系统结构之痛</h2>
<p>微服务并非是<code>银弹</code>，在咨询的过程中，很多公司的代码就像是<code>意大利面</code>一样的缠绕在一起，而这些代码之罪源于 <code>过度压缩研发周期</code> <code>缺失代码评审</code> <code>缺少顶层设计</code> 而非是一门技术所能够解决之事。</p>
<p>其中最为令人窒息的是 <code>代码间调用混乱</code> 与 <code>数据库使用混乱</code>，动则就数表联查，哪怕是采用 <a href="https://microservices.io/patterns/cn/data/database-per-service.html"><code>database-per-service</code></a> 设计模式，在物理上将数据库切分开，也会导致大量的服务间的请求出现，而因为服务库的拆分，更会暴露出系统模块划分的不合理，有点像是打地鼠一样，按住一头又冒出了另外三只。</p>
<p><img src="https://s1.ax1x.com/2018/09/01/PxVEVK.jpg" alt=""></p>
<p>在原本的单体系统中，不合理的函数点调用最多浪费些调用栈，至多多一些数据库的操作，而将这个问题拓展至 <code>微服务</code> 中，缺点暴露的更多，有且不限于 <code>调用过于频繁</code> <code>请求体和响应体过大</code> <code>无良好异常设计</code> 甚至于将一些内部应用的接口暴露给用户。</p>
<h2 id="运维成本之痛"><a class="header-anchor" href="#运维成本之痛">¶</a>运维成本之痛</h2>
<p>一个微服务的系统，少说得有 <code>业务应用 x3</code> <code>服务网关</code> <code>配置中心</code> 构成，应用数量的变多，使得运维变的困难起来，微服务在资源利用上的确有其独到的地方，但带来的问题是在于运维成本急速上升，所以我们看到 <code>CNCF</code> 最近又再疯狂的重新造轮子，试图使用自动化运维手段将这部分的成本降下来，但是问题不仅仅在于工具的选择，我们依然不得不去面对日益增长的应用数，不同的应用甚至于对于运维的技能都有着不一样的需求。</p>
<h2 id="开发成本之痛"><a class="header-anchor" href="#开发成本之痛">¶</a>开发成本之痛</h2>
<p>原本专注于业务开发，不得不去关注于 <a href="https://cloud.tencent.com/developer/article/1080207"><code>服务编排</code></a>，原本的系统开发在 <code>SOA</code> 时代我们需要关注的对方的 <code>IP</code> 地址，在数十年的业界的大势之下，大部分人都已经掌握了基础的网络知识，而现在开发者不得不去面对 <code>服务编排</code> 这个概念，下面有一个例子：</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        太长了，不得不隐藏的编排
    </div>
    <div class='spoiler-content'>
        <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wordpress-mysql</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pv-claim</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">20Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># for versions before 1.9.0 use apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wordpress-mysql</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">tier:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">wordpress</span></span><br><span class="line">        <span class="attr">tier:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">mysql:5.6</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mysql-pass</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">password</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-persistent-storage</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-persistent-storage</span></span><br><span class="line">        <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">          <span class="attr">claimName:</span> <span class="string">mysql-pv-claim</span></span><br></pre></td></tr></table></figure>
    </div>
</div>
<p>这也就是我非常的痛恨 <code>kubernetes</code> 的原因，在现在的 <code>DevOps</code> 的飓风之下，似乎开发都得懂点运维的知识，这个不排斥，但是 <code>kubernetes</code> 又太过于难搞了一些，完全不如 <code>docker-compose</code> 来的简单快乐，当然你引入 <code>Docker</code> 的时候，你就不得不去面对那充满新特性的 <code>Overlay</code> 网络(:doge 祝你玩的开心)。</p>
<p>除此之外，微服务对系统的健壮性的要求是上了100层楼那个高，传统的 <code>中间件</code> 都是相对的稳定，我们在开发的过程中可以省略性的考虑比如 <code>Mysql</code> 不稳定这类的问题，而在微服务中，我们的上游或者下游都是独立的应用，而这些应用并非是经过长期的验证的，我不得不针对这些不稳定的应用进行大量的保护性代码，比如服务熔断，服务重试等等，这些成本是远超原本的单体应用的。</p>
<p>笔者在一些公司，一个大业务部，拆分了数十个微服务，而这些的微服务的开发者往往是一个人，这时候，一个开发者需要维护物理上切分开的软件，而在开发的过程中，对每个服务都了如指掌的时候。自然会产生一些排斥，比如为什么这个工具类我用的地方很多，我是不是可以抽到一个公共的Jar中，而抽取之后又发现每个人都需要进行一些自己的变动，最终会变成各个项目都有一些类似又不一样的代码，对于程序员来说可能是一份冗余，这也是微服务所必须付出的成本。</p>
<h2 id="不得不去面对的新挑战"><a class="header-anchor" href="#不得不去面对的新挑战">¶</a>不得不去面对的新挑战</h2>
<p>除了一些固定的开发成本以外，我们不得不去面对分布式系统中的一些常见又规避不了的问题。</p>
<p><strong>分布式事务：</strong> 我们不得不去面对以前我们通过单体应用规避的分布式事务的问题，中间件方面我们可以假装完全的信任类如<code>Tidb</code> 这样的新时代的分布式数据库，而我们依然需要去面对业务系统的事务问题，基于<code>强一致性</code>或者<code>最终一致性</code> 的方案，我们选择 <code>MQ</code> 或者一些 <code>3PC</code> 的框架来解决这些问题，分布式事务框架本身又可能成为系统的一个单点，那<code>MQ</code>又会造成改造时候，我们不得不去改造业务的流程，又是一例技术逼迫业务改造的是惨痛案例。</p>
<p><strong>链路跟踪：</strong> 众多的应用</p>
<p>可喜的是我们有一些探索者提供了一些工具，我们拿来即可满足大部分的需求，可怕的是我们需要投入更多的人力在系统之中，所以在现阶段<code>微服务</code>还是一些金主手中的玩物。</p>
<h2 id="何时使用微服务"><a class="header-anchor" href="#何时使用微服务">¶</a>何时使用微服务</h2>
<ul>
<li>系统已经具备很大的规模，哪怕是一个单体系统，企业也为其投入了大量的支撑服务，可以考虑使用微服务改造一些高速变更的业务。</li>
<li>企业的组织架构是 <code>INVEST原则</code></li>
<li>业务的 <code>投产时间</code> 已经跟不上业务的发展，业务驱动之下的微服务不得不用。</li>
<li>最后，清晰的明白微服务能够给你带来什么，又会让你付出什么，做好选择，切莫半路而废。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rethink</category>
      </categories>
  </entry>
  <entry>
    <title>关于编程能力的反思</title>
    <url>/2018/08/18/rethink/rethink-code-ability/</url>
    <content><![CDATA[<p>我认为编程上有几种类型的问题</p>
<ol>
<li>第一种是本源性的问题，比如 <strong>算法</strong> ，明确性问题，有专业的科研从业者。</li>
<li>第二种是现实生活中的，输入的条件是不稳定的，外部因素也一直在变化。</li>
<li>第三类是技能无关的技能，比如团队的调节，团队目标的确定等。</li>
</ol>
<span id="more"></span>
<h2 id="技能精细化"><a class="header-anchor" href="#技能精细化">¶</a>技能精细化</h2>
<p>这个也很像是在FP的编程代码里面，有一些东西它的输入是稳定的，得到的结果也是完全的自包含的被称之为 <code>PURE</code> 的，但是在我们生活的世界不是 <code>PURE</code> 的。</p>
<p>人类因为自己的寿命和思维的限制，人类的发展强依赖于分工，在 <a href="http://www.eywedu.net/guofulun/Test004.htm">&lt;国富论&gt;</a> 里面也是有类似的理念</p>
<blockquote>
<p>人们天赋才能的差异，实际上并不象我们所成觉的那么大。人们壮年时在不同职业上表现出来的极不相同的才能，在多数场合，与其说是分工的原因，倒不如说是分工的结果。</p>
</blockquote>
<p>所以在职业发展的后期，如果依然依靠的是 <code>技能</code> 作为自己的生活手段，那我们这个时候所能够做的事情，就会变成精细化。比如</p>
<ul>
<li>KV内存数据设计</li>
<li>Oracle数据库运维优化</li>
<li>保险业务模型分拆</li>
</ul>
<p>这个时候，我们每个人的技能会变成一方面专精，其他方面会至少及格，但是一个人没有办法可以解决<code>所有类型</code>的问题，所有你必须要在不同的问题解决之道之间要有选择。所以你需要不断的解决更难的问题的时候，你就必然会导致你的解决问题的范围是 <code>窄化</code>。但是这种 <code>窄化</code> 也不是一个缺点，我们在生活的时时刻刻都是在不断的进行 <code>取舍</code>。</p>
<h2 id="关于不同的问题"><a class="header-anchor" href="#关于不同的问题">¶</a>关于不同的问题</h2>
<p>核心的本质上，作为一个被<code>别人需要（有帮助的）</code>的人，<code>解决问题的能力</code> 才是核心，因为我们每个人都依赖于上下游。<br>
上游可能是我们依赖的开源项目，亦或者是一个内部组件，下游是我们构建的产品，我们就是一个关键的连接点。</p>
<p>针对不一样的问题，我们的手段也是不一样的，</p>
<ul>
<li>比如我们针对 <code>稳定的算法</code> 问题，我们所能做的事情就是学习现在已经最成熟的方法，明白每一个算法的优点和缺点。</li>
<li>又比如针对 <code>稳定的技术</code> 问题，我们所能做的就是选择正确的技术框架，选择被实践过的成功范式。<br>
而对于 <code>不稳定输入</code> 的现实问题，我们能做的是在将问题分解，获得尽可能稳定的输入，针对稳定的部分我们就像是知道一道有解的题目（当然也需要广阔的<code>阅历</code>），而其他不稳定部分，我们依然需要控制<code>复杂</code>度，使用恰当的方式和精力投入解决这部分的问题。</li>
</ul>
<h2 id="技能高贱之分"><a class="header-anchor" href="#技能高贱之分">¶</a>技能高贱之分</h2>
<p>在以前我们就听说过，卖原子弹的不如卖茶叶蛋的，这个算是一个经济导向的一种高贱之分，但是现在的技术圈依然有这样的分别，比如后端觉得前端不高级，后端搞大数据的看不起搞业务的，搞AI又看不起大数据。这个的诞生的原因是因为，我之前说的我们大部分评价一个工种的高端与否一来依靠一些简单的社会价值划定（比如工资）二来就看这个行业的入门的门槛。入门的门槛往往就是在第一类的问题，而我们往往忽略了第二类，鄙视第三类的问题。我们在毕业入职公司的都喜欢考算法题，而第二类的问题我们在工作之后才能慢慢的发现这个技能的重要性，而对于第三类的问题，我们甚至会觉得技术管理人是编程无能的，实际从我的观察看来，技术管理人往往会编程更为的复杂，时时刻刻需要面对的是一直处于变化之中的世界。</p>
<h2 id="有价值的程序员"><a class="header-anchor" href="#有价值的程序员">¶</a>有价值的程序员</h2>
<p>并不是说写不出一个操作系统的程序员就是毫无价值的，拿一个餐饮行业打个比方，外面千千万万的苍蝇馆，虽然味道不怎么样，但是这些才是正常人填饱肚子的第一选择，程序员的价值也是如此，在一个学习的过程中，我们首先要贡献出自己的价值出来，在既有的技能条件下，将自己手上的事情做好，然后然后不断的提高自己才是正途，实际上往往会有一些不切实地的幻觉，比如想成为这件事情只有我能做，而别人不能做，这样的人很少，大部分的时候，我们都选择<code>效能最高</code>的方式，可能是最为熟悉这方面的事情，而并非是只有你能做，保持<code>学徒</code>的心态，谦卑前行。</p>
<hr>
<p>最终最为重要的事情是保护好自己的身体，编程技能会过时，唯一不变的，你需要的是依靠的是自己强健的体魄和坚忍的毅力去完成你所想的一切，多锻炼，健康饮食，毕竟能够笑到最后的才是赢家。</p>
<p align="right">于 厦门 ● 观音山</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rethink</category>
      </categories>
  </entry>
  <entry>
    <title>Gateway版本迭代反思</title>
    <url>/2018/08/15/rethink/rethink-in-gateway/</url>
    <content><![CDATA[<p>笔者在 2017.12 - 至今（2018.8）都沉浸在 <code>微服务治理平台</code> 的 <code>网关</code> 这个组件的构造之上，恰逢系统更新到 <code>1.2</code> 著此作为反思。</p>
<blockquote>
<p>此处的网关指的是七层的 API 网关</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2018/08/15/PRero4.png" alt="banner"></p>
<span id="more"></span>
<h2 id="0-99-时期"><a class="header-anchor" href="#0-99-时期">¶</a>0.99 时期</h2>
<p>2017年底的时候，随着公司的咨询业务开展以及<code>微服务</code>的流行起来，我们隐约的摸到了大多数的公司仅仅使用<code>SpringCloud</code>的<code>Zuul</code>作为唯一的外置的<code>API网关</code>是不够的，其中又涉及到大量的相同类似的功能，我们因此萌生了开发一个开箱即用的网关的想法，这个项目在12月的时候正式开始启动。</p>
<p>当时作为流行的是 <code>Spring Cloud Netflix Zuul</code>，直至今日都是作为流行的选择之一。<code>Zuul</code> 的编程模型也足够简单，我们也在之上为不同的企业做了多套的方案，是成熟可靠的选择。<br>
<img src="https://s1.ax1x.com/2018/08/15/PReO6P.png" alt="Zuul"></p>
<p>不过当时，我们已经成功的使用 <code>Netty</code> 给 <code>东风汽车</code> 新能源项目做了一套接入的网关，<code>Netty</code>的稳定性和高性能非常的吸引我们，当时也有基于<code>Netty</code>的高性能的  <code>Web框架</code> <a href="https://vertx.io/"><code>vertx</code></a> ，这里涉及到最为重要的就是 <code>NIO</code> 与 <code>BIO</code> 之间的比较。如果能够基于 <code>Netty</code> 的 <code>Reactor</code> 的模型，可以提高大量的吞吐量。</p>
<p><img src="https://s1.ax1x.com/2018/08/15/PRuAdU.png" alt="Netty Reactor"></p>
<p>所以我们决定不基于 <code>Zuul</code>的编程模型，做一套可以同时在 <code>Zuul</code> 与 <code>Vertx</code> 运行的框架。在开发的过程中，我们借鉴了 <code>Netty</code> 的 <code>Pipeline</code> 机制，做了一套流水线。<br>
<img src="https://s1.ax1x.com/2018/08/15/PRnWVO.png" alt="Pipeline"></p>
<p>在物理架构上，我们将 <code>管理端</code> 与 <code>运行端</code> 进行了分离。这样的架构可以保证，<code>运行端</code> 的性能足够好，并且不会因为暴露出一些非必要的请求地址给外部用户。<br>
<img src="http://i1.bvimg.com/596754/6a0e6f920fa9177b.png" alt="架构图"></p>
<p>然后将系统划分为了这么几个模块：</p>
<ul>
<li><code>端点</code>：提供对外暴露接口的能力</li>
<li><code>路由</code>：路由转发能力</li>
<li><code>流控</code>：控制对外接口的转发速度</li>
<li><code>安全</code>：鉴权相关的能力</li>
<li><code>缓存</code>：提供系统的缓存服务</li>
</ul>
<h3 id="不足之处"><a class="header-anchor" href="#不足之处">¶</a>不足之处</h3>
<ol>
<li>因为为了兼容 <code>Zuul</code> 我们整个编程模型，在 <code>Redis</code> 读写 和 <code>Request Body</code> 读写方都是同步阻塞的。所以整体线程模型会是这样的:<br>
<img src="http://i2.bvimg.com/596754/0a69ee94fd3bc281.png" alt="0.99"><br>
我们不得不在网关处持有大量的线程，这样对于网关的性能来说是一个致命的伤。</li>
<li>Redis的读取我们的用了 <a href="https://github.com/redisson/redisson/">Redisson</a>，当时 Redisson 不支持 Reactive的编程模型，所以的行为是阻塞的，除此之外还有一点很可惜，<code>Redisson</code> 存储到Redis的数据往往是非精简的，导致读取数据大小太大这是一个优化点</li>
</ol>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>
<p>在 0.99 版本完成的时候，因为有两个运行端版本共存，一个是 <code>Vertx</code> 和 <code>Zuul</code>，当时为了兼容 <code>Vertx</code> 做了一系列的  <code>Facede</code>项目，后来被证明都是徒劳的，不过当时已经完成了网关的动态化的需求，整体的性能在测试的过程中持平<code>Zuul</code>，性能损耗不大。</p>
<h2 id="1-0-1-1-时期"><a class="header-anchor" href="#1-0-1-1-时期">¶</a>1.0 - 1.1 时期</h2>
<p>这个时期，随着 <code>Spring 5</code> GA，我们也作为第一批吃螃蟹的，我们将网关的底层基座直接切换到了 <code>SpringWebFlux</code>之上，依然可以借力于 <code>Spring Cloud</code> 的生态组件，我们将<code>Vertx</code>的支持放弃，既然<code>Spring</code> 都有了 <code>Netty</code> 的运行时，我们整个业务体系都在<code>Spring</code>上，就没必要投入更多的人力去维护<code>Vertx</code>。<br>
这个阶段，我们尝试使用 <code>WebFlux</code>作为网关的基座，这是非常痛苦的阵痛期，有几个问题：</p>
<ul>
<li><code>Pipeline</code> 设计不满足 <code>reactive</code> 编程的需要</li>
<li><code>webflux</code> 本身的缺陷</li>
</ul>
<p><code>webflux</code> 5.0.0 版本，不仅仅在 <code>ServerExchange</code> 中缺少 <code>RemoteIP</code>，而且无法强制的关闭 <code>CORS</code> 的处理，这些细小的问题却要花上不少的时间去做一些<code>魔改</code>。</p>
<p>最后在 1.1 完成后，整个系统的架构变成了 <code>Input Reactive</code> 和 <code>Output Reactive</code>，但是由于pipeline的处理流程还是阻塞的，导致系统依然存在较大的IO瓶颈。</p>
<p><img src="http://i2.bvimg.com/596754/df1991fdcf2a17e1.png" alt=""></p>
<h2 id="1-2-时期"><a class="header-anchor" href="#1-2-时期">¶</a>1.2 时期</h2>
<p>在 <code>1.2</code> 的重构目标就是去除复杂的 <code>Pipeline</code> 机制，我们可以利用更为完善的 <code>projectreactor</code> 进行流程的控制，这个 <code>Reactive</code> 的编程库足够好也更为的通用。所以在这个阶段，我们将之前的 <code>Pipeline</code> 中的 <code>Stage</code> 概念替换为了 <code>Handler</code> 在系统中保留了之前经过验证的简单又可靠的概念。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReactiveHandler</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Function</span>&lt;T, Mono&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    Mono&lt;T&gt; <span class="title function_">handle</span><span class="params">(T httpExchange)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> Mono&lt;T&gt; <span class="title function_">apply</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> handle(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用单一的处理抽象，结合 <code>Projectreactor</code> 的 <code>Mono</code> 可以达到以前的 <code>Pipeline</code> 的效果。</p>
<p>在这个阶段，我们完成了项目的全<code>响应式</code>:<br>
<img src="http://i2.bvimg.com/596754/a69f8b261cd3c627.png" alt="reactive"></p>
<h3 id="启迪"><a class="header-anchor" href="#启迪">¶</a>启迪</h3>
<p>过度设计是万恶之源，一点都不为过，<code>Pipeline</code> 的设计太过于超前也并不实用，导致在 <code>1.1</code> 时期增加一个功能非常的困难，<code>Pipeline</code> 的编程模型并非是<code>响应式</code>的，所以在我们底层的编程模型变化之后，直接就判处了死刑。</p>
<h3 id="展望"><a class="header-anchor" href="#展望">¶</a>展望</h3>
<p>现在的流控方式还是基于集中化的<code>Redis</code>这个在极大规模的请求情况下，依然会存在性能的瓶颈，我们在后续的开发增加独立的高性能的内存模式，将限流器可以进行配置化。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
        <category>gateway</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学/艺术</title>
    <url>/2019/04/09/rethink/sc-or-art/</url>
    <content><![CDATA[<p>不知道，大家是不是一直受《The Art of Computer Programming》这本书的影响颇大，亦或者大家都是理工科的学生，对于那些没有触及到了艺术就有些向往，就往往冠以计算机艺术之名，计算机艺术这个事情说起来是没错的，无论是操作系统，图形学，AI都是算得上人类智慧的结晶，艺术之作。不过对于大多数的初级程序员来说，这样的说法又让大家忽略了计算机科学工程的那一方面。</p>
<h2 id="软件技能本质上还是一个技能"><a class="header-anchor" href="#软件技能本质上还是一个技能">¶</a>软件技能本质上还是一个技能</h2>
<p>软件技能（software skill），首先突出的是一个技能的本身，无论是是达芬奇还一个美院平平无奇的学生，他们都是具备了<strong>绘画</strong>这个技能，而这个技能本身会体现出来，这个要看创作者本身，当然一个作者想要有一个更好的艺术性，显然也是需要很强的技能作为支撑的，而很多的程序员都忘了，技能的获取是靠的是训练，一个从来不执笔画画的画家是肯定练不成大师的，而一个写代码总是不动脑子的程序员也是成不了大师的。而这样的程序员往往会有几个很明显的特点：</p>
<ul>
<li>固执且单一：一直都在使用自己熟悉的编程范式与语言进行编程，不愿意接受新的事物</li>
<li>无有效训练：完成任务即可，对于如何优化和设计毫无动力</li>
</ul>
<h2 id="执泥于艺术那一面"><a class="header-anchor" href="#执泥于艺术那一面">¶</a>执泥于艺术那一面</h2>
<p>团队中也不缺乏那些聪明而灵活的程序员，本应该走的更远的他们却停滞过于新潮的概念亦或者玄学。而且觉得其中以 《UNIX编程艺术》 这样的书籍作为典范，如果一个程序员张口闭口和你说的都是它的话，那大致可以断定，这是一个玄学程序员。这样的程序员大多数学会了 <code>KISS</code> 之后就抱着这颗大树再也不撒手了，这样的程序员活跃在各大网络论坛和社区之中，他们就是软件行业的<code>禅宗</code>，试图用一些看似有意义的话，让你进行反思，等你反思完成，发现他说的没啥意义的时候，可能已经为时已晚。软件和佛学有点不一样，佛学无法实证，什么内心的愉悦，都是从别人的嘴里讲出来的，因为佛学的禅宗是顺其自然会诞生的，当然也有实证的学派，就比如像苦行僧之类的，而软件本身扎根于计算机，我们所有的行为都是会被01的计算机执行，计算机懂不懂美？我觉得不是不懂的，只有编写的人才懂，这就得要求你，至少写出可行有效的代码，而那些<code>禅宗大师</code>们往往写不出一行能编译通过的代码。</p>
<h2 id="黑客和画家"><a class="header-anchor" href="#黑客和画家">¶</a>黑客和画家</h2>
<p>保罗带了一个坏头，把黑客与画家混为一谈，人们往往因为对成功者的顶礼膜拜，就会对其一言一行进行模拟，当然这本书就变成了某些人的灵魂伴侣了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端分离的罪与罚</title>
    <url>/2020/02/18/rethink/separate-front-end/</url>
    <content><![CDATA[<p>什么时候开始吹起了前后端分离的风，在我的回忆里是应该随着 <code>One Page Application</code> 的风来的，突然有那么一段时间 <code>Vue</code>,<code>Angular</code>,<code>React</code>就像雨后春笋长出来一样，前端离开了后端也可以玩转整个处理的流程了，工种的区分的也慢慢的变成前后端两只岗位了，甚至于过了一段时间出现了 <code>Fullstack</code> 的开发者。</p>
<span id="more"></span>
<h2 id="为什么会需要前后端分离"><a class="header-anchor" href="#为什么会需要前后端分离">¶</a>为什么会需要前后端分离</h2>
<p>原因也很简单，现代的IT技术已经非常的复杂，需要专人专岗了,年轻的朋友们可能已经没听过 <code>Web2.0</code> 了，让我们温顾一下：</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/Web_2.0">Web 2.0</a>，指以最终用户为目标，强调用户生成内容、易用性、参与文化和互操作性（如：与其它产品、系统和设备兼容）的网站。</p>
</blockquote>
<p>在那样的时代，我们几乎使用 JQuery 就可以完成大部分的情况了，但是我们迎来了移动互联网时代，大部分的用户都在手机上进行操作，我们并没有像是BS架构这样的技术直接在手机端使用（当然后面也有一些 HTML View的技术），手机端的数据需要进行和服务器端进行交互，并且此时的Web页面也正在变的复杂，那随之而生的也就是现在大家所能见的 <code>前后端分离</code> 的兴起。</p>
<h2 id="前后端分离是银弹吗？"><a class="header-anchor" href="#前后端分离是银弹吗？">¶</a>前后端分离是银弹吗？</h2>
<p>软件工程没有银弹，前后端分离带来的优点包含</p>
<ul>
<li>专人专岗：提高了单位输出效率</li>
<li>降低门槛：以前要学的现在只要学一半</li>
<li>接口复用：现在提供的接口可以进行复用<br>
能够显而易见的好处大致上有这些，那它的缺点呢，我们显然也不能避而不谈。</li>
</ul>
<h3 id="沟通成本"><a class="header-anchor" href="#沟通成本">¶</a>沟通成本</h3>
<p>对于绝大多数的公司来说，沟通成本本身就足够大，而现在通过刚性的手段将前后端分离，前后端之间通过<strong>脆弱的</strong>API文档进行沟通本身就是不可靠的，对接过支付宝接口之类的同学也都明白，往往仅有一个API文档依然不足够，还需要有足够多的说明的与Demo，如果寄希望后端补齐这些东西，那增加的时间成本又甚至于高于分离的之后减少时间成本，因为对于大部分的公司来说，前后端分离意味着需要花更多的时间进行API层面上的沟通，如果是相互熟悉的团队可能经历了数个周期的磨合之后会有好转，标准化是一个办法，但标准化往往本身就足够困难。</p>
<h3 id="信息隔离"><a class="header-anchor" href="#信息隔离">¶</a>信息隔离</h3>
<p>对于后端来说如果仅仅做后端不考虑前端的实现，往往会写出一些看上去完美的接口，但是实际上在最终和前端对接的过程中，前端同学会心态爆炸，比如对于某些计算值是否都需要前端计算，为什么这个值还要再请求一次，而前端在倒逼后端的时候，后悔的同学也往往会困扰，为何要做这么冗余的设计，而这一切本身都无错，前端是<strong>视觉驱动</strong>：从展示的元素中提炼对象，而后端是<strong>数据驱动</strong>：从业务逻辑中提炼对象，这两份对象常常不同意，前后端分离的解决之道是增加一个中间层，无形之中又增加了复杂度。</p>
<h2 id="真实之道"><a class="header-anchor" href="#真实之道">¶</a>真实之道</h2>
<p>摒弃狭义的前后端分离(仅仅将前后端开发者分离,恰当的说法可能是分家)，而是按照 <code>产品线</code> 与 <code>基础设施</code> 分离，对于<code>产品线</code>来说，绝大多数不应该分离前后端职能，从应用的架构上，可以将前后端分离，但是对于某一产品功能应该采用 <code>E-E</code> 端到端的模式，无论是页面展示还是后台数据的存储调用，都应该由单一责任人进行开发。而对于<code>基础设施</code>处，几乎都是数据驱动的技术性产品，这段可以采用完全的前后端分离，为专业人士排除其他的压力，除此之外，也就是极其复杂的UI页面应该由专业的<code>前端</code>进行开发。</p>
<p>最终构成一个形如网吧的办公场所，人人的技能都可以在相互交流中增长。<br>
<img src="https://s2.ax1x.com/2020/02/18/3AK5nO.png" alt="3AK5nO.png"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rethink</category>
      </categories>
      <tags>
        <tag>反思</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么我厌倦了产品研发(2B)</title>
    <url>/2020/07/06/rethink/stop-create-a-product/</url>
    <content><![CDATA[<p>这不是什么丧气的话，只是这条路暂时不太走得通罢了。从这有限的产品经历看起来，构建一个产品并不容易。</p>
<p><img src="https://wx1.sbimg.cn/2020/07/06/Cmr9M.png" alt="Cmr9M.png"></p>
<span id="more"></span>
<h2 id="产品体系难以建立"><a class="header-anchor" href="#产品体系难以建立">¶</a>产品体系难以建立</h2>
<p>彻彻底底的讲DMP的困难是体系建设的问题，以&quot;研发&quot;为核心的产品体系，制作出来的是一个易碎的瓷碗，看起来不错，但是使用的时候得护着它，不要让它碎掉。而一个完整的产品体系，从需求管理，产品研发，测试，产品交付，售前支持，售后支持，销售培训，乃至于文档管理都需要投入，而我们总是关注于 Make it，将这个东西做出来，仿佛事情已经完成了 80%，现在看起来做出来仅仅完成了任务的 20%，我们只是开始一段旅程。而在很多基于项目的产品线，产品经理的作用是与客户对接，交付工程师由开发兼职，测试已应付客户为主的模式下，产品又如何不脆。</p>
<h2 id="技术产品"><a class="header-anchor" href="#技术产品">¶</a>技术产品</h2>
<p>无论任何依然要认识到制作的并不是一个真正有门槛的技术产品，以前2C产品经理都会有一个问题，如果你们公司被腾讯抄袭，你们会怎么样？我们在做产品时候，也问问自己，你的技术门槛高到别人看了UI也不知道怎么抄袭吗？你的定位是什么？提供给客户一个技术组件还是一个行业经验？实则我们大部分的时候提供的都是一个看似技术产品的经验方案，我们试图用我们多年在行业浸淫的经验，将开源工具更好的组装在一起，以达成输出我们的技术理念，那此时我们提供的本质并不是技术本身，是我们的行业理解与运维经验等…… Wait，我并不是说这么做就是不对的，而是我们要明确我们究竟提供的是什么？如果是基于开源简单的封装，那我们应该在运维的经验铸造更高的城墙，如果我们是自研的，那我们可以更好的做好这个组件本身就是铸好这个坝。切莫调入 科技以换壳为本 为的陷阱之中，贸工技与技工贸 都可以的路径，只要认准的道路就要走下去，忌讳简单的封装 → 科技领先。</p>
<h2 id="产品边界不清"><a class="header-anchor" href="#产品边界不清">¶</a>产品边界不清</h2>
<p>相较于 2C 侧的技术，对于用户开放的是有限的，因此用户和产品的接线有着天然的隔离，当我们做一个 2B 的产品，我们面领着对接客户的应用等可能性，此时应用的问题会蔓延到产品上，也可以是因为产品的问题导致应用出现了问题，变成了你中有我，我中有你的相对局限，导致交付困难，运维困难，经常为了一些简单的事情投入大量的精力排查。这种边界不清也非常容易传到产品的其他部门。</p>
<h2 id="弱产品的体系"><a class="header-anchor" href="#弱产品的体系">¶</a>弱产品的体系</h2>
<p>产品部门的羸弱是有多个原因的 产品形态由研发主导，这因为’2 和另外一个原因导致。另外原因是什么？因为产品经理并没有很强的产品理解，这并怪产品，从DMP的角度，微服务治理是一个有技术提出的理念，在设立之初没有可以值得参照的竞品，我们从技术组件里面归纳总结出来的部分变成了产品的功能，我认为产品经理是值得培养的，需要2-3年的时间可能我们才能将产品这株花种植成功。</p>
<h2 id="回报周期长"><a class="header-anchor" href="#回报周期长">¶</a>回报周期长</h2>
<p>如果真的说做产品，我觉得2年是没有什么声音的，这2年内需要自己找客户不断的磨炼产品，控制好节奏（这个很重要）。尤其是在 2B 行业中，我们不得不去在一个较长的反馈周期内去制造一个产品。</p>
<hr>
<p>我们真的需要客户提供一个产品吗？我也常常问自己，大部分的客户好像不是需要这么个产品，产品的诸多功能都留给控标性，简单的封装一下，按照项目的模式将其输入并且快速的结项，难道就不香嘛。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rethink</category>
      </categories>
  </entry>
  <entry>
    <title>对IOT技术思考</title>
    <url>/2018/04/18/rethink/think-in-iot/</url>
    <content><![CDATA[<p>世界上技术千千万万，如果投身于热点，就如同夸父逐日。</p>
<span id="more"></span>
<p>那我就大胆就做个预测，在互联网时代，我们所做的事情的核心是讲人和人链接一起，其他的物体也是通过人链接在一起的，比如</p>
<ul>
<li>Facebook（连接人和人）</li>
<li>淘宝（连接人和店家）</li>
</ul>
<p>我觉得下一个阶段是将物和物链接在一起并且让其<strong>联动</strong>，在发展的过程中，我们会经历人和物的连接，鉴于这样的的立意，确定自己投身的方向，大胆的预测未来是属于物联网的。</p>
<ul>
<li>采集<br>
采集要稳定高效，并且需要小型化，功耗要低，这块应该设计的是硬件相关的知识，未来应该会从嵌入式的方式进化出更好的采集终端，依赖多种技术的发展（电池，计算能力，传感线单元）</li>
<li>传送<br>
物联网设备应该长期处理不稳定的网络环境，如何高效的传递数据，保证数据的可达性，可能会重写当前的传输协议。但是协议应该很快就会有业界的标准，应该不会更换TCP/IP的基础栈，新老技术的兼容性。</li>
<li>计算分析<br>
物联网的计算肯定是需要高实时性，为了实现物物的联动性，至少需要计算速度 &gt; 人体感知的速度 ，这样才能满足人们对于物联网的想象。数据量大，结构简单，如果未来的计算设备能够更小型化，可能计算会变成终端计算的方式，但是又考虑功耗的问题，应该大概率会将一些特定计算能力放在终端上，大部分的计算能力依然会放在</li>
<li>储存<br>
这块应该会在现有的大数据技术上提高更注重数据储存性能的技术，要求高吞吐量。对查询的要求应该会大幅度的降低。
<ul>
<li><a href="https://cassandra.apache.org/">cassandra</a> 一个简单运维适合存储大量数据组件</li>
<li>TSDB 非常适合物联网环境下，但是觉得我不适合物体联动，适合的是部分的场景</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>思考</tag>
        <tag>物联网</tag>
        <tag>闲聊</tag>
      </tags>
  </entry>
  <entry>
    <title>关于职业规划的思考</title>
    <url>/2018/04/16/rethink/think-in-occupation/</url>
    <content><![CDATA[<p>深受特劳特的《定位》影响，关于职业的规划更多的像是认知自己的过程。</p>
<span id="more"></span>
<h2 id="目录"><a class="header-anchor" href="#目录">¶</a>目录</h2>
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E5%9B%A0%E7%B4%A0">第一阶因素:内因</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E5%9B%A0%E7%B4%A0">第二阶因素:外因</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E5%9B%A0%E7%B4%A0">第三阶因素:其他</a></li>
<li><a href="#%E7%AE%97%E6%98%AF%E6%80%BB%E7%BB%93%E7%9A%84%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<h2 id="1-第一阶因素"><a class="header-anchor" href="#1-第一阶因素">¶</a>1. 第一阶因素</h2>
<p>最高阶的影响称之内因，内在要素，而我又觉得内因的三个核心要素分别是 <code>兴趣倾向</code> <code>性格特征</code> <code>职业理念</code></p>
<p>这三者的权重对于我来说大概为 2：1：1 ， 那剩下来的就是分析自己的这三个方面。</p>
<h4 id="1-0-性格特征"><a class="header-anchor" href="#1-0-性格特征">¶</a>1.0 性格特征</h4>
<p>怎么会突然冒出一个1.0 ，这个大概是我在写兴趣倾向的时候我突然发现自己也没有写性格就去做了兴趣倾向的选择，那我自己的性格特征是什么呢，人往往想不清楚自己的性格特征，当然性格如果直接拿出来说，是很不靠谱的也很难做表述，看一个是怎么样的一个人不应该看他说了什么，更应该是看他做了什么。</p>
<blockquote>
<p>我喜欢阅读很多社科类的数据，看电影更喜欢的是科幻。（喜欢发现，期待未来）</p>
<p>不注重于生活，感觉平时不是在写代码，就是在写代码的路上 - BY 飞哥。（执着，不知道如何平衡）</p>
<p>喜欢买书和键盘，耳机，外设。（物控）</p>
<p>热衷于抒发自己的观点。（外向）</p>
<p>演讲之前会很紧张，但是开始了就会变成的完全不紧张甚至于过热状态。</p>
</blockquote>
<p>这么梳理下来，我的性格特征大概是：</p>
<ul>
<li>执着且坚毅</li>
<li>热爱读书，不求甚解</li>
<li>愈战愈勇，易失理智</li>
<li>喜好专研，缺乏平衡</li>
<li>乐于分享，善于反思</li>
</ul>
<p>PS：喜欢整整齐齐的东西</p>
<h4 id="1-1-兴趣倾向"><a class="header-anchor" href="#1-1-兴趣倾向">¶</a>1.1 兴趣倾向</h4>
<blockquote>
<p>我大概在10岁的时候最喜欢做的事情是拆东西，经常拆电器和玩具，探寻它们的构造，直到遇见了游戏机，仿佛游戏更好玩些，再到后面的时间，迷恋起了计算机的硬件（可能是因为经常玩电脑游戏配置跟不上的原因），那是一个黄金的年代大概从2006年开始到2012年结束，这6年期间，对新的硬件对新的CPU型号，能够轻易分别2个CPU的性能差距，大概是12年开始，有了自己的真正长期使用的台式机，计算机的发展也开始变的慢，Intel变成了牙膏厂，对兴趣的中心从原来只是占20%的软件变成了80%的地位，高中的时候大概也就是看看《大众软件》，《黑客》这样的书籍，剩下不多的时间都花在了游戏上……</p>
</blockquote>
<p>究竟自己的兴趣内因是什么呢，这个问题我觉得其实没有一个准确的答案，世界上的事情千千万万，很多事情我也没尝试过，我也不知道自己的是不是会有另外一件事情比现在做的事情更喜欢，那是总是要分析出自己现在最喜欢的事情，那我现在觉得最有意思的事情是什么，现在的我大概给出的回答是：<strong>编写有意义的程序并被使用</strong></p>
<p>那个这个回答还是有些含糊，那究竟什么才是有意义的程序，我觉得一个有意义的程序应该包含两层的含义，第一层是这个软件本身是能够帮助别人去完成一项工作，另外一层含义这个软件本身应该也会给制作者本身带来正向的反馈，比如成就感，社区回馈等，如果一个代码虽然被大量的使用，但是作者本身也已经丢失了维护的信念，更好的选择是将软件回馈于社区，那这句话还有一半软件应该被使用，这像是如果制作一个永远不能上天的飞机，大概飞机自己也会觉得很难过吧。</p>
<p>如果仅仅是这样又仿佛说的太过于简单了，这种又很像是工作的需求，那为什么我会喜欢编写软件呢，我觉得软件本身的意义是在意分享能力，和修车，修灯一样的道理，我们将自己的所能掌握，而别人所不能掌握的能力以软件的方式分享出去，而恰好我又喜欢写软件，那为什么我会喜欢写软件而不是去修车，或者是修灯，或者是去修手机，看上去写软件的本质也差不多，那软件比其他的行业对我的吸引力在于<strong>创造</strong>，而我的骨子里仿佛刻着折腾不停歇的基因，我也喜欢乐高去自己组装产品但是我又对这些东西的原理有兴趣，源码面前了无秘密。</p>
<blockquote>
<p>兴趣和热情只能让你很执着，但并不一定能让你走好这条路，只有你的能力和你的强项才能让你走好这条路。By 《对程序员职业的一些建议》</p>
</blockquote>
<h4 id="1-2-职业理念"><a class="header-anchor" href="#1-2-职业理念">¶</a>1.2 职业理念</h4>
<p>我是怎么看待工作的，抛开工作可以赚钱这个属性来看，工作的意义对于我来说是<strong>分享</strong>和<strong>探索</strong>，那我们回到职业理念上来，我认为一副适合的我工作是应该可以分享的，分享自己的技能，分享自己的能力，甚至于分享自己的观点，让别人收益（可能教师是一个不错的选择），除此之外，我能够在职业中获取到真正有趣并值得探索的部分。工作本身和游戏又有点接近，我们需要去完成一个目标，在每一步前进的过程中可能会有金币，积分这样的奖励反馈，我们也会有要不断刷的痛苦无聊的过程，为了积累，最终达成我们的目标。</p>
<hr>
<p>如果高度概括自己的内因大概是 <code>创造</code> <code>分享</code> <code>探索</code></p>
<p>相对于本质固定论，我更相信人是在不断的迭代和求证的过程，行知合一才是人生应该遵循的道路，上面的一系列都是我的自己的抽象思考，更多的时候也需要在现实生活中反复验证求证。</p>
<hr>
<h2 id="2-第二阶因素"><a class="header-anchor" href="#2-第二阶因素">¶</a>2. 第二阶因素</h2>
<p>第一阶的因素是在确定我适合做什么，我想要做什么，我称之为内因，第二阶的因素我称之为外因，或者称之为<strong>外在成长驱动</strong>，大概有一下几个方面 <code>行业定位</code> <code>企业匹配</code> <code>成长路径</code></p>
<h4 id="2-1-行业定位"><a class="header-anchor" href="#2-1-行业定位">¶</a>2.1 行业定位</h4>
<p>80年-00年代都是桌面应用的黄金年代，从2000年后，计算机世界的重心已经变成了互联网，互联网更多的不仅仅是工具性的存在，是拉近了人和人的距离，从支付，购物，交流。但是现在再预测未来，那你会觉得世界的重心会从互联网变成另外一种存在吗？不会的，互联网会成为一个基础设施，我眼中的未来是<strong>IOT物联网</strong>，互联网拉近了人和人之间的距离，但是物体和人之间的距离还有充分值得被思考的余地。我觉得IOT的核心计算将和传统的互联网比起来有几个差异技术 <code>采集</code> <code>传输</code> <code>计算</code> <code>储存</code>，而我觉得最难以解决的还是储存，其他的部分都是瞬时的状态，而储存作为一个持久化的方案具有天然的复杂性。</p>
<ul>
<li>远离日暮西山的行业。</li>
</ul>
<h4 id="2-2-企业匹配"><a class="header-anchor" href="#2-2-企业匹配">¶</a>2.2 企业匹配</h4>
<p>应该选择怎么样的一个公司，选择公司的时候要结合自己的状态，如果你现在在一个方面专研的已经很深刻，但是对整个软件的上下游都不知道的话，那我觉得应该还是考虑去一个跨职能的部门或者也就是小型公司去了解上下游生态，反之就可以去专职的岗位。但是无论如何都应该去一个有价值的部门，一个公司可能有上百个工种，但是最有价值的职业并不会那么多。但是有一点是需要及早认知的，在<strong>中国</strong>小而精的公司是很少的（小而美的很多），如果你是想去锻炼自己的技术实力，大型点的平台对于你来说是一个不错的选择，而且学习也像是打游戏，只有和高阶玩家一起玩，你才能提高。但是如果想赚钱，那还是去创业吧 :dog:</p>
<p>关于公司的选择，其实现在主流的意见大概也就是 <code>创业公司</code> <code>大公司</code>的区别了，公司的业务模式也很大不同，但是很多时候其实没得选，本科阶段把我们培养的是通配的技能，或者说是一张白纸，你未来能够做什么也是很偶然的，对于我自己的定义的话，我在公司的前三年，在中小型公司渡过了，小型公司的优点在于灵活，但是其缺点也在于多变，往往你愿意在某一个层面投入更多的精力，但是公司本身又在快速的变化希望把你投身于完全不相关的一个领域，所以我认为在3-5年的这个阶段，在一个规模性的公司专研一门技术是一个不错的选择。</p>
<ul>
<li>做自己感兴趣的事情。</li>
<li>做有积累的事情。</li>
<li>一边走一边看，切勿一条道走到黑。</li>
</ul>
<h4 id="2-3-成长路径"><a class="header-anchor" href="#2-3-成长路径">¶</a>2.3 成长路径</h4>
<p>对于一个程序员来说，他的成长路径是在外界的评价中是这样的：</p>
<blockquote>
<p>程序员 -&gt; 高级程序员 -&gt; 技术专家 -&gt; 架构师 -&gt; 技术总监 -&gt; CTO</p>
</blockquote>
<p>但是这样的路线是很High Level的，没有人告诉你到底怎么才是一个高级程序员，才是一个技术专业，而且技术专业专攻的方面又不一样，架构师好像又差不多？</p>
<p>对于我自己来说我对自己的定义的成长路径是：</p>
<ul>
<li>
<p>工作 1 - 3 年</p>
<p>目标：完成程序员阶段的积淀</p>
<p>描述：能够完成任意的非强技术的模块的开发，代码能够清晰明了，在公司内可以独当一面的进行技术开发，这个阶段摸索探索自己想要去深入的方向，为未来做好积累。</p>
<p>回顾：此阶段完了一个通用性程序员的定义，了解工作使用的框架，语言等完成基础的积累，知道每一门技术背后的High Level原理。</p>
</li>
<li>
<p>工作 3 - 5 年 <strong>（当前阶段）</strong></p>
<p>目标：完成高级程序员的转型</p>
<p>描述：明白软件开发的不确定，思考问题的本质，并具有一门深入的技术能力，可以带领其他的初级程序员成长。</p>
<p>计划：这个阶段的核心是<code>思考</code> 和 <code>深入</code>，样样通不如一门精，我觉得现代软件的核心在于<code>网络</code> <code>储存</code>，这两个是最为难以搞定的事情，投入精力研究这两门技术，并思考为何他们能够做到这样。</p>
<blockquote>
<p>TODO: 需要学习的技术和框架，真实世界的实现，这块作为技术的目标单独补充。</p>
</blockquote>
</li>
<li>
<p>工作 5 - 7 年</p>
<p>目标：成为技术专家</p>
<p>描述：完成上一阶段的广度定义开始在一门技术上专精。</p>
</li>
<li>
<p>工作 7 - 9 年</p>
<p>目标：架构师 / 超技术专家</p>
<p>描述：在技术专家的基础上完成更广度的积累，成为架构师。亦或者完成超技术专家的转型，在一门技术上专精，超越90%的群体。</p>
</li>
</ul>
<p>在此之后的规划就很难预测了，如果能计划自己的十年后，我觉得大概可谓之神。</p>
<h4 id="2-4-成长螺旋"><a class="header-anchor" href="#2-4-成长螺旋">¶</a>2.4 成长螺旋</h4>
<p>人的进步就像是一个螺旋形，有一段时间的快速生长期有一段时间的潜伏阶段，喜欢 @李明 的观点，当可为时乘势而为，不可为时蛰伏待动。</p>
<h2 id="3-第三阶因素"><a class="header-anchor" href="#3-第三阶因素">¶</a>3. 第三阶因素</h2>
<p>第三阶更多像是软技能，那些很重要但是又不是本质性的问题，但是没有做好也会走很多的弯路。</p>
<ul>
<li>
<p>向上管理</p>
<p>如何通过有效的方法，处理好与上司之间的关系，以最大程度获取上司的信任，在工作上获得重用，以便将来获得更大的成长和晋升空间。这个在《定位》也涉及到，你得把自己放到那张核心员工的纸上。</p>
</li>
<li>
<p>社区影响</p>
<p>不一定是质量最好的产品会占据市场的主要份额，在广告里面有个 sound of marking，很多时候我们通过市场公关行为可以让别人感觉我们是一个热门（更好的）选择。</p>
</li>
</ul>
<h2 id="4-算是总结的总结"><a class="header-anchor" href="#4-算是总结的总结">¶</a>4. 算是总结的总结</h2>
<p>按照《原则》的说法，其中有一个观点，是我很喜欢的也愿意去实践的，极度求真和极度透明。就像是王守仁的行知合一，我们没办法去欺骗什么也不能因为一个只是高薪资而去做自己不喜欢的事情，真正的核心是人不仅仅对自己对别人也需要开放与透明，并且认知自己也是贯穿于人的一生的。</p>
<div style="display: none;">
2018/04/16 的时候我和一个长辈程序员lichengqian在上海中心聊了良久，他经历过很长的程序生涯，他在我这么大的时候会有一个困扰，不管你怎么努力投入的东西，在不就的将来都会消失或者被淘汰，那意义是什么？他在未来的日子里找到了自己的答案。我也在思考这个问题，对于我来说，本质上的我热爱的是与人交流沟通分享，这个亘古不变，那表现的形式总是会有具体的，我一直也想不出结果，突然回到家里想明白了点，正如我上午所言，很多时候，我们对于人生都是迭代循环的，每个阶段的我们热爱喜欢的东西都会变化，但是总是有一根暗色的线把他们串联在一起，那大概我找到了那根线。
</div>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ol>
<li><a href="https://book.douban.com/subject/6860890/">黑客:计算机革命的英雄(二十五周年新版)</a></li>
<li><a href="https://book.douban.com/subject/27608239/">原则</a></li>
<li><a href="https://book.douban.com/subject/27015138/">中产阶级如何保护自己的财富</a></li>
<li><a href="https://book.douban.com/subject/26835090/">软技能</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20449208">如何深度思考你的职业生涯</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22244832?refer=career001">还在按照兴趣选工作？</a></li>
<li><a href="https://coolshell.cn/articles/4561.html">对程序员职业的一些建议</a></li>
<li><a href="http://www.fox2008.cn/Article/List/31264.html">定位</a></li>
<li><a href="https://en.wikipedia.org/wiki/70/20/10_Model_(Learning_and_Development)">70/20/10 Model</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35608666">工程师如何在工作中提升自己?</a></li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>生活学习</category>
      </categories>
  </entry>
  <entry>
    <title>Go 擅长什么</title>
    <url>/2020/05/26/rethink/what-is-go-good-at/</url>
    <content><![CDATA[<p>Go 显然不是银弹，软件工程也没有银弹。为了搞清楚 Go 适合做什么，我们先看看Go的诞生。</p>
<span id="more"></span>
<blockquote>
<p>Go was designed atGooglein 2007 to improveprogramming productivityin an era of multicore, networked machines and large codebases.The designers wanted to address criticism of other languages in use atGoogle, but keep their useful characteristics:</p>
<ul>
<li>static typing and run-time efficiency (likeC++),</li>
<li>readability and usability (likePythonorJavaScript),</li>
<li>high-performance networking and multiprocessing.<br>
The designers were primarily motivated by their shareddislike of C++.</li>
</ul>
</blockquote>
<p>Go 在编程语言届里面也是一个新生儿了，从维基百科的短短几行里面我们可以发现，Go在诞生之初就是为了提高编程效率，但是侧重的点是 多核，网络，大型的源码管理。因此我们发现 Go 在实际的体验中，我们也常常用于构建高性能的分布式系统。在 Google 内部，Go 的诞生也是为了填平 C 与 Python 之间的鸿沟，正如定位所言，恰恰属于两者之间。</p>
<h1>良好的并发</h1>
<p>Go 是一个拥有良好并发资质的语言，我们可以轻易的通过 goroutine 写出简单可靠且高性能的应用，但是值得注意的是，Go并不是拥有极致并发能力的语言，因为对于他来说，始终有着两座大山：GC 与 goroutine，goroutine是一个简单的编程模型，但是并不是一个高性能的编程模式，callback &gt;= reactive &gt;= goroutine &gt; blocking，可以参考下 <a href="https://www.techempower.com/benchmarks/">techempower</a> 与 <a href="https://timyang.net/programming/c-erlang-java-performance/">c-erlang-java-performance</a> 实际上能够做到性能机制的依然需要2个致命的要素 <code>无GC</code> 与 <code>低线程切换</code></p>
<h1>泛型缺失</h1>
<p>这个问题已经不用再提及了，对于Google的工程师因为可能长时间的和 Bytes 打交道，对于OOP那套是无感的（实际上是类型系统的延展），因此反而带来了更多的负面性质，因为我们缺少了大量在 FP 中可以执行的操作符，比如 Map，Reduce，Filter。</p>
<h1>关于易读性</h1>
<p>我认为 Go 的可读写方向其实指 好读 而非 易读，举个例子</p>
<div class="tabs" id="快速排序"><ul class="nav-tabs"><li class="tab active"><a href="#快速排序-1">Haskell</a></li><li class="tab"><a href="#快速排序-2">Go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="快速排序-1"><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">quicksort</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]  </span><br><span class="line"><span class="title">quicksort</span> [] = []  </span><br><span class="line"><span class="title">quicksort</span> (x:xs) =   </span><br><span class="line">    <span class="keyword">let</span> smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x]  </span><br><span class="line">        biggerSorted = quicksort [a | a &lt;- xs, a &gt; x]  </span><br><span class="line">    <span class="keyword">in</span>  smallerSorted ++ [x] ++ biggerSorted  </span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="快速排序-2"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generates a slice of size, size filled with random numbers</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateSlice</span><span class="params">(size <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="type">int</span>, size, size)</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">		slice[i] = rand.Intn(<span class="number">999</span>) - rand.Intn(<span class="number">999</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quicksort</span><span class="params">(a []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(a)<span class="number">-1</span></span><br><span class="line">     </span><br><span class="line">    pivot := rand.Int() % <span class="built_in">len</span>(a)</span><br><span class="line">     </span><br><span class="line">    a[pivot], a[right] = a[right], a[pivot]</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt; a[right] &#123;</span><br><span class="line">            a[left], a[i] = a[i], a[left]</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    a[left], a[right] = a[right], a[left]</span><br><span class="line">     </span><br><span class="line">    quicksort(a[:left])</span><br><span class="line">    quicksort(a[left+<span class="number">1</span>:])</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p>从上文我们可以发现 Go 的易读其实相较于 C 进步一大步，而对于真正易读的语言又差了一大步。</p>
<h1>Go 擅长的地方</h1>
<h2 id="网络和Web服务器"><a class="header-anchor" href="#网络和Web服务器">¶</a>网络和Web服务器</h2>
<p>对于大部分人来说，Go能够编译出二进制运行文件 + 良好的并发控制，这简直是为了网络服务器和Web服务器的最佳选择，大家也是这么做的，我们使用Go作为Web服务器。</p>
<h2 id="自动化与命令行工作"><a class="header-anchor" href="#自动化与命令行工作">¶</a>自动化与命令行工作</h2>
<p>Go 是非常适合的自动化工具，对于Python，Java等需要依赖很重的运行时，因此Go既轻量级又快速，并且处理的相对简单的技术逻辑，在社区中已经有人尝试使用 Go 来取缔 Bash Script 对于大部分来说，想要抹平 Bash 在不同系统上的差异可能还真不如直接使用 Go，也替换了那一步 Python 用户。</p>
<h2 id="生产机代码的维护"><a class="header-anchor" href="#生产机代码的维护">¶</a>生产机代码的维护</h2>
<p>比如有 gofmt ，lint ，各种检查机制，这些和上面一种情况类型。</p>
<h1>Go 不擅长的地方</h1>
<h2 id="业务属性较多的地方"><a class="header-anchor" href="#业务属性较多的地方">¶</a>业务属性较多的地方</h2>
<p>无论是 ORM 框架，还是Web框架，Go社区相较于已经成熟的 Java 社区，都是造了一堆玩具状态，并不是不能很高效的进行业务开发。</p>
<h2 id="极限性能要求"><a class="header-anchor" href="#极限性能要求">¶</a>极限性能要求</h2>
<p>OS Kenerl，Banking，Game 这些领域依然不是带有GC的语言可以打入的领域。</p>
<h1>参考</h1>
<ul>
<li><a href="https://www.reddit.com/r/golang/comments/8bdewx/is_golang_a_good_choice_for_a_crud_based_rest_api/">Is Golang a good choice for a CRUD based ReST API?</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>思考</tag>
        <tag>Go</tag>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>我准备在2018学什么</title>
    <url>/2018/04/20/rethink/what-is-learn-in-2018/</url>
    <content><![CDATA[<h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2>
<p>在自己的<a href="http://blog.yannxia.top/2018/04/16/think-in-occupation/">职业规划</a>中我认为未来是属于物理网的，我觉得技术的核心在与 采集 传输 计算 储存，采集和我的原本的专业方向不是很匹配，我把自己定性为研究传输和储存，我决定从网络传输上开始学习。</p>
<span id="more"></span>
<h2 id="计划"><a class="header-anchor" href="#计划">¶</a>计划</h2>
<p>我所认识的中文系的网络大牛大概就是<a href="https://www.zhihu.com/people/giantchen/activities">陈硕</a>，参照他在参考2中所言，<br>
网络编程也可以分为三个层次:</p>
<ol>
<li>读过教程和文档</li>
<li>熟悉本系统 TCP/IP 协议栈的脾气</li>
<li>自己写过一个简单的 TCP/IP Stack</li>
</ol>
<p>我对网络编程的基础完全不了解，我应该站在0上面开始</p>
<p>给我自己定了一个小计划</p>
<ol>
<li>第一阶段<br>
阅读：《TCP/IP Illustrated, Vol. 1: The Protocols》<br>
阅读：《Unix Network Programming, Vol. 1: Networking API》<br>
抵达第一阶段，对网络编程构建自己的知识图谱</li>
</ol>
<blockquote>
<p>还是有点想看看 Computer Networking: A Top-Down Approach (6th Edition)，虽然好像被喷了烂书</p>
</blockquote>
<ol start="2">
<li>
<p>第二阶段<br>
阅读《Effective TCP/IP Programming》<br>
阅读 开源的网络组件库</p>
</li>
<li>
<p>第三阶段<br>
写一个简单的 TCP/IP stack （想起自己怎么也没写完的操作系统）</p>
</li>
</ol>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://coolshell.cn/articles/4990.html">程序员技术练级攻略</a></li>
<li><a href="https://blog.csdn.net/northcan/article/details/7270023">谈一谈网络编程学习经验</a></li>
<li><a href="http://beej.us/guide/bgnet/">Beej’s Guide to Network Programming</a></li>
</ol>
<p><img src="http://static.webhek.com/vaikan/uploads/2014/02/Programming-Books.jpg" alt="W"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>为何有些软件知识自学如此的困难</title>
    <url>/2020/06/28/rethink/why-learn-by-self-so-hard/</url>
    <content><![CDATA[<p>最近常常思考一个问题：</p>
<ul>
<li>什么是技术</li>
<li>什么又是核心竞争力</li>
</ul>
<p>我在 <a href="https://www.v2ex.com/t/684596">v2ex</a> 也问了这个，从大家的收藏的数量看起来大家也一定有一样的困扰。从别人那没有获得什么中肯的答案，多数答案都有像是解释，周末的时候在豆瓣上找到了那本书 <a href="https://book.douban.com/subject/25846075/">技术的本质</a>。</p>
<span id="more"></span>
<h1>什么是技术</h1>
<p>作者在开篇便指出了技术的三要素：</p>
<blockquote>
<p>技术的三个定义：<br>
• 技术是实现人的目的的一种手段。<br>
• 技术是实践和元器件的集成。<br>
• 技术是在某种文化中得以运用的装置和工程实践的集合。</p>
</blockquote>
<p>暂且不论第二点和第三点，技术需要目的性。这个很重要，而这个目的性决定了你又如何搞定这个技术。</p>
<h1>互联网的那些技术</h1>
<p>整合互联网能拿出来说的事情，主要以并发为主。比如阿里的双11等……<br>
他们的目标就很明确：解决XXX并发量的问题。当然随着并发量的增加我们还有很多其他的问题需要解决。可以参考 <a href="https://book.douban.com/subject/26998040/">尽在双11：阿里巴巴技术演进与超越</a></p>
<p>从任何技术上来说，规模化都是一个很重要的考量指标。</p>
<h1>为什么自学就很困难</h1>
<p>想想技术三要素，当我们自学的时候，我们的目标就发生了转变：从解决 XXX 并发量的问题 变成 我要学习别人怎么解决 XXX 并发量的问题，而我们自己是没有这样的需求的，这时候就是所谓的平台的作用性，平台为程序员提供了场合，程序也支持了平台。</p>
<p>我们非要在这个时候学习大厂，其实倒是有可能会画蛇添足，虽然大部分的时候其实画虎不成反类犬的结果。</p>
<h1>那应该怎么办</h1>
<p>最简单的办法莫过于去大平台，而除此之外，我们可以着眼于细微住处，除了并发量的考虑之外，我们还有像是 SQL解析 之类可以在小规模内就可以产生需求的问题，举个例子，比如我们在小平台，我们虽然没有大流量的压力，但是我们可以通过 <code>CodeReview</code> 提供代码质量。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>Actix &amp;#58 Rust 中 Actor 模型的实现</title>
    <url>/2020/09/12/rust/actix/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/09/12/1ZxkC.png" alt="1ZxkC.png"></p>
<p>我们聊完了 <code>Rust</code> 的异步编程框架，我们下来看看更加抽象的 <code>Actor</code> 模型的实现。</p>
<span id="more"></span>
<p>本文基于 <code>Actix-Core: 0.10.0</code></p>
<h2 id="Actor-模型"><a class="header-anchor" href="#Actor-模型">¶</a>Actor 模型</h2>
<p>关于什么是 <code>Actor</code> 模型，这里就不做展开了，可以参考 <a href="https://www.brianstorti.com/the-actor-model/#:~:text=The%20actor%20model%20is%20a,this%20model%20is%20probably%20Erlang%20.">The actor model in 10 minutes</a> 简而言之，我们使用消息传递信息，<code>Actor</code> 作为处理节点。</p>
<p><img src="https://s3.jpg.cm/2020/09/12/HGPu4.png" alt="HGPu4.png"></p>
<h2 id="初窥-Actix"><a class="header-anchor" href="#初窥-Actix">¶</a>初窥 Actix</h2>
<p>对于 <code>Actix</code> 来说我们去实现一个 <code>Actor</code> 非常的简单:</p>
<figure class="highlight rust"><figcaption><span>Example Ping</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> actix::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ping</span>(<span class="type">usize</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> <span class="keyword">for</span> <span class="title class_">Ping</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Result</span> = <span class="type">usize</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyActor</span> &#123;</span><br><span class="line">    count: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Actor</span> <span class="keyword">for</span> <span class="title class_">MyActor</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Context</span> = Context&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Handler</span>&lt;Ping&gt; <span class="keyword">for</span> <span class="title class_">MyActor</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Result</span> = <span class="type">usize</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">handle</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, msg: Ping, _: &amp;<span class="keyword">mut</span> Context&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Handler in &#123;:?&#125;&quot;</span>, thread::<span class="title function_ invoke__">current</span>().<span class="title function_ invoke__">id</span>());</span><br><span class="line">        <span class="keyword">self</span>.count += msg.<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">system</span> = System::<span class="title function_ invoke__">new</span>(<span class="string">&quot;single-arbiter-example&quot;</span>);</span><br><span class="line">    Arbiter::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="comment">// 启动一个 actor</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">addr</span> = MyActor &#123; count: <span class="number">10</span> &#125;.<span class="title function_ invoke__">start</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Arbiter in &#123;:?&#125;&quot;</span>, thread::<span class="title function_ invoke__">current</span>().<span class="title function_ invoke__">id</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = addr.<span class="title function_ invoke__">send</span>(<span class="title function_ invoke__">Ping</span>(<span class="number">10</span>)).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;RESULT: &#123;&#125;&quot;</span>, res.<span class="title function_ invoke__">unwrap</span>() == <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止系统退出</span></span><br><span class="line">        System::<span class="title function_ invoke__">current</span>().<span class="title function_ invoke__">stop</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    system.<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="author-div">
    <label class="author-mark-label">作者语</label>
    <p class="author-mark">这里和官方的不太一样进行了改造，这样比较容易方便后面的代码拆解。</p>
</div>
<p>我们随意的在 <code>handle</code> 函数中设置一个断点，看一下函数栈，熟悉的味道马上就涌上心头。函数栈底还是上次分析的 <code>Tokio</code>，因此对于 <code>Actix</code> 来说，最终的 <code>Runtime</code> 依然是基于 <code>Tokio</code> 的运行模型的。从 <code>Actor</code> 模型的模型的抽象来说最重要的模型莫过于 <code>Actor</code> 了，我们来看看这个运行逻辑的承载者是如何实现的。</p>
<h2 id="Actor-Impl"><a class="header-anchor" href="#Actor-Impl">¶</a>Actor Impl</h2>
<figure class="highlight rust"><figcaption><span>Actor</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Actor</span>: <span class="built_in">Sized</span> + Unpin + <span class="symbol">&#x27;static</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">start</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Addr&lt;<span class="keyword">Self</span>&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: Actor&lt;Context = Context&lt;<span class="keyword">Self</span>&gt;&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        Context::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">run</span>(<span class="keyword">self</span>) <span class="comment">// 构建上下文对象运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;A&gt; Context&lt;A&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    A: Actor&lt;Context = <span class="keyword">Self</span>&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(<span class="keyword">self</span>, act: A) <span class="punctuation">-&gt;</span> Addr&lt;A&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">fut</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">into_future</span>(act);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">addr</span> = fut.<span class="title function_ invoke__">address</span>();</span><br><span class="line">        actix_rt::<span class="title function_ invoke__">spawn</span>(fut);</span><br><span class="line">        addr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上文中，我们可以得到，对于将 <code>Actor</code> 转化为成一个 <code>Funture</code> 然后将其置于 <code>Runtime</code> 中进行处理，对于 <code>actix_rt::spawn(fut)</code> 处理大家可能会觉得比较复杂，其实是相对简单的。我们晚一点再过来看，我们继续看这个 <code>into_future(act)</code> 做了什么，其实也没做啥就是直接构建了 <code>ContextFut</code> 对象。</p>
<figure class="highlight rust"><figcaption><span>src/context.rs:111</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ContextFut</span>&lt;A, C&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    C: AsyncContextParts&lt;A&gt; + Unpin,</span><br><span class="line">    A: Actor&lt;Context = C&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    ctx: C,</span><br><span class="line">    act: A,</span><br><span class="line">    mailbox: Mailbox&lt;A&gt;,</span><br><span class="line">    wait: SmallVec&lt;[ActorWaitItem&lt;A&gt;; <span class="number">2</span>]&gt;,</span><br><span class="line">    items: SmallVec&lt;[Item&lt;A&gt;; <span class="number">3</span>]&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中最重要的某过于 <code>mailbox</code> 和 <code>act</code> 对象了，<code>act</code> -&gt; <code>actor</code> 本身，而 <code>mailbox</code> 使我们后续接收到的数据的一个管道，而在 <code>let addr = fut.address();</code> 返回的恰好就是 <code>mailbox</code> 的地址，那我们看看 <code>mailbox</code> 又是什么东西。</p>
<figure class="highlight rust"><figcaption><span>Mailbox AddressReceiver</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Mailbox</span>&lt;A&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    A: Actor,</span><br><span class="line">    A::Context: AsyncContext&lt;A&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    msgs: AddressReceiver&lt;A&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;A: Actor&gt; AddressSender&lt;A&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">send</span>&lt;M&gt;(&amp;<span class="keyword">self</span>, msg: M) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Receiver&lt;M::<span class="type">Result</span>&gt;, SendError&lt;M&gt;&gt; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">try_send</span>&lt;M&gt;(&amp;<span class="keyword">self</span>, msg: M, park: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), SendError&lt;M&gt;&gt; &#123;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">do_send</span>&lt;M&gt;(&amp;<span class="keyword">self</span>, msg: M) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), SendError&lt;M&gt;&gt; &#123;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">queue_push_and_signal</span>(&amp;<span class="keyword">self</span>, msg: Envelope&lt;A&gt;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">park</span>(&amp;<span class="keyword">self</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll_unparked</span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        do_park: <span class="type">bool</span>,</span><br><span class="line">        cx: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> task::Context&lt;<span class="symbol">&#x27;_</span>&gt;&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> Poll&lt;()&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>Mailbox</code> 只是 <code>AddressReceiver</code> 一个别名罢了，而 <code>AddressReceiver</code> 是什么，我们从 <code>Impl</code> 的函数签名中大概也就是能够明白了，提供一个可供外部发送数据的队列（src/address/channel.rs:Struct Inner）。此时我们对系统有个一个感性的认知：</p>
<p><img src="https://s3.jpg.cm/2020/09/15/Hd64E.png" alt="Hd64E.png"></p>
<p>我们此时知道了 <code>mailbox</code> 理论上承担了通讯的职能，那我们看看怎么工作的。</p>
<h2 id="Mailbox"><a class="header-anchor" href="#Mailbox">¶</a>Mailbox</h2>
<h3 id="Send-Message"><a class="header-anchor" href="#Send-Message">¶</a>Send Message</h3>
<p>发送的逻辑如下</p>
<figure class="highlight rust"><figcaption><span>AddressReceiver#Send</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">send</span>&lt;M&gt;(&amp;<span class="keyword">self</span>, msg: M) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Receiver&lt;M::<span class="type">Result</span>&gt;, SendError&lt;M&gt;&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    A: Handler&lt;M&gt;,</span><br><span class="line">    A::Context: ToEnvelope&lt;A, M&gt;,</span><br><span class="line">    M::<span class="type">Result</span>: <span class="built_in">Send</span>,</span><br><span class="line">    M: Message + <span class="built_in">Send</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = <span class="title function_ invoke__">sync_channel</span>(); <span class="comment">// 拿到 channel 对象（Sender 和 Receiver）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">env</span> = &lt;A::Context <span class="keyword">as</span> ToEnvelope&lt;A, M&gt;&gt;::<span class="title function_ invoke__">pack</span>(msg, <span class="title function_ invoke__">Some</span>(tx)); <span class="comment">// 创建一个 ENV 对象从 Tx 和 Msg 构建</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">queue_push_and_signal</span>(env); <span class="comment">// 将对象放置于 mailbox 队列之中</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(rx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送的逻辑也相对简单，在数据放置于 <code>queue</code> 之后，还做了一个事情  <code>self.signal();</code></p>
<figure class="highlight rust"><figcaption><span>AddressSender#singal</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">signal</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">recv_task</span> = <span class="keyword">self</span>.inner.recv_task.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> recv_task.unparked &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recv_task.unparked = <span class="literal">true</span>;</span><br><span class="line">        recv_task.task.<span class="title function_ invoke__">take</span>()</span><br><span class="line">    &#125;; <span class="comment">//获取到队列中的任务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = task &#123;</span><br><span class="line">        task.<span class="title function_ invoke__">wake</span>(); <span class="comment">//将其唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再次看到了我们熟悉的 <code>wake</code>，对于 <code>Funture</code> 的异步编程来说，我们需要做的事情，显然是在阻塞的过程中，将我们的任务重新唤醒。</p>
<h3 id="Recv-Message"><a class="header-anchor" href="#Recv-Message">¶</a>Recv Message</h3>
<p>刚刚我们瞧完了 <code>Send</code> 我们下面肯定看看 <code>Recv</code> 了。这段逻辑就相对复杂一些，显然这里涉及到我们任务的 <code>Park</code> 操作。</p>
<figure class="highlight rust"><figcaption><span>mailbox#poll</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">poll</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, act: &amp;<span class="keyword">mut</span> A, ctx: &amp;<span class="keyword">mut</span> A::Context, task: &amp;<span class="keyword">mut</span> task::Context&lt;<span class="symbol">&#x27;_</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.msgs.<span class="title function_ invoke__">poll_next_unpin</span>(task) &#123;  <span class="comment">//去 AddressReceiver 中获取数据</span></span><br><span class="line">            Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Some</span>(<span class="keyword">mut</span> msg)) =&gt; &#123;</span><br><span class="line">                not_ready = <span class="literal">false</span>;</span><br><span class="line">                msg.<span class="title function_ invoke__">handle</span>(act, ctx); <span class="comment">// 调用我们声明的 actor 的 handle 函数处理此消息</span></span><br><span class="line">            &#125;</span><br><span class="line">            Poll::<span class="title function_ invoke__">Ready</span>(<span class="literal">None</span>) | Poll::Pending =&gt; <span class="keyword">break</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心逻辑还是在 AddressReceiver 中</span></span><br><span class="line"><span class="keyword">impl</span>&lt;A: Actor&gt; Stream <span class="keyword">for</span> <span class="title class_">AddressReceiver</span>&lt;A&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = Envelope&lt;A&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll_next</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> task::Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">this</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">get_mut</span>();</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">msg</span> = <span class="keyword">match</span> this.<span class="title function_ invoke__">next_message</span>() &#123; <span class="comment">//去inner.message_queue.pop() 一个消息</span></span><br><span class="line">                Poll::<span class="title function_ invoke__">Ready</span>(msg) =&gt; msg,</span><br><span class="line">                Poll::Pending =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 如果没有数据，就尝试将此 cx 休眠掉，不过这里只是标记下状态，并非真正的去休眠线程</span></span><br><span class="line">                    <span class="keyword">match</span> this.<span class="title function_ invoke__">try_park</span>(cx) &#123;</span><br><span class="line">                        TryPark::Parked =&gt; &#123;</span><br><span class="line">                            <span class="keyword">return</span> Poll::Pending;</span><br><span class="line">                        &#125;</span><br><span class="line">                        TryPark::NotEmpty =&gt; &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Poll::<span class="title function_ invoke__">Ready</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于接受消息和发送消息都是内置的队列中获取数据即可，还是比较简单的。</p>
<h3 id="How-it-works"><a class="header-anchor" href="#How-it-works">¶</a>How it works</h3>
<p>那他们又是怎么串联在一起的呢？这个答案其实在最初的逻辑图中已经有所表达。我们将所有的内容放置于 <code>Context</code> 中，而创建出来的对象全称是 <code>ContextFut</code> 本身也是一个 <code>Future</code>对象，而转动齿轮的枢纽就在于此。在此之前我们先考虑一个场景，如果我们需要在 <code>handle_message</code> 中处理另外一个 <code>anysc task</code>呢？</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Handler</span>&lt;Ping&gt; <span class="keyword">for</span> <span class="title class_">MyActor</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Result</span> = <span class="type">usize</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">handle</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, msg: Ping, context: &amp;<span class="keyword">mut</span> Context&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::<span class="type">Result</span> &#123;</span><br><span class="line">        context.<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">            <span class="comment">//do other future task</span></span><br><span class="line">        &#125;.<span class="title function_ invoke__">into_actor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Handler in &#123;:?&#125;&quot;</span>, thread::<span class="title function_ invoke__">current</span>().<span class="title function_ invoke__">id</span>());</span><br><span class="line">        <span class="keyword">self</span>.count += msg.<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面一种场景，也是比较正常的，对于这样的逻辑，我们想要在 <code>Future</code> 嵌套的话，必须通过 <code>context.spawn()</code> 调用，而在此处进行创建的 <code>async task</code> 都会作为 <code>items</code> 数组中的一员。到这里我们再来看看 <code>ContextFut</code></p>
<figure class="highlight rust"><figcaption><span>ContextFut#poll</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;A, C&gt; Future <span class="keyword">for</span> <span class="title class_">ContextFut</span>&lt;A, C&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    C: AsyncContextParts&lt;A&gt; + Unpin,</span><br><span class="line">    A: Actor&lt;Context = C&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">this</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">get_mut</span>();</span><br><span class="line"></span><br><span class="line">        <span class="symbol">&#x27;outer</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="comment">// 处理接收到的消息，除非进入 stopping 状态 或者 wait 状态不为空</span></span><br><span class="line">            this.mailbox.<span class="title function_ invoke__">poll</span>(&amp;<span class="keyword">mut</span> this.act, &amp;<span class="keyword">mut</span> this.ctx, cx);</span><br><span class="line">            <span class="keyword">if</span> !this.wait.<span class="title function_ invoke__">is_empty</span>() &amp;&amp; !this.<span class="title function_ invoke__">stopping</span>() &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里处理在 Handle 中的 async 任务</span></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">idx</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> idx &lt; this.items.<span class="title function_ invoke__">len</span>() &amp;&amp; !this.<span class="title function_ invoke__">stopping</span>() &#123;</span><br><span class="line">                this.ctx.<span class="title function_ invoke__">parts</span>().handles[<span class="number">1</span>] = this.items[idx].<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">match</span> Pin::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">mut</span> this.items[idx].<span class="number">1</span>).<span class="title function_ invoke__">poll</span>(</span><br><span class="line">                    &amp;<span class="keyword">mut</span> this.act,</span><br><span class="line">                    &amp;<span class="keyword">mut</span> this.ctx,</span><br><span class="line">                    cx,</span><br><span class="line">                ) &#123;</span><br><span class="line">                    Poll::Pending =&gt; &#123;</span><br><span class="line">                        <span class="comment">// 如果任务依然是 Pending</span></span><br><span class="line">                        <span class="keyword">if</span> !this.wait.<span class="title function_ invoke__">is_empty</span>() &amp;&amp; !this.<span class="title function_ invoke__">stopping</span>() &#123;</span><br><span class="line">                            <span class="comment">// 移动到队列的尾部，保证调度的公平性</span></span><br><span class="line">                            <span class="keyword">let</span> <span class="variable">next</span> = this.items.<span class="title function_ invoke__">len</span>() - <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">if</span> idx != next &#123;</span><br><span class="line">                                this.items.<span class="title function_ invoke__">swap</span>(idx, next);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">continue</span> <span class="symbol">&#x27;outer</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            idx += <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Poll::<span class="title function_ invoke__">Ready</span>(()) =&gt; &#123;</span><br><span class="line">                        this.items.<span class="title function_ invoke__">swap_remove</span>(idx);</span><br><span class="line">                        <span class="comment">// 继续工作</span></span><br><span class="line">                        <span class="keyword">if</span> !this.wait.<span class="title function_ invoke__">is_empty</span>() &amp;&amp; !this.<span class="title function_ invoke__">stopping</span>() &#123;</span><br><span class="line">                            <span class="keyword">continue</span> <span class="symbol">&#x27;outer</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Poll::Pending;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里我们差不多又有了更多的对于 <code>Actor</code> 感官认知。</p>
<p><img src="https://s3.jpg.cm/2020/09/15/H6Gbf.png" alt="H6Gbf.png"></p>
<h2 id="Runtime"><a class="header-anchor" href="#Runtime">¶</a>Runtime</h2>
<p>为了支撑上层能够完成这样的功能，我们需要一个 <code>Runtime</code> 进行支撑，对于我们来说，我们在 <code>Demo</code> 中发现，我们一个 <code>Actor</code> 就会创建一个 <code>Context</code>，而一个  <code>Context</code> 如果就要使用一个 <code>Thread</code> 进行调度，那成本太过于高了。使用 <code>Tokio</code> 的也有多种 <code>Runtime</code> 可选，因此对于 <code>Actix</code> 实现来说，在此之上实现了一个轻量级的 <code>Runtime</code></p>
<figure class="highlight rust"><figcaption><span>actix-rt/src/runtime.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;Runtime&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rt</span> = runtime::Builder::<span class="title function_ invoke__">new</span>()</span><br><span class="line">            .<span class="title function_ invoke__">enable_io</span>()</span><br><span class="line">            .<span class="title function_ invoke__">enable_time</span>()</span><br><span class="line">            .<span class="title function_ invoke__">basic_scheduler</span>()</span><br><span class="line">            .<span class="title function_ invoke__">build</span>()?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Runtime &#123;</span><br><span class="line">            rt,</span><br><span class="line">            local: LocalSet::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>Actix</code> 构建使用的是 <code>basic_scheduler</code>，默认的 <code>Runtime</code> 只会跑在此时构建运行的线程上，不过对于这个 <code>Runtime</code>，<code>Actix</code> 还搭配了一个 <code>Arbiter</code> 对象。</p>
<h3 id="Arbiter"><a class="header-anchor" href="#Arbiter">¶</a>Arbiter</h3>
<p><code>Arbiter</code> 做什么用，主要有两点左右:  1. 用来停止 <code>Runtime</code> 2. 用来 <code>Spwan Task</code></p>
<h4 id="Stop-Runtime"><a class="header-anchor" href="#Stop-Runtime">¶</a>Stop Runtime</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">ArbiterController</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">mut</span> <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> Pin::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.rx).<span class="title function_ invoke__">poll_next</span>(cx) &#123;</span><br><span class="line">                Poll::<span class="title function_ invoke__">Ready</span>(<span class="literal">None</span>) =&gt; <span class="keyword">return</span> Poll::<span class="title function_ invoke__">Ready</span>(()),</span><br><span class="line">                Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Some</span>(item)) =&gt; <span class="keyword">match</span> item &#123; </span><br><span class="line">                    ArbiterCommand::Stop =&gt; &#123; <span class="comment">// 如果是 Stop 就向 停止队列发送数据</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(stop) = <span class="keyword">self</span>.stop.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                            <span class="keyword">let</span> <span class="variable">_</span> = stop.<span class="title function_ invoke__">send</span>(<span class="number">0</span>);</span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="keyword">return</span> Poll::<span class="title function_ invoke__">Ready</span>(());</span><br><span class="line">                    &#125;</span><br><span class="line">                    ArbiterCommand::<span class="title function_ invoke__">Execute</span>(fut) =&gt; &#123; <span class="comment">// 如果是任务就去调度任务</span></span><br><span class="line">                        <span class="keyword">let</span> <span class="variable">len</span> = PENDING.<span class="title function_ invoke__">with</span>(<span class="keyword">move</span> |cell| &#123; <span class="comment">//去Pending队列获取</span></span><br><span class="line">                            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = cell.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">                            p.<span class="title function_ invoke__">push</span>(tokio::task::<span class="title function_ invoke__">spawn_local</span>(fut));</span><br><span class="line">                            p.<span class="title function_ invoke__">len</span>()</span><br><span class="line">                        &#125;);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                Poll::Pending =&gt; <span class="keyword">return</span> Poll::Pending,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Spwan-task"><a class="header-anchor" href="#Spwan-task">¶</a>Spwan task</h4>
<p>对于 <code>Tokio runtime</code> 的 <code>spwan</code> 并没有向 <code>actix</code> 的用户开放，因此想要去创建新任务，需要调用 <code>Arbiter</code> 的 <code>spawn</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">spawn</span>&lt;F&gt;(future: F)</span><br><span class="line"><span class="keyword">where</span> F: Future&lt;Output = ()&gt; + <span class="symbol">&#x27;static</span> &#123;</span><br><span class="line">    RUNNING.<span class="title function_ invoke__">with</span>(<span class="keyword">move</span> |cell| &#123;</span><br><span class="line">        <span class="keyword">if</span> cell.<span class="title function_ invoke__">get</span>() &#123;</span><br><span class="line">            <span class="comment">// 创建任务置于 queue 之中</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">len</span> = PENDING.<span class="title function_ invoke__">with</span>(<span class="keyword">move</span> |cell| &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = cell.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">                p.<span class="title function_ invoke__">push</span>(tokio::task::<span class="title function_ invoke__">spawn_local</span>(future));</span><br><span class="line">                p.<span class="title function_ invoke__">len</span>()</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h2>
<p>本文意在给大家分析最小的 <code>Actix</code> 的运行机制，除本文之外 <code>Actor</code> 模型里面还有非常重要的 <code>Supervisor</code> 来维护 <code>Actor</code> 的生命周期尚未涉及，并且 <code>Actix-core</code> 意在提供的是单机的 <code>Actor</code> 的模型并没有像 <code>Akka</code> 这等全面，因为代码也相对较少较好理解。</p>
<blockquote>
<p>Have funny in rust proggamming</p>
</blockquote>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://www.brianstorti.com/the-actor-model/#:~:text=The%20actor%20model%20is%20a,this%20model%20is%20probably%20Erlang%20.">The actor model in 10 minutes</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rust</category>
        <category>async</category>
        <category>actor</category>
        <category>actix</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>async</tag>
        <tag>actor</tag>
        <tag>actix</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Dynamic Dispatching</title>
    <url>/2020/10/13/rust/dynamic-dispatch/</url>
    <content><![CDATA[<p><img src="https://n1.i5h5.com/2020/10/14/torLS.png" alt="torLS.png"></p>
<span id="more"></span>
<h2 id="举个例子"><a class="header-anchor" href="#举个例子">¶</a>举个例子</h2>
<p>假设我们有如下定义的一组对象。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Backend</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeA</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeB</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Backend</span> <span class="keyword">for</span> <span class="title class_">TypeA</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Backend</span> <span class="keyword">for</span> <span class="title class_">TypeB</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要构建一个 <code>Services</code> 列表，现在是很常规的操作。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Service</span> &lt;T: Backend&gt; &#123;</span><br><span class="line">    backend: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们具型化的时候会发现一个问题</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">backends</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">backends.<span class="title function_ invoke__">push</span>(TypeA);</span><br><span class="line">backends.<span class="title function_ invoke__">push</span>(TypeB);  <span class="comment">// &lt;---- 类型错误</span></span><br></pre></td></tr></table></figure>
<p>我们如果想要实现这样的机制需要这样操作</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">    backends: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Backend&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">backends</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">backends.<span class="title function_ invoke__">push</span>( <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(PositiveBackend&#123;&#125;) <span class="keyword">as</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Backend&gt;);</span><br><span class="line">backends.<span class="title function_ invoke__">push</span>( <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(NegativeBackend&#123;&#125;) <span class="keyword">as</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Backend&gt;);</span><br></pre></td></tr></table></figure>
<p>上诉的操作就称之为 “Dynamic Dispatching” 动态分发，我们在调用 Backend 之前并不知道他的类型。这也是实现多态的必要条件，不过这样的操作在运行时会有性能损失，为什么会有性能损耗，我们还是来探索一下。</p>
<h2 id="基线测试"><a class="header-anchor" href="#基线测试">¶</a>基线测试</h2>
<p>我们先看看静态分发的性能损耗。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::time::SystemTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PositiveBackend</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PositiveBackend</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">compute</span>(&amp;<span class="keyword">self</span>, number: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">        number + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">backend</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(PositiveBackend);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">res</span> = <span class="number">0</span> <span class="keyword">as</span> <span class="type">u64</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start_time</span> = SystemTime::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total</span> = <span class="number">20_000_000</span> <span class="keyword">as</span> <span class="type">u64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// our main loop</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..total &#123;</span><br><span class="line">        res += backend.<span class="title function_ invoke__">compute</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, res);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Elapsed_ms: &#123;&#125;&quot;</span>, start_time.<span class="title function_ invoke__">elapsed</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_millis</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在笔者的机器上的执行结果几乎不耗时（记得打开release）</p>
<figure class="highlight bash"><figcaption><span>debug</span></figcaption><table><tr><td class="code"><pre><span class="line">➜  learning git:(master) ✗ cargo run --release</span><br><span class="line">    Finished release [optimized] target(s) <span class="keyword">in</span> 0.02s</span><br><span class="line">     Running `target/release/learning`</span><br><span class="line"></span><br><span class="line">Result: 200000010000000</span><br><span class="line">Elapsed_ms: 0</span><br></pre></td></tr></table></figure>
<h2 id="静态分发"><a class="header-anchor" href="#静态分发">¶</a>静态分发</h2>
<h3 id="为什么静态分发这么快"><a class="header-anchor" href="#为什么静态分发这么快">¶</a>为什么静态分发这么快</h3>
<p>我们打开 <code>Hopper Disassembler</code> 对二进制文件进行分析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call       __ZN3std4time10SystemTime3now17h76cefb4014446fb3E ; System.now() 获得当前时间</span><br><span class="line">mov        qword [rbp+var_60], rax</span><br><span class="line">mov        qword [rbp+var_58], rdx</span><br><span class="line">movabs     rax, 0xb5e6218d1680  ; 0xb5e6218d1680 -&gt; 200000010000000 直接是计算好的结果</span><br><span class="line">mov        qword [rbp+var_50], rax</span><br><span class="line">lea        rax, qword [rbp+var_50]</span><br><span class="line">mov        qword [rbp+var_18], rax</span><br><span class="line">lea        rax, qword [__ZN4core3fmt3num3imp52_$LT$impl$u20$core..fmt..Display$u20$for$u20$u64$GT$3fmt17hb00db9d5e1e54df6E]</span><br><span class="line">mov        qword [rbp+var_10], rax</span><br><span class="line">lea        rax, qword [_anon.c8e953eae41e214c40f6f056fcde3153.0+80]</span><br></pre></td></tr></table></figure>
<p>对于编译器来说，在静态器已经知道的数据类型，和计算都可直接通过静态分析得到结果，而不用在运行时真正的再算一遍。</p>
<h3 id="Debug-为什么又这么慢"><a class="header-anchor" href="#Debug-为什么又这么慢">¶</a>Debug 为什么又这么慢</h3>
<p>我们如果运行在 <code>Debug</code> 模式下，结果又是另外一番。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  learning git:(master) ✗ cargo run               </span><br><span class="line">   Compiling learning v0.1.0 (/Users/yann/Codes/rust/learning)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.57s</span><br><span class="line">     Running `target/debug/learning`</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Elapsed_ms: 741</span><br></pre></td></tr></table></figure>
<p>还是打开我们的反编译器看看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loc_100003f2c: ; PositiveBackend:Compute 子函数</span><br><span class="line">0000000100003f49         call       __ZN8learning15PositiveBackend7compute17hbdcd6a613a6654c0E ; PositiveBackend  计算函数的调用</span><br><span class="line">0000000100003f4e         mov        qword [rbp+var_1A8], rax</span><br><span class="line">0000000100003f55         jmp        loc_100003f57</span><br><span class="line"></span><br><span class="line">loc_100003e20: ; For 循环子函数</span><br><span class="line">0000000100003e68         call       __ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h5ff7777380a60e23E ; _$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$::into_iter::h5ff7777380a60e23</span><br><span class="line">0000000100003e6d         mov        qword [rbp+var_170], rdx</span><br><span class="line">0000000100003e74         mov        qword [rbp+var_178], rax</span><br><span class="line">0000000100003e7b         jmp        loc_100003e7d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loc_100003eb5: 比较 total 是否满足</span><br><span class="line">0000000100003eb5         mov        rax, qword [rbp+var_188]                    ; CODE XREF=__ZN8learning4main17h9a9a004d32cb7481E+211</span><br><span class="line">0000000100003ebc         mov        qword [rbp+var_118], rax</span><br><span class="line">0000000100003ec3         mov        rcx, qword [rbp+var_180]</span><br><span class="line">0000000100003eca         mov        qword [rbp+var_110], rcx</span><br><span class="line">0000000100003ed1         mov        rdx, qword [rbp+var_118]</span><br><span class="line">0000000100003ed8         test       rdx, rdx</span><br><span class="line">0000000100003edb         je         loc_100003ee1</span><br></pre></td></tr></table></figure>
<p>对于 <code>Debug</code> 模式下，我们需要进循环体，因此我们将函数拆分了多段，并且通过 call/je 将程序组装起来，显然就是比直接结果 mov 进来要来的慢的多。</p>
<h2 id="动态分发"><a class="header-anchor" href="#动态分发">¶</a>动态分发</h2>
<p>我们将代码修改为如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::time::SystemTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Backend</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">compute</span>(&amp;<span class="keyword">self</span>,number: <span class="type">i64</span>) <span class="punctuation">-&gt;</span> <span class="type">i64</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PositiveBackend</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NegativeBackend</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Backend</span> <span class="keyword">for</span> <span class="title class_">PositiveBackend</span>&#123;</span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">compute</span>(&amp;<span class="keyword">self</span>,number: <span class="type">i64</span>) <span class="punctuation">-&gt;</span> <span class="type">i64</span>&#123;</span><br><span class="line">        number+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Backend</span> <span class="keyword">for</span> <span class="title class_">NegativeBackend</span>&#123;</span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">compute</span>(&amp;<span class="keyword">self</span>,number: <span class="type">i64</span>) <span class="punctuation">-&gt;</span> <span class="type">i64</span>&#123;</span><br><span class="line">        number-<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">backend</span> = <span class="keyword">match</span> env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>).<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(PositiveBackend ) <span class="keyword">as</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Backend&gt;,</span><br><span class="line">        _ =&gt; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(NegativeBackend) <span class="keyword">as</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Backend&gt;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">res</span>= <span class="number">0</span> <span class="keyword">as</span> <span class="type">i64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start_time</span> = SystemTime::<span class="title function_ invoke__">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total</span> = <span class="number">20_000_000</span> <span class="keyword">as</span> <span class="type">i64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span> .. total &#123;</span><br><span class="line">        res += backend.<span class="title function_ invoke__">compute</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>,res);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Elapsed_ms: &#123;&#125;&quot;</span>, start_time.<span class="title function_ invoke__">elapsed</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_millis</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    Finished release [optimized] target(s) <span class="keyword">in</span> 0.03s</span><br><span class="line">     Running `target/release/learning 1`</span><br><span class="line">Result: -20000002</span><br><span class="line">Elapsed_ms: 46</span><br></pre></td></tr></table></figure>
<p>这个时间和我们的 <code>Debug</code> 模式都差不多了。</p>
<h3 id="动态分发的实现"><a class="header-anchor" href="#动态分发的实现">¶</a>动态分发的实现</h3>
<p>对于大多数的编程语言 <code>Rust</code> <code>C++</code> 为了实现动态分发(多态的需求)，都采用了一种叫 <a href="https://en.wikipedia.org/wiki/Virtual_method_table"><code>vtable</code></a> 的技术。</p>
<p><img src="https://n1.i5h5.com/2020/10/14/toD44.png" alt="toD44.png"></p>
<p>对于 <code>Box&lt;dyn Trait&gt;</code> 我们至少需要 <code>2</code> 个 <code>Vtable</code> 这里我们就不看汇编了，我们看看 <code>汇编</code> 生成的伪代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">loc_100004aab:</span><br><span class="line">    r12 = *(r15 + <span class="number">0x18</span>);</span><br><span class="line">    r13 = <span class="number">0x0</span>;</span><br><span class="line">    rbx = <span class="number">0x0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">            rax = (r12)(<span class="number">0x1</span>, rbx);</span><br><span class="line">            rbx = rbx + <span class="number">0x1</span>;</span><br><span class="line">            r13 = rax + r13 * <span class="number">0x2</span>;</span><br><span class="line">            var_78 = r13;</span><br><span class="line">    &#125; <span class="title function_ invoke__">while</span> (rbx != <span class="number">0x1312d00</span>);</span><br><span class="line">    std::io::stdio::_print::<span class="title function_ invoke__">hdea2154009b9e479</span>(<span class="number">0x1000300b0</span>);</span><br><span class="line">    std::time::SystemTime::elapsed::<span class="title function_ invoke__">hd316930bad90c880</span>(<span class="number">0x1000300b0</span>, var_98);</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br></pre></td></tr></table></figure>
<p>现在这次编译出来的结果并没有直接优化成一个值，而是真的去 <code>loop</code> 了 <code>0x1312d00</code> 去计算，那是为什么呢？</p>
<p>答案和代码一体两证的可以发现。 <code>(r12)(0x1, rbx)</code> 是一个函数，而这 <code>r12</code> 就是我们动态代理的核心。</p>
<p>打开反汇编，很容易找到如下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000100004adc         mov        qword [rbp+var_98], rax</span><br><span class="line">0000000100004ae3         mov        qword [rbp+var_90], rdx</span><br><span class="line">0000000100004aea         mov        r12, qword [r15+0x18]</span><br><span class="line">0000000100004aee         xor        r13d, r13d</span><br><span class="line">0000000100004af1         xor        ebx, ebx</span><br><span class="line">0000000100004af3         nop        word [cs:rax+rax]</span><br><span class="line">0000000100004afd         nop        dword [rax]</span><br><span class="line"></span><br><span class="line">loc_100004b00: 循环计算子函数</span><br><span class="line">0000000100004b00         mov        edi, 0x1 ;  立即数 1</span><br><span class="line">0000000100004b05         mov        rsi, rbx</span><br><span class="line">0000000100004b08         call       r12  ; Backend:Compute 函数</span><br><span class="line">0000000100004b0b         inc        rbx</span><br><span class="line">0000000100004b0e         add        r13, rax</span><br><span class="line">0000000100004b11         mov        qword [rbp+var_78], r13</span><br><span class="line">0000000100004b15         cmp        rbx, 0x1312d00 ; 20000000 次循环</span><br><span class="line">0000000100004b1c         jne        loc_100004b00</span><br></pre></td></tr></table></figure>
<p>我们可以发现的核心的恰好就是 <code>r12</code> 这个寄存器中的地址，而如何判断具体应该调用哪一个呢？<code>r12</code> 是 <code>r15</code> + <code>0x18</code> 的固定片偏移而来。</p>
<p>为什么是 <code>0x18</code>？因为 <code>Vtable</code> 的第一部分是一个指向析构函数的 <code>Pointer</code>：<code>8bytes</code>，然后是两个 <code>64bit</code> 的数字是 <code>vtable</code> 的大小和对齐。然后才是我们的函数指向，因为我们只有一个函数，也就是 <code>index:0</code>，那刚好就是 <code>8 + 8 * 2 = 24 = 0x18</code>。</p>
<p>那 <code>r15</code> 是什么？我们从上面可以得知。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loc_1000049ec:</span><br><span class="line">00000001000049f7         lea        r15, qword [_anon.c8e953eae41e214c40f6f056fcde3153.0+80]</span><br><span class="line"></span><br><span class="line">loc_100004a14:</span><br><span class="line">0000000100004a1f         lea        r15, qword [_anon.c8e953eae41e214c40f6f056fcde3153.0+112]</span><br></pre></td></tr></table></figure>
<p>我们有2个子函数进行处理，究竟是 <code>80</code> 的偏移量还是 <code>112</code> 呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000001000049a2         call       __ZN73_$LT$std..env..Args$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h92f309c39800957bE ; 获得参数</span><br><span class="line">00000001000049a7         mov        rdi, qword [rbp+var_70]</span><br><span class="line">00000001000049ab         test       rdi, rdi ; 比较，也就是 match env::args().skip(1).next()</span><br><span class="line">00000001000049ae         je         loc_1000049ec ; goto +80 偏移量</span><br><span class="line"></span><br><span class="line">loc_1000049c0:</span><br><span class="line">00000001000049c0         mov        rsi, qword [rbp+var_68]</span><br><span class="line">00000001000049c4         inc        rbx</span><br><span class="line">00000001000049c7         je         loc_100004a14 ; goto +112 偏移量</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.jpg.cm/2020/10/14/t49aL.png" alt="t49aL.png"><br>
从调用流程上也很容易分析出来。</p>
<h3 id="动态分发的消耗"><a class="header-anchor" href="#动态分发的消耗">¶</a>动态分发的消耗</h3>
<p>根据 <a href="https://medium.com/digitalfrontiers/rust-dynamic-dispatching-deep-dive-236a5896e49b"></a> 测试的看来</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Iterating over 20M elements:</span><br><span class="line">----------------------------</span><br><span class="line">static dispatch:      64 ms</span><br><span class="line">dynamic dispatch:    216 ms</span><br></pre></td></tr></table></figure>
<p>动态分发还是会有不小的衰耗。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rust</category>
        <category>deep-dive</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>deep-dive</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Pin</title>
    <url>/2021/06/20/rust/rust-pin/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210620173801.png" alt=""></p>
<span id="more"></span>
<h2 id="为什么需要-Pin"><a class="header-anchor" href="#为什么需要-Pin">¶</a>为什么需要 Pin</h2>
<p>假如我们有一个对象定义如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    a: <span class="type">String</span>,</span><br><span class="line">    b: *<span class="keyword">const</span> <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(txt: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Test &#123;</span><br><span class="line">            a: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(txt),</span><br><span class="line">            b: std::ptr::<span class="title function_ invoke__">null</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">init</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">self_ref</span>: *<span class="keyword">const</span> <span class="type">String</span> = &amp;<span class="keyword">self</span>.a;</span><br><span class="line">        <span class="keyword">self</span>.b = self_ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">a</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.a</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">b</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(!<span class="keyword">self</span>.b.<span class="title function_ invoke__">is_null</span>(), <span class="string">&quot;Test::b called without Test::init being called first&quot;</span>);</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*(<span class="keyword">self</span>.b) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常规情况下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">test1</span> = Test::<span class="title function_ invoke__">new</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    test1.<span class="title function_ invoke__">init</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">test2</span> = Test::<span class="title function_ invoke__">new</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    test2.<span class="title function_ invoke__">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;&#125;, b: &#123;&#125;&quot;</span>, test1.<span class="title function_ invoke__">a</span>(), test1.<span class="title function_ invoke__">b</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;&#125;, b: &#123;&#125;&quot;</span>, test2.<span class="title function_ invoke__">a</span>(), test2.<span class="title function_ invoke__">b</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a: test1, b: test1</span><br><span class="line">a: test2, b: test2</span><br></pre></td></tr></table></figure>
<p>我们加上一个 <code>swap</code> 呢？</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">test1</span> = Test::<span class="title function_ invoke__">new</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    test1.<span class="title function_ invoke__">init</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">test2</span> = Test::<span class="title function_ invoke__">new</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    test2.<span class="title function_ invoke__">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;&#125;, b: &#123;&#125;&quot;</span>, test1.<span class="title function_ invoke__">a</span>(), test1.<span class="title function_ invoke__">b</span>());</span><br><span class="line">    std::mem::<span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> test1, &amp;<span class="keyword">mut</span> test2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;&#125;, b: &#123;&#125;&quot;</span>, test2.<span class="title function_ invoke__">a</span>(), test2.<span class="title function_ invoke__">b</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果答案就变成了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a: test1, b: test1</span><br><span class="line">a: test1, b: test2</span><br></pre></td></tr></table></figure>
<p>原因就是因为我们将对象的指针交换了，但是并没有保证内部引用 b 还是指向当前的自己。</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210620160333.png" alt=""></p>
<h2 id="解决之道"><a class="header-anchor" href="#解决之道">¶</a>解决之道</h2>
<p>显然我们需要保证 <code>b</code> 所指向的 <strong>Self</strong> 并不能被修改，因此 <code>Pin</code> 可以这么使用</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::marker::PhantomPinned;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    a: <span class="type">String</span>,</span><br><span class="line">    b: *<span class="keyword">const</span> <span class="type">String</span>,</span><br><span class="line">    _marker: PhantomPinned,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(txt: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Test &#123;</span><br><span class="line">            a: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(txt),</span><br><span class="line">            b: std::ptr::<span class="title function_ invoke__">null</span>(),</span><br><span class="line">            _marker: PhantomPinned, <span class="comment">// This makes our type `!Unpin`</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">init</span>&lt;<span class="symbol">&#x27;a</span>&gt;(<span class="keyword">self</span>: Pin&lt;&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">self_ptr</span>: *<span class="keyword">const</span> <span class="type">String</span> = &amp;<span class="keyword">self</span>.a;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">this</span> = <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.<span class="title function_ invoke__">get_unchecked_mut</span>() &#125;;</span><br><span class="line">        this.b = self_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">a</span>&lt;<span class="symbol">&#x27;a</span>&gt;(<span class="keyword">self</span>: Pin&lt;&amp;<span class="symbol">&#x27;a</span> <span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="title function_ invoke__">get_ref</span>().a</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">b</span>&lt;<span class="symbol">&#x27;a</span>&gt;(<span class="keyword">self</span>: Pin&lt;&amp;<span class="symbol">&#x27;a</span> <span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(!<span class="keyword">self</span>.b.<span class="title function_ invoke__">is_null</span>(), <span class="string">&quot;Test::b called without Test::init being called first&quot;</span>);</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*(<span class="keyword">self</span>.b) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们此时使用之前的代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">test1</span> = Test::<span class="title function_ invoke__">new</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">test1</span> = <span class="keyword">unsafe</span> &#123; Pin::<span class="title function_ invoke__">new_unchecked</span>(&amp;<span class="keyword">mut</span> test1) &#125;;</span><br><span class="line">    Test::<span class="title function_ invoke__">init</span>(test1.<span class="title function_ invoke__">as_mut</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">test2</span> = Test::<span class="title function_ invoke__">new</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">test2</span> = <span class="keyword">unsafe</span> &#123; Pin::<span class="title function_ invoke__">new_unchecked</span>(&amp;<span class="keyword">mut</span> test2) &#125;;</span><br><span class="line">    Test::<span class="title function_ invoke__">init</span>(test2.<span class="title function_ invoke__">as_mut</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;&#125;, b: &#123;&#125;&quot;</span>, Test::<span class="title function_ invoke__">a</span>(test1.<span class="title function_ invoke__">as_ref</span>()), Test::<span class="title function_ invoke__">b</span>(test1.<span class="title function_ invoke__">as_ref</span>()));</span><br><span class="line">    std::mem::<span class="title function_ invoke__">swap</span>(test1.<span class="title function_ invoke__">get_mut</span>(), test2.<span class="title function_ invoke__">get_mut</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;&#125;, b: &#123;&#125;&quot;</span>, Test::<span class="title function_ invoke__">a</span>(test2.<span class="title function_ invoke__">as_ref</span>()), Test::<span class="title function_ invoke__">b</span>(test2.<span class="title function_ invoke__">as_ref</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会输出如下错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/Users/yanick/.cargo/bin/cargo build --color=always --message-format=json-diagnostic-rendered-ansi --package helloworld --bin helloworld</span><br><span class="line">   Compiling helloworld v0.1.0 (/Users/yanick/Codes/rust/helloworld)</span><br><span class="line">error[E0277]: `PhantomPinned` cannot be unpinned</span><br><span class="line">  --&gt; src/main.rs:46:26</span><br><span class="line">   |</span><br><span class="line">46 |     std::mem::swap(test1.get_mut(), test2.get_mut());</span><br><span class="line">   |                          ^^^^^^^ within `Test`, the trait `Unpin` is not implemented <span class="keyword">for</span> `PhantomPinned`</span><br><span class="line">   |</span><br><span class="line">   = note: required because it appears within the <span class="built_in">type</span> `Test`</span><br><span class="line"></span><br><span class="line">error[E0277]: `PhantomPinned` cannot be unpinned</span><br><span class="line">  --&gt; src/main.rs:46:43</span><br><span class="line">   |</span><br><span class="line">46 |     std::mem::swap(test1.get_mut(), test2.get_mut());</span><br><span class="line">   |                                           ^^^^^^^ within `Test`, the trait `Unpin` is not implemented <span class="keyword">for</span> `PhantomPinned`</span><br><span class="line">   |</span><br><span class="line">   = note: required because it appears within the <span class="built_in">type</span> `Test`</span><br><span class="line"></span><br><span class="line">error: aborting due to 2 previous errors</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `helloworld`</span><br><span class="line">To learn more, run the <span class="built_in">command</span> again with --verbose.</span><br><span class="line">Process finished with <span class="built_in">exit</span> code 101</span><br></pre></td></tr></table></figure>
<p>从编译时期保证我们的指针不能够被移动。</p>
<h2 id="Pin-in-Asynchronous"><a class="header-anchor" href="#Pin-in-Asynchronous">¶</a>Pin in Asynchronous</h2>
<p>加入我们有个 两个 <code>funture</code> 任务</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AsyncFuture</span> &#123;</span><br><span class="line">    fut_one: FutOne,</span><br><span class="line">    fut_two: FutTwo,</span><br><span class="line">    state: State,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List of states our `async` block can be in</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    AwaitingFutOne,</span><br><span class="line">    AwaitingFutTwo,</span><br><span class="line">    Done,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">AsyncFuture</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">mut</span> <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span>.state &#123;</span><br><span class="line">                State::AwaitingFutOne =&gt; <span class="keyword">match</span> <span class="keyword">self</span>.fut_one.<span class="title function_ invoke__">poll</span>(..) &#123;</span><br><span class="line">                    Poll::<span class="title function_ invoke__">Ready</span>(()) =&gt; <span class="keyword">self</span>.state = State::AwaitingFutTwo,</span><br><span class="line">                    Poll::Pending =&gt; <span class="keyword">return</span> Poll::Pending,</span><br><span class="line">                &#125;</span><br><span class="line">                State::AwaitingFutTwo =&gt; <span class="keyword">match</span> <span class="keyword">self</span>.fut_two.<span class="title function_ invoke__">poll</span>(..) &#123;</span><br><span class="line">                    Poll::<span class="title function_ invoke__">Ready</span>(()) =&gt; <span class="keyword">self</span>.state = State::Done,</span><br><span class="line">                    Poll::Pending =&gt; <span class="keyword">return</span> Poll::Pending,</span><br><span class="line">                &#125;</span><br><span class="line">                State::Done =&gt; <span class="keyword">return</span> Poll::<span class="title function_ invoke__">Ready</span>(()),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在执行 <code>fut_one.poll</code> 时候并没有就绪，显然我们会继续执行 <code>fut_two</code></p>
<p>如果 <code>async</code> 中包含的执行体是这样的</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = [<span class="number">0</span>; <span class="number">128</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">read_into_buf_fut</span> = <span class="title function_ invoke__">read_into_buf</span>(&amp;<span class="keyword">mut</span> x);</span><br><span class="line">    read_into_buf_fut.<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译的时候，会进行转为为如下格式</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ReadIntoBuf</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    buf: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> [<span class="type">u8</span>], <span class="comment">// points to `x` below</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AsyncFuture</span> &#123;</span><br><span class="line">    x: [<span class="type">u8</span>; <span class="number">128</span>],</span><br><span class="line">    read_into_buf_fut: ReadIntoBuf&lt;<span class="symbol">&#x27;what_lifetime</span>?&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然 <code>ReadIntoBuf</code> 持有了 <code>AsyncFunture</code> 中的一个变量，如果 <code>Move</code> <code>AsyncFuture</code> 就会导致 <code>x</code> 失效。因此我们需要保证 <code>AsyncFuture</code> 不会被 <code>Move</code>（值得注意的这是一个编译期的保证）</p>
<p>在 <code>poll</code> 函数定义中，我们可以发现定义如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;futures_api&quot;</span>, since = <span class="string">&quot;1.36.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;F: ?<span class="built_in">Sized</span> + Future + Unpin&gt; Future <span class="keyword">for</span> &amp;<span class="keyword">mut</span> F &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = F::Output;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">mut</span> <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        F::<span class="title function_ invoke__">poll</span>(Pin::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">mut</span> **<span class="keyword">self</span>), cx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;futures_api&quot;</span>, since = <span class="string">&quot;1.36.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;P&gt; Future <span class="keyword">for</span> <span class="title class_">Pin</span>&lt;P&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    P: Unpin + ops::DerefMut&lt;Target: Future&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = &lt;&lt;P <span class="keyword">as</span> ops::Deref&gt;::Target <span class="keyword">as</span> Future&gt;::Output;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        Pin::<span class="title function_ invoke__">get_mut</span>(<span class="keyword">self</span>).<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">poll</span>(cx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不是一个 <code>Unpin</code> 的对象，我们就创建一个 <code>Pin</code> 来 <code>Poll</code>，最终都需要接受一个被 <code>Pin</code> 的任务来执行。</p>
<h2 id="参考文档"><a class="header-anchor" href="#参考文档">¶</a>参考文档</h2>
<ul>
<li><a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html">Asynchronous Programming in Rust - Pinning</a></li>
<li><a href="https://os.phil-opp.com/async-await/">async await</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rust</category>
        <category>deep-dive</category>
        <category>pin</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>deep-dive</tag>
        <tag>pin</tag>
      </tags>
  </entry>
  <entry>
    <title>解密 Rust 异步编程</title>
    <url>/2020/09/04/rust/understanding-rust-async/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/09/04/1E5E4.png" alt="1E5E4.png"></p>
<span id="more"></span>
<h2 id="Future"><a class="header-anchor" href="#Future">¶</a>Future</h2>
<p><code>Rust</code> 在实现异步编程的时候，采用 <code>Poll</code> 模型。最为核心的就是</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Poll</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ready</span>(T),</span><br><span class="line">    Pending,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个类型为 <code>Poll</code> 处于两种状态之一 <code>Ready</code> <code>Pending</code></p>
<ul>
<li>Ready: 我们已经完成了任务可以返回结果 T</li>
<li>Pending：此时我们等待一些其他依赖，这时候我们需要将自己占用的资源释放出来，基于一个 <code>wake()</code> 函数再次将自己唤醒</li>
</ul>
<p>最常见的就是 <code>Socket</code> 编程</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SocketRead</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    socket: &amp;<span class="symbol">&#x27;a</span> Socket,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SimpleFuture</span> <span class="keyword">for</span> <span class="title class_">SocketRead</span>&lt;<span class="symbol">&#x27;_</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;; <span class="comment">//返回值是一个 u8 的 bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, wake: <span class="title function_ invoke__">fn</span>()) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.socket.<span class="title function_ invoke__">has_data_to_read</span>() &#123;</span><br><span class="line">            <span class="comment">// 如果有数据直接返回 Ready 状态下可读的值</span></span><br><span class="line">            Poll::<span class="title function_ invoke__">Ready</span>(<span class="keyword">self</span>.socket.<span class="title function_ invoke__">read_buf</span>())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有数据就直接返回 Pending，等待数据，这里有一个 wake 函数等待被唤醒</span></span><br><span class="line">            <span class="keyword">self</span>.socket.<span class="title function_ invoke__">set_readable_callback</span>(wake);</span><br><span class="line">            Poll::Pending</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于多个 <code>Pollable</code> 的对象，组合在一起非常的合理，就和 <code>Java</code> 的 <code>ComposeFunture</code> 一样</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;FutureA, FutureB&gt; SimpleFuture <span class="keyword">for</span> <span class="title class_">Join</span>&lt;FutureA, FutureB&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    FutureA: SimpleFuture&lt;Output = ()&gt;,</span><br><span class="line">    FutureB: SimpleFuture&lt;Output = ()&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, wake: <span class="title function_ invoke__">fn</span>()) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="comment">// 尝试完成 A</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(a) = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.a &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Poll</span>::<span class="title function_ invoke__">Ready</span>(()) = a.<span class="title function_ invoke__">poll</span>(wake) &#123;</span><br><span class="line">                <span class="keyword">self</span>.a.<span class="title function_ invoke__">take</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 尝试完成 B</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(b) = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.b &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Poll</span>::<span class="title function_ invoke__">Ready</span>(()) = b.<span class="title function_ invoke__">poll</span>(wake) &#123;</span><br><span class="line">                <span class="keyword">self</span>.b.<span class="title function_ invoke__">take</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.a.<span class="title function_ invoke__">is_none</span>() &amp;&amp; <span class="keyword">self</span>.b.<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">            <span class="comment">// 都完成了就是 Ready</span></span><br><span class="line">            Poll::<span class="title function_ invoke__">Ready</span>(())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Poll::Pending</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Wakeup"><a class="header-anchor" href="#Wakeup">¶</a>Wakeup</h2>
<p>从上面的设计中可以发现，如果我们没有 <code>wake</code> 的话，我们只能一直的去轮训的获得是否已经 <code>Ready</code>，整体的效率会比较低，因此我们可以通过 <code>wake</code> 函数将其唤醒。<code>Rust</code> 中对于 <code>Wake</code> 的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">ArcWake</span>: <span class="built_in">Send</span> + <span class="built_in">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">wake</span>(<span class="keyword">self</span>: Arc&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">wake_by_ref</span>(&amp;<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于我们来说，我们需要的就是实现这个 wake_by_ref </span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">wake_by_ref</span>(arc_self: &amp;Arc&lt;<span class="keyword">Self</span>&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们假设一个超时的场景，在运行一段时间之后，我们需要将其唤醒。定义一个 <code>TimerFuture</code> 对象</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">TimerFuture</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(duration: Duration) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shared_state</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(SharedState &#123;</span><br><span class="line">            completed: <span class="literal">false</span>,</span><br><span class="line">            waker: <span class="literal">None</span>,</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动一个新的线程处理我们的状态量</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread_shared_state</span> = shared_state.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(duration);</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">shared_state</span> = thread_shared_state.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="comment">// Thread Sleep 够了就算是超时了，这时候我们需要 wake 我们的工作对象了</span></span><br><span class="line">            shared_state.completed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(waker) = shared_state.waker.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                waker.<span class="title function_ invoke__">wake</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        TimerFuture &#123; shared_state &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Executor"><a class="header-anchor" href="#Executor">¶</a>Executor</h2>
<p>上面只是提供了机制，我们还需要执行的本体，<code>Rust</code> 抽象了 <code>Executor</code> 出来</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    ready_queue: Receiver&lt;Arc&lt;Task&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Spawner</span> &#123;</span><br><span class="line">    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Spawner</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">spawn</span>(&amp;<span class="keyword">self</span>, future: <span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output=()&gt; + <span class="symbol">&#x27;static</span> + <span class="built_in">Send</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">future</span> = future.<span class="title function_ invoke__">boxed</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">task</span> = Arc::<span class="title function_ invoke__">new</span>(Task &#123;</span><br><span class="line">            future: Mutex::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Some</span>(future)),</span><br><span class="line">            task_sender: <span class="keyword">self</span>.task_sender.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">self</span>.task_sender.<span class="title function_ invoke__">send</span>(task).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;too many tasks queued&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Ok</span>(task) = <span class="keyword">self</span>.ready_queue.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">            <span class="comment">// 阻塞结束，完成了一部分的请求数据</span></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">future_slot</span> = task.future.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">mut</span> future) = future_slot.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                <span class="comment">// 创建一个 Waker，将这个任务本体放入</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">waker</span> = <span class="title function_ invoke__">waker_ref</span>(&amp;task);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">context</span> = &amp;<span class="keyword">mut</span> Context::<span class="title function_ invoke__">from_waker</span>(&amp;*waker);</span><br><span class="line">                <span class="comment">// 尝试poll一次，如果是 Pending</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Poll</span>::Pending = future.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">poll</span>(context) &#123;</span><br><span class="line">                    *future_slot = <span class="title function_ invoke__">Some</span>(future);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是有点懵，先不慌，我们看看怎么用的。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (executor, spawner) = <span class="title function_ invoke__">new_executor_and_spawner</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们向 executor 扔一个任务，其实这里就扔到了 ready_queue 的队列中</span></span><br><span class="line">    spawner.<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;howdy!&quot;</span>);</span><br><span class="line">        <span class="comment">// Wait for our timer future to complete after two seconds.</span></span><br><span class="line">        TimerFuture::<span class="title function_ invoke__">new</span>(Duration::<span class="title function_ invoke__">new</span>(<span class="number">2</span>, <span class="number">0</span>)).<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;done!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里会直接运行</span></span><br><span class="line">    executor.<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过我们在此之前，我们需要定义好如下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    future: Mutex&lt;<span class="type">Option</span>&lt;BoxFuture&lt;<span class="symbol">&#x27;static</span>, ()&gt;&gt;&gt;,</span><br><span class="line">    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ArcWake</span> <span class="keyword">for</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">wake_by_ref</span>(arc_self: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cloned</span> = arc_self.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        arc_self.task_sender.<span class="title function_ invoke__">send</span>(cloned).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;too many tasks queued&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会发现实际上我们最终 <code>wake</code> 起来的还是我们自己，我们只是在控制 <code>wake</code> 的方式。</p>
<h2 id="How-it-Work"><a class="header-anchor" href="#How-it-Work">¶</a>How it Work</h2>
<p><img src="https://s3.jpg.cm/2020/09/04/1En6G.png" alt="1En6G.png"></p>
<p>核心的逻辑是，我们接收到这个任务，将其放置于我们的 <code>Task Queue</code> 中</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">spawner.<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> &#123; <span class="comment">// 这个 socpe 就是 Task</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;howdy!&quot;</span>);</span><br><span class="line">    TimerFuture::<span class="title function_ invoke__">new</span>(Duration::<span class="title function_ invoke__">new</span>(<span class="number">2</span>, <span class="number">0</span>)).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;done!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个任务此时还没有 <code>wake</code> 对象，我们为其创建 <code>Context</code> 对象（抽象规定的，我们需要将 Wake 置于其中），并且创建一个 <code>wake</code> 对象，而实际上 <code>wake</code> 对象仅仅是是这个 <code>Task</code> 本身。</p>
<p>因此当我们进入 <code>TimerFuture</code> 的 <code>Poll</code> 函数的时候，我们就已经在等待 <code>2</code> 秒之后，<code>Wake</code> 触发如下逻辑</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">wake_by_ref</span>(arc_self: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cloned</span> = arc_self.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    arc_self.task_sender.<span class="title function_ invoke__">send</span>(cloned).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;too many tasks queued&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，我们只不过又将我们的任务又 <code>Re submit</code> 到我们的任务 <code>Task Queue</code> 去了，此时我们再将整个 <code>Thread</code> 的工作给重新唤醒进行处理即可。</p>
<hr>
<p>线程的变化为</p>
<p><img src="https://s3.jpg.cm/2020/09/04/1El06.png" alt="1El06.png"></p>
<p>参考源码: <a href="https://gist.github.com/yanickxia/270784bc004cb4c0a7b28b13ac9f2aba">https://gist.github.com/yanickxia/270784bc004cb4c0a7b28b13ac9f2aba</a></p>
<h2 id="Wake-in-real-world"><a class="header-anchor" href="#Wake-in-real-world">¶</a>Wake in real world</h2>
<p>在真正的编程中，如果都是基于每一次启动一个线程会显得很不高效，因此一般都是基于信号来处理。<br>
因此对于 <code>socket</code> 来说</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Socket</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_readable_callback</span>(&amp;<span class="keyword">self</span>, waker: Waker) &#123;</span><br><span class="line">        <span class="comment">//这里其实就是 eventloop</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">local_executor</span> = <span class="keyword">self</span>.local_executor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此socket 的id</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">id</span> = <span class="keyword">self</span>.id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将需要监听的事件放入 eventloop 里面，等待 eventloop 回调</span></span><br><span class="line">        local_executor.event_map.<span class="title function_ invoke__">insert</span>(id, waker);</span><br><span class="line">        local_executor.<span class="title function_ invoke__">add_io_event_interest</span>(</span><br><span class="line">            &amp;<span class="keyword">self</span>.socket_file_descriptor,</span><br><span class="line">            Event &#123; id, signals: READABLE &#125;,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的，本篇博客意在指出 <code>Funture</code> 的抽象机制是如何运行的，对于真正的系统比如 <code>tokio</code> 在实现 <code>Executor</code> 会比我们现在所设计的要复杂的多。</p>
<h2 id="Wake是如何真正工作的"><a class="header-anchor" href="#Wake是如何真正工作的">¶</a>Wake是如何真正工作的</h2>
<p>比如我们又如下一个场景的代码</p>
<figure class="highlight rust"><figcaption><span>example</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">example</span>(min_len: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; ➊ </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = <span class="title function_ invoke__">async_read_file</span>(<span class="string">&quot;foo.txt&quot;</span>).<span class="keyword">await</span>; ➋</span><br><span class="line">    <span class="keyword">if</span> content.<span class="title function_ invoke__">len</span>() &lt; min_len &#123;</span><br><span class="line">        content + &amp;<span class="title function_ invoke__">async_read_file</span>(<span class="string">&quot;bar.txt&quot;</span>).<span class="keyword">await</span> ➌</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        content </span><br><span class="line">    &#125;</span><br><span class="line">    ➍</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可能在 <code>async_read_file(&quot;foo.txt&quot;)</code> 和 <code>async_read_file(&quot;bar.txt&quot;)</code> 这两个函数处都进入 <code>Pending</code> 状态，我们势必要保存 <code>example</code> 这个函数的运行状态，再一次唤醒的时候，我们要从处理过的地方再处理下去。</p>
<h3 id="保存状态"><a class="header-anchor" href="#保存状态">¶</a>保存状态</h3>
<p>对于 <code>Rust</code> 来说，保存状态是在 <code>编译期</code> 完成的。对于上面的代码来说，编译器会生成如下代码:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器生成代码，举个例子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StartState</span> &#123;  <span class="comment">//➊ 初始化状态，有一个min_len变量状态</span></span><br><span class="line">    min_len: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WaitingOnFooTxtState</span> &#123; <span class="comment">//➋ 等待执行 Foo.txt 读取时的上下文状态</span></span><br><span class="line">    min_len: <span class="type">usize</span>,</span><br><span class="line">    foo_txt_future: <span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output = <span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WaitingOnBarTxtState</span> &#123; <span class="comment">//➌ 等待执行 Bar.txt 读取时的上下文状态</span></span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">    bar_txt_future: <span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output = <span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EndState</span> &#123;&#125; <span class="comment">//➍ 结束状态</span></span><br></pre></td></tr></table></figure>
<p>很容易理解，在函数入口的地方 ➊，我们只有一个变量也就是 <code>min_len</code>，在执行 <code>async_read_file(&quot;foo.txt&quot;)</code> 的时候 ➋ ，我们从下文中可以捕捉到的变量也只有 <code>min_len</code> 还有就是我们调用的 <code>Futrue</code> 对象了，➌ 处的话，从返回值判断可知 <code>min_len</code> 已经无用了，因此在此时需要关注的变量是 <code>context</code>。</p>
<p>因此我们把这些状态想象成一个有限状态的自动机，可以定下如下状态</p>
<figure class="highlight rust"><figcaption><span>ExampleStateMachine</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ExampleStateMachine</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Start</span>(StartState),</span><br><span class="line">    <span class="title function_ invoke__">WaitingOnFooTxt</span>(WaitingOnFooTxtState),</span><br><span class="line">    <span class="title function_ invoke__">WaitingOnBarTxt</span>(WaitingOnBarTxtState),</span><br><span class="line">    <span class="title function_ invoke__">End</span>(EndState),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于如上状态，我们将 <code>State Machine</code> 变成 <code>Future</code></p>
<figure class="highlight rust"><figcaption><span>ExampleStateMachine</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">ExampleStateMachine</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>; <span class="comment">// 返回值类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span> &#123; </span><br><span class="line">                ExampleStateMachine::<span class="title function_ invoke__">Start</span>(state) =&gt; &#123;…&#125;</span><br><span class="line">                ExampleStateMachine::<span class="title function_ invoke__">WaitingOnFooTxt</span>(state) =&gt; &#123;…&#125;</span><br><span class="line">                ExampleStateMachine::<span class="title function_ invoke__">WaitingOnBarTxt</span>(state) =&gt; &#123;…&#125;</span><br><span class="line">                ExampleStateMachine::<span class="title function_ invoke__">End</span>(state) =&gt; &#123;…&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="状态转换"><a class="header-anchor" href="#状态转换">¶</a>状态转换</h3>
<p>那我们来填充下 <code>Start</code> 函数</p>
<figure class="highlight rust"><figcaption><span>Start</span></figcaption><table><tr><td class="code"><pre><span class="line">ExampleStateMachine::<span class="title function_ invoke__">Start</span>(state) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">foo_txt_future</span> = <span class="title function_ invoke__">async_read_file</span>(<span class="string">&quot;foo.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// `.await` 操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">state</span> = WaitingOnFooTxtState &#123;</span><br><span class="line">        min_len: state.min_len,</span><br><span class="line">        foo_txt_future,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 修改状态到 WaitingOnFooTxt</span></span><br><span class="line">    *<span class="keyword">self</span> = ExampleStateMachine::<span class="title function_ invoke__">WaitingOnFooTxt</span>(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>Start</code> 不存在阻塞的问题，直接进入了下一个状态。我们来看看复杂点的 <code>WaitingOnFooTxt</code></p>
<figure class="highlight rust"><figcaption><span>ExampleStateMachine::WaitingOnFooTxt</span></figcaption><table><tr><td class="code"><pre><span class="line">ExampleStateMachine::<span class="title function_ invoke__">WaitingOnFooTxt</span>(state) =&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> state.foo_txt_future.<span class="title function_ invoke__">poll</span>(cx) &#123; <span class="comment">// 执行 async_read_file(&quot;foo.txt&quot;) 逻辑 </span></span><br><span class="line">        Poll::Pending =&gt; <span class="keyword">return</span> Poll::Pending, <span class="comment">// Pending 直接返回</span></span><br><span class="line">        Poll::<span class="title function_ invoke__">Ready</span>(content) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> content.<span class="title function_ invoke__">len</span>() &lt; state.min_len &#123; <span class="comment">// if 分支命中</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">bar_txt_future</span> = <span class="title function_ invoke__">async_read_file</span>(<span class="string">&quot;bar.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// `.await` 操作</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">state</span> = WaitingOnBarTxtState &#123;</span><br><span class="line">                    content,</span><br><span class="line">                    bar_txt_future,</span><br><span class="line">                &#125;;</span><br><span class="line">                *<span class="keyword">self</span> = ExampleStateMachine::<span class="title function_ invoke__">WaitingOnBarTxt</span>(state); <span class="comment">// 进入 WaitingOnBarTxt 状态</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// if 未命中直接进入 END 状态</span></span><br><span class="line">                *<span class="keyword">self</span> = ExampleStateMachine::<span class="title function_ invoke__">End</span>(EndState));</span><br><span class="line">                <span class="keyword">return</span> Poll::<span class="title function_ invoke__">Ready</span>(content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们很容易整理出来这张图<br>
<img src="https://s3.jpg.cm/2020/09/17/HU9f4.png" alt="HU9f4.png"></p>
<p>因此对于 <code>Rust</code> 来说，编译器会帮我在每一个 <code>.await</code> 处进行上下文的捕获，生成一个状态 <code>Struct</code>，因此我们申明的 <code>async fn</code> 在编译完成之后就变成一个 <code>state machine</code>，因此此阶段并不是通过 <code>OS</code> 保存 <code>Thread</code> 信息来完成了，而所有的信息都在我们的 <code>Future</code> 已经全部包含了，直接拿出来继续执行即可了，不需要传统的上保存下状态。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://rust-lang.github.io/async-book">async-book</a></li>
<li><a href="https://os.phil-opp.com/async-await/">async-await</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rust</category>
        <category>async</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title>博客建站日常备忘录</title>
    <url>/2022/09/14/site/site/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2022/202209141410061.png" alt=""></p>
<p>记录下博客建站的一些日常事务。</p>
<span id="more"></span>
<h2 id="CDN-选择"><a class="header-anchor" href="#CDN-选择">¶</a>CDN 选择</h2>
<p>因为大多数还是中文阅读者，还是把博客挂载国内的CDN上，现在使用 <a href="https://www.upyun.com/league">又拍云联盟</a> 非常的好用，因为还有对象储存&amp;CDN，这样直接部署上去就好了。</p>
<h3 id="图床选择"><a class="header-anchor" href="#图床选择">¶</a>图床选择</h3>
<p>图片和文章还是分开了，之前用过公益图床比如 <code>路过</code>, <code>sm.ms</code> 感觉很多都会倒闭，现在的图片是放在 <code>github repo</code> 中，使用 <a href="https://statically.io/">statically</a> 提供的 <code>https://cdn.staticaly.com</code></p>
<p>还有一部分图片放在了 CDN 上。七牛，又怕云，腾讯都有。<br>
最近在调研的是 <a href="https://vercel.com/">vercel</a></p>
<h3 id="上传工具"><a class="header-anchor" href="#上传工具">¶</a>上传工具</h3>
<p>使用的是 <a href="https://picgo.github.io/PicGo-Doc/en/guide/"><code>picgo</code></a> 值得注意是因为 CDN 除了国内的，其他都比较慢，而且流量收费，最好压缩下，使用的是 <a href="https://www.npmjs.com/package/picgo-plugin-compress">compress</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>site</category>
        <category>blog</category>
      </categories>
      <tags>
        <tag>site</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>2016 技术总结</title>
    <url>/2017/01/01/times/bye-2016/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2016年过去了，我却不怀念过去的这一年。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1>目录</h1>
<ul>
<li><a href="#%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88">在做什么</a></li>
<li><a href="#%E5%AD%A6%E4%BA%86%E4%BB%80%E4%B9%88">学了什么</a></li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8">项目列表</a></li>
</ul>
<h2 id="在做什么"><a class="header-anchor" href="#在做什么">¶</a>在做什么</h2>
<p>2016年都在麻袋理财，大部分的时间都在写“麻袋理财”的账务核心，大概也就是怎么算钱，还记得去年做的生息宝，今年好像就没有做什么比较重量级的东西了。<br>
除此之外，也就是写了一些小项目，给明哥的区块链写了一个基本的管理系统，这个也挺愚蠢的，回头还顺带着升级了一个V2，不过现在的Owner已经转给小火了。<br>
这一年，跟着书，从零开始写JDK，没写完，不知道怎么的就放弃了。</p>
<h2 id="学了什么"><a class="header-anchor" href="#学了什么">¶</a>学了什么</h2>
<h4 id="一点点Docker"><a class="header-anchor" href="#一点点Docker">¶</a>一点点Docker</h4>
<p>写了一点点Docker，搞了一些简单的Sample</p>
<h4 id="学了一点区块链"><a class="header-anchor" href="#学了一点区块链">¶</a>学了一点区块链</h4>
<h4 id="学了一点Haskell"><a class="header-anchor" href="#学了一点Haskell">¶</a>学了一点Haskell</h4>
<h4 id="学了一点JVM"><a class="header-anchor" href="#学了一点JVM">¶</a>学了一点JVM</h4>
<h2 id="项目列表"><a class="header-anchor" href="#项目列表">¶</a>项目列表</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我负责挖坑，从来不负责填坑。</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/UUID-XSH/done-core">Done时间管理</a> [持续更新]</li>
<li><a href="">30days-os 30天从零写OS</a> [没写完，看上去貌似已经不想填坑]</li>
<li><a href="">xRaft</a> [Raft的实现，挖坑未填]</li>
<li><a href="">json-parse</a> [Json解析器，挖坑未填]</li>
<li><a href="">pank</a> [平板撑Android记时，差不多填完]</li>
<li>其他</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>2019的学习计划</title>
    <url>/2019/02/15/times/what-is-to-learn-in-2019/</url>
    <content><![CDATA[<p><code>2018</code>我准备学什么，还是在恬不知耻的活在首页，我现在就开始想着我<code>2019</code>学什么了。终归学点东西总是比点计划没有的好点，至于如果什么都没学会，大概来年又能写下相同的话。</p>
<span id="more"></span>
<h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2>
<p>2018 年什么火？大概上半年是区块链的天下，而下半年是资本寒冬的口号，倘若不能很好的猜准未来的方向，大概也没办法赶上未来的浪潮吧。所以今年的计划还是多了一个章节，我先预测下未来的技术发展吧。</p>
<h2 id="猜想"><a class="header-anchor" href="#猜想">¶</a>猜想</h2>
<p>首先，今年由国内的<code>PingCAP</code> 和 <code>秘猿科技</code> 协调主办了 <a href="https://rustcon.asia/"><code>第一届亚洲 Rust 开发者大会</code></a>，这个在最近几年都是一个前后，前几年最为流行的技术，比如<code>Docker</code> <code>BlockChain</code> 国内都几乎都在应用层倒腾，而现在我们有机会可以参与到一个开源语言最为初期的重量级活动中，就和国内<code>七牛</code>利用早期<code>Go</code>语言成功完成了一个技术公司的标杆，而<code>PingCAP</code>则重新走过那条成功之路，因此我觉得未来国内<code>真正的技术公司</code>会越来越多，并且<code>Rust</code>应该在未来的<code>1-3</code>也会在国内遍地开花。<br>
其次，开源领域来自中国的声音也越来越多了，但是也有一些很不好的声音，比如<code>刷Star，PR</code>等等，开源也应该从以前的宣传开源的模式，转化为大家会在使用开源技术的时候更加的慎重的考虑，因此在企业级的服务市场应该对外包供应商会提出更多的要求。<br>
<code>AI</code>计划现在还是没有看到一个特别的好的场景，与之对应的<code>智能家居</code>也没有一个很好的解决方案，现在想来<code>智能家居</code>的市场依然是叫好不叫座的现状，还有<code>IPv6</code>迟迟不能普及，现在在底层技术上因为一些制约，尤其是在通讯技术上，但是可能<code>手机基础技术</code>可能会领先<code>传统的固定网</code>，现有的机会发展应该还是从拥有大量消费者的手机市场突破。<br>
又因为 <code>Telegram</code> 这样的安全的通讯工具，以及区块链的一把大火，现在的<code>P2P</code>技术又要焕发清楚，现在的基础网速足够的情况下，又加持<code>5G的组网</code>功能，未来去中心的网络技术随着基础设施的完善，也许可以替代现在的互联网技术。<br>
因为现在就是做 <code>微服务</code> 相关的工作，现在开始 <code>Spring Cloud</code> 已经变的不够性感了，因为 <code>Spring Cloud</code> 暴露给客户的东西实在是太多，我们可以从软件行业的发展看来，其实大部分基于业务的开发是不没办法掌握太过于深入的知识的，因此 <code>Spring Cloud</code> 中的 <code>服务发现|客户端负载均衡|客户端熔断</code>这些功能对于开发者并非是多么友好的一件事情，在未来应该会被 <code>Service Mesh</code> 类似的技术所替换掉，这部分的事情的职能依然会转让到<code>PASS</code>平台的维护者或者是运维部门。而<code>API网关</code>面临的最大的挑战也是因为随着上面的一系列组件的消失，<code>API网关</code>与软件系统集成的优势会被抵消，如果仅仅是承担负载均衡相关的职能，在大公司内竞争不过<code>硬件网关</code>，在互联网公司应该也会迭代出自己的轻量级高性能的网关，类似于<code>Ngninx</code>之类，而无论是基于<code>Tyk</code>还是<code>ApiMan</code>都不得不去面对这样的事情，<code>API网关</code>的出路还是在软件之上，如何和业务系统更好的联动可能是未来唯一的出路了。</p>
<h2 id="计划"><a class="header-anchor" href="#计划">¶</a>计划</h2>
<p>因为基于上面的一些预测，提出下面的学习计划</p>
<ul>
<li><code>Rust</code> 这门未来应该主宰底层技术的语言<br>
为什么要学 <code>Rust</code> 在上面说的很清楚啦。</li>
<li><code>Service Mesh</code> 类型的服务器代理项目<br>
<code>Service Mesh</code> 或者是 <code>Istio | Enovy</code> 都值得去了解，这些基础技术未来是支撑微服务组网的基础，而且不仅仅是微服务可能会是未来软件开发的基础设施。</li>
<li><code>P2P</code> 网络项目 <code>ipfs</code><br>
<code>ipfs</code> 应该是现在最为出门的 <code>P2P</code> 网络开源项目了，<code>Rust</code> 现在所能搜索到的 <a href="https://github.com/maidsafe/crust">crust</a> 还不够流行，<code>Rust</code> 的生态也在蓬勃的发展，还是希望<code>Rust</code>的开发者越来越多吧。</li>
<li>分布式数据库的基础<code>KV</code>数据库<br>
业界最为出名的应该是 <code>LevelDB</code>，这篇文章可以作为一个入门的参考 <a href="https://zhuanlan.zhihu.com/p/53299778">既生 Redis 何生 LevelDB</a></li>
<li><code>TiDB</code>(可选)</li>
</ul>
<h2 id="规划"><a class="header-anchor" href="#规划">¶</a>规划</h2>
<h3 id="第一部分-2019-2-2019-5-1"><a class="header-anchor" href="#第一部分-2019-2-2019-5-1">¶</a>第一部分 (2019.2 - 2019.5.1)</h3>
<p>搞定 <code>Rust</code> 语言（送自己一个生日礼物 🎂），对于语言的基础掌握的还可以，利用<code>Rust</code>做一个简单的项目，现在正在尝试的做的自动检测<code>Ping</code>的项目<code>XPing</code>。</p>
<h3 id="第二部分-2019-5-1-2019-7-1"><a class="header-anchor" href="#第二部分-2019-5-1-2019-7-1">¶</a>第二部分 (2019.5.1 - 2019.7.1)</h3>
<p>理清 <code>ServiceMess</code> 的作用，能够做什么又有什么局限性，并且尝试将这个 <code>ServiceMess</code> 带入 <code>DMP</code> 平台中去。</p>
<h3 id="第三部分-2019-7-1-2019-9-1"><a class="header-anchor" href="#第三部分-2019-7-1-2019-9-1">¶</a>第三部分 (2019.7.1 - 2019.9.1)</h3>
<p>学习 <code>P2P</code> 网络姿势，自己尝试写一个 P2P 网络的项目，之前用的那个 <code>P2P</code> 的 <code>Nat</code>组网应用就是一个很好的抄袭项目。</p>
<h3 id="第四部分-2019-9-1-2019-11-1"><a class="header-anchor" href="#第四部分-2019-9-1-2019-11-1">¶</a>第四部分 (2019.9.1 - 2019.11.1)</h3>
<p>学习大规模数据库的基础 <code>KV</code> 数据库的实现。</p>
<p>不过计划是这样的一个大的方向，至于在执行的过程也许略有调整，可能同时学习一些东西（结构化拖延也许也不是一个坏事情:-D）</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Todo</category>
        <category>Plan</category>
      </categories>
      <tags>
        <tag>Todo</tag>
        <tag>Plan</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务中的服务注册与发现</title>
    <url>/2020/01/08/architecture/microservice/discovery/</url>
    <content><![CDATA[<h1>背景知识</h1>
<h2 id="服务注册-发现"><a class="header-anchor" href="#服务注册-发现">¶</a>服务注册 &amp; 发现</h2>
<p>服务注册：服务实例将自身服务信息注册到注册中心。这部分服务信息包括服务所在主机IP和提供服务的Port，以及暴露服务自身状态以及访问协议等信息。<br>
服务发现：服务实例请求注册中心获取所依赖服务信息。服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求它们提供的服务。</p>
<span id="more"></span>
<h2 id="CAP"><a class="header-anchor" href="#CAP">¶</a>CAP</h2>
<p>CAP原则，指的是在一个分布式系统中，Consistency(一致性)、Availability(可用性)、Partition Tolerance(分区容错性)，不能<a href="https://blog.csdn.net/yeyazhishang/article/details/80758354">同时成立</a>。</p>
<p>一致性(Consistency)：它要求在同一时刻点，分布式系统中的所有数据备份都处于同一状态。<br>
可用性(Availability)：在系统集群的一部分节点宕机后，系统依然能够响应用户的请求。<br>
分区容错性(Partition Tolerance)：在网络区间通信出现失败，系统能够容忍。</p>
<p>一般来讲，基于网络的不稳定性，分布容错是不可避免的，所以我们默认CAP中的P总是成立的。<br>
所以我们只能选择 CP 系统 或者是 AP 系统。</p>
<h1>几种实现</h1>
<h2 id="AP-系统"><a class="header-anchor" href="#AP-系统">¶</a>AP 系统</h2>
<p>因为AP系统牺牲了一致性，从而获得了更好的可用性，表现在</p>
<ul>
<li>单机数据可丢失，从而因此架构简单，软件可靠性高</li>
<li>单机的性能好，并发量高</li>
</ul>
<h3 id="Eureka"><a class="header-anchor" href="#Eureka">¶</a>Eureka</h3>
<p>Eureka采用的是Server/Client的模式进行设计。Server扮演了服务注册中心的角色，为Client提供服务注册和发现的功能，维护着注册到自身的Client的相关信息，同时提供接口给Client获取到注册表中其他服务的信息。Client将有关自己的服务的信息通过一定的方式登记到Server上，并在正常范围内维护自己信息的一致性，方便其他服务发现自己，同时可以通过Server获取到自己的依赖的其他服务信息，从而完成服务调用。</p>
<p><img src="https://s2.ax1x.com/2020/02/08/1Rccgx.png" alt="1Rccgx.png"></p>
<p>Eureka中没有使用任何的数据强一致性算法保证不同集群间的Server的数据一致，仅通过数据拷贝的方式争取注册中心数据的最终一致性，虽然放弃数据强一致性但是换来了Server的可用性，降低了注册的代价，提高了集群运行的健壮性。</p>
<h2 id="CP-系统"><a class="header-anchor" href="#CP-系统">¶</a>CP 系统</h2>
<p>AP系统牺牲了可用性，从而获得更好的一致性，表现在</p>
<ul>
<li>发现延迟较低</li>
<li>用户感知低</li>
</ul>
<h3 id="ETCD"><a class="header-anchor" href="#ETCD">¶</a>ETCD</h3>
<p>etcd是CoreOS团队于2013年6月发起的开源项目，它的目标是构建一个高可用的分布式键值(key-value)数据库。etcd内部采用raft协议作为一致性算法，etcd基于Go语言实现。<br>
<img src="https://s2.ax1x.com/2020/02/08/1R2uTg.png" alt="1R2uTg.png"></p>
<h3 id="CONSUL"><a class="header-anchor" href="#CONSUL">¶</a>CONSUL</h3>
<p>Consul是一个服务网格（微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控）解决方案，它是一个一个分布式的，高度可用的系统，而且开发使用都很简便。它提供了一个功能齐全的控制平面，主要特点是：服务发现、健康检查、键值存储、安全服务通信、多数据中心。<br>
<img src="https://s2.ax1x.com/2020/02/08/1R2ftH.png" alt="1R2ftH.png"></p>
<h1>实际应用</h1>
<h2 id="AP-or-CP"><a class="header-anchor" href="#AP-or-CP">¶</a>AP or CP</h2>
<p>从实际的应用的场景看，极大规模的微服务系统因为<strong>组件极多且经常变化</strong>可能会选择 <code>AP</code> 系统，对于大部分用户来说选择 <code>CP</code> 系统是更常见的选择，首先因为微服务系统内的组件是一个相对固定不变的数量，因此微服务系统内部的服务注册中心的数量也是<strong>稳定的</strong>。</p>
<h2 id="扩展性"><a class="header-anchor" href="#扩展性">¶</a>扩展性</h2>
<p>Eureka是其中最差的，因为本身有服务的概念，导致在后续的拓展中是处处受阻的，因此在后续的服务发现的实现中，对于注册数据的筛选使用元数据的方式更为的合理。</p>
<p><img src="https://s2.ax1x.com/2020/02/08/1RfyXq.png" alt="1RfyXq.png"></p>
<p>采用类SQL的模式是相对比较的好的选择。</p>
<h2 id="混合模式"><a class="header-anchor" href="#混合模式">¶</a>混合模式</h2>
<p>对于中等规模的用户来说，更多的时候我们需要混合使用此模式，对于一些量大不敏感且可重试的附件，我们采用<code>AP</code>模式：比如视频目录服务等。而对于比较敏感的服务比如和金额相关的，建议使用<code>CP</code>模式。可喜的是有了部分如此组件的尝试，比如 <a href="https://github.com/alibaba/nacos">nacos</a></p>
<h2 id="中间层"><a class="header-anchor" href="#中间层">¶</a>*中间层</h2>
<p>不同服务发现之间，因为协议的不同导致在后续的切换过程中需要更换客户端 <code>client sdk</code>，因此建议</p>
<ul>
<li>使用服务端负债均衡 / ServiceMesh</li>
<li>增加独立抽象层</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>Learn By Game&amp;#58 01 环境准备</title>
    <url>/2021/01/24/game/learn-by-game/learn-by-game-01/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210124180700.png" alt=""></p>
<p>因为女票只想使用 <code>Java</code> 来学习编程知识，因此我们就来做有趣的游戏 [打飞机] 来学习。</p>
<span id="more"></span>
<h2 id="环境准备"><a class="header-anchor" href="#环境准备">¶</a>环境准备</h2>
<p><code>Java</code> 届最出名的游戏框架显然是 <a href="https://libgdx.badlogicgames.com/download.html">libGDX</a>，我们从 <a href="https://libgdx.badlogicgames.com/download.html">download</a> 下载 <a href="https://libgdx.badlogicgames.com/nightlies/dist/gdx-setup.jar">Setup App</a></p>
<p>在下载完成之后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar gdx-setup.jar</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210124181306.png" alt=""></p>
<h2 id="创建项目模板"><a class="header-anchor" href="#创建项目模板">¶</a>创建项目模板</h2>
<p>使用如下参数创建</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210124181845.png" alt=""></p>
<h2 id="导入项目-运行"><a class="header-anchor" href="#导入项目-运行">¶</a>导入项目 &amp; 运行</h2>
<p>我们导入项目，然后使用 <code>Main</code> 执行运行，见到如下图所示，作为我们项目的基础</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210124182136.png" alt=""></p>
<h2 id="目标"><a class="header-anchor" href="#目标">¶</a>目标</h2>
<p>我们做一个打飞机的小游戏</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210124182544.png" alt=""></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>自学</category>
        <category>Game</category>
      </categories>
      <tags>
        <tag>Game</tag>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务框架 - 2020</title>
    <url>/2020/07/19/java/microservice/new-mircoservice-framework/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/07/20/UBmpO.png" alt="UBmpO.png"></p>
<p>在 <a href="2020/06/20/java/other/2020-new-direction/">Java社区的新方向</a> 中也说明了一个 Java 社区的趋势，在这个过程中有很多在努力的项目和团队，我们今天就先看看有哪些新的框架。</p>
<span id="more"></span>
<h1>Spring Boot/Cloud</h1>
<p><img src="https://s3.jpg.cm/2020/07/20/UBOc6.png" alt="UBOc6.png"></p>
<p><code>Spring Boot</code> 和 <code>Spring Cloud</code> 现阶段仍是最大的微服务框架。大多数读者对其都很熟悉，我们就以 <code>Spring Boot</code> 为标杆，来和其他的框架进行对比。</p>
<p>在最终的 <code>雷达图</code> 中，我们会对比这几种框架的 <code>制品大小</code> <code>启动速度</code> <code>功能性</code> <code>性能</code> 这几个指标。在每个新框架内尽可能举一些比较生动的 DEMO 给大家进行参考。</p>
<h1>Eclipse Vert.X</h1>
<p><img src="https://s3.jpg.cm/2020/07/20/UBZvT.png" alt="UBZvT.png"></p>
<p><a href="https://vertx.io/"><code>Vert.X</code></a> 如果说起来可能比微服务还略早一些，笔者也曾经为其中文社区翻译过文档，<code>Vert.X</code> 社区因为觉得 <code>Spring</code> 还是太重量级了，对于现在的软件开发来说，我们可能需要的仅仅是一组工具，因此推出了此框架：</p>
<blockquote>
<p>Eclipse Vert.x is a <code>tool-kit</code> for building <code>reactive</code> applications on the JVM.</p>
</blockquote>
<p>重点也给大家标红了 <code>tool-kit</code> 和 <code>reactive</code> 是他的最为重要的特征，除此之外</p>
<ul>
<li>轻量级：Core部分代码只有 700kb 左右</li>
<li>快速：<a href="https://www.techempower.com/benchmarks/">techempower benchmarks</a> java 社区少数能打的、</li>
<li>模块化： Vertx的模块化做的非常好，不像 SpringCloud属于拼凑式的模块化</li>
</ul>
<h2 id="Verticles"><a class="header-anchor" href="#Verticles">¶</a>Verticles</h2>
<p><code>Vert.X</code> 比较有趣的基于一种名为 <code>Verticle</code> 的对象进行编程，我们编写函数入口/对象 都是一种 <code>Verticle</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyVerticle</span> <span class="keyword">extends</span> <span class="title class_">AbstractVerticle</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Called when verticle is deployed</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Optional - called when verticle is undeployed</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此在设计之处，<code>Vertx</code> 已经考虑到 <code>Hotrestart</code>，对于开发者更容易理解。<code>Verticle</code> 之间的通讯又有点类似于 <code>Actor</code> 的通讯机制，不过值得注意的，<code>Core</code> 部分是不提供跨主机调研的，只能在同一个 <code>Verticle Deployment</code> 进行通讯，因此并不是可以直接等价于 <code>Akka</code>。</p>
<h2 id="Web-Server"><a class="header-anchor" href="#Web-Server">¶</a>Web Server</h2>
<p><code>Vert.X</code> 更喜欢将控制权返给开发者，<code>框架</code>封装使用，<code>工具</code>展示本质。因此对于我们来说，如果需要构建一个 <code>web server</code>，我们应该使用如下方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HttpServer</span> <span class="variable">server</span> <span class="operator">=</span> vertx.createHttpServer();</span><br><span class="line"></span><br><span class="line"><span class="type">Router</span> <span class="variable">router</span> <span class="operator">=</span> Router.router(vertx);</span><br><span class="line"></span><br><span class="line">router.route().handler(routingContext -&gt; &#123;</span><br><span class="line">  <span class="type">HttpServerResponse</span> <span class="variable">response</span> <span class="operator">=</span> routingContext.response();</span><br><span class="line">  response.putHeader(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">  response.end(<span class="string">&quot;Hello World from Vert.x-Web!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.requestHandler(router).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
<p>从短短的几行里面，我们可以发现 <code>Vert.x</code> 正如宣传的提供的是一系列的 <code>Tookit</code> 在构建的过程中推荐开发者自己亲手搭建一个系统。</p>
<p><img src="https://s3.jpg.cm/2020/07/20/UBfWe.png" alt="UBfWe.png"></p>
<hr>
<p>不过 <code>Vert.x</code> 这个工具箱很强大，提供了 <code>Web</code> <code>Data Access</code> <code>Reactive</code> <code>IoT</code> <code>Authentication and Authorisation</code> <code>Messaging</code> <code>Integration</code> <code>Event Bus Bridge</code> <code>DevOps</code> <code>Testing</code> <code>Clustering</code> <code>Services</code> <code>Standards</code> 这么多系列的工具，总有一款适合你。</p>
<div>
    <label class="author-mark-label">作者语</label>
    <p class="author-mark">个人还是比较喜欢 Vert.X， 像 GoLanguage 也证明这种基于小工具的组合其实也是可以满足需求的，并且因为足够简单在使用的过程中也比较好去排查问题。</p>
</div>
<h1>Quarkus</h1>
<p><img src="https://s3.jpg.cm/2020/07/20/UfLlQ.png" alt="UfLlQ.png"></p>
<p>说起 <code>quarkus</code> 就有点厉害了， <code>quarkus</code> 主打的是 <code>GraalVM</code>，在之前的文章中和大家讨论过在 <code>云原生</code> 时代内的 <code>JVM</code> 太过于笨重，从 <code>JVM</code> 尝试解决这个问题的就是 <code>GraalVM</code>，但是 <code>GraalVM</code> 并非是一个无痛的，比如反射就不能使用(需要转化)，因此 <code>GraalVM</code> 就好比新能源汽车，我们已经不需要汽油发动机，因此也需要配套的设施来发挥，因此 <code>Redhat</code> 就发起了 <code>Quarkus</code> 项目。</p>
<p><img src="https://s3.jpg.cm/2020/07/20/UBgHy.png" alt="UBgHy.png"></p>
<blockquote>
<p>A Kubernetes Native Java stack tailored for OpenJDK HotSpot and <code>GraalVM</code>, crafted from the best of breed Java libraries and standards.</p>
</blockquote>
<p><code>云原生</code> 是其主打特征。</p>
<h2 id="Web-Server-v2"><a class="header-anchor" href="#Web-Server-v2">¶</a>Web Server</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Path(&quot;fruits&quot;)</span></span><br><span class="line"><span class="meta">@Produces(MediaType.APPLICATION_JSON)</span></span><br><span class="line"><span class="meta">@Consumes(MediaType.APPLICATION_JSON)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitResource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@ConfigProperty(name = &quot;myapp.schema.create&quot;, defaultValue = &quot;true&quot;)</span></span><br><span class="line">    <span class="type">boolean</span> schemaCreate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    PgPool client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="keyword">public</span> Multi&lt;Fruit&gt; <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Fruit.findAll(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="meta">@Path(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Uni&lt;Response&gt; <span class="title function_">getSingle</span><span class="params">(<span class="meta">@PathParam</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Fruit.findById(client, id)</span><br><span class="line">                .onItem().apply(fruit -&gt; fruit != <span class="literal">null</span> ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))</span><br><span class="line">                .onItem().apply(ResponseBuilder::build);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST</span></span><br><span class="line">    <span class="keyword">public</span> Uni&lt;Response&gt; <span class="title function_">create</span><span class="params">(Fruit fruit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fruit.save(client)</span><br><span class="line">                .onItem().apply(id -&gt; URI.create(<span class="string">&quot;/fruits/&quot;</span> + id))</span><br><span class="line">                .onItem().apply(uri -&gt; Response.created(uri).build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体的使用上，<code>Quarkus</code> 是非常接近 <code>Spring</code> 的体验，不过整体上因为 <code>Quarkus</code>  更加的拥抱云原生，因此并没有在 <code>Cloud</code> 侧的组件做更多的时期，希望用户基于 <code>CNCF</code> 所提供的能力进行工作，这点可能会让开发者很不舒服。悄悄的告诉你(Quarkus底层也会依赖Vertx)</p>
<blockquote>
<p>Quarkus is based on Vert.x, and almost all network-related features rely on Vert.x. While lots of reactive features from Quarkus don’t show Vert.x, it’s used underneath.</p>
</blockquote>
<p>面向微服务、云原生，编译到 native 以获得超快启动时间、超低内存占用，统一命令式与反应式编程范式，这几点其实新的框架都差不多，Quarkus 更重视“把问题提前到编译期解决”。不过这件事情对于开发者来讲可能就没有什么体感了。</p>
<div>
    <label class="author-mark-label">作者语</label>
    <p class="author-mark">其实也可以理解 Quarkus 基于 Vertx 提供了更好开箱即用的体验，并且和周边生态集成的更加紧密了。</p>
</div>
<h1>Helidon</h1>
<p><img src="https://s3.jpg.cm/2020/07/20/UfPsh.png" alt="UfPsh.png"></p>
<p>刚刚也讲了，其实大部分的框架都比较类似了，<code>Helidon</code> 也是如此。提供了</p>
<ul>
<li>Reactive non-blocking database client</li>
<li>Supports existing blocking JDBC drivers</li>
<li>Relational and non-relational databases</li>
<li>Metrics, tracing, health checks</li>
<li>Portability</li>
<li>Extensibility</li>
</ul>
<p>值得一说的是对 <code>GraalVM</code> 也是积极支持的。<code>Helidon</code> 将项目分为了 <code>SE</code> <code>MP</code>，对于 <code>SE</code> 作为功能组件存在，<code>MP</code> 则是为了实现 <a href="https://projects.eclipse.org/proposals/eclipse-microprofile"><code>MicroProfile</code></a></p>
<p><code>MicroProfile</code> 说起来就比较厉害了，拉了 <code>IBM</code> <code>RedHat</code> <code>Payara</code> <code>Tomitribe</code> <code>SouJava</code> 下水，准备重新搞标准了 ， 天下还苦 <code>Spring</code> 久已， <code>Spring</code> 的确现在看起来有些笨重。</p>
<h2 id="Web-Server-v3"><a class="header-anchor" href="#Web-Server-v3">¶</a>Web Server</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">WebServer</span> <span class="variable">webServer</span> <span class="operator">=</span> WebServer</span><br><span class="line">            .create(Routing.builder()</span><br><span class="line">                            .any((req, res) -&gt; res.send(<span class="string">&quot;It works!&quot;</span>))) </span><br><span class="line">            .start() </span><br><span class="line">            .await(<span class="number">10</span>, TimeUnit.SECONDS); </span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Server started at: http://localhost:&quot;</span> + webServer.port()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div>
    <label class="author-mark-label">作者语</label>
    <p class="author-mark">Helidon 应该还算是最不完善的，文档毕竟稀少，代码的话以封装 JDK & Netty 为主。</p>
</div>
<h1>Micronaut</h1>
<p><img src="https://s3.jpg.cm/2020/07/20/UfRhS.png" alt="UfRhS.png"></p>
<p><code>micronaut</code> 和 <code>grails</code> 实属亲戚关系，而 <code>grails</code> 和 <code>spring</code> 又经常 PY。因此我觉得 <code>Micronaut</code> 和  <code>Spring</code> 总有不可告人的秘密。</p>
<blockquote>
<p>Micronaut is a modern, JVM-based, full stack Java framework designed for building modular, easily testable JVM applications with support for Java, Kotlin and the Groovy language.</p>
</blockquote>
<p>Micronaut 还是有一些有趣的东西，不过和其他家也类似，<code>IOC</code> 是通过 <code>annotation Processor</code> 处理的，也就是所谓的了静态处理。</p>
<h2 id="Web-server"><a class="header-anchor" href="#Web-server">¶</a>Web server</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Micronaut.run(Application.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MicronautTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloControllerSpec</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    EmbeddedServer server; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@Client(&quot;/&quot;)</span></span><br><span class="line">    HttpClient client; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testHelloWorldResponse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> client.toBlocking() </span><br><span class="line">                .retrieve(HttpRequest.GET(<span class="string">&quot;/hello&quot;</span>));</span><br><span class="line">        assertEquals(<span class="string">&quot;Hello World&quot;</span>, response); <span class="comment">//) </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <code>Hello World</code> 看其实和 <code>Spring</code> 没啥却别（更多地方看起来都没啥区别），我还倾向于 <code>Micronaut</code> 仅仅是 <code>Spring</code> 体系的一个马甲。</p>
<h1>Lagom</h1>
<p><img src="https://s3.jpg.cm/2020/07/20/UfWnW.png" alt="UfWnW.png"></p>
<p>Lagom 就一直属于万年老二的状态，以前和 <code>Spring</code> 竞争的 <a href="https://www.playframework.com/"><code>Play Framework</code></a>，现在用 <code>Lagom</code> 和 <code>Spring</code> 竞争，因为 <code>Lagom</code> 的内部通讯基于 <code>Akka Remoting</code> <code>Steam Driver</code> 的机制，可是说是完全独立的一套体系。</p>
<p><img src="https://s3.jpg.cm/2020/07/20/UBaW4.png" alt="UBaW4.png"></p>
<p>说到 <code>Lagom</code> 就一定要说到 <code>Akka</code>，<code>Actor</code> 这个模型说起都说好，但是实际上都没啥人用 <a href="https://www.zhihu.com/question/279512440">为什么Akka(Actor模型)在中国不温不火？</a>。绝大多数的开发者没有意识到布道师的眼中只有优点是没有缺点的。</p>
<p>对于 <code>Akka</code> 也不深入了解，这个就权当给大家一点开拓视野的资料。</p>
<h1>体系之争</h1>
<p>现在开源早就过了单兵作战的时代，每一个开源项目的背后企业也是我们应该考虑的。</p>
<ul>
<li>Spring → Pivotal → VMware</li>
<li>Quarkus/Vert.x → Eclipse 基金会 → Red Hat 支持</li>
<li>Helidon → Oracle</li>
<li>Micronaut → Object Computing（Grails、OpenDDS） → Spring 有 PY</li>
<li>Lagom → Lightbend（Akka）</li>
</ul>
<p>前三家都算是家大业大也不怕跑路， <code>Micronaut</code> 就略为弱一点， <code>Lightbend</code> 和其他家有所区别 <code>Lightbend</code> 面向 <code>EE</code> 因此也是为数几家可以提供 <code>企业化</code> 服务的体系。</p>
<h1>雷达</h1>
<div id="spring-vertx" style="height: 400px"></div>
<script crossorigin="anonymous" integrity="sha384-et+fqdf7kslHL5Ip8rXSJPUPODLa7eMfpFTBaCfnlMzrcAz/wxI5Xm/mNTZwd+7H" src="https://lib.baomitu.com/echarts/4.7.0/echarts.min.js"></script>
<script type="text/javascript">
var dom = document.getElementById("spring-vertx");
var myChart = echarts.init(dom);
var app = {};
option = null;
option = {
    title: {
        text: '技术雷达图'
    },
    tooltip: {},
    legend: {
        data: ['Spring', 'Vertx', 'Quarkus', 'Helidon', 'Micronaut', 'Lagom']
    },
    radar: {
        // shape: 'circle',
        name: {
            textStyle: {
                color: '#fff',
                backgroundColor: '#999',
                borderRadius: 3,
                padding: [3, 5]
            }
        },
        indicator: [
            { name: '制品大小', max: 100},
            { name: '功能性', max: 100},
            { name : '启动速度（越小越好）', max: 100 },
            { name: '性能', max: 100 },
            { name: '生态建设', max: 100},
        ],
        radius: '65%'
    },
    series: [{
        name: '大比拼',
        type: 'radar',
        // areaStyle: {normal: {}},
        data: [
            {
                value: [100, 90, 100, 50, 100],
                name: 'Spring'
            },
            {
                value: [60, 70, 50, 90, 80],
                name: 'Vertx'
            },
            {
                value: [70, 70, 45, 80, 80],
                name: 'Quarkus'
            },
            {
                value: [70, 70, 50, 80, 70],
                name: 'Helidon'
            },
            {
                value: [80, 70, 60, 70, 60],
                name: 'Micronaut'
            },
            {
                value: [80, 70, 70, 70, 60],
                name: 'Lagom'
            }
        ]
    }]
};;

myChart.setOption(option, true);

</script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
        <category>微服务</category>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title>Netty源码分析-(0)-预备知识</title>
    <url>/2018/06/12/java/netty/netty-0-prepare/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>关于Netty我们都知道（现在还不知道的Netty的怕是凤毛麟角）</p>
<blockquote>
<p>Netty is an asynchronous event-driven network application framework<br>
for rapid development of maintainable high performance protocol servers &amp; clients.</p>
</blockquote>
<p>Netty是一个异步事件驱动的应用框架，能够让我们更快的做一些网络开发。</p>
<p>阅读此系列博文，<strong>我对你的要求是</strong> 使用过原生的Java Nio进行过网络编程。<br>
此篇博客算是我阅读Netty的笔记，会有自己探索的过程，望斧正。</p>
<span id="more"></span>
<h2 id="预备知识"><a class="header-anchor" href="#预备知识">¶</a>预备知识</h2>
<ul>
<li>
<p>Java NIO<br>
因为Netty也是建立在Java的Nio基础之上，所以需要有Java NIO的基础，可以参考 <a href="http://blog.yannxia.top/2018/05/07/java/nio/java-nio-1-basic/">Java Nio 基础</a></p>
</li>
<li>
<p>Reactor线程模式<br>
推荐2篇文章</p>
<ul>
<li><a href="https://dzone.com/articles/understanding-reactor-pattern-thread-based-and-eve">Understanding Reactor Pattern: Thread-Based and Event-Driven</a></li>
<li><a href="https://segmentfault.com/a/1190000007403873">Netty 源码分析之 三 我就是大名鼎鼎的 </a><br>
简而言之Netty的线程模式是标准的 <code>多线程Reactor模型</code><br>
<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1528824537102&amp;di=b9b5678aee772b881bb9a76fb1d4c8a2&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg2.imgtn.bdimg.com%2Fit%2Fu%3D3111796757%2C2564753992%26fm%3D214%26gp%3D0.jpg" alt=""></li>
</ul>
</li>
</ul>
<h2 id="Netty模块"><a class="header-anchor" href="#Netty模块">¶</a>Netty模块</h2>
<p><img src="http://netty.io/images/components.png" alt="components"><br>
正如图上所示，我们核心关注的应该是 core 部分</p>
<ul>
<li>Zero Copy Capable Byte Buf: 零拷贝数组</li>
<li>Exstensible Event Model: 可扩展的事件模型</li>
</ul>
<h2 id="源码解读顺序"><a class="header-anchor" href="#源码解读顺序">¶</a>源码解读顺序</h2>
<ol>
<li>
<p>Netty 服务端启动流程</p>
<ul>
<li>如何初始化NioServer</li>
<li>NioEventLoop模型和Channel</li>
</ul>
</li>
<li>
<p>Netty 服务端接受请求分析</p>
</li>
</ol>
<ul>
<li>Netty 线程模式</li>
<li>如何调用Pipeline</li>
<li>Pipeline工作机制</li>
</ul>
<ol start="3">
<li>Netty 的ByteBuf</li>
</ol>
<ul>
<li>Netty的Bytebuf实现</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
        <category>网络编程</category>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty源码分析-(1)-Bootstrap</title>
    <url>/2018/06/12/java/netty/netty-1-bootstrap/</url>
    <content><![CDATA[

<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<h2 id="Bootstrap"><a class="header-anchor" href="#Bootstrap">¶</a>Bootstrap</h2>
<p>Bootstrap 是 Netty 提供的一个便利的工厂类, 我们可以通过它来完成 Netty 的客户端或服务器端的 Netty 初始化。<br>
下面我以 Netty 源码例子中的 Discard 服务器作为例子, 从客户端和服务器端分别分析一下Netty 的程序是如何启动的。</p>
<p><a href="#%E8%A1%A5%E7%95%AA-%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E7%82%B9">快速定位几个关键点</a></p>
<span id="more"></span>
<h2 id="一个标准-ServerBootStarp"><a class="header-anchor" href="#一个标准-ServerBootStarp">¶</a>一个标准 ServerBootStarp</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">        b.group(bossGroup, workerGroup) ➊</span><br><span class="line">                .channel(NioServerSocketChannel.class) ➋</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;  ➌</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">DiscardHandler</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) ➍</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(<span class="number">8080</span>).sync(); ➎</span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们轻而易举的可以发现代码里面有几个元素</p>
<ul>
<li>➊ 声明的 EventLoopGroup</li>
<li>➋ Channel的类型是 NioServerSocketChannel，从我们之前写JavaNIO编程可以猜测出来，这就是Server端的Socket</li>
<li>➌ 这里什么我们的Handler处理的逻辑，从childHandler逻辑上看起来应该是子的处理逻辑</li>
<li>➍ option() 和下一行 childOption() 配置TCP一系列的参数</li>
<li>➎ 在这里我们发现真正的函数入口</li>
</ul>
<p>这里补充下在传统的TCP编程中，我们需要下图的一个流程<br>
<img src="https://www.2cto.com/uploadfile/Collfiles/20180504/20180504092323746.png" alt="tcp-bind"></p>
<p>我们需要在服务器端绑定我们的监听端口，那核心的启动逻辑也可以猜测出就是在这个地方了，我们从这个<code>bind()</code>作为我们的突破口去看看这个Netty是怎么启动起来的。</p>
<h2 id="doBind函数分析"><a class="header-anchor" href="#doBind函数分析">¶</a>doBind函数分析</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister(); ➊</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="comment">// At this point we know that the registration was complete and successful.</span></span><br><span class="line">        <span class="type">ChannelPromise</span> <span class="variable">promise</span> <span class="operator">=</span> channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>else代码被我省略，我们先看看核心正常逻辑，我们在 ➊ 处发现的是注册ChannelFunture，根据名称我们也可以猜测出来是一个异步的Channel注册，继续深入 <code>initAndRegister()</code> 函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();  ➊</span><br><span class="line">        init(channel); ➋</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">//略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel); ➌</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">依然关注核心，我们可以从这个 ➊ 处比较简单，各位可以自行看一下，NIO会采用反射的方式去获得NIOServerChannel这里刚好对应我们在Bootstarp中的 `NioServerSocketChannel.class`  </span><br><span class="line">➋ 处，我们发现的是一个抽象方法，我们发现有<span class="number">2</span>个实现，因为我们看的是服务器端代码，我们关注这个函数 `io.netty.bootstrap.ServerBootstrap#init(channel)` [点击转ServerBootstrap分析](#ServerBootstrap-init-函数分析)  </span><br><span class="line">➌ 处是一个注册，我们大胆的预测这里就是我们的EventLoop上注册我们的NioServer，前半段` config().group()`很好理解，我们拿到的也是我们的 `bossGroup`,这块的注册看样子是一个很重要的函数，我们来到实现的地方去看一下 [点击转Register分析](#AbstractUnsafe-register-函数分析)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## ServerBootstrap.init 函数分析</span><br><span class="line">```java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> channel.pipeline(); ➊</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">EventLoopGroup</span> <span class="variable">currentChildGroup</span> <span class="operator">=</span> childGroup;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelHandler</span> <span class="variable">currentChildHandler</span> <span class="operator">=</span> childHandler;</span><br><span class="line"></span><br><span class="line">    p.addLast(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">            <span class="type">ChannelHandler</span> <span class="variable">handler</span> <span class="operator">=</span> config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; ➋</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ServerBootstrapAcceptor</span>(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现在 ➊ 处，我们通过Channel打开了一个Pipeline，还记得那个Channel是什么吗？就是之前我们通过 <code>channelFactory.newChannel()</code> 创建出来的 Channel。<br>
➋ 处，我们看见了eventLoop这个，和我们之前看到的那个EventLoop是一个东西吗？但是这里看见一个很重要的类是 <code>ServerBootstrapAcceptor</code> 正如我们自己写的DEMO项目这势必是一个接收器。</p>
<p>我们在阅读这里的代码留下了<strong>一个疑问</strong>，在 <code>initChannel(final Channel ch)</code>中我们获得的对象是<strong>什么</strong>？</p>
<h2 id="AbstractUnsafe-register-函数分析"><a class="header-anchor" href="#AbstractUnsafe-register-函数分析">¶</a>AbstractUnsafe.register 函数分析</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> register(<span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(channel, <span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop; </span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise); ➊</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    register0(promise); ➋</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> neverRegistered;</span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="literal">false</span>;</span><br><span class="line">        registered = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span></span><br><span class="line">        <span class="comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一层层的拨开，我们都发现了 ➊ 和 ➋ 都调用了 <code>register0(promise)</code> ，明显这个才是一个核心的为方法在这个方法里面有一个 <code>doRegister();</code> 勾起了我们的关注，我们在<code>io.netty.channel.nio.AbstractNioChannel#doRegister</code> 中获得这个方法的详细内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">selected</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="built_in">this</span>);  ➊</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>恍然开朗，我们在 ➊ 处的得到了这个 <code>selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</code>这才是我们真正的注册的地方。</p>
<h2 id="小结1：注册NioServerSocketChannel的流程"><a class="header-anchor" href="#小结1：注册NioServerSocketChannel的流程">¶</a>小结1：注册NioServerSocketChannel的流程</h2>
<p>我们分析到现在我们已经可以知道了注册NioServerSocketChannel的流程，我们先梳理一下</p>


<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: NioServerSocketChannel 注册过程',
	 'Main->ServerBootstrap: 1.bind(int)',
	 'ServerBootstrap->EventLoopGroup: 2.register(Channel)',
	 'EventLoopGroup->AbstractUnsafe: 3.register0(ChannelPromise)',
     'AbstractUnsafe->AbstractNioChannel: 4.doRegister()'
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>


<h2 id="继续探索-AbstractUnsafe-register0-函数"><a class="header-anchor" href="#继续探索-AbstractUnsafe-register0-函数">¶</a>继续探索 AbstractUnsafe#register0 函数</h2>
<p>在我们的头顶上还有一个疑问，<code>ServerBootstrap.init</code> 中回调的那个 Channel 是什么，我们为了探索这个答案，我们继续往下探索。<br>
<code>pipeline.invokeHandlerAddedIfNeeded();</code> 上面的一行注释告诉们在实际通知Promise之前我们需要增加我们的Handler，再下面反而没有什么有用的信息，我们就从这个函数入手继续分析，我们点击进去会发现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invokeHandlerAddedIfNeeded</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> channel.eventLoop().inEventLoop();</span><br><span class="line">    <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">        firstRegistration = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// We are now registered to the EventLoop. It&#x27;s time to call the callbacks for the ChannelHandlers,</span></span><br><span class="line">        <span class="comment">// that were added before the registration was done.</span></span><br><span class="line">        callHandlerAddedForAllHandlers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这块又多了很核心的函数，我们这里需要注册所有的的Handlers，是不是感觉和我们之前留下的疑问是接近的，但是我们仍然不能断言这个就是对的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callHandlerAddedForAllHandlers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> PendingHandlerCallback pendingHandlerCallbackHead;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        pendingHandlerCallbackHead = <span class="built_in">this</span>.pendingHandlerCallbackHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">PendingHandlerCallback</span> <span class="variable">task</span> <span class="operator">=</span> pendingHandlerCallbackHead; ➊</span><br><span class="line">    <span class="keyword">while</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">        task.execute();</span><br><span class="line">        task = task.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊处我们发现这里就是我们的Handler的回调函数，大胆的预测也就是我们上文疑问处的回调函数调用，继续跟踪下，我们在<br>
<code>io.netty.channel.DefaultChannelPipeline#callHandlerAdded0</code>处发现了最终的调用者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callHandlerAdded0</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ctx.setAddComplete();</span><br><span class="line">        ctx.handler().handlerAdded(ctx);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心的也就是在这里进行handler增加再往下跟踪一个函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="literal">null</span>) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            exceptionCaught(ctx, cause);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            remove(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里➊处也就是我们自己的初始化脚本，是一个抽象类，正好对应着我们的那个回调函数。但是我在这里发现另外一个疑问 <code>ChannelHandlerContext</code>我们在使用的时候是经常会使用到，<code>ChannelHandlerContext</code>包裹了<code>Channel</code>和我们的<code>Pipeline</code>是一个有状态的对象，那他第一次初始化是在哪里？这里通过肉眼看是不明智的，这个时候借助于我们现代化的IDEA。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name,</span><br><span class="line">                                  <span class="type">boolean</span> inbound, <span class="type">boolean</span> outbound) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">&quot;name&quot;</span>); ➊</span><br><span class="line">    <span class="built_in">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="built_in">this</span>.executor = executor;</span><br><span class="line">    <span class="built_in">this</span>.inbound = inbound;</span><br><span class="line">    <span class="built_in">this</span>.outbound = outbound;</span><br><span class="line">    <span class="comment">// Its ordered if its driven by the EventLoop or the given Executor is an instanceof OrderedEventExecutor.</span></span><br><span class="line">    ordered = executor == <span class="literal">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 ➊ 处设置一个 <code>断点</code>，我们去观察下堆栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">newChannel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clazz.getConstructor().newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChannelException</span>(<span class="string">&quot;Unable to create Channel from class &quot;</span> + clazz, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现在初始化 channel 的时候就会初始化我们的 <code>AbstractChannelHandlerContext</code> 这就是说这个 <code>ServerSocket</code>的<code>HandlerContext</code>在整个运行的生命周期都是唯一的。那我们也去验证一下。</p>
<h2 id="旁白-验证-NioServerSocketChannel-的-AbstractChannelHandlerContext"><a class="header-anchor" href="#旁白-验证-NioServerSocketChannel-的-AbstractChannelHandlerContext">¶</a>旁白: 验证 NioServerSocketChannel 的 AbstractChannelHandlerContext</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioServerSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioServerSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FooHandler</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">DiscardHandler</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LogManager.getLogger(FooHandler.class);</span><br><span class="line">    <span class="keyword">private</span> AttributeKey&lt;String&gt; FooAttributeKey = AttributeKey.newInstance(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Attribute&lt;String&gt; attr = ctx.channel().attr(FooAttributeKey);</span><br><span class="line">        <span class="keyword">if</span> (attr.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;FooAttributeKey value setting  &#123;&#125;&quot;</span>, <span class="string">&quot;foo value&quot;</span>);</span><br><span class="line">            attr.setIfAbsent(<span class="string">&quot;foo value&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;FooAttributeKey value &#123;&#125;&quot;</span>, attr.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用curl连接2次，会发现结果是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">16:25:17.399 [nioEventLoopGroup-2-1] INFO  top.yannxia.java.understanding.netty.FooHandler - FooAttributeKey value setting  foo value</span><br><span class="line">16:25:41.266 [nioEventLoopGroup-2-1] INFO  top.yannxia.java.understanding.netty.FooHandler - FooAttributeKey value foo value</span><br></pre></td></tr></table></figure>
<p>验证了我们的想法，那我们由此推断出来，每当一个Channel建立的时候，我们都会为这个Channel创建一个Context。</p>
<h2 id="番外-ClientServerBootStarp"><a class="header-anchor" href="#番外-ClientServerBootStarp">¶</a>番外: ClientServerBootStarp</h2>
<p>我们啃完了难啃的ServerBootStarp，那ClientServerBootStarp就留给读者们自行阅读了，其实从上文我们可以大胆的猜测出来</p>
<ol>
<li>ClientServerBootStarp 是 ServerBootStarp的简化，去除了 NioServerSocketChannel</li>
<li>ClientServerBootStarp 的线程模型是简化的，没有 Acceptor 的</li>
</ol>
<h2 id="补番-几个关键点"><a class="header-anchor" href="#补番-几个关键点">¶</a>补番:几个关键点</h2>
<ol start="0">
<li>
<p>阅读Netty代码的核心是了解Netty的线程模型<br>
参考 <a href="http://www.importnew.com/26718.html">Netty in action — 事件循环和线程模式</a></p>
</li>
<li>
<p>Netty并没有采用BossEventGroup的线程池<br>
<code>io.netty.channel.MultithreadEventLoopGroup#register(io.netty.channel.Channel)</code> 中</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道 ServerNioChannel 只会被注册一次，即便是我们创建了多个Thread，我们依然只能选择其中一个注册我们的 ServerNioChannel</p>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
        <category>网络编程</category>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty源码分析-(2)-Acceptor与线程模型</title>
    <url>/2018/06/19/java/netty/netty-2-acceptor-thread/</url>
    <content><![CDATA[

<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<h2 id="Acceptor"><a class="header-anchor" href="#Acceptor">¶</a>Acceptor</h2>
<p>Acceptor 是 Netty 提供一个接收器。<br>
<img src="https://s1.ax1x.com/2018/06/19/CziSq1.png" alt="Reactor模式"><br>
还记得 <code>Reactor模式</code> 中那个的Acceptor正是连接了 <code>MainReactor</code> 和 <code>SubReactor</code>的核心所在，我们上文已经分析了Netty的 <code>NioServerChannel</code>，这篇我们就来分析下，Netty究竟是怎么去接受请求并且维护链接的。</p>
<span id="more"></span>
<h2 id="ServerBootstrapAcceptor"><a class="header-anchor" href="#ServerBootstrapAcceptor">¶</a>ServerBootstrapAcceptor</h2>
<p>我们还得在ServerBootStrap的过程中，我们有看到一个奇怪的类 <code>ServerBootstrapAcceptor</code> 这个类，我们并没有深入去了解这个类的作用，我们现在来简单的分析下这个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ServerBootstrapAcceptor</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123; ➊</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup childGroup;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler childHandler;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable enableAutoReadTask;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">child</span> <span class="operator">=</span> (Channel) msg;</span><br><span class="line"></span><br><span class="line">            child.pipeline().addLast(childHandler); ➋</span><br><span class="line"></span><br><span class="line">            setChannelOptions(child, childOptions, logger);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">                child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                childGroup.register(child).addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123; ➌</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                            forceClose(child, future.cause());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                forceClose(child, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>➊ 这里指明这个 <code>ServerBootstrapAcceptor</code>类是一个 <code>ChannelInboundHandlerAdapter</code> 我们都知道 <code>ChannelInboundHandlerAdapter</code> 的作用是接受数据请求的实际处理者。<br>
➋ 这里我们将Child的Handler附加到<code>Pipeline</code>内<br>
➌ 将 <code>ChildChannel</code> 注册到 <code>ChildEventGroup</code>，我们可以轻而易举的得知，这里就是实现<code>Reactor模式</code>的核心</p>
<h2 id="childGroup-register-child-探秘"><a class="header-anchor" href="#childGroup-register-child-探秘">¶</a>childGroup.register(child) 探秘</h2>
<p>通过IDEA的强势跳转功能，我们轻松的定位到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(channel, <span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数看上去好像有点眼熟，这不就是上一章中服务端是如何注册自己的<code>ServerNioChannel</code>的方案，原来 <code>NioChannel</code> 也是相同的味道。这里就不展开说了，具体的注册过程在上一章中已有体现。</p>
<h2 id="小结1"><a class="header-anchor" href="#小结1">¶</a>小结1</h2>
<p>我们知道 <code>ServerBootstrap</code> 在初始化的过程中创建了一个 <code>ServerBootstrapAcceptor</code>,  <code>ServerBootstrapAcceptor</code> 在读取数据的时候，会将当前的 <code>NioChannel</code>注册到  <code>ChildEventLoopGroup</code> 也就是 <code>workerGroup</code> 中</p>
<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: 已知的Reactor流程',
	 'Client->ServerChannel: 1. Open',
	 'ServerChannel->ServerBootstrapAcceptor: 2.read msg',
	 'ServerBootstrapAcceptor->ChildEventLoopGroup: 3.register(ChannelPromise)',
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>
<p>那对于我们来说，就是 <code>Client</code> 如何触发 <code>ServerChannel</code> 的READ事件 和  <code>ServerChannel</code> 将数据交付给 <code>ServerBootstrapAcceptor</code> 还是未知的。那我们大胆的预测第一个问题是一个Loop循环，而第二个问题是通过Server的<code>Pipeline</code> 传递过去的（因为<code>ServerBootstrapAcceptor</code> 继承自 <code>ChannelInboundHandlerAdapter</code>）,让我们来验证下吧。</p>
<h2 id="借助Debug工具探索"><a class="header-anchor" href="#借助Debug工具探索">¶</a>借助Debug工具探索</h2>
<p>这个时候就不要盲人摸象啦，我们感谢 <code>jetbrains</code> 提供了 <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a> 这个免费的IDE，我们通过断点的方式在我们的代码中设置断点，去观察下运行的<code>栈</code>。<br>
<img src="https://s1.ax1x.com/2018/06/19/CzSfnP.jpg" alt="debug-tool-by-idea"></p>
<p>我们通过 <code>Debug Frames</code> 可以清晰的看到栈，我们一层层的去寻找，我们很快可以发现一个有趣的方案<br>
<code>io.netty.channel.nio.NioEventLoop#run</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; ➊</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="built_in">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys(); ➋</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioStartTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioTime</span> <span class="operator">=</span> System.nanoTime() - ioStartTime;</span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 处的Loop正对应着这个无限循环的事件<br>
➋ 处即是最核心的处理逻辑</p>
<p>这个类是<code>NioEventLoop</code> 我们发现了真正处理逻辑的是在这个Thread的Run中，在这里我们就明白，整个Reactor那个循环中心就是在此处。继续往下探索。</p>
<p>在<code>io.netty.channel.nio.NioEventLoop#processSelectedKey(java.nio.channels.SelectionKey, io.netty.channel.nio.AbstractNioChannel)</code> 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.<span class="type">NioUnsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> ch.unsafe();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readyOps</span> <span class="operator">=</span> k.readyOps();</span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123; ➊</span><br><span class="line">            <span class="type">int</span> <span class="variable">ops</span> <span class="operator">=</span> k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123; ➋</span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123; ➌</span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 处理连接事件<br>
➋ 处理写事件<br>
➌ 处理读事件<br>
我们下一部分分析下 <code>读事件</code> 的处理方式。</p>
<h2 id="Channel-read-探秘"><a class="header-anchor" href="#Channel-read-探秘">¶</a>Channel read 探秘</h2>
<p>在 <code>io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</code> 中有具体的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> <span class="title function_">eventLoop</span><span class="params">()</span>.inEventLoop();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelConfig</span> <span class="variable">config</span> <span class="operator">=</span> config();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> pipeline();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.<span class="type">Handle</span> <span class="variable">allocHandle</span> <span class="operator">=</span> unsafe().recvBufAllocHandle(); </span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">closed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> readBuf.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            readPending = <span class="literal">false</span>;</span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i)); ➊</span><br><span class="line">        &#125;</span><br><span class="line">        readBuf.clear();</span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>去除一些非主干部分，我们发现 ➊ 部分我们将数据传递给Pipeline 处理，到这里解决了我们第一个处的疑问即：就是 <code>Client</code> 如何触发 <code>ServerChannel</code> 的READ事件。那我们还不知道第二个问题，这个本来在ServerEventGroup中的事件是如何委托给 ChildEventGroup 的。那事件的核心即是 ➊ 处的 pipeline，我们通过Debug工具可以轻易的发现这里的pipeline是 <code>DefaultChannelPipeline&#123;(ServerBootstrap$ServerBootstrapAcceptor#0 = io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor)&#125;</code>，wow，我们抓住了它。</p>
<h2 id="小结2"><a class="header-anchor" href="#小结2">¶</a>小结2</h2>
<p>在<a href="#%E5%B0%8F%E7%BB%931">小结1</a>中，我们已经发现了是如何将 <code>BossGroup</code> 的事件委托给 <code>WorkerGroup</code>，而在后续的分析中，我们知道了Netty是如何将最初的监听事件传递给 <code>ServerBootstrapAcceptor</code> 的，如下图。</p>
<div style="width:100%; overflow-y:scroll;" id="diagram2"></div>
<script>
	var data2 =
	['Title: 完整的Reactor流程',
	 'Client->NioEventLoop: 1. Open，在NioEventLoop中循环监听',
     'NioEventLoop->DefaultChannelPipeline: 2.委托给ServerBootstrapAcceptor处理',
	 'DefaultChannelPipeline->ServerBootstrapAcceptor: 2.read msg',
	 'ServerBootstrapAcceptor->ChildEventLoopGroup: 3.register(ChannelPromise)',
    ].join('\n');
  	var diagram = Diagram.parse(data2);
  	diagram.drawSVG("diagram2", {theme: 'simple', scale: 0.5});
</script>
<h2 id="知识点"><a class="header-anchor" href="#知识点">¶</a>知识点</h2>
<ul>
<li>ServerChannel 如何监听事件</li>
<li>BossEventLoopGroup 如何将事件转让给 WorkerEventLoopGroup （ServerBootstrapAcceptor用途）</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
        <category>网络编程</category>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty源码分析-(3)-ChannelPipeline</title>
    <url>/2018/06/20/java/netty/netty-3-pipeline/</url>
    <content><![CDATA[

<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<h2 id="ChannelPipeline"><a class="header-anchor" href="#ChannelPipeline">¶</a>ChannelPipeline</h2>
<p>ChannelPipeline是整个Netty的流程处理的中心，整个结构如下图所示<br>
<img src="https://s1.ax1x.com/2018/06/19/CzGcXn.png" alt="ChannelPipeline"><br>
在 <a href="https://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html">ChannelPipeline.html</a> 有非常详细的文档。<br>
每个channel内部都会持有一个ChannelPipeline对象pipeline。pipeline默认实现DefaultChannelPipeline内部维护了一个DefaultChannelHandlerContext链表。</p>
<span id="more"></span>
<h2 id="DefaultChannelPipeline"><a class="header-anchor" href="#DefaultChannelPipeline">¶</a>DefaultChannelPipeline</h2>
<p><code>DefaultChannelPipeline</code> 是Netty的实现类，我们看看他的内部实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title class_">ChannelPipeline</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext head; ➊</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel; ➋</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelFuture succeededFuture; ➌</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VoidChannelPromise voidPromise;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;EventExecutorGroup, EventExecutor&gt; childExecutors;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> MessageSizeEstimator.Handle estimatorHandle;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ➋ 处我们看到了支撑业务的的 <code>Channel</code>, ➌ 是一个成功的回调函数。而比较有趣的就是这个 head 和 tail了，我们都知道Pipeline就像一个管道一样将流程贯通起来，那Head和Tail看起来就是头和尾的意思。我们看看这2个变量的赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> <span class="title class_">SucceededChannelFuture</span>(channel, <span class="literal">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> <span class="title class_">VoidChannelPromise</span>(channel, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    tail = <span class="keyword">new</span> <span class="title class_">TailContext</span>(<span class="built_in">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> <span class="title class_">HeadContext</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在这里看到tail 和 head 分别是Netty自己实现的类，我们来看看类声明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TailContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractChannelHandlerContext</span> <span class="keyword">implements</span> <span class="title class_">ChannelInboundHandler</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HeadContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractChannelHandlerContext</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">ChannelOutboundHandler</span>, ChannelInboundHandler</span><br></pre></td></tr></table></figure>
<p>Wow，很精妙的实现，分别是一个 ChannelInboundHandler 和一个 ChannelOutboundHandler。</p>
<h2 id="Pipeline-增加-Handler"><a class="header-anchor" href="#Pipeline-增加-Handler">¶</a>Pipeline 增加 Handler</h2>
<p>我们知道我们实现具体的业务逻辑是在 <code>Handler</code> 中，我们在Demo中有一个声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">DiscardHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们在这里添加一个 <code>DiscardHandler</code>,我们探索下这个 <code>addLast()</code> 行为究竟做了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">        addLast0(newCtx); ➊ </span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ➊ 处我们发现最为重要的增加逻辑就是在 <code>addLast0()</code> 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> &#123;</span><br><span class="line">    <span class="type">AbstractChannelHandlerContext</span> <span class="variable">prev</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">    newCtx.prev = prev;</span><br><span class="line">    newCtx.next = tail;</span><br><span class="line">    prev.next = newCtx;</span><br><span class="line">    tail.prev = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是一个很标准的链表操作，看到这里我们就可以大致才出来<code>addXXX()</code>一系列的行为都是类似，用一张图来表示下<br>
<img src="https://s1.ax1x.com/2018/06/19/CzJzV0.png" alt="netty pipeline"></p>
<p>我们一直操作的都是在 <code>Head</code> 和 <code>Tail</code> 之间，我们可以任意的在之间增加或者删除具体的 <code>Handler</code></p>
<h2 id="Pipeline的调用顺序"><a class="header-anchor" href="#Pipeline的调用顺序">¶</a>Pipeline的调用顺序</h2>
<p>万物的开始我们知道从接受数据开始在<br>
<code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code> 中有一行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">readPending = <span class="literal">false</span>;</span><br><span class="line">pipeline.fireChannelRead(byteBuf); ➊</span><br><span class="line">byteBuf = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>➊ 就是万物的开始，从此开始进入Pipeline，然我又在<br>
<code>io.netty.channel.DefaultChannelPipeline#fireChannelRead</code>中获得</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">fireChannelRead</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRead(head, msg); ➋</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➋ 处我们可以看到我们第一次阅读数据是从HeadContext开始的<br>
在 <code>io.netty.channel.AbstractChannelHandlerContext#fireChannelRead</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelHandlerContext <span class="title function_">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> &#123;</span><br><span class="line">    invokeChannelRead(findContextInbound(), msg); ➌</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➌ 处查找InBoundHandler，这个函数还蛮有意思</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title function_">findContextInbound</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AbstractChannelHandlerContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!ctx.inbound);</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是一个标准的循环，我们一直去找到下一个Inbound的Handler去处理。</p>
<h2 id="小结1"><a class="header-anchor" href="#小结1">¶</a>小结1</h2>
<p>在Head的调用中有点特殊有点复杂，我们使用时序图来理解下。</p>
<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: Pipeline的Head处理流程',
	 'NioByteUnsafe->DefaultChannelPipeline: 1. fireChannelRead(byteBuf)',
	 'DefaultChannelPipeline->DefaultChannelPipeline: 2.invokeChannelRead(head, msg)',
	 'DefaultChannelPipeline->DefaultChannelPipeline: 3. ((ChannelInboundHandler) handler()).channelRead(this, msg)',
     'DefaultChannelPipeline->HeadContext: 4. fireChannelRead(msg)',
     'HeadContext->ChannelHandlerContext: 5.invokeChannelRead(findContextInbound(), msg)'
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>
<p>通过 <strong>findContextInbound()</strong> 就获得我们装载的第一个InboundHandler。<br>
通过分析我们得知Pipeline的下一次的调用依赖的是 <code>io.netty.channel.AbstractChannelHandlerContext#fireChannelRead</code> 这个函数。所以在自己编写的 <code>ChannelInboundHandlerAdapter</code> 实现类中，我们在实现 <code>channelRead</code>方法的时候，如果我们需要调用下一层，我们需要手动 <code>ctx.fireChannelRead(msg);</code></p>
<h2 id="延伸-Pipeline-的-Write操作"><a class="header-anchor" href="#延伸-Pipeline-的-Write操作">¶</a>延伸 Pipeline 的 Write操作</h2>
<p>从Head的Read操作中，我们可以猜测出，Write也就是Tail的Write操作，我们去验证下自己的思路。<br>
在<code>io.netty.channel.DefaultChannelPipeline#writeAndFlush(java.lang.Object)</code>处我们发现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tail.writeAndFlush(msg); ➊</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 处证明处理的流程是从 Tail开始的</p>
<p><code>io.netty.channel.AbstractChannelHandlerContext#write(java.lang.Object, boolean, io.netty.channel.ChannelPromise)</code> 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(Object msg, <span class="type">boolean</span> flush, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="type">AbstractChannelHandlerContext</span> <span class="variable">next</span> <span class="operator">=</span> findContextOutbound(); ➋</span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➋ 和FindInBound多么相似，也就是找个下一个OutBound<br>
最终的写入处是在<br>
<code>io.netty.channel.DefaultChannelPipeline.HeadContext#write</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    unsafe.write(msg, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到熟悉的unsafe，根据我们这么久以来和Netty打交道的经验，这里应该就是Java原生的Nio部分。在具体的实现部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(Object msg, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="type">ChannelOutboundBuffer</span> <span class="variable">outboundBuffer</span> <span class="operator">=</span> <span class="built_in">this</span>.outboundBuffer;</span><br><span class="line">    outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将需要写入的数据放入了 <code>outboundBuffer</code> 中。<br>
具体的写入逻辑在 <code>flush</code> 中，最终会调用 <code>io.netty.channel.socket.nio.NioSocketChannel#doWrite</code> 这部分就留给读者自行阅读了。这个时候我们再回顾下 <img src="https://s1.ax1x.com/2018/06/19/CzJzV0.png" alt="netty pipeline"> 大家会发现Netty的Pipeline实现的是如此的优雅，核心的逻辑清晰明了。</p>
<h2 id="知识点"><a class="header-anchor" href="#知识点">¶</a>知识点</h2>
<ul>
<li>ServerChannel 如何监听事件</li>
<li>BossEventLoopGroup 如何将事件转让给 WorkerEventLoopGroup （ServerBootstrapAcceptor用途）</li>
</ul>
<h2 id="附录：ChannelPipeline事件"><a class="header-anchor" href="#附录：ChannelPipeline事件">¶</a>附录：ChannelPipeline事件</h2>
<ul>
<li>Inbound 事件:
<ul>
<li>ChannelHandlerContext.fireChannelRegistered()</li>
<li>ChannelHandlerContext.fireChannelActive()</li>
<li>ChannelHandlerContext.fireChannelRead(Object)</li>
<li>ChannelHandlerContext.fireChannelReadComplete()</li>
<li>ChannelHandlerContext.fireExceptionCaught(Throwable)</li>
<li>ChannelHandlerContext.fireUserEventTriggered(Object)</li>
<li>ChannelHandlerContext.fireChannelWritabilityChanged()</li>
<li>ChannelHandlerContext.fireChannelInactive()</li>
<li>ChannelHandlerContext.fireChannelUnregistered()</li>
</ul>
</li>
<li>Outbound 事件:
<ul>
<li>ChannelHandlerContext.bind(SocketAddress, ChannelPromise)</li>
<li>ChannelHandlerContext.connect(SocketAddress, SocketAddress, ChannelPromise)</li>
<li>ChannelHandlerContext.write(Object, ChannelPromise)</li>
<li>ChannelHandlerContext.flush()</li>
<li>ChannelHandlerContext.read()</li>
<li>ChannelHandlerContext.disconnect(ChannelPromise)</li>
<li>ChannelHandlerContext.close(ChannelPromise)</li>
<li>ChannelHandlerContext.deregister(ChannelPromise)</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
        <category>网络编程</category>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty源码分析-(伪)-(4)-ByteBuf</title>
    <url>/2018/06/21/java/netty/netty-4-bytebuf/</url>
    <content><![CDATA[

<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<h2 id="ByteBuf"><a class="header-anchor" href="#ByteBuf">¶</a>ByteBuf</h2>
<p>ByteBuf 是 Netty 底层支撑。缓冲区是不同的通道之间传递数据的中介，JDK中的ByteBuffer操作复杂，而且没有经过优化，所以在netty中实现了一个更加强大的缓冲区 ByteBuf 用于表示字节序列。ByteBuf在netty中是通过Channel传输数据的，新的设计解决了JDK中ByteBuffer中的一些问题。</p>
<ul>
<li>可扩展到用户定义的buffer类型中</li>
<li>通过内置的复合buffer类型实现透明的零拷贝(zero-copy)</li>
<li>容量可以根据需要扩展</li>
<li>切换读写模式不需要调用ByteBuffer.flip()方法</li>
<li>读写采用不同的索引</li>
<li>支持方法链接调用</li>
<li>支持引用计数</li>
<li>支持池技术(比如：线程池、数据库连接池)</li>
</ul>
<span id="more"></span>
<h2 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h2>
<p>ByteBuf维护两个不同的索引：读索引和写索引。当你从ByteBuf中读，它的readerIndex增加了读取的字节数；同理，当你向ByteBuf中写，writerIndex增加。下图显示了一个空的ByteBuf的布局和状态:<br>
<img src="https://s1.ax1x.com/2018/06/21/PSN5TI.png" alt="empty"></p>
<h2 id="自动扩容"><a class="header-anchor" href="#自动扩容">¶</a>自动扩容</h2>
<p>在 <code>Java Nio</code> 的 <code>java.nio.HeapByteBuffer#put(byte)</code> 中我们可以看java 的 <code>ByteBuffer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span> x)</span> &#123;</span><br><span class="line">    hb[ix(nextPutIndex())] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nextPutIndex</span><span class="params">()</span> &#123;                         </span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BufferOverflowException</span>(); ➊</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java <code>ByteBuffer</code> 达到上限的时候需要自己手动创建一个新的 <code>ByteBuffer</code> 再存入。而对比 <code>ByteBuf</code></p>
<p><code>io.netty.buffer.AbstractByteBuf#writeByte</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ByteBuf <span class="title function_">writeByte</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    ensureWritable0(<span class="number">1</span>);</span><br><span class="line">    _setByte(writerIndex++, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">ensureWritable0</span><span class="params">(<span class="type">int</span> minWritableBytes)</span> &#123;</span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="keyword">if</span> (minWritableBytes &lt;= writableBytes()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Normalize the current capacity to the power of 2.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);</span><br><span class="line">➋</span><br><span class="line">    <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line">    capacity(newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ➋ Netty的ByteBuf 会进行自动的扩容。拓展的倍数是 2</p>
<h2 id="池化技术"><a class="header-anchor" href="#池化技术">¶</a>池化技术</h2>
<p>传统的 <code>ByteBuffer</code> 的生命周期是委托给 <code>JVM</code> 管理的，Netty分为2块</p>
<ul>
<li>基于对象池的ByteBuf: PooledByteBuf和它的子类PoolDirectByteBuf、PoolUnsafeDirectByteBuf、PooledHeapByteBuf</li>
<li>普通的ByteBuf: UnPoolDirectByteBuf、UnPoolUnsafeDirectByteBuf、UnPoolHeapByteBuf</li>
</ul>
<p>基于对象池的ByteBuf 的核心逻辑就在 <code>PoolArena</code> 对象，关于 <code>PoolArena</code> 的原理可以参看</p>
<ul>
<li><a href="https://www.jianshu.com/p/c4bd37a3555b">深入浅出Netty内存管理</a></li>
<li><a href="https://book.douban.com/subject/26373138/">Netty权威指南</a></li>
</ul>
<h2 id="Netty的零拷贝"><a class="header-anchor" href="#Netty的零拷贝">¶</a>Netty的零拷贝</h2>
<ul>
<li>DirectByteBuf: ByteBuf可以分为HeapByteBuf和DirectByteBuf，当使用DirectByteBuf可以实现零拷贝</li>
<li>DefaultFileRegion: DefaultFileRegion是Netty的文件传输类，它通过transferTo方法将文件直接发送到目标Channel，而不需要循环拷贝的方式，提升了传输性能</li>
</ul>
<p>这块都设计到java的 <code>native</code> 代码故不展开讲。</p>
<h2 id="Netty的内存回收管理"><a class="header-anchor" href="#Netty的内存回收管理">¶</a>Netty的内存回收管理</h2>
<p>Netty会通过 引用计数法 及时申请释放不再被引用的对象 ，实现上是通过 AbstractReferenceCountedByteBuf来实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// increment</span></span><br><span class="line"><span class="keyword">private</span> ByteBuf <span class="title function_">retain0</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> increment)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldRef</span> <span class="operator">=</span> refCntUpdater.getAndAdd(<span class="built_in">this</span>, increment);</span><br><span class="line">    <span class="keyword">if</span> (oldRef &lt;= <span class="number">0</span> || oldRef + increment &lt; oldRef) &#123;</span><br><span class="line">        <span class="comment">// Ensure we don&#x27;t resurrect (which means the refCnt was 0) and also that we encountered an overflow.</span></span><br><span class="line">        refCntUpdater.getAndAdd(<span class="built_in">this</span>, -increment);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalReferenceCountException</span>(oldRef, increment);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decrement</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">release0</span><span class="params">(<span class="type">int</span> decrement)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldRef</span> <span class="operator">=</span> refCntUpdater.getAndAdd(<span class="built_in">this</span>, -decrement);</span><br><span class="line">    <span class="keyword">if</span> (oldRef == decrement) &#123;</span><br><span class="line">        deallocate();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldRef &lt; decrement || oldRef - decrement &gt; oldRef) &#123;</span><br><span class="line">        <span class="comment">// Ensure we don&#x27;t over-release, and avoid underflow.</span></span><br><span class="line">        refCntUpdater.getAndAdd(<span class="built_in">this</span>, decrement);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalReferenceCountException</span>(oldRef, -decrement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有同学会问，为什么需要<code>计数引用</code>，因为Netty采用了池化的技术，GC是无法回收这些数据的，需要自己实现一个简单的GC，技术引用是最简单的方式。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
        <category>网络编程</category>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty源码分析-(5)-其他</title>
    <url>/2018/06/21/java/netty/netty-5-otherwise/</url>
    <content><![CDATA[<h1>其他部分</h1>
<p>Netty最为核心部分我们已经大致上了解完了，Netty中还有一些其他可能会问到的知识点，我们在这里一并提一下。</p>
<span id="more"></span>
<h2 id="epoll空转bug"><a class="header-anchor" href="#epoll空转bug">¶</a>epoll空转bug</h2>
<p><a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6670302">JDK-6670302 : (se) NIO selector wakes up with 0 selected keys infinitely [lnx 2.4]<br>
</a> 这个Bug就是在Select阶段应该会阻塞的，但是JDK在实现调用系统底层函数，由于Epoll会获取不到任何时间，而Select又不断的在唤醒，最终导致CPU 100%</p>
<blockquote>
<p>在部分Linux的2.6的kernel中，poll和epoll对于突然中断的连接socket会对返回的eventSet事件集合置为POLLHUP，也可能是POLLERR，eventSet事件集合发生了变化，这就可能导致Selector会被唤醒。==》这是与操作系统机制有关系的，JDK虽然仅仅是一个兼容各个操作系统平台的软件，但很遗憾在JDK5和JDK6最初的版本中（严格意义上来将，JDK部分版本都是），这个问题并没有解决，而将这个帽子抛给了操作系统方，这也就是这个bug最终一直到2013年才最终修复的原因，最终影响力太广。</p>
</blockquote>
<p>Nett解决思路记录select空转的次数，定义一个阈值，这个阈值默认是512，可以在应用层通过设置系统属性io.netty.selectorAutoRebuldThreshold传入，当空转的次数超过了这个阈值，重新构建新Selector，将老Selector上注册的Channel转移到新建的Selector上，关闭老Selector，用新的Selector代替老Selector。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(<span class="type">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="built_in">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">selectCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTimeNanos</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="type">long</span> <span class="variable">selectDeadLineNanos</span> <span class="operator">=</span> currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//略</span></span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                <span class="comment">// timeoutMillis elapsed without anything selected.</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123; ➊</span><br><span class="line">                rebuildSelector(); ➋</span><br><span class="line">                selector = <span class="built_in">this</span>.selector; ➌</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Select again to populate selectedKeys.</span></span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 处我们发现 当空转的次数超过 <code>SELECTOR_AUTO_REBUILD_THRESHOLD</code> 就会触发下面这个流程分支<br>
➋ 在此处重建 Selector 在 <code>io.netty.channel.nio.NioEventLoop#rebuildSelector0</code><br>
➌ 替换原有的 Selector</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
        <category>网络编程</category>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Java网络编程-(1)-NIO基础</title>
    <url>/2018/05/07/java/nio/java-nio-1-basic/</url>
    <content><![CDATA[<h2 id="Java-BIO"><a class="header-anchor" href="#Java-BIO">¶</a>Java BIO</h2>
<p>传统的网络模式是BIO的模式<br>
<img src="http://tutorials.jenkov.com/images/java-nio/nio-vs-io-1.png" alt="BIO"></p>
<p>我们发现BIO编程模型中最为致命的部分就是 我们需要为 <strong>Stream</strong> 使用一个 <strong>Thread</strong>。<br>
所以在JDK1.6中引入了NIO，优化这一部分。</p>
<span id="more"></span>
<h2 id="Java-NIO"><a class="header-anchor" href="#Java-NIO">¶</a>Java NIO</h2>
<p>NIO 的网络模型对比BIO模式，主要采用 <strong>面向缓存</strong> 的方式。<br>
<img src="https://image.slidesharecdn.com/javanio2final1-160607115222/95/java-nio2-7-638.jpg?cb=1465300539" alt="NIO"></p>
<h2 id="Java-NIO-编程抽象"><a class="header-anchor" href="#Java-NIO-编程抽象">¶</a>Java NIO 编程抽象</h2>
<p>Java将NIO抽象为三个模型 <code>Channels</code> <code>Buffers</code> <code>Selectors</code></p>
<ul>
<li>Channels: 提供Buffers的读写能力</li>
<li>Buffers: 面向缓存的数据</li>
<li>Selectors: 选择器</li>
</ul>
<p>Selector 可以让一个线程处理多个 Channels<br>
<img src="http://tutorials.jenkov.com/images/java-nio/overview-selectors.png" alt="overview-selectors"></p>
<p>关于Channels，如果我一点Linux编程的经验，我们应该也会猜测出Channel中是储存具体的FD（文件句柄）。<br>
<img src="http://tutorials.jenkov.com/images/java-nio/overview-channels-buffers.png" alt="overview-channels-buffers"></p>
<h2 id="Java-NIO-的编程模版"><a class="header-anchor" href="#Java-NIO-的编程模版">¶</a>Java NIO 的编程模版</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectableChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.text.html.HTMLDocument.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Simple echo-back server which listens for incoming stream connections and</span></span><br><span class="line"><span class="comment">* echoes back whatever it reads. A single Selector object is used to listen to</span></span><br><span class="line"><span class="comment">* the server socket (to accept new connections) and all the active socket</span></span><br><span class="line"><span class="comment">* channels.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zale (zalezone.cn)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSockets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">PORT_NUMBER</span> <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SelectSockets</span>().go(argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> PORT_NUMBER;</span><br><span class="line">        <span class="keyword">if</span> (argv.length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">// 覆盖默认的监听端口</span></span><br><span class="line">            port = Integer.parseInt(argv[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Listening on port &quot;</span> + port);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();<span class="comment">// 打开一个未绑定的serversocketchannel</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> serverChannel.socket();<span class="comment">// 得到一个ServerSocket去和它绑定</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();<span class="comment">// 创建一个Selector供下面使用</span></span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));<span class="comment">//设置server channel将会监听的端口</span></span><br><span class="line">        serverChannel.configureBlocking(<span class="literal">false</span>);<span class="comment">//设置非阻塞模式</span></span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);<span class="comment">//将ServerSocketChannel注册到Selector</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// This may block for a long time. Upon returning, the</span></span><br><span class="line">            <span class="comment">// selected set contains keys of the ready channels.</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// nothing to do</span></span><br><span class="line">            &#125;           </span><br><span class="line">            java.util.Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();<span class="comment">// Get an iterator over the set of selected keys</span></span><br><span class="line">            <span class="comment">//在被选择的set中遍历全部的key</span></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> (SelectionKey) it.next();</span><br><span class="line">                <span class="comment">// 判断是否是一个连接到来</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span>(ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> server.accept();</span><br><span class="line">                    registerChannel(selector, channel,SelectionKey.OP_READ);<span class="comment">//注册读事件</span></span><br><span class="line">                    sayHello(channel);<span class="comment">//对连接进行处理</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断这个channel上是否有数据要读</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable())</span><br><span class="line">                &#123;</span><br><span class="line">                    readDataFromSocket(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从selected set中移除这个key，因为它已经被处理过了</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ----------------------------------------------------------</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Register the given channel with the given selector for the given</span></span><br><span class="line"><span class="comment">    * operations of interest</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerChannel</span><span class="params">(Selector selector,SelectableChannel channel, <span class="type">int</span> ops)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 可能会发生</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置通道为非阻塞</span></span><br><span class="line">        channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 将通道注册到选择器上</span></span><br><span class="line">        channel.register(selector, ops);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ----------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Use the same byte buffer for all channels. A single thread is</span></span><br><span class="line">    <span class="comment">// servicing all the channels, so no danger of concurrent acccess.</span></span><br><span class="line">    <span class="comment">//对所有的通道使用相同的缓冲区。单线程为所有的通道进行服务，所以并发访问没有风险</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sample data handler method for a channel with data ready to read.</span></span><br><span class="line"><span class="comment">    * 对于一个准备读入数据的通道的简单的数据处理方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    A SelectionKey object associated with a channel determined by</span></span><br><span class="line"><span class="comment">    the selector to be ready for reading. If the channel returns</span></span><br><span class="line"><span class="comment">    an EOF condition, it is closed here, which automatically</span></span><br><span class="line"><span class="comment">    invalidates the associated key. The selector will then</span></span><br><span class="line"><span class="comment">    de-register the channel on the next select call.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    一个选择器决定了和通道关联的SelectionKey object是准备读状态。如果通道返回EOF，通道将被关闭。</span></span><br><span class="line"><span class="comment">    并且会自动使相关的key失效，选择器然后会在下一次的select call时取消掉通道的注册</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">readDataFromSocket</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        buffer.clear(); <span class="comment">// 清空Buffer</span></span><br><span class="line">        <span class="comment">// Loop while data is available; channel is nonblocking</span></span><br><span class="line">        <span class="comment">//当可以读到数据时一直循环，通道为非阻塞</span></span><br><span class="line">        <span class="keyword">while</span> ((count = socketChannel.read(buffer)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer.flip(); <span class="comment">// 将缓冲区置为可读</span></span><br><span class="line">            <span class="comment">// Send the data; don&#x27;t assume it goes all at once</span></span><br><span class="line">            <span class="comment">//发送数据，不要期望能一次将数据发送完</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining())</span><br><span class="line">            &#123;</span><br><span class="line">                socketChannel.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// WARNING: the above loop is evil. Because</span></span><br><span class="line">            <span class="comment">// it&#x27;s writing back to the same nonblocking</span></span><br><span class="line">            <span class="comment">// channel it read the data from, this code can</span></span><br><span class="line">            <span class="comment">// potentially spin in a busy loop. In real life</span></span><br><span class="line">            <span class="comment">// you&#x27;d do something more useful than this.</span></span><br><span class="line">            <span class="comment">//这里的循环是无意义的，具体按实际情况而定</span></span><br><span class="line">            buffer.clear(); <span class="comment">// Empty buffer</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Close channel on EOF, invalidates the key</span></span><br><span class="line">            <span class="comment">//读取结束后关闭通道，使key失效</span></span><br><span class="line">            socketChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ----------------------------------------------------------</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Spew a greeting to the incoming client connection.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    The newly connected SocketChannel to say hello to.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        buffer.clear();</span><br><span class="line">        buffer.put(<span class="string">&quot;Hi there!\r\n&quot;</span>.getBytes());</span><br><span class="line">        buffer.flip();</span><br><span class="line">        channel.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ol>
<li><a href="http://tutorials.jenkov.com/java-nio/index.html">Java NIO Tutorial</a></li>
<li><a href="http://www.importnew.com/22623.html">java NIO详解</a></li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
        <category>网络编程</category>
        <category>NIO</category>
      </categories>
  </entry>
  <entry>
    <title>Java社区的新方向</title>
    <url>/2020/06/20/java/other/2020-new-direction/</url>
    <content><![CDATA[<p><code>Java</code> 作为一个不怎么年轻的语言，从 <code>JDK9</code> 开始加速进化，颇有老树焕新芽的风采。语言上 <code>类型自动推动</code> <code>No-Op Garbage Collector</code> <code>JEP 321: HTTP Client</code> 也算是非常的务实了。但是除了语言本身更重要的是社区建设，站在 2020 的时间节点上，我们看看未来社区的几个新方向。</p>
<span id="more"></span>
<h1>去JVM化</h1>
<p>为啥要去 <code>JVM</code>，这事情这事情就让我给大家掰扯掰扯。<code>Java社区</code> 在他所诞生的时代为了解决不同操作系统之间的隔离屏障，做了一个很重的实现，其名曰为 <code>虚拟机</code>，在 90 年代虚拟机技术给广大的开发者解决非常多跨系统不一致的问题，但是在现在这个节点，虚拟机技术慢慢的正在变的鸡肋起来，原因有三（从国内的角度看）：</p>
<ol>
<li>服务器技术统一化：国内的大厂和小厂都在积极的 Linux 化，指令集也是 <code>x86</code> 为主，Jvm跨平台的特性的基石正在消失。</li>
<li>云原生的冲击：CNCF社区带着Go走来，交叉编译能解决 90% 的问题，还没有臃肿的镜像问题，更云原生了。</li>
<li>资源消耗 &amp; 产品规模：JVM 有一个消耗资源的基础线，包括每次 malloc 都会消耗更多的资源，以前做的都是大型应用（单体，巨石），现在随着微服务的发展，<code>JVM</code> 的性能诟病又重新摆到了桌子上。</li>
</ol>
<p>因此随着行业的发展，语言也需要适应发展，现在大家需要的是 <code>易开发</code> <code>资源消耗低</code> <code>云原生</code> 的编程语言(框架)，因此一个行业新星正在冉冉升起 <code>GraalVM</code>，基于 <code>Java</code> 语言本身将 Bytcode 转化为 NativeCode。</p>
<h1>ServiceMesh化</h1>
<p>这个其实不能算是社区的变化，不过因为这个特性会导致整个研发体系发生剧变，就单独拿出来说说。</p>
<p><code>Mesh</code> 也是分时代的，对于 <code>Isito</code> 这样的组件，我认为还是 <code>v1.0</code> 的时代，此时我们注重的是网络流量的走向问题，从而来解决比如灰度发布之类的问题，并且基于这些能力做一些 <code>流控</code> <code>请求安全</code> 的功能。<br>
但是慢慢的社区迈入 <code>v2.0</code> 时代，因为在之前的模式中，我们没有对应用进行任何修改。但是在 <code>v2.0</code> 时期，我们需要做的是真正的 <code>ServiceMesh</code>。</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NGjejx.png" alt="NGjejx.png"></p>
<p>未来我们会在应用之间增加一层 <code>Mesh</code> 层，那好奇的朋友肯定会问，这个和以前的中间件有啥区别？这里的区别可大了，举一个例子：</p>
<blockquote>
<p>比如你在企业内部提供的内部接口能力，当你第一次交付出去的时候是 v1 版本，当你需要发新版的时候你发布了 v2 版本。但是你不知道谁用了你的 v1 版本，你只能让其继续维护下去，而在 <code>Mesh</code> 时代，你可以在不修应用的情况下，就直接将所有v1版本请求进行一点点修正，再让其把所有的流量转移到 v2 上，这样你再也不需要维护2个不同的版本了。</p>
</blockquote>
<p>伴随着 <code>Mesh</code> 技术的普及，慢慢的我们会发现，我们对中间件和应用都提出了新的理念，规范应用开发体系，桂发中间件提供的API规范，将所有的技术层都放置于 <code>Mesh</code> 中。</p>
<p><img src="https://vjvcpg.dm.files.1drv.com/y4mrL7Bo198vgFvtPcn4P8_fwm7FyFrAsP-4GtXA4_2yUn3KuLfhvf0ED2nBUPt0xR4rXiDq9CwTKgulXtOqEHgqbusyYAZFN3m0gR-Xk4LVoJfRJzR07euG1yRpjbZoepNpMpkfsb8lvIhLFBjdDPFxvDEDjwUPfAwK0KxxcGrrqdnQT6jiJc2bbzaG09zPKhaOErN7MNPKUfw3PAqWQ0uAw?width=661&amp;height=231&amp;cropmode=none" alt="cool"></p>
<p>而这一切社区也在积极的推动，比如 <code>Macha</code> 理论等<br>
<img src="https://s1.ax1x.com/2020/06/22/NGOEa4.png" alt="NGOEa4.png"></p>
<h1>框架轻量级化</h1>
<p>因为未来的趋势是 <code>Mesh</code> 话，原本 <code>Spring Cloud</code> <code>Spring Sercuirty</code> 的能力都慢慢的沉淀到中间层，因为 <code>Java</code> 现在的臃肿，可能并不适合中间层，未来可能还是会长时间的在 <code>Biz</code> 层，而在 <code>Biz</code> 我们需要的显然是 <code>轻量级</code> <code>业务友好型</code> 的框架，如果能高性能就更好了。</p>
<p>不过社区在这方面已经有了一些成果：</p>
<ul>
<li><a href="https://vertx.io/">Vertx</a> : 一个性能至上的框架系列。</li>
<li><a href="micronaut">Micronaut</a>: 非常友好的微服务框架</li>
</ul>
<p>包括之前的 <code>SparkWeb</code> 之类，都可能在未来焕发第二春，Java并不是一个啰嗦的语言，但是惯用法在 <code>Spring</code> 时代已经被约定，但是面对 <code>Go</code> 系列的冲击，也不得不进行转换。</p>
<h1>参考</h1>
<ul>
<li><a href="https://www.zhihu.com/question/274042223">如何评价 GraalVM 这个项目</a></li>
<li><a href="https://developer.aliyun.com/article/761321">Mecha：将 Mesh 进行到底</a></li>
<li><a href="https://www.redhat.com/en/topics/microservices/what-is-a-service-mesh">What is service mesh</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>New Features in Java 9,10,11</title>
    <url>/2021/04/24/java/other/java11/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2021/04/24/aSn1L.png" alt="aSn1L.png"></p>
<blockquote>
<p>Java 11 is the first long-term support (LTS) release after Java 8. Oracle also stopped supporting Java 8 in January 2019. As a consequence, a lot of us will upgrade to Java 11.</p>
</blockquote>
<p>作为 <code>8</code> 之后的 <code>LTS</code> 版本，让我们来快速学习一下吧</p>
<span id="more"></span>
<h2 id="模块化"><a class="header-anchor" href="#模块化">¶</a>模块化</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> com.baeldung.java9.modules.car &#123;</span><br><span class="line">    <span class="keyword">requires</span> com.baeldung.java9.modules.engines;</span><br><span class="line">    <span class="keyword">exports</span> com.baeldung.java9.modules.car.handling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模块化并不算服务端很刚需的需求，更多的可以查阅 <a href="https://openjdk.java.net/projects/jigsaw/quick-start"><code>Project Jigsaw: Module System Quick-Start Guide</code></a></p>
<h2 id="全新的-HTTPClient"><a class="header-anchor" href="#全新的-HTTPClient">¶</a>全新的 HTTPClient</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClient.newBuilder()</span><br><span class="line">  .version(HttpClient.Version.HTTP_2)</span><br><span class="line">  .connectTimeout(Duration.ofSeconds(<span class="number">20</span>))</span><br><span class="line">  .build();</span><br><span class="line"><span class="type">HttpRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> HttpRequest.newBuilder()</span><br><span class="line">  .GET()</span><br><span class="line">  .uri(URI.create(<span class="string">&quot;http://localhost:&quot;</span> + port))</span><br><span class="line">  .build();</span><br><span class="line"><span class="type">HttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">assertThat(httpResponse.body()).isEqualTo(<span class="string">&quot;Hello from the server!&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Interface-私有方法"><a class="header-anchor" href="#Interface-私有方法">¶</a>Interface 私有方法</h2>
<p>interface 越来越像一个普通 <code>class</code> 了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceWithPrivateMethods</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">staticPrivate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;static private&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">instancePrivate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;instance private&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> staticPrivate();</span><br><span class="line">        <span class="type">InterfaceWithPrivateMethods</span> <span class="variable">pvt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceWithPrivateMethods</span>() &#123;</span><br><span class="line">            <span class="comment">// anonymous class</span></span><br><span class="line">        &#125;;</span><br><span class="line">        result = pvt.instancePrivate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="local-变量"><a class="header-anchor" href="#local-变量">¶</a>local 变量</h2>
<p>在 <code>jdk10</code> 中增加了一个新的关键字，减少啰嗦的类型定义。</p>
<table>
<tr><td> Java 8 </td></tr>
<tr><td> 
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
</td></tr>
<tr><td> Java 11</td></tr>
<tr><td>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">idToNameMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br></pre></td></tr></table></figure>
</td></tr>
</table>
<p>不过限制还是很多的，只能在局部变量使用。</p>
<h2 id="更多-String-操作函数"><a class="header-anchor" href="#更多-String-操作函数">¶</a>更多 String 操作函数</h2>
<p>增加了 <code>isBlank</code>, <code>lines</code>, <code>strip</code>, <code>stripLeading</code>, <code>stripTrailing</code>, and <code>repeat</code> 这些函数。</p>
<table>
<tr><td> Java 8 </td></tr>
<tr><td> 
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">multilineString</span> </span><br><span class="line">      <span class="operator">=</span> <span class="string">&quot;Baeldung helps \n developers \n explore Java.&quot;</span>;</span><br><span class="line">List&lt;String&gt; lines =  Arrays.stream(multilineString.split(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line">        .filter(StringUtils::isBlank)</span><br><span class="line">        .map(String::strip)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</td></tr>
<tr><td> Java 11</td></tr>
<tr><td>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">multilineString</span> </span><br><span class="line">      <span class="operator">=</span> <span class="string">&quot;Baeldung helps \n developers \n explore Java.&quot;</span>;</span><br><span class="line">List&lt;String&gt; lines = multilineString.lines()</span><br><span class="line">        .filter(line -&gt; !line.isBlank())</span><br><span class="line">        .map(String::strip)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</td></tr>
</table>
<h2 id="文件读操作"><a class="header-anchor" href="#文件读操作">¶</a>文件读操作</h2>
<p>增加了 <code>readString</code> 和 ``writeString` 两种操作</p>
<table>
<tr><td> Java 8 </td></tr>
<tr><td> 
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(Files.createTempFile(tempDir, <span class="string">&quot;demo&quot;</span>, <span class="string">&quot;.txt&quot;</span>).toFile()));</span><br><span class="line">outputStreamWriter.write(<span class="string">&quot;Sample text&quot;</span>);</span><br></pre></td></tr></table></figure>
</td></tr>
<tr><td> Java 11</td></tr>
<tr><td>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">filePath</span> <span class="operator">=</span> Files.writeString(Files.createTempFile(tempDir, <span class="string">&quot;demo&quot;</span>, <span class="string">&quot;.txt&quot;</span>), <span class="string">&quot;Sample text&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">fileContent</span> <span class="operator">=</span> Files.readString(filePath);</span><br><span class="line">assertThat(fileContent).isEqualTo(<span class="string">&quot;Sample text&quot;</span>);</span><br></pre></td></tr></table></figure>
</td></tr>
</table>
<h2 id="Collection-2-Array"><a class="header-anchor" href="#Collection-2-Array">¶</a>Collection 2 Array</h2>
<p>包含一个比较 <code>符合直觉</code> 的方式将 Collection 转化为 Array</p>
<table>
<tr><td> Java 8 </td></tr>
<tr><td> 
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">sampleList</span> <span class="operator">=</span> Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>);</span><br><span class="line">String[] sampleArray =sampleList.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>])</span><br><span class="line">assertThat(sampleArray).containsExactly(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>);</span><br></pre></td></tr></table></figure>
</td></tr>
<tr><td> Java 11</td></tr>
<tr><td>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">sampleList</span> <span class="operator">=</span> Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>);</span><br><span class="line">String[] sampleArray = sampleList.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">assertThat(sampleArray).containsExactly(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>);</span><br></pre></td></tr></table></figure>
</td></tr>
</table>
<h2 id="Lambda-的-局部变量-语法"><a class="header-anchor" href="#Lambda-的-局部变量-语法">¶</a>Lambda 的 局部变量 语法</h2>
<table>
<tr><td> Java 8 </td></tr>
<tr><td> 
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; sampleList = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">resultString</span> <span class="operator">=</span> sampleList.stream()</span><br><span class="line">  .map((<span class="meta">@Nonnull</span> String x) -&gt; x.toUpperCase())</span><br><span class="line">  .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line">assertThat(resultString).isEqualTo(<span class="string">&quot;JAVA, KOTLIN&quot;</span>);</span><br></pre></td></tr></table></figure>
</td></tr>
<tr><td> Java 11</td></tr>
<tr><td>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; sampleList = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">resultString</span> <span class="operator">=</span> sampleList.stream()</span><br><span class="line">  .map((<span class="meta">@Nonnull</span> <span class="keyword">var</span> x) -&gt; x.toUpperCase())</span><br><span class="line">  .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line">assertThat(resultString).isEqualTo(<span class="string">&quot;JAVA, KOTLIN&quot;</span>);</span><br></pre></td></tr></table></figure>
</td></tr>
</table>
<h2 id="全量更新列表"><a class="header-anchor" href="#全量更新列表">¶</a>全量更新列表</h2>
<ul>
<li><a href="http://openjdk.java.net/projects/jdk9/">jdk9 更新</a></li>
<li><a href="http://openjdk.java.net/projects/jdk10/">jdk10 更新</a></li>
<li><a href="http://openjdk.java.net/projects/jdk11/">jdk11 更新</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>写给 Java 开发者的 Kotlin 教程 (2) - 基础语法</title>
    <url>/2018/07/10/kotlin/easy-way-to-kotlin-for-java-proggamer/basic-syntax/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2018/07/11/PuAzgf.png" alt="banner"></p>
<p>作为教程的第一章，我们先从 <code>基础语言</code> 开始了解一下 <code>Kotlin</code>，并了解和 <code>Java</code> 的不同之处。</p>
<span id="more"></span>
<h2 id="包定义"><a class="header-anchor" href="#包定义">¶</a>包定义</h2>
<div class="tabs" id="package"><ul class="nav-tabs"><li class="tab active"><a href="#package-1">Kotlin</a></li><li class="tab"><a href="#package-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="package-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.demo</span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="package-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> my.demo</span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="comment">// 和左边是一样的</span></span><br></pre></td></tr></table></figure></div></div></div>
<p><strong>敲黑板：</strong> <code>Kotlin</code> 和 <code>Java</code> 不同之处在于，<code>Kotlin</code> 源文件可以任意放置在文件夹内，而 <code>Java</code> 不行。<br>
这个特性对于代码部分没有太多的影响，但是针对 <code>Test</code> 部分的代码，我们可以将测试的代码更灵活的存放于不同的 <code>目录</code> 之下。</p>
<h2 id="函数定义"><a class="header-anchor" href="#函数定义">¶</a>函数定义</h2>
<div class="tabs" id="functuin"><ul class="nav-tabs"><li class="tab active"><a href="#functuin-1">Kotlin</a></li><li class="tab"><a href="#functuin-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="functuin-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="functuin-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p><strong>敲黑板：</strong> <code>Kotlin</code> 更注重代码的可读性，<code>变量名</code> 在 <code>变量类型</code> 之前，返回值在函数声明的最后。<br>
<img src="https://s1.ax1x.com/2018/07/11/PumGwD.png" alt="function syntax"></p>
<h2 id="变量定义"><a class="header-anchor" href="#变量定义">¶</a>变量定义</h2>
<div class="tabs" id="vars"><ul class="nav-tabs"><li class="tab active"><a href="#vars-1">Kotlin</a></li><li class="tab"><a href="#vars-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="vars-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1</span>  <span class="comment">// 立即赋值</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">2</span>   <span class="comment">// `Int` 类型被推导而来</span></span><br><span class="line"><span class="keyword">val</span> c: <span class="built_in">Int</span>  <span class="comment">// 声明而无赋值</span></span><br><span class="line">c = <span class="number">3</span>       <span class="comment">// 延迟赋值</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="vars-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> b;</span><br><span class="line">b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div></div></div>
<p><strong>敲黑板：</strong> <code>Kotlin</code> 拥有更强的 <code>类型推导能力</code>，大部分情况下都可以通过 <code>右值</code> 推导出 <code>左值</code>的申明。另外 <code>Kotlin</code> 中区分 <code>val</code> 和 <code>var</code>， <code>val</code> 类似于 <code>Java</code> 中的 <code>final</code> 修饰符仅仅允许进行一次赋值操作。如果需要使用变量需要采用如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span> </span><br><span class="line">x += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="注释"><a class="header-anchor" href="#注释">¶</a>注释</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is an end-of-line comment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is a block comment</span></span><br><span class="line"><span class="comment">   on multiple lines. */</span></span><br></pre></td></tr></table></figure>
<p>和 <code>Java</code> <code>Javascript</code> 都是一样的，唯一不同的是 <code>Kotlin</code> 的注释是允许嵌套的。比如如下是合法的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="comment">    /*</span></span></span><br><span class="line"><span class="comment"><span class="comment">    nest comment</span></span></span><br><span class="line"><span class="comment"><span class="comment">     */</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="String-模版"><a class="header-anchor" href="#String-模版">¶</a>String 模版</h2>
<div class="tabs" id="string-template"><ul class="nav-tabs"><li class="tab active"><a href="#string-template-1">Kotlin</a></li><li class="tab"><a href="#string-template-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="string-template-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="string">&quot;a is <span class="variable">$a</span>&quot;</span>  <span class="comment">// 简单映射</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> s2 = <span class="string">&quot;<span class="subst">$&#123;s1.replace(<span class="string">&quot;is&quot;</span>, <span class="string">&quot;was&quot;</span>)&#125;</span>, but now is <span class="variable">$a</span>&quot;</span> <span class="comment">// 复杂表达式嵌入</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="string-template-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.format(<span class="string">&quot;a is %d&quot;</span>,a);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s, but now is %a&quot;</span>, s1.replace(<span class="string">&quot;is&quot;</span>, <span class="string">&quot;was&quot;</span>), a);</span><br></pre></td></tr></table></figure></div></div></div>
<p>更多功能后续介绍</p>
<h2 id="简化IF表达式"><a class="header-anchor" href="#简化IF表达式">¶</a>简化IF表达式</h2>
<div class="tabs" id="expressions"><ul class="nav-tabs"><li class="tab active"><a href="#expressions-1">Kotlin</a></li><li class="tab"><a href="#expressions-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="expressions-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxOf</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b </span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="expressions-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxOf</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p><strong>敲黑板：</strong>  <code>Kotlin</code> 简化一些简单表达式。</p>
<h2 id="可空类型"><a class="header-anchor" href="#可空类型">¶</a>可空类型</h2>
<p><code>Kotlin</code> 当值可能为 <code>null</code> 时，必须将引用显式标记为可为空。</p>
<div class="tabs" id="nullable"><ul class="nav-tabs"><li class="tab active"><a href="#nullable-1">Kotlin</a></li><li class="tab"><a href="#nullable-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="nullable-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(str: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="comment">// 任何Int 或者 null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(str: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 任何Int 不可能为 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="nullable-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer <span class="title function_">paserInt</span><span class="params">(String input)</span>&#123;</span><br><span class="line">    <span class="comment">// 无法判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p><strong>敲黑板：</strong>  <code>Kotlin</code> 在解决 <code>NPE</code> 问题从编译器的层面去解决，关于这个设计模式，我们将单独开辟一篇进行讲解。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printProduct</span><span class="params">(arg1: <span class="type">String</span>, arg2: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = parseInt(arg1)</span><br><span class="line">    <span class="keyword">val</span> y = parseInt(arg2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 x 和 y 之前必须进行 非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; y != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// x and y are automatically cast to non-nullable after null check</span></span><br><span class="line">        println(x * y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;either &#x27;<span class="variable">$arg1</span>&#x27; or &#x27;<span class="variable">$arg2</span>&#x27; is not a number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型检查与自动转换"><a class="header-anchor" href="#类型检查与自动转换">¶</a>类型检查与自动转换</h2>
<div class="tabs" id="type-checks-and-automatic-casts"><ul class="nav-tabs"><li class="tab active"><a href="#type-checks-and-automatic-casts-1">Kotlin</a></li><li class="tab"><a href="#type-checks-and-automatic-casts-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="type-checks-and-automatic-casts-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">        <span class="comment">// `obj` 被自动转行成了  `String`</span></span><br><span class="line">        <span class="keyword">return</span> obj.length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="type-checks-and-automatic-casts-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer <span class="title function_">getStringLength</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) obj).length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p><strong>敲黑板：</strong>  <code>Kotlin</code> 必须要在判断类型之后再进行类型转换，可以节约很多代码的篇幅。</p>
<h2 id="Range"><a class="header-anchor" href="#Range">¶</a>Range</h2>
<div class="tabs" id="range"><ul class="nav-tabs"><li class="tab active"><a href="#range-1">Kotlin</a></li><li class="tab"><a href="#range-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="range-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">val</span> y = <span class="number">9</span></span><br><span class="line"><span class="keyword">if</span> (x <span class="keyword">in</span> <span class="number">1.</span>.y+<span class="number">1</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;fits in range&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    print(x)</span><br><span class="line">&#125;</span><br><span class="line">println()</span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">9</span> downTo <span class="number">0</span> step <span class="number">3</span>) &#123;</span><br><span class="line">    print(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="range-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    System.out.println(i);            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p><strong>敲黑板：</strong>  虽然只是一个语法糖，可是好吃呀。</p>
<h2 id="when"><a class="header-anchor" href="#when">¶</a>when</h2>
<div class="tabs" id="when"><ul class="nav-tabs"><li class="tab active"><a href="#when-1">Kotlin</a></li><li class="tab"><a href="#when-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="when-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">describe</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: String =</span><br><span class="line"><span class="keyword">when</span> (obj) &#123;</span><br><span class="line">    <span class="number">1</span>          -&gt; <span class="string">&quot;One&quot;</span></span><br><span class="line">    <span class="string">&quot;Hello&quot;</span>    -&gt; <span class="string">&quot;Greeting&quot;</span></span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Long</span>    -&gt; <span class="string">&quot;Long&quot;</span></span><br><span class="line">    !<span class="keyword">is</span> String -&gt; <span class="string">&quot;Not a string&quot;</span></span><br><span class="line">    <span class="keyword">else</span>       -&gt; <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="when-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//switch &amp; case 抱歉做不到</span></span><br></pre></td></tr></table></figure></div></div></div>
<p><strong>敲黑板：</strong>  <code>when</code> 是一个增强的 <code>switch</code> 语法，尤其是在多态的情况下，尤为有用。</p>
<h2 id="参考文献"><a class="header-anchor" href="#参考文献">¶</a>参考文献</h2>
<ul>
<li><a href="http://kotlinlang.org/docs/reference/basic-syntax.html">kotlin reference</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kotlin</category>
        <category>easy-way-to-kotlin-for-java-programer</category>
      </categories>
  </entry>
  <entry>
    <title>写给 Java 开发者的 Kotlin 教程 (4) - 控制流表达式</title>
    <url>/2018/07/12/kotlin/easy-way-to-kotlin-for-java-proggamer/control-flow/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2018/07/12/Pu28Re.png" alt="banner"></p>
<p>有个先贤说过</p>
<blockquote>
<p>掌握了规则就掌握了一切。</p>
</blockquote>
<p>我认为在编程语言中掌握了 <code>控制语句</code> 就算是掌握了编程语言（在 <code>FP</code> 中效果打折）。所以我们今天开始要去探索编程语言中至为重要的 <code>Control Flow</code> 部分。</p>
<span id="more"></span>
<h2 id="if-表达式"><a class="header-anchor" href="#if-表达式">¶</a>if 表达式</h2>
<div class="tabs" id="if-statement"><ul class="nav-tabs"><li class="tab active"><a href="#if-statement-1">if</a></li><li class="tab"><a href="#if-statement-2">if else</a></li><li class="tab"><a href="#if-statement-3">if代码块</a></li></ul><div class="tab-content"><div class="tab-pane active" id="if-statement-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">34</span></span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">	println(<span class="string">&quot;<span class="variable">$n</span> is even&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="if-statement-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> max: <span class="built_in">Int</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    max = a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max = b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="if-statement-3"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    print(<span class="string">&quot;Choose a&quot;</span>)</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Choose b&quot;</span>)</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p><strong>敲黑板：</strong> <code>Kotlin</code> 和 <code>Java</code> 不同之处在于 <code>if</code> 的分支可以是代码块，<code>最后的表达式</code>作为该块的值，如示例代码中的 <code>a</code> 和 <code>b</code>。</p>
<h2 id="When-表达式"><a class="header-anchor" href="#When-表达式">¶</a>When 表达式</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">&quot;x == 1&quot;</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">&quot;x == 2&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 注意这个块</span></span><br><span class="line">        print(<span class="string">&quot;x is neither 1 nor 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>when</code> 将它的参数和所有的分支条件 <strong>顺序</strong> 比较，直到某个分支满足条件，如果其他分支都不满足条件将会求值 <code>else</code> 分支。<br>
当然我们也可以把 <strong>多个分支组合</strong> 在一起比如如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dayOfWeek = <span class="number">6</span></span><br><span class="line"><span class="keyword">when</span>(dayOfWeek) &#123;</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> -&gt; println(<span class="string">&quot;Weekday&quot;</span>)</span><br><span class="line">    <span class="number">6</span>, <span class="number">7</span> -&gt; println(<span class="string">&quot;Weekend&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; println(<span class="string">&quot;Invalid Day&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至可以是在一个 <code>Range</code> 内</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dayOfMonth = <span class="number">5</span></span><br><span class="line"><span class="keyword">when</span>(dayOfMonth) &#123;</span><br><span class="line">    <span class="keyword">in</span> <span class="number">1.</span><span class="number">.7</span> -&gt; println(<span class="string">&quot;We&#x27;re in the first Week of the Month&quot;</span>)</span><br><span class="line">    !<span class="keyword">in</span> <span class="number">15.</span><span class="number">.21</span> -&gt; println(<span class="string">&quot;We&#x27;re not in the third week of the Month&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; println(<span class="string">&quot;none of the above&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="For-循环"><a class="header-anchor" href="#For-循环">¶</a>For 循环</h2>
<p><code>for</code> 循环可以对任何提供 <code>迭代器（iterator）</code> 的对象进行遍历</p>
<div class="tabs" id="for-statement"><ul class="nav-tabs"><li class="tab active"><a href="#for-statement-1">for range</a></li><li class="tab"><a href="#for-statement-2">for array</a></li><li class="tab"><a href="#for-statement-3">if代码块</a></li></ul><div class="tab-content"><div class="tab-pane active" id="for-statement-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(value <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">    print(<span class="string">&quot;<span class="variable">$value</span> &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="for-statement-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> primeNumbers = intArrayOf(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(number <span class="keyword">in</span> primeNumbers) &#123;</span><br><span class="line">    print(<span class="string">&quot;<span class="variable">$number</span> &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="for-statement-3"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    print(<span class="string">&quot;Choose a&quot;</span>)</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;Choose b&quot;</span>)</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="While-循环"><a class="header-anchor" href="#While-循环">¶</a>While 循环</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    x--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> y = retrieveData()</span><br><span class="line">&#125; <span class="keyword">while</span> (y != <span class="literal">null</span>) <span class="comment">// y 在此处可见</span></span><br></pre></td></tr></table></figure>
<p>与 <code>Java</code> 一致</p>
<h2 id="Break和continue"><a class="header-anchor" href="#Break和continue">¶</a>Break和continue</h2>
<p>与 <code>Java</code> 一致</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kotlin</category>
        <category>easy-way-to-kotlin-for-java-programer</category>
      </categories>
  </entry>
  <entry>
    <title>写给 Java 开发者的 Kotlin 教程 (3) - 数据类型</title>
    <url>/2018/07/11/kotlin/easy-way-to-kotlin-for-java-proggamer/data-types/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2018/07/11/PuwrnO.png" alt="banner"></p>
<p><code>Kotlin</code> 的第一个特点就是一门 <a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><code>静态类型</code></a> 语言，所以先从如何在 <code>Kotlin</code> 中声明变量，<code>Kotlin</code> 如何推断变量的类型，以及 <code>Kotlin</code> 支持创建变量的基本数据类型开始我们的学习之旅。</p>
<span id="more"></span>
<h2 id="变量"><a class="header-anchor" href="#变量">¶</a>变量</h2>
<h3 id="数字类型"><a class="header-anchor" href="#数字类型">¶</a>数字类型</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>Bits</th>
</tr>
</thead>
<tbody>
<tr>
<td>Double</td>
<td>64</td>
</tr>
<tr>
<td>Float</td>
<td>32</td>
</tr>
<tr>
<td>Long</td>
<td>64</td>
</tr>
<tr>
<td>Int</td>
<td>32</td>
</tr>
<tr>
<td>Short</td>
<td>16</td>
</tr>
<tr>
<td>Byte</td>
<td>8</td>
</tr>
</tbody>
</table>
<p><strong>敲黑板：</strong> 字符类型在 <code>Kotlin</code> 不是 <code>Number类型</code></p>
<h4 id="显式转换"><a class="header-anchor" href="#显式转换">¶</a>显式转换</h4>
<p>我们先看一个例子，再来理解这个特性</p>
<div class="tabs" id="explicit-conversions"><ul class="nav-tabs"><li class="tab active"><a href="#explicit-conversions-1">Kotlin</a></li><li class="tab"><a href="#explicit-conversions-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="explicit-conversions-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="explicit-conversions-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a; <span class="comment">//OK</span></span><br></pre></td></tr></table></figure></div></div></div>
<p><code>Kotlin</code> 提供一系列的数据转换的函数，如下：</p>
<ul>
<li>toByte(): Byte</li>
<li>toShort(): Short</li>
<li>toInt(): Int</li>
<li>toLong(): Long</li>
<li>toFloat(): Float</li>
<li>toDouble(): Double</li>
<li>toChar(): Char</li>
</ul>
<h3 id="算术操作"><a class="header-anchor" href="#算术操作">¶</a>算术操作</h3>
<p><code>Kotlin</code> 支持标准的 <code>算术操作</code> 比如 <code>左移</code> <code>右移</code> 和 <code>Java</code> 不同的 <code>Kotlin</code> 认为这些也是标准的函数<br>
举个例子</p>
<div class="tabs" id="operations"><ul class="nav-tabs"><li class="tab active"><a href="#operations-1">Kotlin</a></li><li class="tab"><a href="#operations-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="operations-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x = (<span class="number">1</span> shl <span class="number">2</span>) and <span class="number">0x000FF000</span></span><br><span class="line"><span class="comment">//或者是</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="number">1.</span>shl(<span class="number">2</span>).and(<span class="number">0x000FF000</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="operations-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span> &amp; <span class="number">0x000FF000</span>;</span><br></pre></td></tr></table></figure></div></div></div>
<ul>
<li>shl(bits) – 有符号左移 (Java’s &lt;&lt;)</li>
<li>shr(bits) – 有符号右移 (Java’s &gt;&gt;)</li>
<li>ushr(bits) – 无符号右移 (Java’s &gt;&gt;&gt;)</li>
<li>and(bits) – 与操作</li>
<li>or(bits) – 或操作</li>
<li>xor(bits) – 异或操作</li>
<li>inv() – 反转操作</li>
</ul>
<p>好奇的你，肯定想问为什么可以写成 <code>val x = (1 shl 2) and 0x000FF000</code> 这样的语法，其实这个在很多语言中也有<br>
也就是所谓的 <code>中缀表达式</code> 这里的内容会在 <code>函数</code> 中细说。所以聪明的你也会联系到是否 <code>+</code> <code>-</code> <code>*</code> <code>%</code> 也如此。<br>
的确如此……</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>函数表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>a + b</td>
<td>a.plus(b)</td>
</tr>
<tr>
<td>a - b</td>
<td>a.minus(b)</td>
</tr>
<tr>
<td>a * b</td>
<td>a.times(b)</td>
</tr>
<tr>
<td>a / b</td>
<td>a.div(b)</td>
</tr>
<tr>
<td>a % b</td>
<td>a.rem(b)</td>
</tr>
<tr>
<td>a++</td>
<td>a.inc()</td>
</tr>
<tr>
<td>a−−</td>
<td>a.dec()</td>
</tr>
<tr>
<td>a &gt; b</td>
<td>a.compareTo(b) &gt; 0</td>
</tr>
<tr>
<td>a &lt; b</td>
<td>a.compareTo(b) &lt; 0</td>
</tr>
<tr>
<td>a += b</td>
<td>a.plusAssign(b)</td>
</tr>
</tbody>
</table>
<h2 id="字符类型"><a class="header-anchor" href="#字符类型">¶</a>字符类型</h2>
<p>字符文字用单引号括起：如 ‘1’。可以使用反斜杠转义特殊字符。支持以下转义序列：<code>\t</code>，<code>\b</code>，<code>\n</code>，<code>\r</code>，<code>\</code>，<code>\&quot;</code>，<code>\\</code>和<code>\$</code>。要对其他字符进行编码，需要使用 Unicode 转义序列语法：<code>'\uFF00'</code></p>
<h2 id="数组类型"><a class="header-anchor" href="#数组类型">¶</a>数组类型</h2>
<p>在 <code>Kotlin</code> 将 java 中的数据转换为了 <code>Array</code> 类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&lt;<span class="type">T</span>&gt; <span class="keyword">private</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Kotlin</code> 创建一个数组提供一些列简单的函数来帮助我们创建数组，比如</p>
<div class="tabs" id="array"><ul class="nav-tabs"><li class="tab active"><a href="#array-1">Kotlin</a></li><li class="tab"><a href="#array-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="array-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 构造函数 创建一个 Array&lt;String&gt; 初始化为 [&quot;0&quot;, &quot;1&quot;, &quot;4&quot;, &quot;9&quot;, &quot;16&quot;]</span></span><br><span class="line"><span class="keyword">val</span> asc = Array(<span class="number">5</span>, &#123; i -&gt; (i \* i).toString() &#125;)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="array-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></div></div></div>
<p>除此之外 <code>Kotlin</code> 为 <code>Array</code> 增加了更多的方便操作的函数。举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xx = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">xx = xx.plus(<span class="number">5</span>) <span class="comment">//增加一个元素在最后</span></span><br><span class="line">xx = xx.copyOfRange(<span class="number">0</span>, <span class="number">2</span>)<span class="comment">//拷贝 0 - 2 下标的元素</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a class="header-anchor" href="#字符串">¶</a>字符串</h2>
<h3 id="字符串字面值"><a class="header-anchor" href="#字符串字面值">¶</a>字符串字面值</h3>
<p>创建一个单行的字符串 <code>s</code> 这个和 java 一样。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;Hello, world!\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>但是 <code>Kotlin</code> 支持多行 <code>String</code></p>
<div class="tabs" id="multie-string"><ul class="nav-tabs"><li class="tab active"><a href="#multie-string-1">Kotlin</a></li><li class="tab"><a href="#multie-string-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="multie-string-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">select \* from users</span></span><br><span class="line"><span class="string">where</span></span><br><span class="line"><span class="string">username = &#x27;jack&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="multie-string-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;select \* from users\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;where\n&quot;</span> +  </span><br><span class="line"> <span class="string">&quot;username = &#x27;jack&#x27;&quot;</span></span><br></pre></td></tr></table></figure></div></div></div>
<p>这个特性在我们需要输出比较复杂的 <code>Sql</code>或者是多行文本的情况下是极为方便的。</p>
<h3 id="字符串模板"><a class="header-anchor" href="#字符串模板">¶</a>字符串模板</h3>
<p>字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（$）开头，由一个简单的名字构成:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">10</span></span><br><span class="line">println(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>) <span class="comment">// 输出“i = 10”</span></span><br></pre></td></tr></table></figure>
<p>或者用花括号括起来的任意表达式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;abc&quot;</span></span><br><span class="line">println(<span class="string">&quot;<span class="variable">$s</span>.length is <span class="subst">$&#123;s.length&#125;</span>&quot;</span>) <span class="comment">// 输出“abc.length is 3”</span></span><br></pre></td></tr></table></figure>
<h3 id="类型别名"><a class="header-anchor" href="#类型别名">¶</a>类型别名</h3>
<p>类型别名可以为已有的类型提供替代的名称. 如果类型名称太长, 你可以指定一个更短的名称, 然后使用新的名称。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> NodeSet = Set&lt;Network.Node&gt;</span><br><span class="line"><span class="keyword">typealias</span> FileTable&lt;K&gt; = MutableMap&lt;K, MutableList&lt;File&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="常量"><a class="header-anchor" href="#常量">¶</a>常量</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> SUBSYSTEM_DEPRECATED: String = <span class="string">&quot;This subsystem is deprecated&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h2>
<p>参考官方文档中还有 <code>Boolean</code> 与 <code>Char</code> 类型，这两个类型和 Java 是极为接近就不多做阐述。</p>
<p>而且我们从文中，我们可以发现，<code>Kotlin</code> 不存在 <code>Java</code> 中的 原始数据类型和包装数据类型，不存在 <code>int Integer</code> <code>long Long</code> <code>byte Byte</code> 的关系，也算是去除了 <code>Java</code> 中不太 <code>OOP</code> 的一部分。</p>
<h2 id="Q-A"><a class="header-anchor" href="#Q-A">¶</a>Q&amp;A</h2>
<ul>
<li>Q: 执行位运算的执行顺序<br>
A: 中缀函数调用的优先级低于算术操作符、类型转换以及 rangeTo 操作符，但是高于布尔操作符 &amp;&amp; 与 ||、is- 与 in- 检测以及其他一些操作符，所以 <code>1 shl 2 + 3 === 1 shl (2 + 3)</code></li>
</ul>
<h2 id="参考文献-课外阅读"><a class="header-anchor" href="#参考文献-课外阅读">¶</a>参考文献 &amp; 课外阅读</h2>
<ul>
<li><a href="https://www.zhihu.com/question/19918532/answer/21647195">弱类型、强类型、动态类型、静态类型语言的区别是什么</a></li>
<li><a href="https://www.callicoder.com/kotlin-operators/">Kotlin Operators with Examples</a></li>
<li><a href="https://www.callicoder.com/kotlin-infix-notation/">Kotlin Infix Notation - Make function calls more intuitive</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kotlin</category>
        <category>easy-way-to-kotlin-for-java-programer</category>
      </categories>
  </entry>
  <entry>
    <title>写给 Java 开发者的 Kotlin 教程 (7) - 函数高阶</title>
    <url>/2018/07/25/kotlin/easy-way-to-kotlin-for-java-proggamer/functions-advance/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2018/07/25/PtmXYn.jpg" alt="banner"></p>
<p>上一章，我们看过 <code>kotlin</code> 的一些函数的基本用法，<code>kotlin</code> 作为一门年轻的语言，当然不能和 <code>1995</code>年的 <code>Java</code> 一样，当然还有一些不一样的特性，我们今天就来看看 <code>kotlin</code> 的一些函数的高阶特性。</p>
<span id="more"></span>
<h2 id="操作符重载"><a class="header-anchor" href="#操作符重载">¶</a>操作符重载</h2>
<h3 id="一元表达式"><a class="header-anchor" href="#一元表达式">¶</a>一元表达式</h3>
<table>
<thead>
<tr>
<th>表达式</th>
<th>翻译为</th>
</tr>
</thead>
<tbody>
<tr>
<td>+a</td>
<td>a.unaryPlus()</td>
</tr>
<tr>
<td>-a</td>
<td>a.unaryMinus()</td>
</tr>
<tr>
<td>!a</td>
<td>a.not()</td>
</tr>
</tbody>
</table>
<p>举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">unaryMinus</span><span class="params">()</span></span> = Point(-x, -y)  <span class="comment">//这里是扩展函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> point = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">println(-point)  <span class="comment">// 打印结果为 &quot;(-10, -20)&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="递增与递减操作符"><a class="header-anchor" href="#递增与递减操作符">¶</a>递增与递减操作符</h3>
<table>
<thead>
<tr>
<th>表达式</th>
<th>翻译为</th>
</tr>
</thead>
<tbody>
<tr>
<td>a++</td>
<td>a.inc()</td>
</tr>
<tr>
<td>a–</td>
<td>a.dec()</td>
</tr>
</tbody>
</table>
<h3 id="二元操作符"><a class="header-anchor" href="#二元操作符">¶</a>二元操作符</h3>
<table>
<thead>
<tr>
<th>表达式</th>
<th>翻译为</th>
</tr>
</thead>
<tbody>
<tr>
<td>a + b</td>
<td>a.plus(b)</td>
</tr>
<tr>
<td>a - b</td>
<td>a.minus(b)</td>
</tr>
<tr>
<td>a * b</td>
<td>a.times(b)</td>
</tr>
<tr>
<td>a / b</td>
<td>a.div(b)</td>
</tr>
<tr>
<td>a % b</td>
<td>a.rem(b)</td>
</tr>
<tr>
<td>a…b</td>
<td>a.rangeTo(b)</td>
</tr>
</tbody>
</table>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Counter</span>(<span class="keyword">val</span> dayIndex: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(increment: <span class="type">Int</span>)</span></span>: Counter &#123;</span><br><span class="line">        <span class="keyword">return</span> Counter(dayIndex + increment)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解构函数"><a class="header-anchor" href="#解构函数">¶</a>解构函数</h2>
<p>比如我们有这么表达式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> collections: Collection&lt;Pair&lt;<span class="built_in">Int</span>,String&gt;&gt;</span><br><span class="line"><span class="keyword">for</span> ((a, b) <span class="keyword">in</span> collection) &#123; ... &#125;</span><br><span class="line"><span class="comment">// 注意这个 (a, b) 就是解构</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person: Person = Person(<span class="string">&quot;Jone&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> (name, age) = person</span><br><span class="line">println(<span class="string">&quot;name: <span class="variable">$name</span>, age: <span class="variable">$age</span>&quot;</span>)<span class="comment">// 打印：name: Jone, age: 20</span></span><br></pre></td></tr></table></figure>
<p>这里有一个语法糖，对于解构的对象语法，kotlin 会去调用 <code>componentX</code> 函数，比如上文的 <code>name</code> 和 <code>age</code>，对应到 <code>kotlin</code> 其实是在 <code>var (name, age) = person</code> 调用了 <code>component1()</code> 和 <code>component2()</code> 函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> j = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span> = i</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span> = j</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> (i,j) = Test()</span><br></pre></td></tr></table></figure>
<h2 id="中缀表达式"><a class="header-anchor" href="#中缀表达式">¶</a>中缀表达式</h2>
<p>在 <code>kotlin</code> 源码中，我们发现一些函数是被 <code>infix</code> 修饰的，这种函数在 <code>kotlin</code> 是能够使用 <code>中缀表达式</code> 进行操作的，举个例子：</p>
<div class="tabs" id="infix-notation"><ul class="nav-tabs"><li class="tab active"><a href="#infix-notation-1">Kotlin infix</a></li><li class="tab"><a href="#infix-notation-2">Kotlin without infix</a></li></ul><div class="tab-content"><div class="tab-pane active" id="infix-notation-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="number">1</span> to <span class="string">&quot;one&quot;</span>, <span class="number">2</span> to <span class="string">&quot;two&quot;</span>, <span class="number">3</span> to <span class="string">&quot;three&quot;</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="infix-notation-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="number">1.</span>to(<span class="string">&quot;one&quot;</span>), <span class="number">2.</span>to(<span class="string">&quot;two&quot;</span>), <span class="number">3.</span>to(<span class="string">&quot;three&quot;</span>))</span><br></pre></td></tr></table></figure></div></div></div>
<p><code>中缀表达式</code> 直观上的表现形式将 . 和 () 去掉了，带来的是代码的可读性的提高。我们看看<code>中缀函数的申明</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B&gt;</span> A.<span class="title">to</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt; = Pair(<span class="keyword">this</span>, that)</span><br></pre></td></tr></table></figure>
<p>这个函数和普通的函数并没有什么区别，唯独多的也就是 <code>infix</code> 关键字。但是如果想要申明一个函数是 <code>infix</code> 必须满足一下几个条件：</p>
<ul>
<li>它们必须是<code>成员函数</code>或<code>扩展函数</code></li>
<li>它们必须只有<code>一个</code>参数</li>
<li>其参数<code>不得</code>接受<code>可变数量的参数</code>且<code>不能有默认值</code></li>
</ul>
<h3 id="更多的例子"><a class="header-anchor" href="#更多的例子">¶</a>更多的例子</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如我们声明</span></span><br><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">shl</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123; …… &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用中缀表示法调用该函数</span></span><br><span class="line"><span class="number">1</span> shl <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于这样</span></span><br><span class="line"><span class="number">1.</span>shl(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="注意点"><a class="header-anchor" href="#注意点">¶</a>注意点</h3>
<ol>
<li>中缀函数调用的优先级低于算术操作符、类型转换以及 rangeTo 操作符。</li>
<li>中缀函数调用的优先级高于布尔操作符 &amp;&amp; 与 ||、is- 与 in- 检测以及其他一些操作符。</li>
</ol>
<h2 id="lambda-表达式-高阶函数"><a class="header-anchor" href="#lambda-表达式-高阶函数">¶</a>lambda 表达式 &amp; 高阶函数</h2>
<h3 id="高阶函数"><a class="header-anchor" href="#高阶函数">¶</a>高阶函数</h3>
<p>在阐述 <code>lambda</code> 之前，我们先来了解一下 <code>Kotlin</code> 函数都是头等的，这意味着它们可以存储在变量与数据结构中、作为参数传递给其他高阶函数以及从其他高阶函数返回。可以像操作任何其他非函数值一样操作函数。</p>
<p>举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Collection<span class="type">&lt;T&gt;</span>.<span class="title">fold</span><span class="params">(➊</span></span></span><br><span class="line"><span class="params"><span class="function">    initial: <span class="type">R</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    combine: (<span class="type">acc</span>: <span class="type">R</span>, <span class="type">nextElement</span>: <span class="type">T</span>) -&gt; <span class="type">R</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: R &#123;➋</span><br><span class="line">    <span class="keyword">var</span> accumulator: R = initial</span><br><span class="line">    <span class="keyword">for</span> (element: T <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        accumulator = combine(accumulator, element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 处为 <code>Collection</code> 类型增加一个 <code>fold</code> 函数，参数有两个 <code>initial</code> 和 <code>combine</code> 而 <code>combine</code> 的定义是一个函数类型 <code>(acc: R, nextElement: T) -&gt; R</code> 也就说我们需要传入的第二个 参数 是一个函数。<br>
➋ 定义了返回的 R 类型的类型</p>
<p>所以对于 <code>Kotlin</code> 来说，我们可以使用 <code>函数</code> 作为参数，也就是具有了 <code>高阶函数</code> 的特性。</p>
<p>我们在这里看到了 <code>Kotlin</code> 使用类似 <code>(Int) -&gt; String</code> 的一系列函数类型来处理函数的声明，而在这里就是我们下面要讲到来的一个概念，Lambda 表达式。</p>
<h3 id="Lambda-表达式与匿名函数"><a class="header-anchor" href="#Lambda-表达式与匿名函数">¶</a>Lambda 表达式与匿名函数</h3>
<p>比如我们有一个 <code>max</code> 函数，<code>max</code> 是一个高阶函数，它接受一个函数作为第二个参数。 其第二个参数是一个表达式，它本身是一个函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">max(strings, &#123; a, b -&gt; a.length &lt; b.length &#125;)</span><br></pre></td></tr></table></figure>
<p>而 <code>&#123; a, b -&gt; a.length &lt; b.length &#125;</code> 等价于以下的命名函数:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compare</span><span class="params">(a: <span class="type">String</span>, b: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> = a.length &lt; b.length</span><br></pre></td></tr></table></figure>
<p>Lambda 表达式的完整语法形式如下:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y &#125;</span><br></pre></td></tr></table></figure>
<p>我们把所有可选标注都留下，看起来如下:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sum: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; x, y -&gt; x + y &#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>kotlin</code> 的 <code>Lambda</code> 有以下一些特性</p>
<h4 id="lambda-表达式传给最后一个参数"><a class="header-anchor" href="#lambda-表达式传给最后一个参数">¶</a>lambda 表达式传给最后一个参数</h4>
<p>在 Kotlin 中有一个约定：如果函数的最后一个参数接受函数，那么作为相应参数传入的 lambda 表达式可以放在圆括号之外：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> product = items.fold(<span class="number">1</span>) &#123; acc, e -&gt; acc * e &#125;</span><br></pre></td></tr></table></figure>
<h4 id="it：单个参数的隐式名称"><a class="header-anchor" href="#it：单个参数的隐式名称">¶</a>it：单个参数的隐式名称</h4>
<p>一个 lambda 表达式只有一个参数是很常见的。<br>
如果编译器自己可以识别出签名，也可以不用声明唯一的参数并忽略 -&gt;。 该参数会隐式声明为 <code>it</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ints.filter &#123; it &gt; <span class="number">0</span> &#125; <span class="comment">// (it: Int) -&gt; Boolean</span></span><br></pre></td></tr></table></figure>
<h4 id="从-lambda-表达式中返回一个值"><a class="header-anchor" href="#从-lambda-表达式中返回一个值">¶</a>从 lambda 表达式中返回一个值</h4>
<p>我们可以使用返回语法从 lambda 显式返回一个值。 否则，将隐式返回<code>最后一个表达式</code>的值。</p>
<h4 id="下划线用于未使用的变量"><a class="header-anchor" href="#下划线用于未使用的变量">¶</a>下划线用于未使用的变量</h4>
<p>从 1.1 版本之后，我们可以用下划线取代其名称：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">map.forEach &#123; _, value -&gt; println(<span class="string">&quot;<span class="variable">$value</span>!&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<h2 id="柯里化"><a class="header-anchor" href="#柯里化">¶</a>柯里化</h2>
<p><code>FP</code> 语言里面有个很不错的特性叫 <code>柯里化</code></p>
<blockquote>
<p>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
</blockquote>
<p>比如在 <code>javascript</code> 中，我们就可以这么做</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increment = <span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> addTen = <span class="title function_">add</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">increment</span>(<span class="number">2</span>); <span class="comment">//结果 -&gt; 3</span></span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">2</span>); <span class="comment">//结果 -&gt; 12</span></span><br></pre></td></tr></table></figure>
<p>而在 <code>kotlin</code> 中我们依然可以使用这样的方式比如</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a: <span class="type">Int</span>)</span></span>: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; b: <span class="built_in">Int</span> -&gt; a + b &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> increment2 = add(<span class="number">2</span>)</span><br><span class="line">increment2(<span class="number">10</span>) <span class="comment">//结果 -&gt; 12</span></span><br></pre></td></tr></table></figure>
<p>其实我们这里看到，在这里，返回了一个 <code>lambda</code>，我们利用 <code>lambda</code> 完成一个 <code>柯里化</code> 的操作。</p>
<h2 id="协程"><a class="header-anchor" href="#协程">¶</a>协程</h2>
<p>一些 API 启动长时间运行的操作（例如网络 IO、文件 IO、CPU 或 GPU 密集型任务等），并要求调用者阻塞直到它们完成。协程提供了一种避免阻塞线程并用更廉价、更可控的操作替代线程阻塞的方法：<code>协程挂起</code>。</p>
<h3 id="快速体验"><a class="header-anchor" href="#快速体验">¶</a>快速体验</h3>
<p><code>kotlin</code> 提供一个新的关键字叫 <code>suspend</code> 被这个关键字所修饰的 函数只能被协程调用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(foo: <span class="type">Foo</span>)</span></span>: Bar&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result: Deferred&lt;String&gt; = async &#123; doSomethingTimeout() &#125;</span><br><span class="line">	println(<span class="string">&quot;I will got the result <span class="subst">$&#123;result.await()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingTimeout</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Result&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里， <code>async</code> 代码块会新启动一个协程后立即执行，并且返回一个 <code>Deferred</code> 类型的值，调用它的 <code>await</code> 方法后会<code>暂停</code>当前协程，直到获取到 <code>async</code> 代码块执行结果，当前协程才会继续执行。</p>
<h3 id="协程事件传递"><a class="header-anchor" href="#协程事件传递">¶</a>协程事件传递</h3>
<p>如果我们需要在不同的<code>协程</code>之间传递数据，我们需要 <code>channel</code> 调用它的 <code>send</code> 与 <code>receive</code> 方法，就是最简单的使用了。不过要注意，这两个方法会互相等待，所以它们必须运行在<code>不同的</code>协程。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel()</span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) channel.send(x)</span><br><span class="line">        channel.close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) println(channel.receive())</span><br><span class="line">    <span class="comment">//  or `for (x in channel) println(x)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a class="header-anchor" href="#参考文献">¶</a>参考文献</h2>
<ul>
<li><a href="https://www.callicoder.com/kotlin-infix-notation/">kotlin-functions</a></li>
<li><a href="https://hltj.gitbooks.io/kotlin-reference-chinese/content/txt/functions.html">Reference</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kotlin</category>
        <category>easy-way-to-kotlin-for-java-programer</category>
      </categories>
  </entry>
  <entry>
    <title>写给 Java 开发者的 Kotlin 教程 (6) - 函数基础</title>
    <url>/2018/07/22/kotlin/easy-way-to-kotlin-for-java-proggamer/functions/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2018/07/22/PGJYwT.png" alt="kotlin functions"><br>
函数是构成软件的基础块。我们今天就开始 <code>Kotlin</code> 旅程的第二站 - <code>函数</code></p>
<span id="more"></span>
<h2 id="函数定义"><a class="header-anchor" href="#函数定义">¶</a>函数定义</h2>
<p>我们都知道函数的本质也就是接受一些东西然后吐出一些东西，那最为重要的是 <code>入参</code>，<code>出惨</code>，然后又知道 <code>Kotlin</code> 是一门静态语言，那类型又很重要，那我们来看看 <code>Kotlin</code> 是如何申明函数的。</p>
<div class="tabs" id="for-function-def"><ul class="nav-tabs"><li class="tab active"><a href="#for-function-def-1">Kotlin 函数定义</a></li><li class="tab"><a href="#for-function-def-2">Java 函数定义</a></li></ul><div class="tab-content"><div class="tab-pane active" id="for-function-def-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">avg</span><span class="params">(a: <span class="type">Double</span>, b: <span class="type">Double</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>  (a + b)/<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="for-function-def-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Double <span class="title function_">avg</span><span class="params">(Double a, Double b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p>和 <code>Java</code> 略有不同</p>
<ul>
<li><code>Kotlin</code> 申明函数使用关键字 <code>fun</code></li>
<li><code>Kotlin</code> 的<code>入参</code>类型是<code>后置</code>的</li>
<li><code>Kotlin</code> 的<code>出参</code>类型是<code>后置</code>的</li>
</ul>
<p>所以我们通常定义一个函数都会使用以下的格式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionName</span><span class="params">(param1: <span class="type">Type1</span>, param2: <span class="type">Type2</span>,..., paramN: <span class="type">TypeN</span>)</span></span>: Type &#123;</span><br><span class="line">	<span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单行函数定义"><a class="header-anchor" href="#单行函数定义">¶</a>单行函数定义</h3>
<p>和 <code>java</code> 略有不同，<code>kotlin</code> 有一些特殊的函数格式比如 <code>单行函数</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">avg</span><span class="params">(a: <span class="type">Double</span>, b: <span class="type">Double</span>)</span></span> = (a + b)/<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="Unit-类型"><a class="header-anchor" href="#Unit-类型">¶</a>Unit 类型</h3>
<p>如果希望函数无返回值，可以采用 <code>Unit</code> 作为返回类型，这个和 <code>java</code> 的 <code>void</code> 一个含义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printAverage</span><span class="params">(a: <span class="type">Double</span>, b: <span class="type">Double</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Avg of (<span class="variable">$a</span>, <span class="variable">$b</span>) = <span class="subst">$&#123;(a + b)/<span class="number">2</span>&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，默认如果这里不填写任何类型，默认即是 <code>Unit</code>，下面的代码和上面等价</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printAverage</span><span class="params">(a: <span class="type">Double</span>, b: <span class="type">Double</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Avg of (<span class="variable">$a</span>, <span class="variable">$b</span>) = <span class="subst">$&#123;(a + b)/<span class="number">2</span>&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数特性"><a class="header-anchor" href="#函数特性">¶</a>函数特性</h2>
<h3 id="函数默认参数"><a class="header-anchor" href="#函数默认参数">¶</a>函数默认参数</h3>
<p><code>Kotlin</code> 借鉴其他语言的实现，也支持函数的默认参数值。如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">displayGreeting</span><span class="params">(message: <span class="type">String</span>, name: <span class="type">String</span> = <span class="string">&quot;Guest&quot;</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello <span class="variable">$name</span>, <span class="variable">$message</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以这样调用这个<code>函数</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">displayGreeting(<span class="string">&quot;Welcome to the Yann Blog&quot;</span>, <span class="string">&quot;John&quot;</span>) </span><br><span class="line"><span class="comment">// Hello John, Welcome to the Yann Blog</span></span><br><span class="line">displayGreeting(<span class="string">&quot;Welcome to the Yann Blog&quot;</span>) </span><br><span class="line"><span class="comment">// Hello Guest, Welcome to the Yann Blog</span></span><br></pre></td></tr></table></figure>
<p>考虑以下的定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">arithmeticSeriesSum</span><span class="params">(a: <span class="type">Int</span> = <span class="number">1</span>, n: <span class="type">Int</span>, d: <span class="type">Int</span> = <span class="number">1</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n/<span class="number">2</span> * (<span class="number">2</span>*a + (n-<span class="number">1</span>)*d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们尝试用下面的方式调用，我们会发现失败</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">arithmeticSeriesSum(<span class="number">10</span>) <span class="comment">// error: 缺少参数</span></span><br></pre></td></tr></table></figure>
<p>因为我们的参数只能自左向右的传递入函数，所以我们可以这样调用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">arithmeticSeriesSum(<span class="number">1</span>, <span class="number">10</span>)  <span class="comment">// 结果 = 55</span></span><br></pre></td></tr></table></figure>
<p>所以我们在申明函数的时候，尽可能的将带默认值的参数放在函数的右侧。</p>
<h3 id="命名参数"><a class="header-anchor" href="#命名参数">¶</a>命名参数</h3>
<p>我们经常在 <code>Python</code> 的代码中看见，如下的定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">named_function</span>(<span class="params">a, b=<span class="number">20</span>, c=<span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line">named_function(<span class="number">10</span>, c=<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>这种称之为 <code>Named Arguments</code>，<code>Kotlin</code> 也可以做到如何</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">arithmeticSeriesSum</span><span class="params">(a: <span class="type">Int</span> = <span class="number">1</span>, n: <span class="type">Int</span>, d: <span class="type">Int</span> = <span class="number">1</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n/<span class="number">2</span> * (<span class="number">2</span>*a + (n-<span class="number">1</span>)*d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arithmeticSeriesSum(n=<span class="number">10</span>)  <span class="comment">// 结果 = 55</span></span><br><span class="line">arithmeticSeriesSum(n=<span class="number">10</span>, d=<span class="number">2</span>, a=<span class="number">3</span>) <span class="comment">//OK</span></span><br><span class="line">arithmeticSeriesSum(n=<span class="number">10</span>, <span class="number">2</span>) <span class="comment">//EROOR</span></span><br></pre></td></tr></table></figure>
<p>注意最后一种方式不被允许了，原因也很简单，因为一旦命名了，我们就无法得知后续的参数应该从哪里开始。</p>
<h3 id="可变参数"><a class="header-anchor" href="#可变参数">¶</a>可变参数</h3>
<p>和 <code>Java</code> 不同<code>Kotlin</code>采用一种特殊的关键字 <code>vararg</code> 来申明可变参数</p>
<div class="tabs" id="for-varargs"><ul class="nav-tabs"><li class="tab active"><a href="#for-varargs-1">Kotlin 可变参数</a></li><li class="tab"><a href="#for-varargs-2">Java 可变参数</a></li></ul><div class="tab-content"><div class="tab-pane active" id="for-varargs-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sumOfNumbers</span><span class="params">(<span class="keyword">vararg</span> numbers: <span class="type">Double</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum: <span class="built_in">Double</span> = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span>(number <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">        sum += number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="for-varargs-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Double <span class="title function_">sumOfNumbers</span><span class="params">(Double... numbers)</span> &#123;</span><br><span class="line">    <span class="type">Double</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="number">0D</span>;</span><br><span class="line">    <span class="keyword">for</span> (Double d : numbers) &#123;</span><br><span class="line">        rs += d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rs / numbers.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p><code>值得注意</code> 在一个函数中只允许出现一个 <code>vararg</code>。</p>
<h2 id="函数作用域"><a class="header-anchor" href="#函数作用域">¶</a>函数作用域</h2>
<h3 id="包级别作用域"><a class="header-anchor" href="#包级别作用域">¶</a>包级别作用域</h3>
<p>比如下面这个函数的作用域就是这个包级别，也就是在同一个<code>包</code>里都可以访问这个函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> maths</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findNthFibonacciNo</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> c: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">        c = a+b</span><br><span class="line">        a = b</span><br><span class="line">        b = c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如我们可以这么调用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> maths</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;10th fibonacci number is - <span class="subst">$&#123;findNthFibonacciNo(<span class="number">10</span>)&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="成员函数"><a class="header-anchor" href="#成员函数">¶</a>成员函数</h3>
<p>和大部分的 <code>Java</code> 函数相同，我们可以在 <code>类</code> 声明函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> firstName: String, <span class="keyword">val</span> lastName: String) &#123;</span><br><span class="line">	<span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getFullName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套函数"><a class="header-anchor" href="#嵌套函数">¶</a>嵌套函数</h3>
<p>在 <code>java</code> 程序中，我们经常需要为了代码的可读性将一些列的行为抽象成一个独特的函数，这些函数往往会被定义为<br>
<code>private</code> 但是往往被复用一次而已。比如下面这个 <code>calculateBMI</code>，对比之下，我个人更喜欢的是<code>嵌套函数</code></p>
<div class="tabs" id="nested-functions"><ul class="nav-tabs"><li class="tab active"><a href="#nested-functions-1">Java 嵌套函数</a></li><li class="tab"><a href="#nested-functions-2">Java 嵌套匿名表达式</a></li><li class="tab"><a href="#nested-functions-3">Kotlin 嵌套函数</a></li></ul><div class="tab-content"><div class="tab-pane active" id="nested-functions-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">Double</span> calculateBMI(<span class="built_in">Double</span> weightInKg, <span class="built_in">Double</span> heightInCm) &#123;</span><br><span class="line">    <span class="keyword">return</span> weightInKg / (heightInCm / <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Double</span> findBodyMassIndex(<span class="built_in">Double</span> weightInKg, <span class="built_in">Double</span> heightInCm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (weightInKg &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> new IllegalArgumentException(<span class="string">&quot;Weight must be greater than zero&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (heightInCm &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> new IllegalArgumentException(<span class="string">&quot;Height must be greater than zero&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> calculateBMI(weightInKg, heightInCm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="nested-functions-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Double <span class="title function_">findBodyMassIndex</span><span class="params">(Double weightInKg, Double heightInCm)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (weightInKg &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Weight must be greater than zero&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (heightInCm &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Height must be greater than zero&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BiFunction&lt;Double, Double, Double&gt; calculateBMI = (w, h) -&gt; w / (h / <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> calculateBMI.apply(weightInKg, heightInCm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="nested-functions-3"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">findBodyMassIndex</span><span class="params">(weightInKg: Double, heightInCm: Double)</span>: Double &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(weightInKg &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Weight must be greater than zero&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(heightInCm &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Height must be greater than zero&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun <span class="title function_">calculateBMI</span><span class="params">(weightInKg: Double, heightInCm: Double)</span>: Double &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">heightInMeter</span> <span class="operator">=</span> heightInCm / <span class="number">100</span></span><br><span class="line">        <span class="keyword">return</span> weightInKg / (heightInMeter * heightInMeter)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 BMI</span></span><br><span class="line">    <span class="keyword">return</span> calculateBMI(weightInKg, heightInCm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="内联函数"><a class="header-anchor" href="#内联函数">¶</a>内联函数</h2>
<p>内联函数可以在编译器展开，减少 <code>Function Stack</code> 的使用，对于提高性能有 <code>迷之作用</code><br>
我们想要将一个函数设置为内联函数只需要如下声明即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lock</span><span class="params">(lock: <span class="type">Lock</span>, body: () -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要在函数的前面增加一个 <code>inline</code> 关键字即可。</p>
<h2 id="扩展函数"><a class="header-anchor" href="#扩展函数">¶</a>扩展函数</h2>
<p>想想一个场景，我们需要给某个类型的对象增加一个函数，而这个类型的源码可能是在某个第三方的<code>Jar</code>内，我们仅仅能通过继承来实现我们的需求，而现在 <code>kotlin</code> 可以通过拓展函数来实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">swap</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tmp = <span class="keyword">this</span>[index1] <span class="comment">// “this”对应该列表</span></span><br><span class="line">    <span class="keyword">this</span>[index1] = <span class="keyword">this</span>[index2]</span><br><span class="line">    <span class="keyword">this</span>[index2] = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就为了 <code>MutableList&lt;Int&gt;</code> 增加一个新的函数 <code>swap(index1: Int, index2: Int)</code></p>
<p><strong>值得注意：</strong> 扩展是静态解析的，也就是说并不会因为运行时的状态而采用多态的函数进行调用。举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="type">C</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">&quot;d&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printFoo</span><span class="params">(c: <span class="type">C</span>)</span></span> &#123;</span><br><span class="line">    println(c.foo())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printFoo(D())</span><br><span class="line"><span class="comment">// &quot;c&quot; not &quot;d&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="函数泛型"><a class="header-anchor" href="#函数泛型">¶</a>函数泛型</h2>
<p>既然有函数，怎么可能没有泛型呢？<code>Kotlin</code> 的泛型系统比 <code>java</code> 更加复杂，关于这块，我们将在一个独立的章节进行讲解。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">singletonList</span><span class="params">(item: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a class="header-anchor" href="#参考文献">¶</a>参考文献</h2>
<ul>
<li><a href="https://hltj.gitbooks.io/kotlin-reference-chinese/content/txt/extensions.html">扩展特性</a></li>
<li><a href="https://www.callicoder.com/kotlin-functions/">kotlin-functions</a></li>
<li><a href="https://hltj.gitbooks.io/kotlin-reference-chinese/content/txt/functions.html">Reference</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kotlin</category>
        <category>easy-way-to-kotlin-for-java-programer</category>
      </categories>
  </entry>
  <entry>
    <title>写给 Java 开发者的 Kotlin 教程 (13) - 最佳实践</title>
    <url>/2018/08/17/kotlin/easy-way-to-kotlin-for-java-proggamer/kotlin-best-practices/</url>
    <content><![CDATA[<p><img src="https://s1.ax2x.com/2018/08/17/59jvsG.jpg" alt=""></p>
<span id="more"></span>
<h2 id="表达式"><a class="header-anchor" href="#表达式">¶</a>表达式</h2>
<div class="tabs" id="expressions"><ul class="nav-tabs"><li class="tab active"><a href="#expressions-1">✔✔✔</a></li><li class="tab"><a href="#expressions-2">✘✘✘</a></li></ul><div class="tab-content"><div class="tab-pane active" id="expressions-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getDefaultLocale2</span><span class="params">(deliveryArea: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> (deliveryArea.toLowerCase()) &#123;</span><br><span class="line">    <span class="string">&quot;germany&quot;</span>, <span class="string">&quot;austria&quot;</span> -&gt; Locale.GERMAN</span><br><span class="line">    <span class="string">&quot;usa&quot;</span>, <span class="string">&quot;great britain&quot;</span> -&gt; Locale.ENGLISH</span><br><span class="line">    <span class="string">&quot;france&quot;</span> -&gt; Locale.FRENCH</span><br><span class="line">    <span class="keyword">else</span> -&gt; Locale.ENGLISH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="expressions-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getDefaultLocale</span><span class="params">(deliveryArea: <span class="type">String</span>)</span></span>: Locale &#123;</span><br><span class="line">    <span class="keyword">val</span> deliverAreaLower = deliveryArea.toLowerCase()</span><br><span class="line">    <span class="keyword">if</span> (deliverAreaLower == <span class="string">&quot;germany&quot;</span> || deliverAreaLower == <span class="string">&quot;austria&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Locale.GERMAN</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deliverAreaLower == <span class="string">&quot;usa&quot;</span> || deliverAreaLower == <span class="string">&quot;great britain&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Locale.ENGLISH</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deliverAreaLower == <span class="string">&quot;france&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Locale.FRENCH</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Locale.ENGLISH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="Try"><a class="header-anchor" href="#Try">¶</a>Try</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> json = <span class="string">&quot;&quot;&quot;&#123;&quot;message&quot;:&quot;HELLO&quot;&#125;&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">val</span> message = <span class="keyword">try</span> &#123;</span><br><span class="line">    JSONObject(json).getString(<span class="string">&quot;message&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex: JSONException) &#123;</span><br><span class="line">    json</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象工具类"><a class="header-anchor" href="#对象工具类">¶</a>对象工具类</h2>
<div class="tabs" id="utility-functions"><ul class="nav-tabs"><li class="tab active"><a href="#utility-functions-1">✔✔✔</a></li><li class="tab"><a href="#utility-functions-2">✘✘✘</a></li></ul><div class="tab-content"><div class="tab-pane active" id="utility-functions-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">countAmountOfX</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> length - replace(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;&quot;</span>).length</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&quot;xFunxWithxKotlinx&quot;</span>.countAmountOfX()</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="utility-functions-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> StringUtil &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">countAmountOfX</span><span class="params">(string: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> string.length - string.replace(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;&quot;</span>).length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">StringUtil.countAmountOfX(<span class="string">&quot;xFunxWithxKotlinx&quot;</span>)</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="优先使用命名参数"><a class="header-anchor" href="#优先使用命名参数">¶</a>优先使用命名参数</h2>
<div class="tabs" id="utility-functions"><ul class="nav-tabs"><li class="tab active"><a href="#utility-functions-1">✔✔✔</a></li><li class="tab"><a href="#utility-functions-2">✘✘✘</a></li></ul><div class="tab-content"><div class="tab-pane active" id="utility-functions-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> config2 = SearchConfig2(</span><br><span class="line">       root = <span class="string">&quot;~/folder&quot;</span>,</span><br><span class="line">       term = <span class="string">&quot;kotlin&quot;</span>,</span><br><span class="line">       recursive = <span class="literal">true</span>,</span><br><span class="line">       followSymlinks = <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="utility-functions-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> config = SearchConfig()</span><br><span class="line">       .setRoot(<span class="string">&quot;~/folder&quot;</span>)</span><br><span class="line">       .setTerm(<span class="string">&quot;kotlin&quot;</span>)</span><br><span class="line">       .setRecursive(<span class="literal">true</span>)</span><br><span class="line">       .setFollowSymlinks(<span class="literal">true</span>)</span><br><span class="line">StringUtil.countAmountOfX(<span class="string">&quot;xFunxWithxKotlinx&quot;</span>)</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="不要重载默认参数"><a class="header-anchor" href="#不要重载默认参数">¶</a>不要重载默认参数</h2>
<div class="tabs" id="overload-for-default-arguments"><ul class="nav-tabs"><li class="tab active"><a href="#overload-for-default-arguments-1">✔✔✔</a></li><li class="tab"><a href="#overload-for-default-arguments-2">✘✘✘</a></li></ul><div class="tab-content"><div class="tab-pane active" id="overload-for-default-arguments-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(name: <span class="type">String</span>, recursive: <span class="type">Boolean</span> = <span class="literal">true</span>)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="overload-for-default-arguments-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(name: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    find(name, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(name: <span class="type">String</span>, recursive: <span class="type">Boolean</span>)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="考虑使用-let"><a class="header-anchor" href="#考虑使用-let">¶</a>考虑使用 let</h2>
<div class="tabs" id="lets"><ul class="nav-tabs"><li class="tab active"><a href="#lets-1">✔✔✔</a></li><li class="tab"><a href="#lets-2">✘✘✘</a></li></ul><div class="tab-content"><div class="tab-pane active" id="lets-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">findOrder()?.let &#123; dun(it.customer) &#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">findOrder()?.customer?.let(::dun)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="lets-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> order: Order? = findOrder()</span><br><span class="line"><span class="keyword">if</span> (order != <span class="literal">null</span>)&#123;</span><br><span class="line">    dun(order.customer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kotlin</category>
        <category>easy-way-to-kotlin-for-java-programer</category>
      </categories>
  </entry>
  <entry>
    <title>写给 Java 开发者的 Kotlin 教程 (11) - object 关键字</title>
    <url>/2018/08/15/kotlin/easy-way-to-kotlin-for-java-proggamer/kotlin-object/</url>
    <content><![CDATA[<h2 id="对象表达式"><a class="header-anchor" href="#对象表达式">¶</a>对象表达式</h2>
<p><code>kotlin</code> 里面有个关键字 <code>object</code>，用作创建一个对象。<br>
比如我们有个例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">A</span>(x: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">val</span> y: <span class="built_in">Int</span> = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ab: A = <span class="keyword">object</span> : A(<span class="number">1</span>), B &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> y = <span class="number">15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>又比如我们可以创建一个独立的对象</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> adHoc = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> y: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    print(adHoc.x + adHoc.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以申明一个匿名类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countClicks</span><span class="params">(window: <span class="type">JComponent</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clickCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> enterCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">            clickCount++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">            enterCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单例对象"><a class="header-anchor" href="#单例对象">¶</a>单例对象</h2>
<p>在 <code>kotlin</code> 中引入了 <code>object</code> 关键字，让这个事情变的简单起来。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Payroll &#123;</span><br><span class="line">    <span class="keyword">val</span> allEmployees = arrayListOf&lt;Person&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculateSalary</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (person <span class="keyword">in</span> allEmployees) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="伴生对象"><a class="header-anchor" href="#伴生对象">¶</a>伴生对象</h2>
<p><code>kotlin</code> 去除了 <code>static</code> 关键字，如果我们希望声明一个 <code>static</code> 的函数，我们可以可以定一个 <code>pacage-level</code> 的函数，但是 <code>pacage-level</code> 不能够访问一个类的私有变量，解决方案是采用 <code>companion</code> 关键字进行伴生对象申明。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Companion object called&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; A.bar()</span><br><span class="line">Companion <span class="keyword">object</span> called</span><br></pre></td></tr></table></figure>
<p>值得注意，你如果希望能够被 <code>java</code> 调用，你需要在属性或者函数上加上一个注解 <code>@JvmStatic</code> / <code>@JvmField</code>。</p>
<h2 id="匿名类"><a class="header-anchor" href="#匿名类">¶</a>匿名类</h2>
<p><code>object</code> 函数还可以构建匿名类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> listener = <span class="keyword">object</span> : MouseAdapter &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kotlin</category>
        <category>easy-way-to-kotlin-for-java-programer</category>
      </categories>
  </entry>
  <entry>
    <title>写给 Java 开发者的 Kotlin 教程 (12) - 拾遗</title>
    <url>/2018/08/15/kotlin/easy-way-to-kotlin-for-java-proggamer/kotlin-omissions/</url>
    <content><![CDATA[<h2 id="Kotlin的泛型"><a class="header-anchor" href="#Kotlin的泛型">¶</a>Kotlin的泛型</h2>
<h2 id="密封类"><a class="header-anchor" href="#密封类">¶</a>密封类</h2>
<p>密封类用来表示受限的类继承结构：当一个值为有限集中的类型、而不能有任何其他类型时。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Expr</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Const</span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Sum</span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line"><span class="keyword">object</span> NotANumber : Expr()</span><br></pre></td></tr></table></figure>
<p>密封类的好处在于 <code>when</code> 语句</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span>(expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">    <span class="comment">// 不再需要 `else` 子句，因为我们已经覆盖了所有的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="嵌套类和内部类"><a class="header-anchor" href="#嵌套类和内部类">¶</a>嵌套类和内部类</h2>
<h3 id="嵌套类"><a class="header-anchor" href="#嵌套类">¶</a>嵌套类</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Nested</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> demo = Outer.Nested().foo() <span class="comment">// == 2</span></span><br></pre></td></tr></table></figure>
<h3 id="内部类"><a class="header-anchor" href="#内部类">¶</a>内部类</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lass Outer &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> demo = Outer().Inner().foo() <span class="comment">// == 1</span></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kotlin</category>
        <category>easy-way-to-kotlin-for-java-programer</category>
      </categories>
  </entry>
  <entry>
    <title>写给 Java 开发者的 Kotlin 教程 (1) - 概述</title>
    <url>/2018/07/09/kotlin/easy-way-to-kotlin-for-java-proggamer/kotlin-overview-installation-setup/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2018/07/10/PnH1S0.png" alt="start"></p>
<p><code>Kotlin</code> 是由 <code>JetBrains</code> 开发的一门编程语言, 也就是那个出品了一些列著名 <code>IDE</code> 比如 <code>IntelliJ IDEA</code>, <code>PhpStorm</code>, <code>PyCharm</code>, <code>ReSharper</code>的公司。</p>
<p><code>Kotlin</code> 运行在 JVM 之上，并且可以可以编译成 <code>JavaScript</code> 和 <code>机器码</code> （敲黑板）。</p>
<p>这是本片教程的第一章，我们先看看 <code>Kotlin</code> 的一些特性，让我们快速的了解 <code>Kotlin</code> 语言的特点。</p>
<span id="more"></span>
<h2 id="Kotlin-特点"><a class="header-anchor" href="#Kotlin-特点">¶</a>Kotlin 特点</h2>
<h3 id="静态类型"><a class="header-anchor" href="#静态类型">¶</a>静态类型</h3>
<p><code>Kotlin</code> 是一种静态类型编程语言。这意味着每个变量和表达式的类型在编译时都是已知的。静态类型的优点是编译器可以在编译时自行验证对象的方法调用和属性访问，并防止在运行时出现的许多微不足道的错误。虽然Kotlin是一种静态类型语言，但它并不要求明确指定您声明的每个变量的类型。大多数情况下，Kotlin可以从初始化表达式或周围的上下文推断变量的类型，也就是 <strong>类型推断</strong> 。</p>
<h3 id="简明"><a class="header-anchor" href="#简明">¶</a>简明</h3>
<p><code>Kotlin</code> 很简洁。减少了在其他OOP语言（如Java）中一直编写的样板代码。（虽然java也有 <code>Lombok</code>，但是依然存在一些不太方便的问题比如 <code>Builder</code> 的继承）<br>
例如，可以在一行中创建一个包含getter，setters，equals()，hashCode() 和 toString() 方法的POJO类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> email: String, <span class="keyword">val</span> country: String)</span><br></pre></td></tr></table></figure>
<h3 id="安全"><a class="header-anchor" href="#安全">¶</a>安全</h3>
<p><code>Kotlin</code> 通过支持可空性作为其类型系统的一部分来避免 <code>NullPointerException</code><br>
例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello, World&quot;</span>    <span class="comment">// 非空类型</span></span><br><span class="line">str = <span class="literal">null</span> <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>
<p>如果你想要储存 <code>null</code> 值，那必须申明的时候明确指出</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">String nullableStr? = <span class="literal">null</span>   </span><br></pre></td></tr></table></figure>
<p>由于 <code>Kotlin</code> 知道哪些变量可以为空，哪些变量不可为，因此它可以在编译时检测和禁止不安全的调用，否则会在运行时导致<code>NullPointerException</code> (<code>JDK8 - Optional</code> 同样解决这个问题，不过并没有编译器上解决)</p>
<h3 id="明确"><a class="header-anchor" href="#明确">¶</a>明确</h3>
<p><code>Kotlin</code> 是明确的。显性声明被认为是一件好事。<br>
比如</p>
<ul>
<li>Kotlin不允许隐式类型转换，例如，int为long，或float为double。它提供了像toLong() 和toDouble() 这样的方法来显式地这样做。</li>
<li>默认情况下，Kotlin中的所有类都是 <code>final</code>（不可继承）。您需要将类显式标记为 <code>open</code> 以允许其他类继承它。同样，默认情况下，类的所有属性和成员函数都是 <code>final</code> 。您需要将函数或属性显式标记为打开，以允许子类覆盖它。</li>
<li>如果要覆盖父类函数或属性，则需要使用 <code>override</code> 修饰符显式注释它。</li>
</ul>
<h3 id="与Java完全交互"><a class="header-anchor" href="#与Java完全交互">¶</a>与Java完全交互</h3>
<p><code>Kotlin</code> 与 <code>Java</code> 可以互相操作。可以轻松地从Kotlin访问Java代码，反之亦然。</p>
<h3 id="IDEA友好"><a class="header-anchor" href="#IDEA友好">¶</a>IDEA友好</h3>
<p><code>Kotlin</code> 开创了 <code>IDEA</code> 先行的先例，在诞生之初就拥有良好的开发工具链。</p>
<h3 id="全栈式"><a class="header-anchor" href="#全栈式">¶</a>全栈式</h3>
<p>kotlin是一门真正全栈式的编程语言，可以开发web，Socket，安卓，js，NativeApp等。</p>
<h3 id="免费-开源"><a class="header-anchor" href="#免费-开源">¶</a>免费&amp;开源</h3>
<p>天下有免费的馅饼。</p>
<h2 id="安装-Kotlin"><a class="header-anchor" href="#安装-Kotlin">¶</a>安装 Kotlin</h2>
<h3 id="单独安装-Kotlin-编译器"><a class="header-anchor" href="#单独安装-Kotlin-编译器">¶</a>单独安装 Kotlin 编译器</h3>
<ol>
<li>去 <a href="https://github.com/JetBrains/kotlin/releases/latest">kotlin releases</a> 下载最近的压缩包</li>
<li>解压缩下载的kotlin-compiler-x.x.x.zip文件</li>
<li>将解压后的路径/bin 添加到PATH变量中</li>
<li>验证下 kotlinc</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Welcome to Kotlin version 1.2.51 (JRE 1.8.0_162-ea-b01)</span><br><span class="line">Type :<span class="built_in">help</span> <span class="keyword">for</span> <span class="built_in">help</span>, :quit <span class="keyword">for</span> quit</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="为-IntelliJ-IDEA-安装-Kotlin"><a class="header-anchor" href="#为-IntelliJ-IDEA-安装-Kotlin">¶</a>为 IntelliJ IDEA 安装 Kotlin</h3>
<p>新版本的  <code>IntelliJ IDEA</code> 都已经支持了 <code>Kotlin</code>，我们在创建项目的时候记得勾选 <code>Kotlin</code> 即可。</p>
<h3 id="为-Eclipse-安装-Kotlin"><a class="header-anchor" href="#为-Eclipse-安装-Kotlin">¶</a>为 Eclipse 安装 Kotlin</h3>
<ol>
<li>
<p>打开 <code>Eclipse Marketplace</code> 并搜索 <code>Kotlin</code><br>
<img src="https://s1.ax1x.com/2018/07/10/PnXZIe.png" alt="x"></p>
</li>
<li>
<p>安装并重启 <code>Eclipse</code></p>
</li>
<li>
<p>创建项目选择 <code>Kotlin</code> 即可</p>
</li>
</ol>
<h3 id="Hello-Kotlin"><a class="header-anchor" href="#Hello-Kotlin">¶</a>Hello Kotlin</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello, Kotlin!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 <code>Hello Kotlin</code> 结束这一个介绍的教程，希望大家在后续的课程中玩的开心, have fun。</p>
<h2 id="参考文献"><a class="header-anchor" href="#参考文献">¶</a>参考文献</h2>
<ul>
<li><a href="https://www.callicoder.com/kotlin-overview-installation-setup/">kotlin-overview-installation-setup</a></li>
<li><a href="http://blog.teamtreehouse.com/absolute-beginners-guide-kotlin">absolute-beginners-guide-kotlin</a></li>
<li><a href="https://www.tutorialkart.com/kotlin-tutorial/">Kotlin Tutorial</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kotlin</category>
        <category>easy-way-to-kotlin-for-java-programer</category>
      </categories>
  </entry>
  <entry>
    <title>写给 Java 开发者的 Kotlin 教程 (5) - Null对象与类型安全</title>
    <url>/2018/07/17/kotlin/easy-way-to-kotlin-for-java-proggamer/null-type/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2018/07/17/PlWoad.png" alt="banner"></p>
<p>Kotlin 的类型系统旨在消除来自代码空引用的危险,许多编程语言（包括 <code>Java</code>）中最常见的陷阱之一，就是访问空引用的成员会导致空引用异常。在 <code>Java</code> 中，这等同于 <code>NullPointerException</code> 或简称 <code>NPE</code> 。</p>
<span id="more"></span>
<h2 id="一件趣事"><a class="header-anchor" href="#一件趣事">¶</a>一件趣事</h2>
<blockquote>
<p>“我把 Null 引用称为自己的十亿美元错误。它的发明是在1965 年，那时我用一个面向对象语言( ALGOL W )设计了第一个全面的引用类型系统。我的目的是确保所有引用的使用都是绝对安全的，编译器会自动进行检查。但是我未能抵御住诱惑，加入了Null引用，仅仅是因为实现起来非常容易。它导致了数不清的错误、漏洞和系统崩溃，可能在之后 40 年中造成了十亿美元的损失。近年来，大家开始使用各种程序分析程序，比如微软的 PREfix 和 PREfast 来检查引用，如果存在为非 Null 的风险时就提出警告。更新的程序设计语言比如 Spec# 已经引入了非 Null 引用的声明。这正是我在1965年拒绝的解决方案。”<br>
—— 《Null References: The Billion Dollar Mistake》托尼·霍尔（Tony Hoare），图灵奖得主</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2018/07/17/PlWqRP.md.png" alt=""></p>
<h2 id="Null的错误"><a class="header-anchor" href="#Null的错误">¶</a>Null的错误</h2>
<p>简单来说：NULL 是一个不是值的值，而它现在有很多名字：NULL、nil、null、None、Nothing、Nil 和 nullptr。每种语言都有自己的细微差别。<code>Null</code> 有很多缺点，我们细数下罪状。</p>
<h3 id="类型检测失败"><a class="header-anchor" href="#类型检测失败">¶</a>类型检测失败</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(String input)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> input.Length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 中，如果我编写 x.Length()，编译器会检查 x 的类型。如果 x 是一个 String，那么类型检查成功；</p>
<p>如果 x 是一个 Socket，那么类型检查失败，编译时检查存在一个致命缺陷：任何引用都可以是 null，而调用一个 null 对象的方法会产生一个 NullPointerException。</p>
<p>所以 <code>null.Length()</code> 会抛出一个 <code>NullPointerException</code> 而和原本的类型系统冲突，因为 <code>NULL</code> 超出了类型检查的范围。越过类型检查，运行时会给你一个巨大的惊喜。解决这种问题我们一般会选择 <code>入参检测</code> 来让错误尽早的暴露出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(String input)</span>&#123;</span><br><span class="line">    Validate.nonNull(input, <span class="string">&quot;input must be not null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> input.Length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NULL-是一个特例"><a class="header-anchor" href="#NULL-是一个特例">¶</a>NULL 是一个特例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserVo <span class="title function_">getUser</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数定义中，返回值会有三种可能 <code>UserVo</code> <code>null</code> <code>Expection</code>， 而我们在 获取 <code>null</code> 值的时候，我们不知道是因为 <code>ID</code> 不对，还是其他其他问题，甚至于在实践阶段，我们可能赋予 <code>null</code>返回是一个特殊的情况，在外部应该给予处理。</p>
<p>除此之外 <code>Null</code>还有</p>
<ul>
<li><code>NULL</code> 难以调试</li>
<li><code>NULL</code> 使我们需要进行大量的 <code>IF</code> 判断</li>
<li><code>NULL</code> 存储在数据结构中，导致数据意义失效</li>
</ul>
<h2 id="Kotlin-解决之道"><a class="header-anchor" href="#Kotlin-解决之道">¶</a>Kotlin 解决之道</h2>
<p>在 <code>Java 1.8</code> 之前我们使用使用 <code>Guava</code> 的 <code>Optional</code> 对，<code>1.8</code> 之后我们使用内置数据结构。<br>
在 <code>Kotlin</code> 中，我们使用 <code>类型系统</code> 来帮助我们。</p>
<div class="tabs" id="null"><ul class="nav-tabs"><li class="tab active"><a href="#null-1">nonNull</a></li><li class="tab"><a href="#null-2">nullable</a></li></ul><div class="tab-content"><div class="tab-pane active" id="null-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a: String = <span class="string">&quot;abc&quot;</span></span><br><span class="line">a = <span class="literal">null</span> <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="null-2"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b: String? = <span class="string">&quot;abc&quot;</span></span><br><span class="line">b = <span class="literal">null</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></div></div></div>
<p>看出来了吗？我们使用 <code>类型系统</code> 区分一个引用可以为 null 还是不能容纳。这个时候我们如果访问其中的函数或变量</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b: String? = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">val</span> l = b.length <span class="comment">// 错误：变量“b”可能为空</span></span><br></pre></td></tr></table></figure>
<p>那我们如何去访问这个对象的函数呢？有以下几种方式</p>
<h3 id="在条件中检查-null"><a class="header-anchor" href="#在条件中检查-null">¶</a>在条件中检查 null</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b: String? = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">val</span> l = <span class="keyword">if</span> (b != <span class="literal">null</span>) b.length <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="安全调用"><a class="header-anchor" href="#安全调用">¶</a>安全调用</h3>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b: String? = <span class="string">&quot;abc&quot;</span></span><br><span class="line">b?.length</span><br></pre></td></tr></table></figure>
<p>这里需要注意 如果 <code>b</code> 非空，就返回 <code>b.length</code>，否则返回 <code>null</code>，这个表达式的返回值是 <code>Int?</code> 类型。<br>
而且我们可以采用 <code>链式调用</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">bob?.department?.head?.name</span><br></pre></td></tr></table></figure>
<h3 id="Elvis-操作符"><a class="header-anchor" href="#Elvis-操作符">¶</a>Elvis 操作符</h3>
<p>我们都在 <code>Optional</code> 对象往往有这种的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; someOpt;</span><br><span class="line"><span class="type">String</span> <span class="variable">unwrap</span> <span class="operator">=</span> someOpt.orElse(<span class="string">&quot;Default&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>而在 <code>Kotlin</code> 我们可以如下操作</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> l = b?.length ?: -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="操作符"><a class="header-anchor" href="#操作符">¶</a>!! 操作符</h2>
<p>非空断言运算符（!!）将任何值转换为非空类型</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> l = b!!.length  <span class="comment">//如果 b 为空，就会抛出一个 NPE 异常</span></span><br></pre></td></tr></table></figure>
<h3 id="题外话"><a class="header-anchor" href="#题外话">¶</a>题外话</h3>
<p>在大量的第三类库中</p>
<ul>
<li><code>Guava</code> 宣称在 <code>95%</code> 的代码处没有 <code>null</code></li>
<li><code>Lombok</code> 有一个注解 <code>@Nonull</code> 可以在生成代码中检测是否为空</li>
<li><code>Spring JPA</code> 在 <code>Reposity</code> 定义中全面支持 <code>Optional</code></li>
</ul>
<p><code>Nonull</code> 设计已经算是在 <code>Java</code> 领域非常成功的设计了，希望大家早日上船。</p>
<h2 id="参考文献"><a class="header-anchor" href="#参考文献">¶</a>参考文献</h2>
<ul>
<li><a href="http://blog.jobbole.com/93667/">计算机科学中的最严重错误，造成十亿美元损失</a></li>
<li><a href="https://hltj.gitbooks.io/kotlin-reference-chinese/content/txt/null-safety.html">null-safety</a></li>
<li><a href="http://www.baeldung.com/java-optional">java-optional</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kotlin</category>
        <category>easy-way-to-kotlin-for-java-programer</category>
      </categories>
  </entry>
  <entry>
    <title>写给 Java 开发者的 Kotlin 教程 (8) -  面向对象 - 基础</title>
    <url>/2018/08/03/kotlin/easy-way-to-kotlin-for-java-proggamer/oop-basic/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2018/08/03/PBGkQK.jpg" alt="banner"></p>
<p>话不多说，Kotlin依然是一个门 <code>OOP</code> 语言，我们从今天开始我们来踏上最后一段旅程。</p>
<span id="more"></span>
<h2 id="Class-类"><a class="header-anchor" href="#Class-类">¶</a>Class 类</h2>
<p><code>Kotlin</code> 与 <code>Java</code> 一样，依然保留 <code>class</code> 这个关键字，我们可以使用类似于 <code>Java</code> 的类声明</p>
<div class="tabs" id="class-def"><ul class="nav-tabs"><li class="tab active"><a href="#class-def-1">Kotlin 类定义</a></li><li class="tab"><a href="#class-def-2">Java 类定义</a></li></ul><div class="tab-content"><div class="tab-pane active" id="class-def-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="class-def-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//没啥区别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p>相比较 <code>Java</code> 而言， <code>Kotlin</code> 允许省略空声明的 一对<code>&#123;&#125;</code> 即是</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> //合法声明</span><br></pre></td></tr></table></figure>
<p>实例化一个类的时候不再需要 <code>new</code> 这个关键字。</p>
<div class="tabs" id="instance-def"><ul class="nav-tabs"><li class="tab active"><a href="#instance-def-1">Kotlin 实例化</a></li><li class="tab"><a href="#instance-def-2">Java 实例化</a></li></ul><div class="tab-content"><div class="tab-pane active" id="instance-def-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> person = Person()</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="instance-def-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="构造函数"><a class="header-anchor" href="#构造函数">¶</a>构造函数</h2>
<p><code>Kotlin</code> 具有两种 <code>构造函数</code> 分别是 <code>主构造函数</code>和 <code>次构造函数</code>，</p>
<p><code>主构造函数</code>仅允许出现一次，出现在类定义上</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">constructor</span>(firstName: String) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 <code>constructor</code> 关键字。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(firstName: String) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p><code>次构造函数</code> 声明在类定义体内</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(parent: Person) &#123;</span><br><span class="line">        parent.children.add(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 this 关键字即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String, parent: Person) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        parent.children.add(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Initializer-块"><a class="header-anchor" href="#Initializer-块">¶</a>Initializer 块</h3>
<p>除构造函数之外，<code>Kotlin</code> 还有一个特殊的关键字 <code>init</code>，因为 <code>主构造函数</code> 不能申明代码，所以初始化的逻辑只能放在一个单独的代码块中，这块区域被称之为 <code>初始化块</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(_firstName: String, _lastName: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> firstName: String</span><br><span class="line">    <span class="keyword">var</span> lastName: String</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化块</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = _firstName</span><br><span class="line">        <span class="keyword">this</span>.lastName = _lastName</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;Initialized a new Person object with firstName = <span class="variable">$firstName</span> and lastName = <span class="variable">$lastName</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的 <code>init</code> 段是允许出现多次的，执行的顺序是按照书写的顺序执行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InitOrderDemo</span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> firstProperty = <span class="string">&quot;First property: <span class="variable">$name</span>&quot;</span>.also(::println)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;First initializer block that prints <span class="subst">$&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> secondProperty = <span class="string">&quot;Second property: <span class="subst">$&#123;name.length&#125;</span>&quot;</span>.also(::println)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Second initializer block that prints <span class="subst">$&#123;name.length&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a class="header-anchor" href="#继承">¶</a>继承</h2>
<p><code>Kotlin</code> 中的所有的类都 继承于 <code>Any</code> 类，</p>
<blockquote>
<p>注意：Any 并不是 java.lang.Object；尤其是，它除了 equals()、hashCode()和toString()外没有任何成员。</p>
</blockquote>
<p>需要继承类也非常的简单，只需要使用 <code>:</code> 把类型放到类头的冒号之后即可。</p>
<div class="tabs" id="extend-def"><ul class="nav-tabs"><li class="tab active"><a href="#extend-def-1">Kotlin 继承</a></li><li class="tab"><a href="#extend-def-2">Java 继承</a></li></ul><div class="tab-content"><div class="tab-pane active" id="extend-def-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Base</span>(p: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>(p: <span class="built_in">Int</span>) : Base(p)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="extend-def-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> extend Base&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<blockquote>
<p>类上的 open 标注与 Java 中 final 相反，它允许其他类从这个类继承。默认情况下，在 Kotlin 中所有的类都是 final， 对应于《Effective Java》第三版书中的第 19 条：要么为继承而设计，并提供文档说明，要么就禁止继承。</p>
</blockquote>
<h2 id="覆盖方法-覆盖属性"><a class="header-anchor" href="#覆盖方法-覆盖属性">¶</a>覆盖方法 &amp; 覆盖属性</h2>
<p>Kotlin 力求清晰显式。与 Java 不同，Kotlin 需要显式标注可覆盖的成员。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nv</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>() : Base() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Derived.v() 函数上必须加上 <code>override</code> 标注。如果没写，编译器将会报错。 如果函数没有标注 open 如 Base.nv()，则子类中不允许定义相同签名的函数， 不论加不加 override。在一个 final 类中（没有用 open 标注的类），开放成员是禁止的。</p>
<p>覆盖属性 与方法覆盖类似</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> <span class="keyword">get</span>() &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar1</span> : <span class="type">Foo</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> = ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用超类实现"><a class="header-anchor" href="#调用超类实现">¶</a>调用超类实现</h2>
<p>派生类中的代码可以使用 <code>super</code> 关键字调用其超类的函数与属性访问器的实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;Foo.f()&quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> <span class="keyword">get</span>() = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> : <span class="type">Foo</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; </span><br><span class="line">        <span class="keyword">super</span>.f()</span><br><span class="line">        println(<span class="string">&quot;Bar.f()&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> <span class="keyword">get</span>() = <span class="keyword">super</span>.x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类"><a class="header-anchor" href="#抽象类">¶</a>抽象类</h2>
<p>类和其中的某些成员可以声明为 <code>abstract</code>。 抽象成员在本类中可以不用实现。 需要注意的是，我们并不需要用 open 标注一个抽象类或者函数——因为这不言而喻。<br>
我们可以用一个抽象成员覆盖一个非抽象的开放成员。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="type">Base</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可见性修饰"><a class="header-anchor" href="#可见性修饰">¶</a>可见性修饰</h2>
<p><code>Kotlin</code> 与 <code>Java</code> 类型具有四种可见性修饰关键字 <code>public</code>, <code>private</code>, <code>protected</code> 和 <code>internal</code>，前三个和 <code>Java</code> 中的语义是一样的，最后<code>internal</code> 是指在同一个 模块下 可以被访问，这里的<code>模块</code>的定义是：</p>
<ul>
<li>一个 IntelliJ IDEA 模块；</li>
<li>一个 Maven 项目；</li>
<li>一个 Gradle 源集（例外是 test 源集可以访问 main 的 internal 声明）；</li>
<li>一次 ＜kotlinc＞ Ant 任务执行所编译的一套文件。</li>
</ul>
<h2 id="参考文献"><a class="header-anchor" href="#参考文献">¶</a>参考文献</h2>
<ul>
<li><a href="https://www.kotlincn.net/docs/reference">kotlin Refence</a></li>
<li><a href="https://www.kotlincn.net/docs/reference/visibility-modifiers.html#%E6%A8%A1%E5%9D%97">visibility-modifiers</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kotlin</category>
        <category>easy-way-to-kotlin-for-java-programer</category>
      </categories>
  </entry>
  <entry>
    <title>写给 Java 开发者的 Kotlin 教程 (10) -  面向对象 - 继承与多态</title>
    <url>/2018/08/14/kotlin/easy-way-to-kotlin-for-java-proggamer/oop-class-polymorphism/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2018/08/14/P2gOAK.jpg" alt="banner"><br>
继承是面向对象的最重要的特性之一，我们今天就来先看看继承这个特性，我们都知道 <code>kotlin</code> 的任何一个类都是继承自 <code>Any</code> 类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> // 隐形的 <span class="title">Person</span> 继承自 <span class="title">Any</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="继承"><a class="header-anchor" href="#继承">¶</a>继承</h2>
<p>如果我们需要继承一个类，我们可以使用如下</p>
<h3 id="类继承"><a class="header-anchor" href="#类继承">¶</a>类继承</h3>
<div class="tabs" id="inheritance"><ul class="nav-tabs"><li class="tab active"><a href="#inheritance-1">Kotlin 继承</a></li><li class="tab"><a href="#inheritance-2">Java 继承</a></li></ul><div class="tab-content"><div class="tab-pane active" id="inheritance-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Laptop</span>: <span class="type">Computer</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="inheritance-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Laptop</span>: Computer() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p>这里有些不一样的地方就是，<code>kotlin</code> 默认的认为所有的类都是不能够被继承的，我们希望自己的类能够被继承，我们需要在<code>class</code> 前面增加 <code>open</code> 这个关键字。<br>
我们也知道 <code>kotlin</code> 有主构造器，那它的继承语法是这样的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Computer</span>(<span class="keyword">val</span> name: String,</span><br><span class="line">                    <span class="keyword">val</span> brand: String) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Laptop</span>(name: String, </span><br><span class="line">             brand: String, </span><br><span class="line">             <span class="keyword">val</span> batteryLife: <span class="built_in">Double</span>) : Computer(name, brand) &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法覆写"><a class="header-anchor" href="#方法覆写">¶</a>方法覆写</h3>
<p>和类相似，<code>kotlin</code> 默认的函数都是 <code>final</code> 不能够被重载的。我们也需要在能够被重载的函数上进行 <code>open</code> 修饰。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="comment">// 必须定义为 open</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">teach</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Teaching...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MathsTeacher</span> : <span class="type">Teacher</span>() &#123;</span><br><span class="line">    <span class="comment">// override 关键字也是必须的</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">teach</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Teaching Maths...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性覆写"><a class="header-anchor" href="#属性覆写">¶</a>属性覆写</h3>
<p>与函数类似</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="comment">// 必须定义为 open</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> baseSalary: <span class="built_in">Double</span> = <span class="number">30000.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span> : <span class="type">Employee</span>() &#123;</span><br><span class="line">    <span class="comment">// override 关键字也是必须的</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> baseSalary: <span class="built_in">Double</span> = <span class="number">50000.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用父类方法"><a class="header-anchor" href="#调用父类方法">¶</a>调用父类方法</h3>
<p>与 <code>Java</code> 一样，采用的是 <code>super</code> 关键字</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> baseSalary: <span class="built_in">Double</span> = <span class="number">10000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">displayDetails</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;I am an Employee&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Developer</span>: <span class="type">Employee</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> baseSalary: <span class="built_in">Double</span> = <span class="keyword">super</span>.baseSalary + <span class="number">10000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">displayDetails</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.displayDetails()</span><br><span class="line">        println(<span class="string">&quot;I am a Developer&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类与属性函数"><a class="header-anchor" href="#抽象类与属性函数">¶</a>抽象类与属性函数</h2>
<p>我们依然可以使用 <code>abstract</code> 定义一个抽象类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span></span><br></pre></td></tr></table></figure>
<p><code>kotlin</code> 除了支持抽象类，还支持抽象函数和抽象属性，抽象函数和传统的 <code>java</code> 类似，但是抽象属性在java中并没有类型的东西，我们来看一下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span>(<span class="keyword">val</span> name: String,</span><br><span class="line">                       <span class="keyword">val</span> color: String,</span><br><span class="line">                       <span class="keyword">val</span> weight: <span class="built_in">Double</span>) &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象属性必须被子类覆写</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">var</span> maxSpeed: <span class="built_in">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象属性必须被子类实现</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型检查"><a class="header-anchor" href="#类型检查">¶</a>类型检查</h2>
<p>因为多态的存在，我们需要进行类型检查。</p>
<div class="tabs" id="type-checks"><ul class="nav-tabs"><li class="tab active"><a href="#type-checks-1">Kotlin Type Check</a></li><li class="tab"><a href="#type-checks-2">Java Type Check</a></li></ul><div class="tab-content"><div class="tab-pane active" id="type-checks-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mixedTypeList: List&lt;Any&gt; = listOf(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;am&quot;</span>, <span class="number">5</span>, <span class="string">&quot;feet&quot;</span>, <span class="number">9.5</span>, <span class="string">&quot;inches&quot;</span>, <span class="string">&quot;tall&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(value <span class="keyword">in</span> mixedTypeList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">is</span> String) &#123;</span><br><span class="line">        println(<span class="string">&quot;String: &#x27;<span class="variable">$value</span>&#x27; of length <span class="subst">$&#123;value.length&#125;</span> &quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">is</span> <span class="built_in">Int</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Integer: &#x27;<span class="variable">$value</span>&#x27;&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">is</span> <span class="built_in">Double</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Double: &#x27;<span class="variable">$value</span>&#x27; with Ceil value <span class="subst">$&#123;Math.ceil(value)&#125;</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Unknown Type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="type-checks-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; objects = Arrays.asList(<span class="string">&quot;123&quot;</span>, <span class="number">123</span>, <span class="number">1D</span>);</span><br><span class="line"><span class="keyword">for</span> (Object v : objects) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        ((String) v).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p>看起来好像差不多，<code>kotlin</code> 在进行完 <code>is</code> 比较之后，在后续的代码块中会自行的将对象转化为 <code>is</code> 比较的对象，减少一个强制类型转换。</p>
<div class="tabs" id="type-smart-casts"><ul class="nav-tabs"><li class="tab active"><a href="#type-smart-casts-1">Kotlin Cast</a></li><li class="tab"><a href="#type-smart-casts-2">Java Smart Cast</a></li></ul><div class="tab-content"><div class="tab-pane active" id="type-smart-casts-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> obj: Any = <span class="string">&quot;The quick brown fox jumped over a lazy dog&quot;</span></span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">    <span class="comment">// The variable obj is automatically cast to a String in this scope.</span></span><br><span class="line">    <span class="comment">// No Explicit Casting needed. </span></span><br><span class="line">    println(<span class="string">&quot;Found a String of length <span class="subst">$&#123;obj.length&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="type-smart-casts-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;The quick brown fox jumped over a lazy dog&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="comment">// Explicit Casting to `String`</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">    System.out.println(<span class="string">&quot;Found a String of length &quot;</span> + str.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p>除了这么用之外，<code>kotlin</code> 还可以和 <code>when</code> 结合</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(value <span class="keyword">in</span> mixedTypeList) &#123;</span><br><span class="line">    <span class="keyword">when</span>(value) &#123;</span><br><span class="line">        <span class="keyword">is</span> String -&gt; println(<span class="string">&quot;String: &#x27;<span class="variable">$value</span>&#x27; of length <span class="subst">$&#123;value.length&#125;</span> &quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;Integer: <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Double</span> -&gt; println(<span class="string">&quot;Double: <span class="variable">$value</span> with Ceil value <span class="subst">$&#123;Math.ceil(value)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;Unknown Type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="强制类型转换"><a class="header-anchor" href="#强制类型转换">¶</a>强制类型转换</h3>
<p>在 java 里我们可以将对象强制的转换，但是这个行为不一定是安全的，在 <code>kotlin</code> 里也提供了这样的行为关键字 <code>as</code> 我们可以使用如下代码段。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> obj: Any = <span class="string">&quot;The quick brown fox jumped over a lazy dog&quot;</span></span><br><span class="line"><span class="keyword">val</span> str: String = obj <span class="keyword">as</span> String</span><br><span class="line">println(str.length)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> str: String = obj <span class="keyword">as</span> String <span class="comment">//会抛出运行时 ClassCastException</span></span><br></pre></td></tr></table></figure>
<p>但是<code>kotlin</code> 提供了 <strong>安全的转换尝试</strong> 可以使用 <code>as?</code> 进行转换</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> obj: Any = <span class="number">123</span></span><br><span class="line"><span class="keyword">val</span> str: String? = obj <span class="keyword">as</span>? String </span><br><span class="line">println(str)  <span class="comment">// 这里会是 null 对象</span></span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ul>
<li><a href="https://www.callicoder.com/kotlin-type-checks-smart-casts/">smart casts</a></li>
<li><a href="https://www.callicoder.com/kotlin-abstract-classes/">abstract class</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kotlin</category>
        <category>easy-way-to-kotlin-for-java-programer</category>
      </categories>
  </entry>
  <entry>
    <title>写给 Java 开发者的 Kotlin 教程 (9) -  面向对象 - 属性</title>
    <url>/2018/08/07/kotlin/easy-way-to-kotlin-for-java-proggamer/oop-class-with-properties/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2018/08/07/PsMWvT.jpg" alt="banner"></p>
<p>上一章，我们聊过了面向对象的基础对象。我们继续来来对象中最为重要的 <code>属性</code> 和 <code>方法</code> 中的第一个。</p>
<span id="more"></span>
<h2 id="主构造函数与属性"><a class="header-anchor" href="#主构造函数与属性">¶</a>主构造函数与属性</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用主构造函数与属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(_id: <span class="built_in">Int</span>, _name: String, _age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// Properties of User class</span></span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span> = _id         <span class="comment">// val 不可变量</span></span><br><span class="line">    <span class="keyword">var</span> name: String = _name  <span class="comment">// var 变量</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = _age       <span class="comment">// var 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同上文 <code>Class</code> 中的可见性修饰一样，<code>kotlin</code>中属性的默认的修饰符也是 <code>public</code> 所以我们在外部进行变量读取，我们可以使用一下的方式。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> user = User(<span class="number">1</span>, <span class="string">&quot;Jack Sparrow&quot;</span>, <span class="number">44</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得一个属性</span></span><br><span class="line"><span class="keyword">val</span> name = user.name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定一个属性</span></span><br><span class="line">user.age = <span class="number">46</span></span><br><span class="line"></span><br><span class="line">user.id = <span class="number">2</span>	<span class="comment">// Error: Val 是不能够赋值的</span></span><br></pre></td></tr></table></figure>
<h2 id="Getters-and-Setters"><a class="header-anchor" href="#Getters-and-Setters">¶</a>Getters and Setters</h2>
<p><code>kotlin</code> 中设定 <code>Getters</code> 和 <code>Setters</code> 和 <code>Java</code> 完全不同，完整的语法规则是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure>
<div class="tabs" id="getters-and-setters"><ul class="nav-tabs"><li class="tab active"><a href="#getters-and-setters-1">Kotlin</a></li><li class="tab"><a href="#getters-and-setters-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="getters-and-setters-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(_id: <span class="built_in">Int</span>, _name: String, _age: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> simple: <span class="built_in">Int</span>? </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span>  <span class="comment">//函数Getter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span> = _id</span><br><span class="line">        <span class="keyword">get</span>() = field</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name: String = _name</span><br><span class="line">        <span class="keyword">get</span>() = field   <span class="comment">//普通属性Getter</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;  <span class="comment">// 这里的 value 是默认名称可以修改为任何值</span></span><br><span class="line">            field = value  <span class="comment">//而这路的 field 是 也就是我们上面声明的 name</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = _age</span><br><span class="line">        <span class="keyword">get</span>() = field</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="getters-and-setters-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p>肯定有同学想问，为什么看起来这么奇怪，那是因为 <code>Kotlin</code> 使用了一种 <code>Backing Field</code> 技术，我们默认并非是访问属性本身，是使用 <code>Getter</code> 和 <code>Setter</code> 去访问属性的。所以下面的代码是等价的。</p>
<div class="tabs" id="backing-field"><ul class="nav-tabs"><li class="tab active"><a href="#backing-field-1">Kotlin</a></li><li class="tab"><a href="#backing-field-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="backing-field-1"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DummyClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> isEmpty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="backing-field-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DummyClass</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> isEmpty;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.size = var1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.isEmpty;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setEmpty</span><span class="params">(<span class="type">boolean</span> var1)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.isEmpty = var1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p>所以我们在访问的时候，其实是通过 <code>Get</code> 和 <code>Set</code> 方法进行访问的。</p>
<h2 id="常量"><a class="header-anchor" href="#常量">¶</a>常量</h2>
<p>已知值的属性可以使用 const 修饰符标记为 <code>编译期常量</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> SUBSYSTEM_DEPRECATED: String = <span class="string">&quot;This subsystem is deprecated&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="延迟初始化"><a class="header-anchor" href="#延迟初始化">¶</a>延迟初始化</h2>
<p>一般地，属性声明为非空类型必须在构造函数中初始化。 但是我们常常需要通过依赖注入来初始化， 或者在单元测试的 setup 方法中初始化。 这种情况下，我们可以使用 <code>lateinit</code> 关键字</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> subject: TestSubject  <span class="comment">//注意这里并没有申明为  subject? </span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SetUp</span> <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject = TestSubject()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject.method()  <span class="comment">// 直接解引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据类"><a class="header-anchor" href="#数据类">¶</a>数据类</h2>
<p>我们经常创建一些只保存数据的 POJO 类，形如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> y;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getX</span><span class="params">()</span> &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getY</span><span class="params">()</span> &#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">double</span> v)</span> &#123; x = v; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">double</span> v)</span> &#123; y = v; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object other)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的类 <code>Get</code> 和 <code>Set</code> 方式是冗余的，<code>Kotlin</code>对其进行了优化。我们可以使用 <code>data</code> 关键字进行简化。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>
<p>编译器自动从主构造函数中声明的所有属性推导出函数：</p>
<ul>
<li>equals()/hashCode() 函数</li>
<li>toString() 函数</li>
<li>componentN() 解构函数（后续说明）</li>
<li>copy() 拷贝函数</li>
</ul>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ul>
<li><a href="https://www.kotlincn.net/docs/reference/properties.html">属性和字段</a></li>
<li><a href="https://www.callicoder.com/kotlin-properties-backing-fields-getters-setters/">Kotlin Properties, Backing Fields, Getters and Setters</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kotlin</category>
        <category>easy-way-to-kotlin-for-java-programer</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Rust 为 Envoy 构建插件</title>
    <url>/2020/10/30/networking/envoy/build-plugin-for-envoy-by-rust/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/10/30/NaNFT.png" alt="NaNFT.png"></p>
<p>今天就带大家使用 <code>Rust</code> 构建 <code>WebAssembly</code> 作为 <code>Envoy</code> 的插件。</p>
<span id="more"></span>
<h2 id="什么是-WebAssembly"><a class="header-anchor" href="#什么是-WebAssembly">¶</a>什么是 WebAssembly</h2>
<p><code>WebAssembly</code>（Wasm）是一种由多种语言编写的，可移植的字节码格式，它能以以接近本机的速度执行。其最初的设计目标与上述挑战很相符，并且在其背后得到了相当大的行业支持。<code>Wasm</code> 是在所有主流浏览器中可以本地运行的第四种标准语言（继 HTML，CSS 和 JavaScript 之后），于 2019 年 12 月成为 W3C 正式建议。这使我们有信心对其进行战略下注。</p>
<h2 id="WebAssembly-In-Envoy"><a class="header-anchor" href="#WebAssembly-In-Envoy">¶</a>WebAssembly In Envoy</h2>
<p>在早期的 <code>Envoy</code> 版本中，支持两种插件模式 <code>C++动态库</code> / <code>Lua脚本</code> 的模式，不过这两种模式都对语言本身产生了需求，因此在后续提出了 <code>wasm</code> 的支持，一开始作为一个 <code>side</code> 项目独立演进的 <a href="https://github.com/envoyproxy/envoy-wasm/"><code>envoy-wasm</code></a></p>
<p>使用 <code>Wasm</code> 扩展 <code>Envoy</code> 带来了几个主要好处：</p>
<ul>
<li><code>敏捷性</code>：可以用 <code>Istio</code> 控制平面在运行时下发和重载扩展。这就可以快速的进行扩展开发→ 测试→ 发布周期，而无需重启 <code>Envoy</code>。</li>
<li><code>发布库</code>：一旦完成合并到主树中之后，<code>Istio</code> 和其它程序将能够使用 <code>Envoy</code> 的发布库，而不是自己构建。这也方便 <code>Envoy</code> 社区迁移某些内置扩展到这个模型，从而减少他们的工作。</li>
<li><code>可靠性和隔离性</code>：扩展部署在具有资源限制的沙箱中，这意味着它们现在可以崩溃或泄漏内存，但不会让整个 <code>Envoy</code> 挂掉。CPU 和内存使用率也可以受到限制。</li>
<li><code>安全性</code>：沙盒具有一个明确定义的 <code>API</code>，用于和 <code>Envoy</code> 通信，因此扩展只能访问和修改链接或者请求中有限数量的属性。此外，由于 <code>Envoy</code> 协调整个交互，因此它可以隐藏或清除扩展中的敏感信息（例如，<code>HTTP</code> 头中的 “Authorization”和“Cookie”，或者客户端的 IP 地址）。</li>
<li><code>灵活性</code>：可以将超过 30 种编程语言编译为 <code>WebAssembly</code>，可以让各种技术背景的开发人员都可以用他们选择的语言来编写 <code>Envoy</code> 扩展，比如：C++，Go，Rust，Java，TypeScript 等。</li>
</ul>
<p>在 <a href="https://github.com/proxy-wasm/spec"><code>proxy-wasm spec</code></a> 有着 ABI 的定义，并且为很多语言提供了 <code>SDK</code>，那我们先来看看我们最适合的 <code>Rust SDK</code></p>
<h2 id="Rust-WebAssembly-In-Action"><a class="header-anchor" href="#Rust-WebAssembly-In-Action">¶</a>Rust WebAssembly In Action</h2>
<p>在 <a href="https://github.com/proxy-wasm/proxy-wasm-rust-sdk"><code>proxy-wasm-rust-sdk</code></a> 提供了操作 <code>Proxy SDK</code>。</p>
<h3 id="准备工作"><a class="header-anchor" href="#准备工作">¶</a>准备工作</h3>
<p>因为需要 <code>wasm</code> 的支持，先安装我们的目标架构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rustup target add wasm32-unknown-unknown</span><br></pre></td></tr></table></figure>
<p>我们首先创建一个我们的 <code>Rust</code> 项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo new --lib my-frist-wasm-filter</span><br></pre></td></tr></table></figure>
<p>因为我们最终生成的代码给 <code>envoy</code> 使用，因此还需要修改生成的 <code>lib</code> 类型，顺带加上我们的 <code>lib</code> 依赖</p>
<figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">crate-type</span> = [<span class="string">&quot;cdylib&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">proxy-wasm</span> = <span class="string">&quot;0.1.2&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="插件运行机制"><a class="header-anchor" href="#插件运行机制">¶</a>插件运行机制</h3>
<p><img src="https://s3.jpg.cm/2020/10/30/Nar7Q.png" alt="Nar7Q.png"></p>
<p>作为插件十之八九都是被 <code>宿主</code> 回调的，因此查阅 <code>abi</code> 有哪些函数，我们大致上就知道我们能做哪些工作了，<a href="https://github.com/proxy-wasm/spec/tree/master/abi-versions/vNEXT"><code>文档在此</code></a></p>
<h4 id="重要的函数"><a class="header-anchor" href="#重要的函数">¶</a>重要的函数</h4>
<h5 id="回调点"><a class="header-anchor" href="#回调点">¶</a>回调点</h5>
<ul>
<li>_start: 在模块的载入和初始化的时候会调用，一般用来设置一些状态量</li>
<li>proxy_on_context_create: 上下文创建的时候回调</li>
<li>proxy_on_done: 在context 处理完成</li>
<li>proxy_on_vm_start: 在启动 wasm 虚拟器的时候</li>
<li>proxy_on_new_connection: 建立新连接时</li>
<li>proxy_on_upstream_data: 收到数据时</li>
<li>proxy_on_http_request_headers: 收到 http headers 的时候</li>
</ul>
<h5 id="虚拟机环境实现的函数"><a class="header-anchor" href="#虚拟机环境实现的函数">¶</a>虚拟机环境实现的函数</h5>
<ul>
<li>proxy_log: 打印日志</li>
<li>proxy_done： 当前context 处理完成</li>
<li>proxy_get_shared_data: 获得 context 共享的对象</li>
</ul>
<h4 id="对象"><a class="header-anchor" href="#对象">¶</a>对象</h4>
<p><img src="https://s3.jpg.cm/2020/10/30/NTJh8.png" alt="NTJh8.png"></p>
<p>整个 <code>WASM</code> 中最重要的就是 <code>Context</code> 对象，这个封装了对于系统的操作，实现 <code>Proxy-Wasm</code> 插件需要进行如下 2 个步骤。</p>
<ul>
<li>定义 <code>Context</code></li>
<li>使用定义的 <code>Context</code> 重载默认实现</li>
</ul>
<p><code>Context</code> 对象，在系统中多种定义，比如 <code>RootContext</code> <code>HttpContext</code> <code>StreamContext</code> 对应不同处理流程中的</p>
<p>比如 <code>HttpContext</code></p>
<figure class="highlight rust"><figcaption><span>HttpContext</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">HttpContext</span>: Context &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_http_request_headers</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, _num_headers: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> Action &#123;</span><br><span class="line">        Action::Continue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_http_request_body</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, _body_size: <span class="type">usize</span>, _end_of_stream: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> Action &#123;</span><br><span class="line">        Action::Continue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_http_request_trailers</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, _num_trailers: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> Action &#123;</span><br><span class="line">        Action::Continue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_http_request_trailers</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;(<span class="type">String</span>, <span class="type">String</span>)&gt; &#123;</span><br><span class="line">        hostcalls::<span class="title function_ invoke__">get_map</span>(MapType::HttpRequestTrailers).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_http_request_trailers</span>(&amp;<span class="keyword">self</span>, trailers: <span class="type">Vec</span>&lt;(&amp;<span class="type">str</span>, &amp;<span class="type">str</span>)&gt;) &#123;</span><br><span class="line">        hostcalls::<span class="title function_ invoke__">set_map</span>(MapType::HttpRequestTrailers, trailers).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_log</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Example"><a class="header-anchor" href="#Example">¶</a>Example</h3>
<p>我们来实现我们第一个 <code>Hello World</code> 吧，就是在我们每一次接收到请求的时候，打印出一句 <code>Hello World</code></p>
<figure class="highlight rust"><figcaption><span>lib.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> log::info;</span><br><span class="line"><span class="keyword">use</span> proxy_wasm::traits::Context;</span><br><span class="line"><span class="keyword">use</span> proxy_wasm::traits::HttpContext;</span><br><span class="line"><span class="keyword">use</span> proxy_wasm::&#123;types::Action&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为内存管理委托给 Envoy，这里加上 no_mangle 禁止内存管理</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    proxy_wasm::<span class="title function_ invoke__">set_log_level</span>(proxy_wasm::types::LogLevel::Trace);</span><br><span class="line">    proxy_wasm::<span class="title function_ invoke__">set_http_context</span>(|_, _| <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> HttpContext&gt; &#123; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(HelloContext &#123;&#125;) &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HelloContext</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Context</span> <span class="keyword">for</span> <span class="title class_">HelloContext</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">HttpContext</span> <span class="keyword">for</span> <span class="title class_">HelloContext</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_http_request_headers</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, num_headers: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> Action &#123;</span><br><span class="line">        info!(<span class="string">&quot;Hello new Connection.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Action::Continue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单元测试的写法和普通系统无异，这里就不做展开。</p>
<h3 id="集成测试"><a class="header-anchor" href="#集成测试">¶</a>集成测试</h3>
<p>首先我们其编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo build --target wasm32-unknown-unknown --release</span><br></pre></td></tr></table></figure>
<p>我们现在需要一个  <code>Envoy</code> 来进行我们的测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull envoyproxy/envoy-dev:af418e1096a386000f936744a1a884b6ce87cee0</span><br></pre></td></tr></table></figure>
<p>创建一个 <code>bootstrap.yml</code> 然后启动</p>
<figure class="highlight yaml"><figcaption><span>envoy-bootstrap.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">listeners:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">listener_0</span></span><br><span class="line">    <span class="attr">address:</span></span><br><span class="line">      <span class="attr">socket_address:</span></span><br><span class="line">        <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        <span class="attr">port_value:</span> <span class="number">10000</span></span><br><span class="line">    <span class="attr">filter_chains:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.http_connection_manager</span></span><br><span class="line">          <span class="attr">typed_config:</span></span><br><span class="line">            <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager</span></span><br><span class="line">            <span class="attr">stat_prefix:</span> <span class="string">ingress_http</span></span><br><span class="line">            <span class="attr">http_filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.wasm</span></span><br><span class="line">              <span class="attr">typed_config:</span></span><br><span class="line">                <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm</span></span><br><span class="line">                <span class="attr">config:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">&quot;my_plugin&quot;</span></span><br><span class="line">                  <span class="attr">vm_config:</span></span><br><span class="line">                    <span class="attr">runtime:</span> <span class="string">&quot;envoy.wasm.runtime.v8&quot;</span></span><br><span class="line">                    <span class="attr">code:</span></span><br><span class="line">                      <span class="attr">local:</span></span><br><span class="line">                        <span class="attr">filename:</span> <span class="string">&quot;/my_frist_wasm_filter.wasm&quot;</span></span><br><span class="line">                    <span class="attr">allow_precompiled:</span> <span class="literal">true</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br><span class="line">            <span class="attr">route_config:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">local_route</span></span><br><span class="line">              <span class="attr">virtual_hosts:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">local_service</span></span><br><span class="line">                <span class="attr">domains:</span> [<span class="string">&quot;*&quot;</span>]</span><br><span class="line">                <span class="attr">routes:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">                    <span class="attr">prefix:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">                  <span class="attr">route:</span></span><br><span class="line">                    <span class="attr">host_rewrite_literal:</span> <span class="string">www.envoyproxy.io</span></span><br><span class="line">                    <span class="attr">cluster:</span> <span class="string">service_envoyproxy_io</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">clusters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">service_envoyproxy_io</span></span><br><span class="line">    <span class="attr">connect_timeout:</span> <span class="string">30s</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">LOGICAL_DNS</span></span><br><span class="line">    <span class="comment"># Comment out the following line to test on v6 networks</span></span><br><span class="line">    <span class="attr">dns_lookup_family:</span> <span class="string">V4_ONLY</span></span><br><span class="line">    <span class="attr">load_assignment:</span></span><br><span class="line">      <span class="attr">cluster_name:</span> <span class="string">service_envoyproxy_io</span></span><br><span class="line">      <span class="attr">endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">            <span class="attr">address:</span></span><br><span class="line">              <span class="attr">socket_address:</span></span><br><span class="line">                <span class="attr">address:</span> <span class="string">www.envoyproxy.io</span></span><br><span class="line">                <span class="attr">port_value:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">transport_socket:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">envoy.transport_sockets.tls</span></span><br><span class="line">      <span class="attr">typed_config:</span></span><br><span class="line">        <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext</span></span><br><span class="line">        <span class="attr">sni:</span> <span class="string">www.envoyproxy.io</span></span><br><span class="line"></span><br><span class="line"><span class="attr">admin:</span></span><br><span class="line">  <span class="attr">access_log_path:</span> <span class="string">/dev/null</span></span><br><span class="line">  <span class="attr">address:</span></span><br><span class="line">    <span class="attr">socket_address:</span></span><br><span class="line">      <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">      <span class="attr">port_value:</span> <span class="number">9901</span></span><br></pre></td></tr></table></figure>
<p>然后就是最激动人心的运行时刻。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run --<span class="built_in">rm</span> -it -v $(<span class="built_in">pwd</span>)/envoy-custom.yaml:/envoy-custom.yaml -v $(<span class="built_in">pwd</span>)/target/wasm32-unknown-unknown/release/my_frist_wasm_filter.wasm:/my_frist_wasm_filter.wasm -p 9901:9901 -p 10000:10000 envoyproxy/envoy-dev -c /envoy-custom.yaml</span><br><span class="line"></span><br><span class="line">$ curl localhost:10000</span><br><span class="line">[2020-10-30 09:38:40.116][26][info][wasm] [<span class="built_in">source</span>/extensions/common/wasm/context.cc:1154] wasm <span class="built_in">log</span>: Hello new Connection.</span><br></pre></td></tr></table></figure>
<p>我们看到了我们打印的</p>
<blockquote>
<p>…<br>
[2020-10-30 09:38:40.116][26][info][wasm] [source/extensions/common/wasm/context.cc:1154] wasm log: Hello new Connection.<br>
…</p>
</blockquote>
<p>代表着我们的插件运行成功了。</p>
<h2 id="周边生态"><a class="header-anchor" href="#周边生态">¶</a>周边生态</h2>
<h3 id="webassembly-hub"><a class="header-anchor" href="#webassembly-hub">¶</a>webassembly hub</h3>
<p>(<a href="https://webassemblyhub.io/">https://webassemblyhub.io/</a>): 因为很多插件可以复用，因此<code>istio</code> 联合 <code>solo.io</code> 社区完成了 <code>webassemblyhub</code> 的建设<br>
<img src="https://s3.jpg.cm/2020/10/30/NaSyE.png" alt="NaSyE.png"></p>
<p>除此之外还提供了 <code>wasme</code> 这个 <code>cli</code> 工具可以帮助我们简单的开发系统。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://rustwasm.github.io/docs/book/">rustwasm book</a></li>
<li><a href="https://s3.us.cloud-object-storage.appdomain.cloud/developer/series/os-academy-istio-2020/nl/zh/static/4-WASM.pdf">Wasm for isito</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rust</category>
        <category>envoy</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>envoy</tag>
      </tags>
  </entry>
  <entry>
    <title>Envoy Filters</title>
    <url>/2022/04/27/networking/envoy/filters/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2022/202204271957129.png" alt=""></p>
<p>今天我们来聊聊，Envoy 中最重要的抽象 <code>Filter</code></p>
<span id="more"></span>
<h2 id="FilterChainManager"><a class="header-anchor" href="#FilterChainManager">¶</a>FilterChainManager</h2>
<p>书接上文 <a href="/2020/04/21/networking/around-envoy/">Around Envoy</a> 我们已知 <code>Envoy</code> 是一个基于 <code>FilterChain</code> 的系统。</p>
<p><code>Envoy</code> 做了简单的抽象，把 <code>Filter</code> 相关的逻辑都至于 <a href="https://github.com/envoyproxy/envoy/blob/release%2Fv1.21/include/envoy/network/filter.h#L13">filter.h</a> 中，在这个简单的抽象中，我们可以发现</p>
<figure class="highlight cpp"><figcaption><span>Filter</span><a href="https://github.com/envoyproxy/envoy/blob/main/envoy/network/filter.h#L209">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Filter</span> : <span class="keyword">public</span> WriteFilter, <span class="keyword">public</span> ReadFilter &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Filter</code> 这层抽象就是由 <code>WriteFilter</code> 和 <code>ReadFilter</code> 组合而来</p>
<figure class="highlight cpp"><figcaption><span>ReadFilter</span><a href="https://github.com/envoyproxy/envoy/blob/release%2Fv1.21/envoy/network/filter.h#L168-L201">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadFilter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ReadFilter</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 流式处理数据读取</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> FilterStatus <span class="title">onData</span><span class="params">(Buffer::Instance&amp; data, <span class="type">bool</span> end_stream)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 建立链接时触发一次</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> FilterStatus <span class="title">onNewConnection</span><span class="params">()</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 Callback，这个主要是给 Filter manager 来处理</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">initializeReadFilterCallbacks</span><span class="params">(ReadFilterCallbacks&amp; callbacks)</span> PURE</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WriteFilter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">WriteFilter</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 流式处理数据写入</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> FilterStatus <span class="title">onWrite</span><span class="params">(Buffer::Instance&amp; data, <span class="type">bool</span> end_stream)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 Callback</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">initializeWriteFilterCallbacks</span><span class="params">(WriteFilterCallbacks&amp;)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>网络编程</category>
        <category>API</category>
        <category>Gateway</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>Gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>Isito iptables &amp; CNI</title>
    <url>/2022/04/16/networking/istio/istio-iptables/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/202204161647430.png" alt=""></p>
<p>众所周知 <code>istio</code> 通过 <code>iptables</code> 拦截流量，对于这个 <code>iptables</code> 的规则，我们仔细的分析下。</p>
<span id="more"></span>
<h2 id="IPTABLES-规则"><a class="header-anchor" href="#IPTABLES-规则">¶</a>IPTABLES 规则</h2>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/202204162022284.png" alt=""></p>
<p>我们找到任意的一个节点先看看我的配置项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables --table nat --list</span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ISTIO_INBOUND  tcp  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ISTIO_OUTPUT  tcp  --  anywhere             anywhere            </span><br><span class="line">RETURN     udp  --  anywhere             anywhere             udp dpt:domain owner UID match 1337</span><br><span class="line">RETURN     udp  --  anywhere             anywhere             udp dpt:domain owner GID match 1337</span><br><span class="line">REDIRECT   udp  --  anywhere             kube-dns.kube-system.svc.cluster.local  udp dpt:domain redir ports 15053</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain ISTIO_INBOUND (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">RETURN     tcp  --  anywhere             anywhere             tcp dpt:15008</span><br><span class="line">RETURN     tcp  --  anywhere             anywhere             tcp dpt:ssh</span><br><span class="line">RETURN     tcp  --  anywhere             anywhere             tcp dpt:15090</span><br><span class="line">RETURN     tcp  --  anywhere             anywhere             tcp dpt:15021</span><br><span class="line">RETURN     tcp  --  anywhere             anywhere             tcp dpt:15020</span><br><span class="line">ISTIO_IN_REDIRECT  tcp  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain ISTIO_IN_REDIRECT (3 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">REDIRECT   tcp  --  anywhere             anywhere             redir ports 15006</span><br><span class="line"></span><br><span class="line">Chain ISTIO_OUTPUT (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">RETURN     all  --  127.0.0.6            anywhere            </span><br><span class="line">ISTIO_IN_REDIRECT  tcp  --  anywhere            !localhost            tcp dpt:!domain owner UID match 1337</span><br><span class="line">RETURN     tcp  --  anywhere             anywhere             tcp dpt:!domain ! owner UID match 1337</span><br><span class="line">RETURN     all  --  anywhere             anywhere             owner UID match 1337</span><br><span class="line">ISTIO_IN_REDIRECT  all  --  anywhere            !localhost            owner GID match 1337</span><br><span class="line">RETURN     tcp  --  anywhere             anywhere             tcp dpt:!domain ! owner GID match 1337</span><br><span class="line">RETURN     all  --  anywhere             anywhere             owner GID match 1337</span><br><span class="line">REDIRECT   tcp  --  anywhere             kube-dns.kube-system.svc.cluster.local  tcp dpt:domain redir ports 15053</span><br><span class="line">RETURN     all  --  anywhere             localhost           </span><br><span class="line">ISTIO_REDIRECT  all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain ISTIO_REDIRECT (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">REDIRECT   tcp  --  anywhere             anywhere             redir ports 15001</span><br></pre></td></tr></table></figure>
<h3 id="入口流量顺序"><a class="header-anchor" href="#入口流量顺序">¶</a>入口流量顺序</h3>
<ol>
<li>PREROUTING: 任意的 TCP 协议都会被 转发到 ISTIO_INBOUND，也就是本机器的所有的外部流量都会被拦击</li>
<li>ISTIO_INBOUND: 15008/22/15090/15021/15020 都会直接被放行
<ol>
<li>这里可以参考 <a href="https://istio.io/latest/docs/ops/deployment/requirements/">Ports used by Istio</a></li>
<li>其他请求会被 转发 到 ISTIO_IN_REDIRECT</li>
</ol>
</li>
<li>ISTIO_IN_REDIRECT: 也就是 Envoy Inbound 的监听器</li>
</ol>
<h3 id="出口流量顺序"><a class="header-anchor" href="#出口流量顺序">¶</a>出口流量顺序</h3>
<ol>
<li>OUTPUT: 任意 TCP 都转发至 ISTIO_OUTPUT，除了以下几个特殊的Case
<ol>
<li>UID 或者 GID 是 1337 (uid=1337(istio-proxy) gid=1337(istio-proxy) groups=1337(istio-proxy) 直接放行</li>
<li>KUBE DNS 请求重定向到 15053（DNS Agent）</li>
</ol>
</li>
<li>ISTIO_OUTPUT:</li>
</ol>
<p>略微复杂点，主要几个特殊的情况</p>
<ol>
<li>127.0.0.6 直接放行，这里是一个特殊处理 inbound passthrough cluster 就是这个 IP</li>
<li><a href="https://github.com/istio/istio/blob/016bc46f4a5e0ef3fa135b3c5380ab7765467c1a/tools/istio-iptables/pkg/capture/run.go#L502-L502">当服务通过 VIP 访问本身，在本机器的 ENVOY 完成所有逻辑，appN =&gt; Envoy (client) =&gt; Envoy (server) =&gt; appN.</a></li>
<li>重定向 53 的 DNS 请求</li>
<li>忽略访问 Localhost 的请求</li>
</ol>
<h2 id="istio-agnet-iptables"><a class="header-anchor" href="#istio-agnet-iptables">¶</a>istio agnet iptables</h2>
<p>众所周知，istio agent 来帮我们配置 iptables，代码主要在 <a href="https://github.com/istio/istio/blob/016bc46f4a5e0ef3fa135b3c5380ab7765467c1a/tools/istio-iptables/pkg/cmd/root.go#L98-L98">root.go</a> 中</p>
<p>代码主要帮助完成一些自动化的配置，在此不做分析。</p>
<h2 id="CNI"><a class="header-anchor" href="#CNI">¶</a>CNI</h2>
<p><code>Istio</code> 同样提供的 <code>CNI</code> 插件，但是这里的 <code>CNI</code> 主要的工作就是帮助系统完成 <code>Iptables</code> 的初始化</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/202204162117895.png" alt=""></p>
<p>主要消除了 <code>Sidecar</code> 部署到 <code>Istio</code> 中的 <code>NET_ADMIN</code> 和 <code>NET_RAW</code> 权限的需求。</p>
<p><code>CNI</code> 作为一个标准的 <code>CS</code> 模型，提供了一套标准的代码模板，<code>Istio</code> 基于这个模式，实现的逻辑在 <a href="https://github.com/istio/istio/blob/016bc46f4a5e0ef3fa135b3c5380ab7765467c1a/cni/pkg/plugin#L59-L59">plugin</a> 中</p>
<figure class="highlight go"><figcaption><span>CmdAdd github</span><a href="https://github.com/istio/istio/blob/016bc46f4a5e0ef3fa135b3c5380ab7765467c1a/cni/pkg/plugin/plugin.go#L264-L279">link</a></figcaption><table><tr><td class="code"><pre><span class="line">log.Debugf(<span class="string">&quot;Setting up redirect for pod %v/%v&quot;</span>, podNamespace, podName)</span><br><span class="line"><span class="keyword">if</span> redirect, redirErr := NewRedirect(pi); redirErr != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Errorf(<span class="string">&quot;Pod %s/%s redirect failed due to bad params: %v&quot;</span>, podNamespace, podName, redirErr)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Get the constructor for the configured type of InterceptRuleMgr</span></span><br><span class="line">    interceptMgrCtor := GetInterceptRuleMgrCtor(interceptRuleMgrType)</span><br><span class="line">    <span class="keyword">if</span> interceptMgrCtor == <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Errorf(<span class="string">&quot;Pod redirect failed due to unavailable InterceptRuleMgr of type %s&quot;</span>,</span><br><span class="line">            interceptRuleMgrType)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rulesMgr := interceptMgrCtor()</span><br><span class="line">        <span class="keyword">if</span> err := rulesMgr.Program(podName, args.Netns, redirect); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要逻辑也是就在处理 <code>NetworkNamespace</code> 上，而这里直接复用了 <code>Agent Iptables</code> 的逻辑，所以任何区别</p>
<figure class="highlight go"><figcaption><span>Program github</span><a href="https://github.com/istio/istio/blob/016bc46f4a5e0ef3fa135b3c5380ab7765467c1a/cni/pkg/plugin/iptables.go#L37-L64">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Program defines a method which programs iptables based on the parameters</span></span><br><span class="line"><span class="comment">// provided in Redirect.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ipt *iptables)</span></span> Program(podName, netns <span class="type">string</span>, rdrct *Redirect) <span class="type">error</span> &#123;</span><br><span class="line">	viper.Set(constants.CNIMode, <span class="literal">true</span>)</span><br><span class="line">	viper.Set(constants.NetworkNamespace, netns)</span><br><span class="line">	viper.Set(constants.EnvoyPort, rdrct.targetPort)</span><br><span class="line">	viper.Set(constants.ProxyUID, rdrct.noRedirectUID)</span><br><span class="line">	viper.Set(constants.InboundInterceptionMode, rdrct.redirectMode)</span><br><span class="line">	viper.Set(constants.ServiceCidr, rdrct.includeIPCidrs)</span><br><span class="line">	viper.Set(constants.InboundPorts, rdrct.includePorts)</span><br><span class="line">	viper.Set(constants.LocalExcludePorts, rdrct.excludeInboundPorts)</span><br><span class="line">	viper.Set(constants.ExcludeInterfaces, rdrct.excludeInterfaces)</span><br><span class="line">	viper.Set(constants.LocalOutboundPortsExclude, rdrct.excludeOutboundPorts)</span><br><span class="line">	viper.Set(constants.ServiceExcludeCidr, rdrct.excludeIPCidrs)</span><br><span class="line">	viper.Set(constants.KubeVirtInterfaces, rdrct.kubevirtInterfaces)</span><br><span class="line">	drf := dryRunFilePath.Get()</span><br><span class="line">	viper.Set(constants.DryRun, drf != <span class="string">&quot;&quot;</span>)</span><br><span class="line">	viper.Set(constants.OutputPath, drf)</span><br><span class="line">	viper.Set(constants.RedirectDNS, rdrct.dnsRedirect)</span><br><span class="line">	viper.Set(constants.CaptureAllDNS, rdrct.dnsRedirect)</span><br><span class="line">	iptablesCmd := cmd.GetCommand()</span><br><span class="line">	log.Infof(<span class="string">&quot;============= Start iptables configuration for %v =============&quot;</span>, podName)</span><br><span class="line">	<span class="keyword">defer</span> log.Infof(<span class="string">&quot;============= End iptables configuration for %v =============&quot;</span>, podName)</span><br><span class="line">	<span class="keyword">if</span> err := iptablesCmd.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://iximiuz.com/en/posts/laymans-iptables-101/">Illustrated introduction to Linux iptables</a></li>
<li><a href="https://www.booleanworld.com/depth-guide-iptables-linux-firewall/">An In-Depth Guide to iptables, the Linux Firewall</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>isito</category>
      </categories>
      <tags>
        <tag>isito</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Run In Istio</title>
    <url>/2020/12/20/networking/istio/spring-cloud-with-istio/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201220144511.png" alt=""></p>
<p><code>istio</code> 迈入 <code>1.6</code> 之后趋于稳定，大家都慢慢的开始尝试起来，摆在大家面前会有这么一个问题，原来的旧系统如何兼容 <code>istio</code>？</p>
<span id="more"></span>
<h2 id="How-Spring-Cloud-Works"><a class="header-anchor" href="#How-Spring-Cloud-Works">¶</a>How Spring Cloud Works</h2>
<p><code>Spring Cloud</code> 体系是如何工作的呢？</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201220144847.png" alt=""></p>
<p><code>Spring Cloud</code> 体系中，每一个服务实例会将自己的 <code>IP</code> 地址上报至 <code>Service Registry</code> 中，这一步是通过 <code>Registry Client</code> 实现，当其需要访问其他的实例的时候，也会去 <code>Service Registry</code> 中获取其他实例的 <code>IP</code> 地址</p>
<p><code>Registry Client</code> 和  <code>Service Registry </code>都是抽象的构成，在实现的过程中</p>
<ul>
<li><code>Service Registry</code> 常见为 <code>Eureka</code> <code>Consul</code> <code>ZooKeepr</code></li>
<li><code>Registry Client</code> 则对应这三者(<code>eurke-client</code> / <code>consul-client</code> / <code>zookeerer-client</code>)，这三者会有一个共同的抽象: <code>DiscoveryClient</code></li>
</ul>
<h3 id="通用概念"><a class="header-anchor" href="#通用概念">¶</a>通用概念</h3>
<ul>
<li><code>实例</code>: 每一个 <code>Registry Client</code> 所代表的就是一个服务实例，[ PS:通常一个Java程序就是一个实例]</li>
<li><code>服务</code>: 多个实例组合成一个服务，服务是 <code>Spring Cloud</code> 负载均衡的对象</li>
</ul>
<p>对于 <code>Eureka</code> 所包含的 <code>Zone</code> 概念在其他的 <code>Client</code> 中并没有相对应的，因此对于 <code>Spring Cloud</code> 通用的抽象是比较的简单的。</p>
<h3 id="基于-Eureka-的流程分析"><a class="header-anchor" href="#基于-Eureka-的流程分析">¶</a>基于 Eureka 的流程分析</h3>
<h4 id="注册流程"><a class="header-anchor" href="#注册流程">¶</a>注册流程</h4>
<p>不同的注册中心的区别主要在注册中心自身逻辑上[AP/CP]，对于其他部分的影响不大</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201220145809.png" alt=""></p>
<p>实例所对应的服务是由 元数据 提供，IP 地址是由系统检测生成 (但是可以<code>手动覆盖</code>)</p>
<h4 id="调用过程"><a class="header-anchor" href="#调用过程">¶</a>调用过程</h4>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201220145846.png" alt=""></p>
<p>而调用过程，<code>Biz</code> 一般会通过 <code>RestfulTemaplate</code>/<code>Feign</code> 来访问远程地址，通过一些中间件的集成。将 <code>服务名</code> 翻译成 <code>IP</code> 地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.restTemplate.exchange(</span><br><span class="line">    <span class="string">&quot;http://bookmark-service/&#123;userId&#125;/bookmarks&quot;</span>,</span><br><span class="line">    HttpMethod.GET,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;Bookmark&gt;&gt;() &#123;</span><br><span class="line">    &#125;,(Object) <span class="string">&quot;mstine&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>此例中 <code>bookmark-service</code> -&gt; <code>192.168.xxx.yyy</code>  在 <code>k8s</code> 中，此 <code>IP</code> 约等同于 <code>POD IP</code></p>
<h2 id="How-Istio-Works"><a class="header-anchor" href="#How-Istio-Works">¶</a>How Istio Works</h2>
<p>那么相对应的 <code>istio</code> 体系又是如何工作的呢？</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201220150134.png" alt=""></p>
<p>对于 <code>istio</code> 来说，<code>poliot</code> 将监控所有的关心的数据，在客户端进行访问远程地址的时候，通过的是 <code>ClusterIP/DNS</code> 进行访问，<code>istio</code> 通过 <code>tcp</code> 协议中的 <code>dest ip</code> 或者是 <code>http</code> 协议中的 <code>host</code> 进行判断需要访问某个具体的服务，在 <code>Envoy</code> 进行负载均衡。</p>
<p>在 <a href="/2020/10/28/networking/istio/isito-pilot/">Isito の Pilot 组件</a> 有深入的解读，就不作展开。</p>
<p>如果我们直接访问某个不受 <code>istio</code> 托管的服务地址 (比如 <code>pod ip</code>/<code>未知的service ip</code>) ，istio 会认为这次请求是 <code>PassthroughCluster</code> 无法利用任何 <code>istio</code> 的特性。</p>
<h2 id="那么问题呢？"><a class="header-anchor" href="#那么问题呢？">¶</a>那么问题呢？</h2>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201220151800.png" alt=""></p>
<p>我们希望我们的系统能够跑在 <code>istio</code> 享受到 <code>istio</code> 所带来的诸多特性，而非是通过 <code>sidecar</code> 绕了一圈而什么都没有做。</p>
<p>在 <code>Spring Cloud</code> 体系中，<code>Biz</code> 通过 <code>IP</code> 访问其他服务，<code>istio</code> 并不能区分 <code>192.168.2.3</code> 是哪个服务的地址，会选择直接转发，就谈不上任何管控维度。</p>
<h3 id="WHY-TLDR"><a class="header-anchor" href="#WHY-TLDR">¶</a>WHY [TLDR]</h3>
<p>这就要了解到 <code>Istio</code> 的工作原理，<code>istio</code> 将配置转为 <code>Envoy</code> 的配置<br>
<img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201220152108.png" alt=""></p>
<table>
<thead>
<tr>
<th></th>
<th>xds</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Listener</td>
<td>LDS</td>
<td>监听一个端口，可以配置多条，监听多个端口</td>
</tr>
<tr>
<td>Routes</td>
<td>RDS</td>
<td>一个 cluster 是具有完全相同行为的多个 endpoint 它们组成一个Cluster，从 cluster 到 endpoint 的过程称为负载均衡</td>
</tr>
<tr>
<td>Clusters</td>
<td>CDS</td>
<td>有时候多个 cluster 具有类似的功能，但是是不同的版本号， 可以通过 route 规则，选择将请求路由到某一个版本号</td>
</tr>
<tr>
<td>Endpoints</td>
<td>EDS</td>
<td>目标的 ip 地址和端口，这个是 proxy 最终将请求转发到的地方</td>
</tr>
</tbody>
</table>
<p>举个例子</p>
<p>比如远端有一个 <code>helloworld.sample.svc.cluster.local</code> ，端口 <code>5000</code> 提供 <code>HTTP</code> 服务</p>
<ul>
<li>Envoy 的 Listener 配置中会监听 0.0.0.0:5000 的数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ istioctl proxy-config listeners sleep-854565cb79-9t29h.sample --context cluster2</span><br><span class="line">address        port            <span class="built_in">type</span>                                  route</span><br><span class="line">0.0.0.0       5000  Trans: raw_buffer; App: HTTP                  Route: 5000</span><br></pre></td></tr></table></figure>
<ul>
<li>Envoy 的 Route 配置从上面就知道指向名为 <code>5000</code> 的 <code>Route</code> 配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ istioctl proxy-config routes sleep-854565cb79-9t29h.sample --context cluster2</span><br><span class="line">NAME           DOMAINS         MATCH                  VIRTUAL SERVICE</span><br><span class="line">5000             helloworld      /*</span><br></pre></td></tr></table></figure>
<p>根据 <code>route</code> 规则，我们知道这个服务的出口 <code>cluster</code> 是 <code>outbound|5000||helloworld.sample.svc.cluster.local</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;route&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cluster&quot;</span><span class="punctuation">:</span> <span class="string">&quot;outbound|5000||helloworld.sample.svc.cluster.local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0s&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;retryPolicy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;retryOn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;numRetries&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;retryHostPredicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;envoy.retry_host_predicates.previous_hosts&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>outbound|5000||helloworld.sample.svc.cluster.local</code> 的 <code>Cluster</code> 配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ istioctl proxy-config clusters sleep-854565cb79-9t29h.sample --fqdn helloworld.sample.svc.cluster.local --context cluster2</span><br><span class="line">SERVICE FQDN                            PORT     SUBSET     DIRECTION     TYPE     DESTINATION RULE</span><br><span class="line">helloworld.sample.svc.cluster.local     5000     -          outbound      EDS</span><br><span class="line"></span><br><span class="line">$ istioctl proxy-config endpoints sleep-854565cb79-9t29h.sample  --context cluster2 --cluster  <span class="string">&quot;outbound|5000||helloworld.sample.svc.cluster.local&quot;</span></span><br><span class="line">ENDPOINT             STATUS      OUTLIER CHECK     CLUSTER</span><br><span class="line">10.244.1.9:5000      HEALTHY     OK                outbound|5000||helloworld.sample.svc.cluster.local</span><br><span class="line">10.244.2.15:5000     HEALTHY     OK                outbound|5000||helloworld.sample.svc.cluster.local</span><br><span class="line">10.244.2.16:5000     HEALTHY     OK                outbound|5000||helloworld.sample.svc.cluster.local</span><br></pre></td></tr></table></figure>
<p>我们可以发现，其实最终的目标地址也就是我们的 <code>K8S</code> 的 <code>POD</code> 地址，而整个拦截的链路最核心的是在 <code>Route</code> 的匹配定义中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;domains&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;helloworld.sample.svc.cluster.local&quot;</span>,</span><br><span class="line">    <span class="string">&quot;helloworld.sample.svc.cluster.local:5000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;helloworld&quot;</span>,</span><br><span class="line">    <span class="string">&quot;helloworld:5000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;helloworld.sample.svc.cluster&quot;</span>,</span><br><span class="line">    <span class="string">&quot;helloworld.sample.svc.cluster:5000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;helloworld.sample.svc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;helloworld.sample.svc:5000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;helloworld.sample&quot;</span>,</span><br><span class="line">    <span class="string">&quot;helloworld.sample:5000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;10.100.41.75&quot;</span>, <span class="comment"># Cluster IP</span></span><br><span class="line">    <span class="string">&quot;10.100.41.75:5000&quot;</span> <span class="comment"># Cluster IP</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>可见，<code>istio</code> 需要目标地址访问的是 <code>dns</code> 中的域名或者是 <code>ClusterIP</code> 才会进行拦截，</p>
<h2 id="解决之道"><a class="header-anchor" href="#解决之道">¶</a>解决之道</h2>
<p>显然我们有好几个办法来做这个兼容设计，大致上的思路可以分为</p>
<ul>
<li>让 <code>istio</code> 匹配 <code>pod ip</code></li>
<li>让 <code>spring cloud</code> 访问 <code>cluster ip</code></li>
</ul>
<h3 id="Spring-Cloud-访问-Cluster-IP"><a class="header-anchor" href="#Spring-Cloud-访问-Cluster-IP">¶</a>Spring Cloud 访问 Cluster IP</h3>
<h4 id="By-Eureka-Server"><a class="header-anchor" href="#By-Eureka-Server">¶</a>By Eureka Server</h4>
<p>从 <code>eureka</code> 解决这个问题，想办法让 <code>Eureka Server</code> 返回给客户端的是 <code>Service Address</code></p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201220153800.png" alt=""></p>
<ul>
<li><code>Fake Eureka Server</code> 对于注册和心跳保持不处理直接返回 <code>200</code></li>
<li><code>Fake Eureka Server</code> 对于 <code>Fetch</code> 请求，返回服务名对应的 <code>ClusterIP</code></li>
</ul>
<p>我们为每个服务服务创建一个 <code>Cluster IP</code> 对象即可。</p>
<h4 id="By-Eureka-Client"><a class="header-anchor" href="#By-Eureka-Client">¶</a>By Eureka Client</h4>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201220154352.png" alt=""></p>
<ul>
<li><code>Eureka Client</code> 在返回给 <code>Ribbin</code> 之前将 <code>IP</code> 翻译成 <code>Srv IP</code></li>
</ul>
<blockquote>
<p>Ribbon: Spring Cloud 客户端负载均衡组件</p>
</blockquote>
<h3 id="Istio-匹配-Pod-IP"><a class="header-anchor" href="#Istio-匹配-Pod-IP">¶</a>Istio 匹配 Pod IP</h3>
<h4 id="Add-Http-Header"><a class="header-anchor" href="#Add-Http-Header">¶</a>Add Http Header</h4>
<p>对于 <code>istio</code> 来说(<code>Envoy</code>)， <code>Http filter</code> 是 一个接着一个运行的。</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201220154655.png" alt=""></p>
<p><code>Routing</code> 的 <code>HTTP Filter</code> 优先级较低，如果我们能在 <code>Routing</code> 之前增加一个 <code>Filter</code> 然后将 <code>IP</code> 转化为 <code>Host</code> 然后加入 <code>HttpHeaders</code> 中，应该就可以满足需求。<a href="https://github.com/envoyproxy/envoy-filter-example/blob/master/http-filter-example/http_filter.cc">https://github.com/envoyproxy/envoy-filter-example/blob/master/http-filter-example/http_filter.cc</a></p>
<figure class="highlight rust"><figcaption><span>example</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> log::info;</span><br><span class="line"><span class="keyword">use</span> proxy_wasm::traits::Context;</span><br><span class="line"><span class="keyword">use</span> proxy_wasm::traits::HttpContext;</span><br><span class="line"><span class="keyword">use</span> proxy_wasm::&#123;types::Action&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    proxy_wasm::<span class="title function_ invoke__">set_log_level</span>(proxy_wasm::types::LogLevel::Trace);</span><br><span class="line">    proxy_wasm::<span class="title function_ invoke__">set_http_context</span>(|_, _| <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> HttpContext&gt; &#123; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(HelloContext &#123;&#125;) &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HelloContext</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Context</span> <span class="keyword">for</span> <span class="title class_">HelloContext</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">HttpContext</span> <span class="keyword">for</span> <span class="title class_">HelloContext</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_http_request_headers</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, num_headers: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> Action &#123;</span><br><span class="line">        info!(<span class="string">&quot;Set Host Header As reviews.default.svc.cluster.local.&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">set_http_request_header</span>(<span class="string">&quot;Host&quot;</span>, <span class="title function_ invoke__">Some</span>(<span class="string">&quot;reviews.default.svc.cluster.local&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call server pod ip -&gt; cluster ip</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">clear_http_route_cache</span>();  <span class="comment">//记得Cache Route Cache ！！！！！！！ FXXXXXXXXK</span></span><br><span class="line">        <span class="keyword">return</span> Action::Continue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Custom-Registry"><a class="header-anchor" href="#Custom-Registry">¶</a>Custom Registry</h4>
<p>虽然官网并没有写这部分，其实我们类似于 <code>MCP</code> 的实现，将 <code>Eureka</code> 的数据作为其中一个 <code>Registery</code> 实现一遍，不过这个工程过于浩大，不做展开。</p>
<h3 id="Best-Way"><a class="header-anchor" href="#Best-Way">¶</a>Best Way</h3>
<p>重构代码，将 <code>Spring Cloud</code> 的部分除去，保留 <code>Spring Boot</code> 部分即可，不仅仅减少复杂度而且系统会运行的更快。</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>优势</th>
<th>劣势</th>
<th>研发复杂度</th>
<th>性能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fake Eureka</td>
<td>架构简单,易于排查</td>
<td>用户可见，增加了非透明性</td>
<td>多版本的适配性</td>
<td>与原生SpringCloud相比没有任何性能的损耗</td>
</tr>
<tr>
<td>Isito WASM</td>
<td>用户无感知</td>
<td>增大的系统复杂度 &amp; 降低了可调试性</td>
<td>语言切换等</td>
<td>在转发逻辑中将无法利用原生的缓冲的机制，会带来一些转发性能的损耗(因是in Memory逻辑，应该是很低的值)</td>
</tr>
<tr>
<td>公共</td>
<td></td>
<td>一切基于 IP规则的策略都会失效(熔断 &amp; 负载均衡)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://piotrminkowski.com/2020/06/01/service-mesh-on-kubernetes-with-istio-and-spring-boot/">Service mesh on Kubernetes with Istio and Spring Boot</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>spring</category>
        <category>istio</category>
      </categories>
      <tags>
        <tag>istio</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中流量劫持的几个常见姿势</title>
    <url>/2023/05/25/networking/linux/hijack-in-linux/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2023/202305261450813.png" alt=""></p>
<p>在 istio 中我们见识过流量劫持的厉害，我们今天就盘算下相关的技术。</p>
<span id="more"></span>
<h2 id="Use-Iptables"><a class="header-anchor" href="#Use-Iptables">¶</a>Use Iptables</h2>
<p>使用 Iptables 是最常见的劫持方式，无论是常规的 <code>KubeProxy</code> 还是 <code>istio</code> 都使用了这种模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -s 192.168.0.10 -p tcp --dport 80 -j REDIRECT --to-port 8080</span><br></pre></td></tr></table></figure>
<p>这样我们就可以将本身发往 192.168.0.10:80 的请求转到到 192.168.0.10:8080<br>
这种技术一般被称之为 <code>DNAT</code></p>
<h2 id="Use-epbf"><a class="header-anchor" href="#Use-epbf">¶</a>Use epbf</h2>
<p>使用比较新的 Linux 版本可以 sockmap 完成在 <strong>本机</strong> 上的更高级的转发方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> bpf_map_def <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;maps&quot;</span>)</span> sock_map = &#123;</span><br><span class="line">    .type = BPF_MAP_TYPE_SOCKMAP,</span><br><span class="line">    .max_entries = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;sockops&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_tcp</span><span class="params">(<span class="keyword">struct</span> __sk_buff *skb)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> =</span> bpf_hdr_pointer(skb);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span> =</span> (<span class="keyword">struct</span> iphdr *)(eth + <span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">tcp</span> =</span> (<span class="keyword">struct</span> tcphdr *)(ip + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the packet is TCP</span></span><br><span class="line">    <span class="keyword">if</span> (ip-&gt;protocol != IPPROTO_TCP)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redirect packets to another socket using the sock_map</span></span><br><span class="line">    bpf_sock_ops_redirect(skb, &amp;sock_map, BPF_F_INGRESS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Use-Tun-Tap"><a class="header-anchor" href="#Use-Tun-Tap">¶</a>Use Tun/Tap</h2>
<p>相对复杂点</p>
<ol>
<li>常见一个 tun 虚拟网卡，分配地址，并且激活</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip tuntap add mode tun dev tun0</span><br><span class="line"></span><br><span class="line">ip addr add 10.0.0.1/24 dev tun0</span><br><span class="line"></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev tun0 up</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>配置路由</li>
</ol>
<p>这里比如我们将 <code>192.168.0.0/24</code> 都转到这里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip route add 192.168.0.0/24 dev tun0</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>编写代码读取</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tun_fd = open(<span class="string">&quot;/dev/net/tun&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (tun_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Failed to open TUN device&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line">ifr.ifr_flags = IFF_TUN;  <span class="comment">// Set as TUN device</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ioctl(tun_fd, TUNSETIFF, (<span class="type">void</span> *)&amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Failed to set TUN device options&quot;</span>);</span><br><span class="line">    close(tun_fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line"><span class="type">ssize_t</span> num_bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    num_bytes = read(tun_fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (num_bytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error while reading from TUN device&quot;</span>);</span><br><span class="line">        close(tun_fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process the received data</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个完整的例子 <a href="https://github.com/sjlongland/tuntap-packet-dumper">tuntap-packet-dumper</a></p>
<p>当我们尝试 <code>Ping</code> 的时候，就可以从 Tun0 的另外一头获得数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Flags: 0x0000  Protocol: 0x86dd</span><br><span class="line">To:    60:00:00:00:00:08</span><br><span class="line">From:  3a:ff:fe:80:00:00</span><br><span class="line">IP Version 0  Priority: 0</span><br><span class="line">Flow Label:  0x001077</span><br><span class="line">Payload length: 26488</span><br><span class="line">Next header: 0xd2</span><br><span class="line">Hop <span class="built_in">limit</span>:   68</span><br><span class="line">Source IP: 9c62:ff02::</span><br><span class="line">Dest IP:   2:8500:96a0::</span><br><span class="line">  48:  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15</span><br><span class="line">   0: 00 00 10 77 67 78 d2 44 9c 62 ff 02 00 00 00 00</span><br><span class="line">  16: 00 00 00 00 00 00 00 00 00 02 85 00 96 a0 00 00</span><br><span class="line">  32: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<h2 id="USE-LD-PRELOAD"><a class="header-anchor" href="#USE-LD-PRELOAD">¶</a>USE LD_PRELOAD</h2>
<p>这是 <code>chatgpt</code> 给的一种方式，原以为很离谱，真的有这样的 <a href="https://manpages.ubuntu.com/manpages/trusty/man8/torsocks.8.html">torsocks</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_PRELOAD=/lib/libtorsocks.so</span><br></pre></td></tr></table></figure>
<p>本质上编写自定义共享库：创建一个共享库来拦截与 TCP 相关的系统调用并修改它们的行为。您可以使用 C 或 C++ 等编程语言来编写库。一些通常被拦截的函数包括 socket、connect、bind、listen、accept、send 和 recv。在这些拦截函数中，您可以根据需要实施重定向 TCP 流量的逻辑。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>linux</category>
        <category>network</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP-(1)-ARP</title>
    <url>/2018/05/06/networking/tcp-ip/tcp-ip-review-1-arp/</url>
    <content><![CDATA[

<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<h2 id="预备知识"><a class="header-anchor" href="#预备知识">¶</a>预备知识</h2>
<p><img src="http://electricala2z.com/wp-content/uploads/2017/10/osi-model.gif" alt="OSI"><br>
网络是<strong>分层</strong>的，TCP/IP 关注的是 第三层采用 IP 协议 和 第四层 采用的是 TCP 和 UDP 协议。<br>
对于第一层和第二层，我们需要在意的是 <strong>MTU</strong> （最大传输单元）,<br>
这个值有一个<strong>最小值</strong>,因为载波监听的需求，并没强制性的最大值，Lan默认的是1500。(如何优化MTU可以见 <strong>参考2</strong>) 如何查询MTU可以通过 <code>ifconfig</code> 命令查询。</p>
<span id="more"></span>
<h2 id="ARP"><a class="header-anchor" href="#ARP">¶</a>ARP</h2>
<h3 id="ARP-协议"><a class="header-anchor" href="#ARP-协议">¶</a>ARP 协议</h3>
<p>ARP 提供的是IP转化为MAC地址的功能，提供的是在局域网内传输的能力，因为在局域网内传输数据，需要使用MAC地址（因为在数据链路层的协议需要）。</p>
<ul>
<li>静态映射：直接写在路由表内</li>
<li>动态映射：采用广播的方式查询（ARP协议）</li>
</ul>
<p><img src="https://networkingfolks.files.wordpress.com/2012/03/arp13.jpg" alt="ARP"></p>
<h3 id="ARP-流程"><a class="header-anchor" href="#ARP-流程">¶</a>ARP 流程</h3>
<p><strong>ARP</strong>的核心是有一个源目标IP地址和目标IP地址，目标的物理地址是<strong>填充0</strong>，以广播的方式发送出去，识别出是自己IP的机器以单播的方式返回给发送者。</p>


<div id="diagram"></div>
<script>
	var data =
	['Title: ARP流程',
	 'Sender->Receiver: 1.准备广播报文',
	 'Note right of Sender: 目标地址IP，目标MAC地址置为0',
	 'Receiver->Sender: 2.单播响应',
	 'Note left of Receiver: 采用ARP报文将自己的MAC响应'].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple'});
</script>


<h3 id="ARP-相关命令"><a class="header-anchor" href="#ARP-相关命令">¶</a>ARP 相关命令</h3>
<ul>
<li><code>arp -a</code> : 查询所有arp相关</li>
<li><code>tcpdump -n arp</code> : 监听arp请求</li>
</ul>
<h3 id="ARP-相关攻击"><a class="header-anchor" href="#ARP-相关攻击">¶</a>ARP 相关攻击</h3>
<p>arp本身没有验证性，可以强制回答自己的mac地址。如果有黑客接入网络会导致大批量的arp地址错误。<br>
可以参考本文的 <code>参考资料3</code>。</p>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ol>
<li><a href="https://book.douban.com/subject/1088054/">TCP/IP协议卷一: 详解</a></li>
<li><a href="https://kb.netgear.com/19863/Ping-Test-to-determine-Optimal-MTU-Size-on-Router">Ping Test to determine Optimal MTU Size on Router</a></li>
<li><a href="http://www.freebuf.com/articles/system/10517.html">ARP攻击防范方法总结</a></li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>网络编程</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP-(2)-Internet协议</title>
    <url>/2018/05/07/networking/tcp-ip/tcp-ip-review-2-ip/</url>
    <content><![CDATA[

<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<h2 id="IP-协议格式"><a class="header-anchor" href="#IP-协议格式">¶</a>IP 协议格式</h2>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1525701055612&amp;di=0948d9e53d38bcc604965c72842d3074&amp;imgtype=0&amp;src=http%3A%2F%2F7xntdm.com1.z0.glb.clouddn.com%2FIPformat.png" alt="ip"></p>
<p>IP 报文是 <code>无连接</code> 的，IP报文可能出现丢失，重复等等，这个在IP协议中是无任何保证的，IP协议就是能够将数据发送到目标地址即可。<br>
值得注意的点：</p>
<ul>
<li>IP的头部中有一个总长度字段，这个是以<code>字节</code>为单位的，这个单位只有16位，所以最大为 2^16 = 65535 长度，不过依然会被MTU限制切分</li>
<li>标识字段：这个字段为每一个报文生成一个累加的值，对于数据分片的时候，如果标识字段相同即可认为是同一个数据片</li>
<li>TTL：代表最大的调数，每经过一个Route就减一，等于0的时候就自然被丢弃</li>
</ul>
<span id="more"></span>
<h2 id="IP转发"><a class="header-anchor" href="#IP转发">¶</a>IP转发</h2>
<p>IP包的转发逻辑是没有强制规定的，不过这个实现的话一般会有4个必要的属性</p>
<ul>
<li>目的地：目标地址</li>
<li>掩码：子网掩码</li>
<li>下一跳：传递给下一个网络路由的地址</li>
<li>接口：也就是网卡</li>
</ul>
<table>
<thead>
<tr>
<th>目的地</th>
<th style="text-align:center">掩码</th>
<th style="text-align:right">下一跳</th>
<th style="text-align:right">接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>180.70.65.192</td>
<td style="text-align:center">/26</td>
<td style="text-align:right">-</td>
<td style="text-align:right">m2</td>
</tr>
<tr>
<td>180.70.65.192</td>
<td style="text-align:center">/25</td>
<td style="text-align:right">-</td>
<td style="text-align:right">m0</td>
</tr>
</tbody>
</table>
<p>逻辑步骤是这样的</p>
<ol>
<li>将目标IP和掩码进行运算，得到正确的网段</li>
<li>找到匹配的路由表信息</li>
<li>如果存在下一条地址就将此报文发送给下一条地址 / 如果没有就直接交付给ARP协议通过内网转发</li>
</ol>
<h2 id="相关命令"><a class="header-anchor" href="#相关命令">¶</a>相关命令</h2>
<ul>
<li><code>route -n</code> : 查看所有的路由表</li>
</ul>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ol>
<li><a href="https://book.douban.com/subject/1088054/">TCP/IP协议卷一: 详解</a></li>
<li><a href="https://book.douban.com/subject/5386194/">TCP/IP协议族</a></li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>网络编程</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP-(3)-UDP协议</title>
    <url>/2018/06/05/networking/tcp-ip/tcp-ip-review-3-udp/</url>
    <content><![CDATA[

<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<p>UDP是基于<code>IP 报文</code>上层的一个协议，在TCP/IP协议簇中也提及到，其实UDP只是比IP多提供了进程到进程之间的通讯，除此之外并没有提供额外什么功能。</p>
<h2 id="UDP-协议格式"><a class="header-anchor" href="#UDP-协议格式">¶</a>UDP 协议格式</h2>
<p><img src="http://network-insight.net/wp-content/uploads/2014/10/UDP-Header.jpg" alt="udp"></p>
<p>值得注意的点：</p>
<ul>
<li>UDP头部多了源端口号和目标端口号</li>
<li>UDP依然受限于IP的报文大小最大65535，还需要减掉20个UDP的报文头，也就是65507</li>
</ul>
<span id="more"></span>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ol>
<li><a href="https://book.douban.com/subject/1088054/">TCP/IP协议卷一: 详解</a></li>
<li><a href="https://book.douban.com/subject/5386194/">TCP/IP协议族</a></li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>网络编程</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP-(4)-TCP协议</title>
    <url>/2018/06/05/networking/tcp-ip/tcp-ip-review-4-tcp/</url>
    <content><![CDATA[

<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<p>TCP是基于<code>IP 报文</code>上层的一个协议，和上文所言的UDP不同，TCP是为了在恶劣的网络条件下，依然可以提供<code>可靠</code>的网络连接所提供的一种协议。</p>
<h2 id="TCP-协议概述"><a class="header-anchor" href="#TCP-协议概述">¶</a>TCP 协议概述</h2>
<p><img src="http://img1.51cto.com/attachment/200708/200708061186360118937.jpg" alt="TCP"></p>
<ul>
<li>TCP提供的是流（可以想象成一个管道）</li>
<li>TCP拥有发送和接受缓存</li>
<li>TCP按报文段分发</li>
<li>TCP是可靠的会进行数据包检查</li>
</ul>
<p>总而言之和UDP不同，TCP是提供面向连接的协议，比如需要在A-B之间通讯，我们需要<code>使用TCP在A和B之间建立连接</code>。</p>
<span id="more"></span>
<h2 id="TCP-编号系统"><a class="header-anchor" href="#TCP-编号系统">¶</a>TCP 编号系统</h2>
<p>TCP会将每一个字节都编号，比如我们有 6000个字节系统，我们的序号从 1002开始，那最后一个序号就是 7002，而分段机制根据我们的运行的最大长度切分开。因为我们需要检测，所以我们会有一个·<code>确认号</code>的机制，如果我们接受的报文是 1054，那接受者的返回应该是 1055（发送号+1）。</p>
<h2 id="TCP-的生命周期分述"><a class="header-anchor" href="#TCP-的生命周期分述">¶</a>TCP 的生命周期分述</h2>
<h3 id="1-连接建立"><a class="header-anchor" href="#1-连接建立">¶</a>1. 连接建立</h3>
<p>TCP的建立是三次握手，这块就不展开细聊了。转一个链接 <a href="https://www.jianshu.com/p/9968b16b607e">图解TCP协议中的三次握手和四次挥手</a></p>
<p>不过有一个值得注意的地方：在服务端最后一个ACK的时候，下一次客户端就需要发送TCP数据包了，他的seq号是上一次的ack号，而在三次握手中的第二次的SEQ的用途仅仅是是为了第三次的ACK。见图<img src="https://img-blog.csdn.net/20170405171821911?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTEwMDc3Mjk5OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h3 id="2-数据发送过程"><a class="header-anchor" href="#2-数据发送过程">¶</a>2. 数据发送过程</h3>
<p>这里需要注意的是</p>
<ul>
<li>上面我们知道了TCP是有缓存的，如果我们想要跳过缓存服务，可以设置P的推送字段为1</li>
</ul>
<h3 id="3-连接中止"><a class="header-anchor" href="#3-连接中止">¶</a>3. 连接中止</h3>
<p>很多网上会有中止的四次挥手之说，这里其实无论是三次还是四次都是可以的，关键在于是否存在半关闭的问题。</p>
<ul>
<li>case 1: 直接关闭</li>
</ul>

<div id="diagram"></div>
<script>
	var data =
	['Title: 三次确认关闭流程',
	 'Client->Server: 1.seq:x  ack:y  AF',
	 'Server->Client: 2.seq:y  ack:x+1  AF',
	 'Client->Server: 3.seq:x  ack:y+1  A',
  ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple'});
</script>


<ul>
<li>case 2: 半关闭</li>
</ul>

<div id="diagram2"></div>
<script>
	var data =
	['Title: 四次确认关闭流程',
	 'Client->Server: 1.seq:x  ack:y  AF',
	 'Server->Client: 2.seq:y  ack:x+1  A',
   'Client-->Server: 3. 多次数据提交',
	 'Server->Client: 3.seq:z  ack:x+1  AF',
   'Client->Server: 1.seq:x  ack:z+1  A',
  ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram2", {theme: 'simple'});
</script>

<h2 id="TCP-的窗口"><a class="header-anchor" href="#TCP-的窗口">¶</a>TCP 的窗口</h2>
<p>TCP的流控，差错，拥堵都依赖于窗口机制。待补充</p>
<h2 id="ACK确认机制"><a class="header-anchor" href="#ACK确认机制">¶</a>ACK确认机制</h2>
<ul>
<li>累计确认: 无需每个包都确认可以累计一系列连续的包再确认</li>
<li>选择确认: 这个是高级功能</li>
</ul>
<h2 id="重传"><a class="header-anchor" href="#重传">¶</a>重传</h2>
<ul>
<li>RTO超时重传</li>
<li>超过3次ACK之后的重传</li>
</ul>
<h2 id="计时器"><a class="header-anchor" href="#计时器">¶</a>计时器</h2>
<ul>
<li>重传计时器：TTL时间估算</li>
<li>持续计时器：这个为了防止窗口大小都为0的时候，ack重新激活，但是丢失了，之后会进入一个死锁的状态</li>
<li>保活计时器：无响应的持续</li>
<li>TIME-WAIT：FIN阶段专用的</li>
</ul>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ol>
<li><a href="https://book.douban.com/subject/1088054/">TCP/IP协议卷一: 详解</a></li>
<li><a href="https://book.douban.com/subject/5386194/">TCP/IP协议族</a></li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>网络编程</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Project 2&amp;#58 Log-structured file I/O 解读</title>
    <url>/2020/10/16/rust/talent-plan/project-2/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/10/16/txTC8.png" alt="txTC8.png"></p>
<p><code>PingCAP Talent Plan</code> 是很不错的入门教程，今天我们来分析下 <code>Project 2</code> 的项目代码。</p>
<span id="more"></span>
<p>本章的目标</p>
<ul>
<li>处理错误和异常</li>
<li>使用 <code>serde</code> 进行序列化</li>
<li>使用标准的 API 进行数据的读写</li>
<li>从磁盘上读取 <code>KV</code></li>
<li>在内存中维护 <code>Indexs</code></li>
<li>压缩数据</li>
</ul>
<p><a href="https://github.com/pingcap/talent-plan/blob/master/courses/rust/projects/project-2/src/kv.rs">代码地址</a></p>
<h2 id="定义-KvStore"><a class="header-anchor" href="#定义-KvStore">¶</a>定义 KvStore</h2>
<figure class="highlight rust"><figcaption><span>def kv</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">KvStore</span> &#123;</span><br><span class="line">    <span class="comment">// 储存数据的目录，文件的序号从 0 开始, 1,2,3,4 依次递增</span></span><br><span class="line">    path: PathBuf,</span><br><span class="line">    <span class="comment">// Key 是文件序号，Value 是读取的文件</span></span><br><span class="line">    readers: HashMap&lt;<span class="type">u64</span>, BufReaderWithPos&lt;File&gt;&gt;,</span><br><span class="line">    <span class="comment">// 当前文件的序号</span></span><br><span class="line">    current_gen: <span class="type">u64</span>,</span><br><span class="line">    <span class="comment">// 当前文件的写入的 POS</span></span><br><span class="line">    writer: BufWriterWithPos&lt;File&gt;,</span><br><span class="line">    <span class="comment">// Key 是储存的Key，Value 是 CommandPos</span></span><br><span class="line">    index: BTreeMap&lt;<span class="type">String</span>, CommandPos&gt;,</span><br><span class="line">    <span class="comment">// 累计的 Log 条数</span></span><br><span class="line">    uncompacted: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CommandPos</span> &#123;</span><br><span class="line">    gen: <span class="type">u64</span>,</span><br><span class="line">    pos: <span class="type">u64</span>,</span><br><span class="line">    len: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据储存的形式是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── data</span><br><span class="line">│   ├── 1.log</span><br><span class="line">│   ├── 2.log</span><br><span class="line">│   └── 3.log</span><br></pre></td></tr></table></figure>
<p>对于 <code>readers</code> 中最终的储存数据为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 -&gt; File(1.log)</span><br><span class="line">2 -&gt; File(2.log)</span><br><span class="line">3 -&gt; File(3.log)</span><br></pre></td></tr></table></figure>
<p>而每一个 <code>log</code> 文件内部的格式如下：</p>
<p><img src="https://s3.jpg.cm/2020/10/16/txx1k.png" alt="log.file"></p>
<p>因此每一个 <code>CommandPos</code> 内标记的是 1. 隶属于某个 <code>Log</code> 文件， 2. <code>Log</code> 文件中的起始 Pos， 3. <code>Command</code> 的长度。</p>
<h2 id="初始化-KvStore"><a class="header-anchor" href="#初始化-KvStore">¶</a>初始化 KvStore</h2>
<p>初始化的工作，我们需要做的事情，显然就是将当前目录下所有的 <code>*.log</code> 文件都载入内存中。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">open</span>(path: <span class="keyword">impl</span> <span class="title class_">Into</span>&lt;PathBuf&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;KvStore&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">readers</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = BTreeMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将目录下的文件按照从小到大的排序载入，vec![1,2,3,6,9]</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gen_list</span> = <span class="title function_ invoke__">sorted_gen_list</span>(&amp;path)?; </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">uncompacted</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照顺序挨个读取 log 文件</span></span><br><span class="line">    <span class="keyword">for</span> &amp;gen <span class="keyword">in</span> &amp;gen_list &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">reader</span> = BufReaderWithPos::<span class="title function_ invoke__">new</span>(File::<span class="title function_ invoke__">open</span>(<span class="title function_ invoke__">log_path</span>(&amp;path, gen))?)?;</span><br><span class="line">        uncompacted += <span class="title function_ invoke__">load</span>(gen, &amp;<span class="keyword">mut</span> reader, &amp;<span class="keyword">mut</span> index)?;</span><br><span class="line">        readers.<span class="title function_ invoke__">insert</span>(gen, reader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以最大的 log 序号 + 1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">current_gen</span> = gen_list.<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">unwrap_or</span>(&amp;<span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 以 current_gen 创建一个新文件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">writer</span> = <span class="title function_ invoke__">new_log_file</span>(&amp;path, current_gen, &amp;<span class="keyword">mut</span> readers)?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而更为核心的内容在 <code>load</code> 中，<code>load</code> 的功能就是将目录中的数据载入系统中来。</p>
<figure class="highlight rust"><figcaption><span>load</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">load</span>(</span><br><span class="line">    gen: <span class="type">u64</span>,</span><br><span class="line">    reader: &amp;<span class="keyword">mut</span> BufReaderWithPos&lt;File&gt;,</span><br><span class="line">    index: &amp;<span class="keyword">mut</span> BTreeMap&lt;<span class="type">String</span>, CommandPos&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">u64</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 置位 0，从零开始</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">pos</span> = reader.<span class="title function_ invoke__">seek</span>(SeekFrom::<span class="title function_ invoke__">Start</span>(<span class="number">0</span>))?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stream</span> = Deserializer::<span class="title function_ invoke__">from_reader</span>(reader).into_iter::&lt;Command&gt;();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">uncompacted</span> = <span class="number">0</span>; <span class="comment">// Log 条目的计数器</span></span><br><span class="line">    <span class="comment">// 读取一条从 log 中，判断不同的类型进行处理</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(cmd) = stream.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">new_pos</span> = stream.<span class="title function_ invoke__">byte_offset</span>() <span class="keyword">as</span> <span class="type">u64</span>;</span><br><span class="line">        <span class="keyword">match</span> cmd? &#123;</span><br><span class="line">            Command::Set &#123; key, .. &#125; =&gt; &#123;</span><br><span class="line">                <span class="comment">// 如果是 set， 我们在 index 中插入 Key， 和定位的 POS</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(old_cmd) = index.<span class="title function_ invoke__">insert</span>(key, (gen, pos..new_pos).<span class="title function_ invoke__">into</span>()) &#123;</span><br><span class="line">                    uncompacted += old_cmd.len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Command::Remove &#123; key &#125; =&gt; &#123;</span><br><span class="line">                <span class="comment">// 删除一个 key</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(old_cmd) = index.<span class="title function_ invoke__">remove</span>(&amp;key) &#123;</span><br><span class="line">                    uncompacted += old_cmd.len;</span><br><span class="line">                &#125;</span><br><span class="line">                uncompacted += new_pos - pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(uncompacted)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获得数据"><a class="header-anchor" href="#获得数据">¶</a>获得数据</h2>
<p>获得数据是很快的，因为我们已经在内存中储存了 <code>Index</code>  的缓存。</p>
<p><img src="https://s3.jpg.cm/2020/10/16/txZAr.png" alt="txZAr.png"></p>
<figure class="highlight rust"><figcaption><span>get key</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Option</span>&lt;<span class="type">String</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(cmd_pos) = <span class="keyword">self</span>.index.<span class="title function_ invoke__">get</span>(&amp;key) &#123;</span><br><span class="line">        <span class="comment">// 获得了 command_pos 之后就去具体的文件中读取</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">reader</span> = <span class="keyword">self</span></span><br><span class="line">            .readers</span><br><span class="line">            .<span class="title function_ invoke__">get_mut</span>(&amp;cmd_pos.gen)</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Cannot find log reader&quot;</span>);</span><br><span class="line">        reader.<span class="title function_ invoke__">seek</span>(SeekFrom::<span class="title function_ invoke__">Start</span>(cmd_pos.pos))?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cmd_reader</span> = reader.<span class="title function_ invoke__">take</span>(cmd_pos.len);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Command</span>::Set &#123; value, .. &#125; = serde_json::<span class="title function_ invoke__">from_reader</span>(cmd_reader)? &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Some</span>(value))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(KvsError::UnexpectedCommandType)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// index 无key，直接返回了</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="literal">None</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增加数据"><a class="header-anchor" href="#增加数据">¶</a>增加数据</h2>
<figure class="highlight rust"><figcaption><span>set key value</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: <span class="type">String</span>, value: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// 创建一个 Command 对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cmd</span> = Command::<span class="title function_ invoke__">set</span>(key, value);</span><br><span class="line">    <span class="comment">// 当前 Log 文件的写入偏移位置</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pos</span> = <span class="keyword">self</span>.writer.pos;</span><br><span class="line">    <span class="comment">// 写入文件</span></span><br><span class="line">    serde_json::<span class="title function_ invoke__">to_writer</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.writer, &amp;cmd)?;</span><br><span class="line">    <span class="comment">// 刷新到磁盘</span></span><br><span class="line">    <span class="keyword">self</span>.writer.<span class="title function_ invoke__">flush</span>()?;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Command</span>::Set &#123; key, .. &#125; = cmd &#123;</span><br><span class="line">        <span class="comment">// 更新到 Index 中</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(old_cmd) = <span class="keyword">self</span></span><br><span class="line">            .index</span><br><span class="line">            .<span class="title function_ invoke__">insert</span>(key, (<span class="keyword">self</span>.current_gen, pos..<span class="keyword">self</span>.writer.pos).<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">self</span>.uncompacted += old_cmd.len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未压缩的超过 COMPACTION_THRESHOLD 就触发压缩</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.uncompacted &gt; COMPACTION_THRESHOLD &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">compact</span>()?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据压缩"><a class="header-anchor" href="#数据压缩">¶</a>数据压缩</h3>
<p>对于我们不再使用的数据，我们可以进行压缩</p>
<p><img src="https://s3.jpg.cm/2020/10/16/tOquG.png" alt="tOquG.png"></p>
<p>显然，我们需要做的事情也很明确，从我们的 <code>Index</code> 扫描保存在用的 <code>Command</code>，而其他的都可以删除了。</p>
<figure class="highlight rust"><figcaption><span>compact</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">compact</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// 压缩后的 log 的序号是当前序号 + 1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">compaction_gen</span> = <span class="keyword">self</span>.current_gen + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一次写入的是 log 序号是当前序号 + 2</span></span><br><span class="line">    <span class="keyword">self</span>.current_gen += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">self</span>.writer = <span class="keyword">self</span>.<span class="title function_ invoke__">new_log_file</span>(<span class="keyword">self</span>.current_gen)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建处理压缩结果的文件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">compaction_writer</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">new_log_file</span>(compaction_gen)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">new_pos</span> = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 index 取出所有的Value</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">cmd_pos</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.index.<span class="title function_ invoke__">values_mut</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">reader</span> = <span class="keyword">self</span>.readers.<span class="title function_ invoke__">get_mut</span>(&amp;cmd_pos.gen).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Cannot find log reader&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> reader.pos != cmd_pos.pos &#123;</span><br><span class="line">            reader.<span class="title function_ invoke__">seek</span>(SeekFrom::<span class="title function_ invoke__">Start</span>(cmd_pos.pos))?;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">entry_reader</span> = reader.<span class="title function_ invoke__">take</span>(cmd_pos.len);</span><br><span class="line">        <span class="comment">// 当前 Value 写入压缩 Log 文件</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = io::<span class="title function_ invoke__">copy</span>(&amp;<span class="keyword">mut</span> entry_reader, &amp;<span class="keyword">mut</span> compaction_writer)?;</span><br><span class="line">        *cmd_pos = (compaction_gen, new_pos..new_pos + len).<span class="title function_ invoke__">into</span>();</span><br><span class="line">        new_pos += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入磁盘</span></span><br><span class="line">    compaction_writer.<span class="title function_ invoke__">flush</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删掉比 压缩Log 序号更小的 log，因为已经被压缩完了。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stale_gens</span>: <span class="type">Vec</span>&lt;_&gt; = <span class="keyword">self</span>.readers.<span class="title function_ invoke__">keys</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|&amp;&amp;gen| gen &lt; compaction_gen).<span class="title function_ invoke__">cloned</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stale_gen</span> <span class="keyword">in</span> stale_gens &#123;</span><br><span class="line">        <span class="keyword">self</span>.readers.<span class="title function_ invoke__">remove</span>(&amp;stale_gen);</span><br><span class="line">        fs::<span class="title function_ invoke__">remove_file</span>(<span class="title function_ invoke__">log_path</span>(&amp;<span class="keyword">self</span>.path, stale_gen))?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.uncompacted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除数据"><a class="header-anchor" href="#删除数据">¶</a>删除数据</h2>
<p>删除数据非常的简单，和 <code>Set</code> 相同，可以看作 <code>Set Null</code>，因此直接 <code>Append Log</code> 即可。</p>
<figure class="highlight rust"><figcaption><span>remove</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">remove</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.index.<span class="title function_ invoke__">contains_key</span>(&amp;key) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cmd</span> = Command::<span class="title function_ invoke__">remove</span>(key);</span><br><span class="line">        serde_json::<span class="title function_ invoke__">to_writer</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.writer, &amp;cmd)?;</span><br><span class="line">        <span class="keyword">self</span>.writer.<span class="title function_ invoke__">flush</span>()?;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Command</span>::Remove &#123; key &#125; = cmd &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">old_cmd</span> = <span class="keyword">self</span>.index.<span class="title function_ invoke__">remove</span>(&amp;key).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;key not found&quot;</span>);</span><br><span class="line">            <span class="keyword">self</span>.uncompacted += old_cmd.len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(KvsError::KeyNotFound)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rust</category>
        <category>pingcap</category>
        <category>talent-plan</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>pingcap</tag>
        <tag>talent-plan</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Project 3&amp;#58  Synchronous client-server networking 解读</title>
    <url>/2020/10/20/rust/talent-plan/project-3/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/10/21/NciWO.png" alt="NciWO.png"></p>
<p>上次讲完了我们单机模式下的 <code>KV Store</code>，这次接着解读，我们将访问模式从 <code>CMD</code> 变成 <code>Networking</code> 的模式。</p>
<span id="more"></span>
<p>本文主要解读代码的构成部分，对于类库的使用就一笔带过。</p>
<h2 id="服务端"><a class="header-anchor" href="#服务端">¶</a>服务端</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    env_logger::<span class="title function_ invoke__">builder</span>().<span class="title function_ invoke__">filter_level</span>(LevelFilter::Info).<span class="title function_ invoke__">init</span>();</span><br><span class="line">    <span class="comment">// 读取配置</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">opt</span> = Opt::<span class="title function_ invoke__">from_args</span>();</span><br><span class="line">    <span class="comment">// current_engine() 是说 current_kv_engine 也就是当前目录</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="title function_ invoke__">current_engine</span>().<span class="title function_ invoke__">and_then</span>(<span class="keyword">move</span> |curr_engine| &#123;</span><br><span class="line">        <span class="title function_ invoke__">run</span>(opt)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动"><a class="header-anchor" href="#启动">¶</a>启动</h3>
<p>显然所有的逻辑都在我们的 <code>run</code> 之中</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>(opt: Opt) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">engine</span> = opt.engine.<span class="title function_ invoke__">unwrap_or</span>(DEFAULT_ENGINE);</span><br><span class="line">    info!(<span class="string">&quot;kvs-server &#123;&#125;&quot;</span>, <span class="built_in">env!</span>(<span class="string">&quot;CARGO_PKG_VERSION&quot;</span>));</span><br><span class="line">    info!(<span class="string">&quot;Storage engine: &#123;&#125;&quot;</span>, engine);</span><br><span class="line">    info!(<span class="string">&quot;Listening on &#123;&#125;&quot;</span>, opt.addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write engine to engine file</span></span><br><span class="line">    fs::<span class="title function_ invoke__">write</span>(<span class="title function_ invoke__">current_dir</span>()?.<span class="title function_ invoke__">join</span>(<span class="string">&quot;engine&quot;</span>), <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, engine))?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> engine &#123;</span><br><span class="line">        Engine::kvs =&gt; <span class="title function_ invoke__">run_with_engine</span>(KvStore::<span class="title function_ invoke__">open</span>(<span class="title function_ invoke__">current_dir</span>()?)?, opt.addr),</span><br><span class="line">        Engine::sled =&gt; <span class="title function_ invoke__">run_with_engine</span>(</span><br><span class="line">            SledKvsEngine::<span class="title function_ invoke__">new</span>(sled::Db::<span class="title function_ invoke__">start_default</span>(<span class="title function_ invoke__">current_dir</span>()?)?),</span><br><span class="line">            opt.addr,</span><br><span class="line">        ),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里我们的代码开始分叉，我们需要处理两种情况，<code>sled</code> 和 <code>kvs</code>，不过其实 <code>sled</code> 仅仅是一个测试的 <code>Mock</code> 实现，从 <a href="https://raw.githubusercontent.com/pingcap/talent-plan/master/courses/rust/projects/project-3/src/engines/sled.rs">sled.rs</a> 的实现可以看出来，仅仅是一个 <code>IN-MEM</code> 的实现罢了，我们还是核心要去看 <code>Engine::kvs</code> 的 <code>CASE</code>（不过其实也没啥区别，就是换了 kv 引擎）</p>
<p>来到了我们 <code>Run</code> 服务器的地方了</p>
<figure class="highlight rust"><figcaption><span>run</span><a href="https://github.com/pingcap/talent-plan/blob/master/courses/rust/projects/project-3/src/server.rs#L19">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>&lt;A: ToSocketAddrs&gt;(<span class="keyword">mut</span> <span class="keyword">self</span>, addr: A) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅仅打开了一个监听的 Socket</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(addr)?;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">        <span class="keyword">match</span> stream &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(stream) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="keyword">self</span>.<span class="title function_ invoke__">serve</span>(stream) &#123;</span><br><span class="line">                    error!(<span class="string">&quot;Error on serving client: &#123;&#125;&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逻辑处理"><a class="header-anchor" href="#逻辑处理">¶</a>逻辑处理</h3>
<p>核心的逻辑依然需要往下走一点，我们就来到了有趣的部分了，几乎就是如何手写一个纯粹的 <code>Web</code> 服务。</p>
<figure class="highlight rust"><figcaption><span>serve</span><a href="https://github.com/pingcap/talent-plan/blob/master/courses/rust/projects/project-3/src/server.rs#L34">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">serve</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, tcp: TcpStream) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">peer_addr</span> = tcp.<span class="title function_ invoke__">peer_addr</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 BufReader 来读取数据，标准的装饰器模式……</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reader</span> = BufReader::<span class="title function_ invoke__">new</span>(&amp;tcp);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">writer</span> = BufWriter::<span class="title function_ invoke__">new</span>(&amp;tcp);</span><br><span class="line">    <span class="comment">// 读取的数据解析成 Request 类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">req_reader</span> = Deserializer::<span class="title function_ invoke__">from_reader</span>(reader).into_iter::&lt;Request&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust 宏，这个宏很简单，一个表达式参数，将 resp 对象写入 writer</span></span><br><span class="line">    <span class="built_in">macro_rules!</span> send_resp &#123;</span><br><span class="line">        ($resp:expr) =&gt; &#123;&#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">resp</span> = $resp;</span><br><span class="line">            serde_json::<span class="title function_ invoke__">to_writer</span>(&amp;<span class="keyword">mut</span> writer, &amp;resp)?;</span><br><span class="line">            writer.<span class="title function_ invoke__">flush</span>()?;</span><br><span class="line">            debug!(<span class="string">&quot;Response sent to &#123;&#125;: &#123;:?&#125;&quot;</span>, peer_addr, resp);</span><br><span class="line">        &#125;;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里其实是 Blocking IO，我们每一次都需要等待完整的 Request 达到进入循环体内</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">req</span> <span class="keyword">in</span> req_reader &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">req</span> = req?;</span><br><span class="line">        debug!(<span class="string">&quot;Receive request from &#123;&#125;: &#123;:?&#125;&quot;</span>, peer_addr, req);</span><br><span class="line">        <span class="comment">// 处理不同的数据类型即可</span></span><br><span class="line">        <span class="comment">// 处理逻辑实则就是我们 kv store 的三个操作</span></span><br><span class="line">        <span class="keyword">match</span> req &#123;</span><br><span class="line">            Request::Get &#123; key &#125; =&gt; send_resp!(<span class="keyword">match</span> <span class="keyword">self</span>.engine.<span class="title function_ invoke__">get</span>(key) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(value) =&gt; GetResponse::<span class="title function_ invoke__">Ok</span>(value),</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; GetResponse::<span class="title function_ invoke__">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e)),</span><br><span class="line">            &#125;),</span><br><span class="line">            Request::Set &#123; key, value &#125; =&gt; send_resp!(<span class="keyword">match</span> <span class="keyword">self</span>.engine.<span class="title function_ invoke__">set</span>(key, value) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(_) =&gt; SetResponse::<span class="title function_ invoke__">Ok</span>(()),</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; SetResponse::<span class="title function_ invoke__">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e)),</span><br><span class="line">            &#125;),</span><br><span class="line">            Request::Remove &#123; key &#125; =&gt; send_resp!(<span class="keyword">match</span> <span class="keyword">self</span>.engine.<span class="title function_ invoke__">remove</span>(key) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(_) =&gt; RemoveResponse::<span class="title function_ invoke__">Ok</span>(()),</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; RemoveResponse::<span class="title function_ invoke__">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e)),</span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端"><a class="header-anchor" href="#客户端">¶</a>客户端</h2>
<p>客户端的代码和服务端类似，不过显然我仅仅发送网络请求即可。</p>
<figure class="highlight rust"><figcaption><span>client run</span><a href="https://github.com/pingcap/talent-plan/blob/master/courses/rust/projects/project-3/src/bin/kvs-client.rs#L75">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>(opt: Opt) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> opt.command &#123;</span><br><span class="line">        Command::Get &#123; key, addr &#125; =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">client</span> = KvsClient::<span class="title function_ invoke__">connect</span>(addr)?;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(value) = client.<span class="title function_ invoke__">get</span>(key)? &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Key not found&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Command::Set &#123; key, value, addr &#125; =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">client</span> = KvsClient::<span class="title function_ invoke__">connect</span>(addr)?;</span><br><span class="line">            client.<span class="title function_ invoke__">set</span>(key, value)?;</span><br><span class="line">        &#125;</span><br><span class="line">        Command::Remove &#123; key, addr &#125; =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">client</span> = KvsClient::<span class="title function_ invoke__">connect</span>(addr)?;</span><br><span class="line">            client.<span class="title function_ invoke__">remove</span>(key)?;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送逻辑显然也很简单</p>
<figure class="highlight rust"><figcaption><span>client</span><a href="https://github.com/pingcap/talent-plan/blob/master/courses/rust/projects/project-3/src/client.rs#L16">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Option</span>&lt;<span class="type">String</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 将 Get 请求，序列化之后，写入 Writer</span></span><br><span class="line">    serde_json::<span class="title function_ invoke__">to_writer</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.writer, &amp;Request::Get &#123; key &#125;)?;</span><br><span class="line">    <span class="keyword">self</span>.writer.<span class="title function_ invoke__">flush</span>()?;</span><br><span class="line">    <span class="comment">// 将返回的结果反序列出来</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">resp</span> = GetResponse::<span class="title function_ invoke__">deserialize</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.reader)?;</span><br><span class="line">    <span class="keyword">match</span> resp &#123;</span><br><span class="line">        GetResponse::<span class="title function_ invoke__">Ok</span>(value) =&gt; <span class="title function_ invoke__">Ok</span>(value),</span><br><span class="line">        GetResponse::<span class="title function_ invoke__">Err</span>(msg) =&gt; <span class="title function_ invoke__">Err</span>(KvsError::<span class="title function_ invoke__">StringError</span>(msg)),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rust</category>
        <category>pingcap</category>
        <category>talent-plan</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>pingcap</tag>
        <tag>talent-plan</tag>
      </tags>
  </entry>
  <entry>
    <title>Isito 1.8 新功能&amp;#58 DNS Agent</title>
    <url>/2021/02/07/networking/istio/feature/dns-agent/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210207175028.png" alt=""></p>
<p>在 <code>1.8</code> 的版本中，<code>istio</code> 悄悄的上了一个预览版的功能 <a href="https://istio.io/latest/blog/2020/dns-proxy/">DNS Proxy</a>，这个功能极为的强大，让我们一起来看看吧。</p>
<span id="more"></span>
<h2 id="为何诞生"><a class="header-anchor" href="#为何诞生">¶</a>为何诞生</h2>
<p>从官方的文档中，<code>DNS Proxy</code>的功能主要为了 <code>减少KubeDNS的查询</code>，这个很好理解</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210207175250.png" alt=""></p>
<p>除此之外，还要解决一个很重大的问题：<code>VM 和 Kubernetes</code> 的集成问题。</p>
<iframe frameborder="0" style="width:100%;height:400px;" src="https://viewer.diagrams.net/?highlight=0000ff&edit=_blank&layers=1&nav=1&title=VMs%20to%20Kubernetes%20integration.drawio#Uhttps%3A%2F%2Fraw.githubusercontent.com%2Fyanickxia%2Fdrawio%2Fmaster%2FVMs%2520to%2520Kubernetes%2520integration.drawio"></iframe>
<p>当我们将 <code>虚拟机</code> 接入集群的时候，<code>虚拟机</code> 中的应用如何访问 <code>Kubernates</code> 中的应用一直是一个困难的事情。还顺带解决了多集群访问的问题。让我们看看他是怎没做的。</p>
<h2 id="DNS-Proxy"><a class="header-anchor" href="#DNS-Proxy">¶</a>DNS Proxy</h2>
<p>启用此功能需要在 <code>pilot-agent</code> 的环境变量增加 <code>ISTIO_META_DNS_CAPTURE=true</code></p>
<h3 id="DNS-请求拦截"><a class="header-anchor" href="#DNS-请求拦截">¶</a>DNS 请求拦截</h3>
<p>当<code>Pod</code>启动的时候，我们会为 <code>Pod</code> 指定域名解析服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash-5.0<span class="comment"># cat /etc/resolv.conf </span></span><br><span class="line">nameserver 10.96.0.10</span><br><span class="line">search test-istio.svc.cluster.local svc.cluster.local cluster.local byted.org</span><br><span class="line">options ndots:5</span><br></pre></td></tr></table></figure>
<p>这里的 <code>nameserver</code> 指向的就是 <code>kube-dns</code> 的地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get svc --all-namespaces | grep <span class="string">&#x27;10.96.0.10&#x27;</span></span><br><span class="line">kube-system    kube-dns                ClusterIP      10.96.0.10       &lt;none&gt;         53/UDP,53/TCP,9153/TCP                                                       39d</span><br></pre></td></tr></table></figure>
<p><code>istio</code> 在会将此请求拦截，转发至 <code>pilot-agent</code>，这里并没有通过 <code>envoy</code>，是通过 <code>iptables</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nsenter -t1963097 -n iptables-save -L</span><br><span class="line">.....</span><br><span class="line">-A OUTPUT -p udp -m udp --dport 53 -m owner --uid-owner 1337 -j RETURN</span><br><span class="line">-A OUTPUT -p udp -m udp --dport 53 -m owner --gid-owner 1337 -j RETURN</span><br><span class="line">-A OUTPUT -p udp -m udp --dport 53 -j DNAT --to-destination 127.0.0.1:15053</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>在 <code>isito</code> 的 <code>pilot/pkg/dns/proxy.go:62</code> 中，我们可以很轻松的看到</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *dnsProxy)</span></span> start() &#123;</span><br><span class="line">	log.Infof(<span class="string">&quot;Starting local %s DNS server at 0.0.0.0:15053&quot;</span>, p.protocol)</span><br><span class="line">	err := p.downstreamServer.ActivateAndServe()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Errorf(<span class="string">&quot;Local %s DNS server terminated: %v&quot;</span>, p.protocol, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DNS-Agent"><a class="header-anchor" href="#DNS-Agent">¶</a>DNS Agent</h3>
<p>对于 <code>DNS Agent</code> 的运行逻辑也相对的不算很复杂。主要集中在 <code>pilot/pkg/dns/dns.go</code> 的 <code>ServeDNS</code> 函数中。</p>
<figure class="highlight go"><figcaption><span>ServeDNS</span><a href="https://github.com/istio/istio/blob/1.8.2/pilot/pkg/dns/dns.go#L154">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *LocalDNSServer)</span></span> ServeDNS(proxy *dnsProxy, w dns.ResponseWriter, req *dns.Msg) &#123;</span><br><span class="line">	<span class="keyword">var</span> response *dns.Msg</span><br><span class="line"></span><br><span class="line">    lp := h.lookupTable.Load()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lookupTable 未加载成功，返回解析失败</span></span><br><span class="line">    <span class="keyword">if</span> lp == <span class="literal">nil</span> &#123;</span><br><span class="line">        response = <span class="built_in">new</span>(dns.Msg)</span><br><span class="line">        response.SetReply(req)</span><br><span class="line">        response.Rcode = dns.RcodeNameError</span><br><span class="line">        _ = w.WriteMsg(response)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    lookupTable := lp.(*LookupTable)</span><br><span class="line">    <span class="keyword">var</span> answers []dns.RR</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去 lookupTable 进行查找</span></span><br><span class="line">    hostname := strings.ToLower(req.Question[<span class="number">0</span>].Name)</span><br><span class="line">    answers, hostFound := lookupTable.lookupHost(req.Question[<span class="number">0</span>].Qtype, hostname)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> hostFound &#123; <span class="comment">// 找到就是返回</span></span><br><span class="line">        response = <span class="built_in">new</span>(dns.Msg)</span><br><span class="line">        response.SetReply(req)</span><br><span class="line">        response.Answer = answers</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(answers) == <span class="number">0</span> &#123; <span class="comment">// 多个地址特殊处理失败</span></span><br><span class="line">            response.Rcode = dns.RcodeNameError</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找不到向上游查询</span></span><br><span class="line">        response = h.queryUpstream(proxy.upstreamClient, req)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	_ = w.WriteMsg(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理的逻辑并不算复杂，而比较复杂的显然是 <code>lookupTable</code> 从何而来，这个答案都指向了 <code>pilot-discovery</code> 组件</p>
<figure class="highlight go"><figcaption><span>HandleUpstream</span><a href="https://github.com/istio/istio/blob/1.8.2/pkg/istio-agent/xds_proxy.go#L241">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *XdsProxy)</span></span> HandleUpstream(ctx context.Context, con *ProxyConnection, xds discovery.AggregatedDiscoveryServiceClient) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> resp, ok := &lt;-con.responsesChan:</span><br><span class="line">    <span class="keyword">switch</span> resp.TypeUrl &#123;</span><br><span class="line">    <span class="keyword">case</span> v3.NameTableType:</span><br><span class="line">        <span class="keyword">if</span> p.localDNSServer != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(resp.Resources) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> nt nds.NameTable</span><br><span class="line">            <span class="keyword">if</span> err = ptypes.UnmarshalAny(resp.Resources[<span class="number">0</span>], &amp;nt); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Errorf(<span class="string">&quot;failed to unmarshall name table: %v&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">            p.localDNSServer.UpdateLookupTable(&amp;nt)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见 <code>pilot-discovery</code> 将这些数据 <code>push</code> 到了我们的 <code>pilot-agent</code> 上。</p>
<h3 id="Pilot-Discovery"><a class="header-anchor" href="#Pilot-Discovery">¶</a>Pilot-Discovery</h3>
<p>对于 <code>XDS</code> 来说，我们熟系的有 <code>LDS</code> <code>RDS</code> <code>RSDS</code> 等，对于 <code>DNS</code> 的数据，<code>istio</code> 拓展了一种 <a href="https://github.com/istio/istio/blob/1.8.2/pilot/pkg/xds/nds.go"><code>NDS</code></a> 协议</p>
<figure class="highlight go"><figcaption><span>DNS Generate</span><a href="https://github.com/istio/istio/blob/1.8.2/pilot/pkg/xds/nds.go#L68">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n NdsGenerator)</span></span> Generate(proxy *model.Proxy, push *model.PushContext, w *model.WatchedResource, req *model.PushRequest) model.Resources &#123;</span><br><span class="line">	<span class="keyword">if</span> !ndsNeedsPush(req) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	nt := n.Server.ConfigGenerator.BuildNameTable(proxy, push)</span><br><span class="line">	<span class="keyword">if</span> nt == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	resources := model.Resources&#123;util.MessageToAny(nt)&#125;</span><br><span class="line">	<span class="keyword">return</span> resources</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码的生成中，我们可以发现那些东西会被 <code>Push</code> 到 <code>Agent</code> 中</p>
<figure class="highlight go"><figcaption><span>BuildNameTable</span><a href="https://github.com/istio/istio/blob/1.8.2/pilot/pkg/networking/core/v1alpha3/name_table.go#L27">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(configgen *ConfigGeneratorImpl)</span></span> BuildNameTable(node *model.Proxy, push *model.PushContext) *nds.NameTable &#123;</span><br><span class="line">	out := &amp;nds.NameTable&#123;</span><br><span class="line">		Table: <span class="keyword">map</span>[<span class="type">string</span>]*nds.NameTable_NameInfo&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获得所有的服务 [这里是一个整合的概念，不仅仅包含了 kube Service]</span></span><br><span class="line">	<span class="keyword">for</span> _, svc := <span class="keyword">range</span> push.Services(node) &#123;</span><br><span class="line">		<span class="keyword">if</span> svc.Hostname.IsWildCarded() &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		svcAddress := svc.GetServiceAddressForProxy(node, push)</span><br><span class="line">		<span class="keyword">var</span> addressList []<span class="type">string</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果地址是 0.0.0.0 </span></span><br><span class="line">		<span class="keyword">if</span> svcAddress == constants.UnspecifiedIP &#123;</span><br><span class="line">			<span class="keyword">if</span> svc.Attributes.ServiceRegistry == <span class="type">string</span>(serviceregistry.Kubernetes) &amp;&amp;</span><br><span class="line">				svc.Resolution == model.Passthrough &amp;&amp; <span class="built_in">len</span>(svc.Ports) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 如果是 Passthrough 的模式并且有 Ports 的配置，就把 ServiceInstance 的 IP 写入 </span></span><br><span class="line">				<span class="keyword">for</span> _, instance := <span class="keyword">range</span> push.ServiceInstancesByPort(svc, svc.Ports[<span class="number">0</span>].Port, <span class="literal">nil</span>) &#123;</span><br><span class="line">					addressList = <span class="built_in">append</span>(addressList, instance.Endpoint.Address)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(addressList) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他直接放地址即可</span></span><br><span class="line">			addressList = <span class="built_in">append</span>(addressList, svcAddress)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		nameInfo := &amp;nds.NameTable_NameInfo&#123;</span><br><span class="line">			Ips:      addressList,</span><br><span class="line">			Registry: svc.Attributes.ServiceRegistry, </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛开 <code>headless</code> 的服务来说，大部分的服务地址都可以通过 <code>GetServiceAddressForProxy</code> 获得。</p>
<figure class="highlight go"><figcaption><span>GetServiceAddressForProxy</span><a href="https://github.com/istio/istio/blob/1.8.2/pilot/pkg/model/service.go#L600">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> GetServiceAddressForProxy(node *Proxy, push *PushContext) <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 从节点内获得 ClusterIP</span></span><br><span class="line">	<span class="keyword">if</span> node.Metadata != <span class="literal">nil</span> &amp;&amp; node.Metadata.ClusterID != <span class="string">&quot;&quot;</span> &amp;&amp; push.ServiceIndex.ClusterVIPs[s][node.Metadata.ClusterID] != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> push.ServiceIndex.ClusterVIPs[s][node.Metadata.ClusterID]</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果开启 DNSCapture 而且服务又是 Headless 的，这里会使用 AutoAllocatedAddress</span></span><br><span class="line">	<span class="keyword">if</span> node.Metadata != <span class="literal">nil</span> &amp;&amp; node.Metadata.DNSCapture != <span class="string">&quot;&quot;</span> &amp;&amp;</span><br><span class="line">		s.Address == constants.UnspecifiedIP &amp;&amp; s.AutoAllocatedAddress != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s.AutoAllocatedAddress</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.Address</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而生产 <code>IP</code> 的逻辑在 <a href="https://github.com/istio/istio/blob/88a2bfb3bd8e0010229ee66befc4e56b326c2a3a/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go#L894">autoAllocateIPs</a> 不做过多的展开。</p>
<p>在 <code>PushContext</code> 中，获得所有的 <code>Service</code> 的时候，会自动的生成这些 <code>IP</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceEntryStore)</span></span> Services() ([]*model.Service, <span class="type">error</span>) &#123;</span><br><span class="line">	services := <span class="built_in">make</span>([]*model.Service, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, cfg := <span class="keyword">range</span> s.store.ServiceEntries() &#123;</span><br><span class="line">		services = <span class="built_in">append</span>(services, convertServices(cfg)...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> autoAllocateIPs(services), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DNS-Proxy-Works"><a class="header-anchor" href="#DNS-Proxy-Works">¶</a>DNS Proxy Works</h2>
<p>说了那么多的原理，让我们看看，这个功能究竟会给我们带来什么。</p>
<h3 id="VM-访问-Kube-内资源"><a class="header-anchor" href="#VM-访问-Kube-内资源">¶</a>VM 访问 Kube 内资源</h3>
<iframe frameborder="0" style="width:100%;height:400px;" src="https://viewer.diagrams.net/?highlight=0000ff&edit=_blank&layers=1&nav=1&title=vm-access-kube.drawio#Uhttps%3A%2F%2Fraw.githubusercontent.com%2Fyanickxia%2Fdrawio%2Fmaster%2Fvm-access-kube.drawio"></iframe>
<p>当我们让 <code>VM</code> 访问 <code>Kube</code> 内资源的时候，会经过</p>
<ol>
<li>VM 内应用查询 DNS 解析 <code>demo.demo.srv.cluster.local</code></li>
<li>DNS 解析返回缓存的地址，实际上对应的 <code>srv</code> 地址</li>
<li>访问此地址，被 <code>Envoy</code> 拦截</li>
<li><code>Envoy</code> 将请求转发至 <code>Ingress Gateway</code></li>
<li><code>Ingress Gateway</code> 通过 <code>SNI</code> 转发至 <code>Service</code></li>
</ol>
<h3 id="跨集群访问"><a class="header-anchor" href="#跨集群访问">¶</a>跨集群访问</h3>
<p>在以前的跨集群访问中，如果某个服务仅仅在某一个集群中，此时我们在另外一个不包含此服务的集群中访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># curl something.demo.srv.cluster.local</span></span><br><span class="line">curl: (6) Could not resolve host: something.demo.srv.cluster.local</span><br></pre></td></tr></table></figure>
<p>这里错误是因为 <code>KubeDNS</code> 并不能成功的了解析其他集群中的服务地址。现在基于 <code>DNS PROXY</code> 和 <a href="">#VM 访问 Kube 内资源</a> 一样解决了这样的问题。</p>
<iframe frameborder="0" style="width:100%;height:400px;" src="https://viewer.diagrams.net/?highlight=0000ff&edit=_blank&layers=1&nav=1&title=access-other-kube.drawio#Uhttps%3A%2F%2Fraw.githubusercontent.com%2Fyanickxia%2Fdrawio%2Fmaster%2Faccess-other-kube.drawio"></iframe>
<h3 id="ServiceEntry-一键接入外部服务"><a class="header-anchor" href="#ServiceEntry-一键接入外部服务">¶</a>ServiceEntry 一键接入外部服务</h3>
<p>以前我们想要将一个 <code>vm</code> 的服务单方向的接入系统，我们需要如下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">details-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">notexist.foo.cluster.local</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">STATIC</span></span><br></pre></td></tr></table></figure>
<p>此时我们访问 <code>notexist.foo.cluster.local</code> 依然会出现 <code>Could not resolve host</code> 的问题，解决办法是创建一个 <code>headless</code> 的 <code>service</code> 资源。</p>
<p>而现在不需要了，<code>ServiceEntry</code> 的对象会分配一个 <code>E Class IP</code>，因此我们进行解析的时候会获得一个 <code>IP</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># nslookup notexist.foo.cluster.local</span></span><br><span class="line">Server:         10.233.0.3</span><br><span class="line">Address:        10.233.0.3:53</span><br><span class="line"></span><br><span class="line">** server can<span class="string">&#x27;t find notexist.foo.cluster.local: NXDOMAIN</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Non-authoritative answer:</span></span><br><span class="line"><span class="string">Name:   notexist.foo.cluster.local</span></span><br><span class="line"><span class="string">Address: 240.240.12.17</span></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>isito</category>
      </categories>
      <tags>
        <tag>isito</tag>
      </tags>
  </entry>
  <entry>
    <title>istio locality load balancing not working</title>
    <url>/2023/01/20/networking/istio/feature/locality-load-balancing/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2022/202301200907733.png" alt=""></p>
<p>首先我们知道 isito 是支持 地域路由的，比较同地域优先。<a href="https://istio.io/latest/docs/tasks/traffic-management/locality-load-balancing/">istio locality-load-balancing</a> 但是此文档缺失验证，本篇意在从 Inside 来看看是是怎么工作的。</p>
<span id="more"></span>
<h2 id="易混关键词"><a class="header-anchor" href="#易混关键词">¶</a>易混关键词</h2>
<ul>
<li>Node: Istio 中的 Sidecar 节点（proxy节点）</li>
<li>KubeNode: k8s 中的 node 节点 (kubectl get nodes) 中的 node</li>
</ul>
<h2 id="正文"><a class="header-anchor" href="#正文">¶</a>正文</h2>
<p>首先因为地域路由肯定需要地域信息，对于 <code>当前节点</code> 和 <code>目标地址</code> 的地域信息。</p>
<h3 id="当前节点"><a class="header-anchor" href="#当前节点">¶</a>当前节点</h3>
<p>打开 Envoy 的控制台</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">istioctl dashboard envoy &lt;YOUR-POD&gt;</span><br></pre></td></tr></table></figure>
<p>然后看看 Config_Dump 中的 Node 中的 locality 信息 ( 没有也是正常的看下文 ）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;locality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cn-beijing&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;zone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cn-beijing-b&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="Istio-是如何获得这个值的"><a class="header-anchor" href="#Istio-是如何获得这个值的">¶</a>Istio 是如何获得这个值的</h4>
<p>代码在 <a href="https://github.com/istio/istio/blob/9e0d31bd287d28465b6cdfe2b9cc1e2711b3cd78/pkg/bootstrap/config.go#L622-L629">getNodeMeta</a> 中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> l *core.Locality</span><br><span class="line"><span class="keyword">if</span> meta.Labels[model.LocalityLabel] == <span class="string">&quot;&quot;</span> &amp;&amp; options.Platform != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="comment">// The locality string was not set, try to get locality from platform</span></span><br><span class="line">   l = options.Platform.Locality()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   localityString := model.GetLocalityLabelOrDefault(meta.Labels[model.LocalityLabel], <span class="string">&quot;&quot;</span>)</span><br><span class="line">   l = util.ConvertLocality(localityString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 isito 支持 GCP，aws 和 azure 自动获得这个信息，而其他的需要自己配置 LocalityLabel 这个 Label，也就是需要在 POD 中增加 这样的信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">istio-locality:</span> <span class="string">cn-beijing.cn-beijing-a</span></span><br></pre></td></tr></table></figure>
<h4 id="如果不存在的话"><a class="header-anchor" href="#如果不存在的话">¶</a>如果不存在的话</h4>
<p>当这个值不存在的时候，也不一定就完全不能工作。在下面有一个特殊的处理代码在<br>
<a href="https://github.com/istio/istio/blob/d3676a8318c5f1380b21ceb583d2d9016ec7c26b/pilot/pkg/xds/ads.go#L554-L594">https://github.com/istio/istio/blob/d3676a8318c5f1380b21ceb583d2d9016ec7c26b/pilot/pkg/xds/ads.go#L554-L594</a></p>
<p>在节点注册到 istiod 的时候，会有一个初始化的过程，初始化的时候会尝试从 Endpoint 里面去匹配出一个地域信息出来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initializeProxy completes the initialization of a proxy. It is expected to be called only after</span></span><br><span class="line"><span class="comment">// initProxyMetadata.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span></span> initializeProxy(node *core.Node, con *Connection) <span class="type">error</span> &#123;</span><br><span class="line">   proxy := con.proxy</span><br><span class="line">   <span class="comment">// this should be done before we look for service instances, but after we load metadata</span></span><br><span class="line">   <span class="comment">// TODO fix check in kubecontroller treat echo VMs like there isn&#x27;t a pod</span></span><br><span class="line">   <span class="keyword">if</span> err := s.WorkloadEntryController.RegisterWorkload(proxy, con.Connect); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   s.computeProxyState(proxy, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Get the locality from the proxy&#x27;s service instances.</span></span><br><span class="line">   <span class="comment">// We expect all instances to have the same IP and therefore the same locality.</span></span><br><span class="line">   <span class="comment">// So its enough to look at the first instance.</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(proxy.ServiceInstances) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      proxy.Locality = util.ConvertLocality(proxy.ServiceInstances[<span class="number">0</span>].Endpoint.Locality.Label)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If there is no locality in the registry then use the one sent as part of the discovery request.</span></span><br><span class="line">   <span class="comment">// This is not preferable as only the connected Pilot is aware of this proxies location, but it</span></span><br><span class="line">   <span class="comment">// can still help provide some client-side Envoy context when load balancing based on location.</span></span><br><span class="line">   <span class="keyword">if</span> util.IsLocalityEmpty(proxy.Locality) &#123;</span><br><span class="line">      proxy.Locality = &amp;core.Locality&#123;</span><br><span class="line">         Region:  node.Locality.GetRegion(),</span><br><span class="line">         Zone:    node.Locality.GetZone(),</span><br><span class="line">         SubZone: node.Locality.GetSubZone(),</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   locality := util.LocalityToString(proxy.Locality)</span><br><span class="line">   <span class="comment">// add topology labels to proxy metadata labels</span></span><br><span class="line">   proxy.Metadata.Labels = labelutil.AugmentLabels(proxy.Metadata.Labels, proxy.Metadata.ClusterID, locality, proxy.Metadata.Network)</span><br><span class="line">   <span class="comment">// Discover supported IP Versions of proxy so that appropriate config can be delivered.</span></span><br><span class="line">   proxy.DiscoverIPVersions()</span><br><span class="line"></span><br><span class="line">   proxy.WatchedResources = <span class="keyword">map</span>[<span class="type">string</span>]*model.WatchedResource&#123;&#125;</span><br><span class="line">   <span class="comment">// Based on node metadata and version, we can associate a different generator.</span></span><br><span class="line">   <span class="keyword">if</span> proxy.Metadata.Generator != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      proxy.XdsResourceGenerator = s.Generators[proxy.Metadata.Generator]</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果此实例有 ServiceInstance 的话，会尝试从相同 Entpoint 中去找到相对应的地域信息，而 endpoint 的地域信息是从 KubeNode 中获取的，可以看下文。</p>
<blockquote>
<p>这里比较抽象，下面举个例子</p>
</blockquote>
<h5 id="例子：无法生效的规则"><a class="header-anchor" href="#例子：无法生效的规则">¶</a>例子：无法生效的规则</h5>
<p>如下的例子里，只有一个DP，没有Service ，这个实例就无法获得 ServiceInstances 列表，自然无法从上面的逻辑中去拼凑出一个地域信息出来。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">netshoot</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">netshoot</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">netshoot</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">netshoot</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">netshoot</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nicolaka/netshoot</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment">#Always</span></span><br><span class="line">        <span class="attr">command:</span> [ <span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;--&quot;</span> ]</span><br><span class="line">        <span class="attr">args:</span> [ <span class="string">&quot;while true; do sleep 30; done;&quot;</span> ]</span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">128Mi</span></span><br></pre></td></tr></table></figure>
<h5 id="例子：可以生效的规则"><a class="header-anchor" href="#例子：可以生效的规则">¶</a>例子：可以生效的规则</h5>
<p>增加了一个Service 就可以生效了，因为可以获得  ServiceInstances 了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">netshoot</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">netshoot</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">netshoot</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">netshoot</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">netshoot</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">cr-cn-beijing.volces.com/ams-tools/netshoot:latest</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">command:</span> [ <span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;--&quot;</span> ]</span><br><span class="line">        <span class="attr">args:</span> [ <span class="string">&quot;while true; do sleep 30; done;&quot;</span> ]</span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">128Mi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">netshoot</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">netshoot</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http-echo</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">netshoot</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论就是，<br>
如果希望一个没有 Service 的实例开启地域感知，需要在实例配置 istio-locality 标签<br>
如果一个有 Service 的实例就不需要了</p>
</blockquote>
<h3 id="目的地址的地域信息"><a class="header-anchor" href="#目的地址的地域信息">¶</a>目的地址的地域信息</h3>
<p>同样的打开 Envoy 控制台，看  Cluster 信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">outbound|80||echo-web.default.svc.cluster.local::172.16.128.16:80::weight::1</span><br><span class="line">outbound|80||echo-web.default.svc.cluster.local::172.16.128.16:80::region::cn-beijing</span><br><span class="line">outbound|80||echo-web.default.svc.cluster.local::172.16.128.16:80::zone::cn-beijing-a</span><br><span class="line">outbound|80||echo-web.default.svc.cluster.local::172.16.128.16:80::sub_zone::</span><br><span class="line">outbound|80||echo-web.default.svc.cluster.local::172.16.128.16:80::canary::<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>这里后面有 region 值就是正确的</p>
<h4 id="Istio-是如何获得这个值的-v2"><a class="header-anchor" href="#Istio-是如何获得这个值的-v2">¶</a>Istio 是如何获得这个值的</h4>
<p>这部分的值是从 POD 所在的 Node 自动获取的，但是对于 Workentry 需要手动配置，因为没有Node信息。</p>
<h5 id="POD"><a class="header-anchor" href="#POD">¶</a>POD</h5>
<p><a href="https://github.com/istio/istio/blob/9e0d31bd287d28465b6cdfe2b9cc1e2711b3cd78/pilot/pkg/serviceregistry/kube/controller/controller.go#L892-L918">https://github.com/istio/istio/blob/9e0d31bd287d28465b6cdfe2b9cc1e2711b3cd78/pilot/pkg/serviceregistry/kube/controller/controller.go#L892-L918</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getPodLocality retrieves the locality for a pod.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> getPodLocality(pod *v1.Pod) <span class="type">string</span> &#123;</span><br><span class="line">   <span class="comment">// if pod has `istio-locality` label, skip below ops</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(pod.Labels[model.LocalityLabel]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> model.GetLocalityLabelOrDefault(pod.Labels[model.LocalityLabel], <span class="string">&quot;&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// NodeName is set by the scheduler after the pod is created</span></span><br><span class="line">   <span class="comment">// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#late-initialization</span></span><br><span class="line">   node, err := c.nodeLister.Get(pod.Spec.NodeName)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> pod.Spec.NodeName != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">         log.Warnf(<span class="string">&quot;unable to get node %q for pod %q/%q: %v&quot;</span>, pod.Spec.NodeName, pod.Namespace, pod.Name, err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   region := getLabelValue(node.ObjectMeta, NodeRegionLabelGA, NodeRegionLabel)</span><br><span class="line">   zone := getLabelValue(node.ObjectMeta, NodeZoneLabelGA, NodeZoneLabel)</span><br><span class="line">   subzone := getLabelValue(node.ObjectMeta, label.TopologySubzone.Name, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> region == <span class="string">&quot;&quot;</span> &amp;&amp; zone == <span class="string">&quot;&quot;</span> &amp;&amp; subzone == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> region + <span class="string">&quot;/&quot;</span> + zone + <span class="string">&quot;/&quot;</span> + subzone <span class="comment">// Format: &quot;%s/%s/%s&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="WorkloadEntry"><a class="header-anchor" href="#WorkloadEntry">¶</a>WorkloadEntry</h5>
<p>直接使用配置中的 Locality 字段来获取的。<br>
<a href="https://github.com/istio/istio/blob/9e0d31bd287d28465b6cdfe2b9cc1e2711b3cd78/pilot/pkg/serviceregistry/serviceentry/conversion.go#L277-L299">https://github.com/istio/istio/blob/9e0d31bd287d28465b6cdfe2b9cc1e2711b3cd78/pilot/pkg/serviceregistry/serviceentry/conversion.go#L277-L299</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">labels := labelutil.AugmentLabels(wle.Labels, clusterID, wle.Locality, networkID)</span><br><span class="line"><span class="keyword">return</span> &amp;model.ServiceInstance&#123;</span><br><span class="line">   Endpoint: &amp;model.IstioEndpoint&#123;</span><br><span class="line">      Address:         addr,</span><br><span class="line">      EndpointPort:    instancePort,</span><br><span class="line">      ServicePortName: servicePort.Name,</span><br><span class="line">      Network:         network.ID(wle.Network),</span><br><span class="line">      Locality: model.Locality&#123;</span><br><span class="line">         Label:     wle.Locality,</span><br><span class="line">         ClusterID: clusterID,</span><br><span class="line">      &#125;,</span><br><span class="line">      LbWeight:       wle.Weight,</span><br><span class="line">      Labels:         labels,</span><br><span class="line">      TLSMode:        tlsMode,</span><br><span class="line">      ServiceAccount: sa,</span><br><span class="line">      <span class="comment">// Workload entry config name is used as workload name, which will appear in metric label.</span></span><br><span class="line">      <span class="comment">// After VM auto registry is introduced, workload group annotation should be used for workload name.</span></span><br><span class="line">      WorkloadName: configKey.name,</span><br><span class="line">      Namespace:    configKey.namespace,</span><br><span class="line">   &#125;,</span><br><span class="line">   Service:     service,</span><br><span class="line">   ServicePort: convertPort(servicePort),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置区间路由"><a class="header-anchor" href="#配置区间路由">¶</a>配置区间路由</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">echo-web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">echo-web.default.svc.cluster.local</span></span><br><span class="line">  <span class="attr">trafficPolicy:</span></span><br><span class="line">    <span class="attr">connectionPool:</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">maxRequestsPerConnection:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">loadBalancer:</span></span><br><span class="line">      <span class="attr">localityLbSetting:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">outlierDetection:</span></span><br><span class="line">      <span class="attr">consecutive5xxErrors:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1s</span></span><br><span class="line">      <span class="attr">baseEjectionTime:</span> <span class="string">1m</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，配置同区域优先只需要配置 enabled: true 即可。<br>
但是一定要搭配使用 outlierDetection</p>
<p>在 1.13.4 的istio 版本还有一个值得注意的地方。如果在 workload 中一开始没有配置 locality，但是已经配置了 DestinationRule，此时再配置 locality 就无效，需要重新配置 DestinationRule</p>
<h3 id="数据面"><a class="header-anchor" href="#数据面">¶</a>数据面</h3>
<p>在 Envoy 中，其实有两种感知模式 zone_aware_lb_config 和 locality_weighted_lb_config，分别对应了客户端感知和服务端感知，在 istio 中，并没有使用前者，都是用了后者（换言之，控制策略都在服务端），因此，在 istio 最终配置下来的的策略中，我们需要关注的是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">outbound|80||echo-web.default.svc.cluster.local::172.16.128.66:80::region::cn-beijing</span><br><span class="line">outbound|80||echo-web.default.svc.cluster.local::172.16.128.66:80::zone::cn-beijing-b</span><br><span class="line">outbound|80||echo-web.default.svc.cluster.local::172.16.128.66:80::sub_zone::</span><br><span class="line">outbound|80||echo-web.default.svc.cluster.local::172.16.128.66:80::canary::<span class="literal">false</span></span><br><span class="line">outbound|80||echo-web.default.svc.cluster.local::172.16.128.66:80::priority::1</span><br><span class="line"></span><br><span class="line">outbound|80||echo-web.default.svc.cluster.local::172.16.128.17:80::region::cn-beijing</span><br><span class="line">outbound|80||echo-web.default.svc.cluster.local::172.16.128.17:80::zone::cn-beijing-a</span><br><span class="line">outbound|80||echo-web.default.svc.cluster.local::172.16.128.17:80::sub_zone::</span><br><span class="line">outbound|80||echo-web.default.svc.cluster.local::172.16.128.17:80::canary::<span class="literal">false</span></span><br><span class="line">outbound|80||echo-web.default.svc.cluster.local::172.16.128.17:80::priority::0</span><br></pre></td></tr></table></figure>
<p>看上面的两个 Cluster，权重高的是下面的，权重低的是上面。<br>
在这里有个 testcare 可以关注下 <a href="https://github.com/istio/istio/blob/d3676a8318c5f1380b21ceb583d2d9016ec7c26b/pilot/pkg/networking/core/v1alpha3/loadbalancer/loadbalancer_test.go#L83-L107">https://github.com/istio/istio/blob/d3676a8318c5f1380b21ceb583d2d9016ec7c26b/pilot/pkg/networking/core/v1alpha3/loadbalancer/loadbalancer_test.go#L83-L107</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.Run(<span class="string">&quot;Failover: all priorities&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   g := NewWithT(t)</span><br><span class="line">   env := buildEnvForClustersWithFailover()</span><br><span class="line">   cluster := buildFakeCluster()</span><br><span class="line">   ApplyLocalityLBSetting(cluster.LoadAssignment, <span class="literal">nil</span>, locality, <span class="literal">nil</span>, env.Mesh().LocalityLbSetting, <span class="literal">true</span>)</span><br><span class="line">   <span class="keyword">for</span> _, localityEndpoint := <span class="keyword">range</span> cluster.LoadAssignment.Endpoints &#123;</span><br><span class="line">      <span class="keyword">if</span> localityEndpoint.Locality.Region == locality.Region &#123;</span><br><span class="line">         <span class="keyword">if</span> localityEndpoint.Locality.Zone == locality.Zone &#123;</span><br><span class="line">            <span class="keyword">if</span> localityEndpoint.Locality.SubZone == locality.SubZone &#123;</span><br><span class="line">               g.Expect(localityEndpoint.Priority).To(Equal(<span class="type">uint32</span>(<span class="number">0</span>)))</span><br><span class="line">               <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            g.Expect(localityEndpoint.Priority).To(Equal(<span class="type">uint32</span>(<span class="number">1</span>)))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         g.Expect(localityEndpoint.Priority).To(Equal(<span class="type">uint32</span>(<span class="number">2</span>)))</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> localityEndpoint.Locality.Region == <span class="string">&quot;region2&quot;</span> &#123;</span><br><span class="line">         g.Expect(localityEndpoint.Priority).To(Equal(<span class="type">uint32</span>(<span class="number">3</span>)))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         g.Expect(localityEndpoint.Priority).To(Equal(<span class="type">uint32</span>(<span class="number">4</span>)))</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>生成的逻辑参考如下<br>
<a href="https://github.com/istio/istio/blob/d3676a8318c5f1380b21ceb583d2d9016ec7c26b/pilot/pkg/xds/eds.go#L333-L371">https://github.com/istio/istio/blob/d3676a8318c5f1380b21ceb583d2d9016ec7c26b/pilot/pkg/xds/eds.go#L333-L371</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span></span> generateEndpoints(b EndpointBuilder) *endpoint.ClusterLoadAssignment &#123;</span><br><span class="line">   llbOpts, err := s.llbEndpointAndOptionsForCluster(b)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> buildEmptyClusterLoadAssignment(b.clusterName)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Apply the Split Horizon EDS filter, if applicable.</span></span><br><span class="line">   llbOpts = b.EndpointsByNetworkFilter(llbOpts)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> model.IsDNSSrvSubsetKey(b.clusterName) &#123;</span><br><span class="line">      <span class="comment">// For the SNI-DNAT clusters, we are using AUTO_PASSTHROUGH gateway. AUTO_PASSTHROUGH is intended</span></span><br><span class="line">      <span class="comment">// to passthrough mTLS requests. However, at the gateway we do not actually have any way to tell if the</span></span><br><span class="line">      <span class="comment">// request is a valid mTLS request or not, since its passthrough TLS.</span></span><br><span class="line">      <span class="comment">// To ensure we allow traffic only to mTLS endpoints, we filter out non-mTLS endpoints for these cluster types.</span></span><br><span class="line">      llbOpts = b.EndpointsWithMTLSFilter(llbOpts)</span><br><span class="line">   &#125;</span><br><span class="line">   llbOpts = b.ApplyTunnelSetting(llbOpts, b.tunnelType)</span><br><span class="line"></span><br><span class="line">   l := b.createClusterLoadAssignment(llbOpts)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If locality aware routing is enabled, prioritize endpoints or set their lb weight.</span></span><br><span class="line">   <span class="comment">// Failover should only be enabled when there is an outlier detection, otherwise Envoy</span></span><br><span class="line">   <span class="comment">// will never detect the hosts are unhealthy and redirect traffic.</span></span><br><span class="line">   enableFailover, lb := getOutlierDetectionAndLoadBalancerSettings(b.DestinationRule(), b.port, b.subsetName)</span><br><span class="line">   lbSetting := loadbalancer.GetLocalityLbSetting(b.push.Mesh.GetLocalityLbSetting(), lb.GetLocalityLbSetting())</span><br><span class="line">   <span class="keyword">if</span> lbSetting != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// Make a shallow copy of the cla as we are mutating the endpoints with priorities/weights relative to the calling proxy</span></span><br><span class="line">      l = util.CloneClusterLoadAssignment(l)</span><br><span class="line">      wrappedLocalityLbEndpoints := <span class="built_in">make</span>([]*loadbalancer.WrappedLocalityLbEndpoints, <span class="built_in">len</span>(llbOpts))</span><br><span class="line">      <span class="keyword">for</span> i := <span class="keyword">range</span> llbOpts &#123;</span><br><span class="line">         wrappedLocalityLbEndpoints[i] = &amp;loadbalancer.WrappedLocalityLbEndpoints&#123;</span><br><span class="line">            IstioEndpoints:      llbOpts[i].istioEndpoints,</span><br><span class="line">            LocalityLbEndpoints: l.Endpoints[i],</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      loadbalancer.ApplyLocalityLBSetting(l, wrappedLocalityLbEndpoints, b.locality, b.proxy.Metadata.Labels, lbSetting, enableFailover)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此最终生效，只需要看 Cluster 中的数据是否已经按照期望的优先级排序即可验证想法。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>isito</category>
      </categories>
      <tags>
        <tag>isito</tag>
      </tags>
  </entry>
  <entry>
    <title>Isito 虚拟机健康检查</title>
    <url>/2022/07/23/networking/istio/how-it-works/vm-health-check/</url>
    <content><![CDATA[<p><img src="https://fastly.jsdelivr.net/gh/yanickxia/picture-bed@master/20220723234135.png" alt=""></p>
<p>今天我们聊聊 《Isito 虚拟机健康检查》</p>
<span id="more"></span>
<p>已知 Istio 对接入的 VM 有健康检查，对于 k8s 上的服务来说，Pod 中就包含了健康检查部分</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">goproxy</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">goproxy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">goproxy</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s.gcr.io/goproxy:0.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">readinessProbe:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>而对于 <code>VM</code> 接入的 <code>Workload</code>，<code>istio</code> 也提供了类似的能力。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">WorkloadGroup</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">bookinfo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/name:</span> <span class="string">reviews</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/version:</span> <span class="string">&quot;1.3.4&quot;</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="attr">grpc:</span> <span class="number">3550</span></span><br><span class="line">      <span class="attr">http:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">serviceAccount:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">probe:</span></span><br><span class="line">    <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">timeoutSeconds:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">periodSeconds:</span> <span class="number">4</span></span><br><span class="line">    <span class="attr">successThreshold:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">httpGet:</span></span><br><span class="line">     <span class="attr">path:</span> <span class="string">/foo/bar</span></span><br><span class="line">     <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">     <span class="attr">port:</span> <span class="number">3100</span></span><br><span class="line">     <span class="attr">scheme:</span> <span class="string">HTTPS</span></span><br><span class="line">     <span class="attr">httpHeaders:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Lit-Header</span></span><br><span class="line">       <span class="attr">value:</span> <span class="string">Im-The-Best</span></span><br></pre></td></tr></table></figure>
<p>这个如何工作的呢？我们今天就来探索下这个问题</p>
<h2 id="How-it-works"><a class="header-anchor" href="#How-it-works">¶</a>How it works</h2>
<h3 id="PerformApplicationHealthCheck"><a class="header-anchor" href="#PerformApplicationHealthCheck">¶</a>PerformApplicationHealthCheck</h3>
<p>在 <a href="https://github.com/istio/istio/blob/release-1.13/pkg/istio-agent/xds_proxy.go#L131-L235"><code>initXdsProxy</code></a> 函数中，我们可以看到，<code>istio-agent</code> 在初始化的时候会创建一个 <code>xds.Proxy</code> 对象，这个对象会被用来处理一些工作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> proxy.healthChecker.PerformApplicationHealthCheck(<span class="function"><span class="keyword">func</span><span class="params">(healthEvent *health.ProbeEvent)</span></span> &#123;</span><br><span class="line">		<span class="comment">// Store the same response as Delta and SotW. Depending on how Envoy connects we will use one or the other.</span></span><br><span class="line">    <span class="comment">// 这里根据 PerformApplicationHealthCheck 执行的结果，创建不同的 DiscoveryRequest 分别对应 健康状态下 与 非健康状态</span></span><br><span class="line">		<span class="keyword">var</span> req *discovery.DiscoveryRequest</span><br><span class="line">		<span class="keyword">if</span> healthEvent.Healthy &#123;</span><br><span class="line">			req = &amp;discovery.DiscoveryRequest&#123;TypeUrl: v3.HealthInfoType&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			req = &amp;discovery.DiscoveryRequest&#123;</span><br><span class="line">				TypeUrl: v3.HealthInfoType,</span><br><span class="line">				ErrorDetail: &amp;google_rpc.Status&#123;</span><br><span class="line">					Code:    <span class="type">int32</span>(codes.Internal),</span><br><span class="line">					Message: healthEvent.UnhealthyMessage,</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		proxy.PersistRequest(req)</span><br><span class="line">    <span class="comment">// skip DeltaDiscoveryRequest </span></span><br><span class="line">	&#125;, proxy.stopChan)</span><br></pre></td></tr></table></figure>
<p>对于 <a href="https://github.com/istio/istio/blob/release-1.13/pkg/istio-agent/health/health_check.go#L129-L192"><code>PerformApplicationHealthCheck</code></a> 这里就不做展开，大致上也就是模拟发个请求。</p>
<h3 id="HealthInfoType-DiscoveryRequest"><a class="header-anchor" href="#HealthInfoType-DiscoveryRequest">¶</a>HealthInfoType DiscoveryRequest</h3>
<p>那我们发给 <code>Poilt</code> 的 <code>DiscoveryRequest</code> 有何作用呢，我们继续往下探索。</p>
<p>在 <a href="https://github.com/istio/istio/blob/release-1.13/pilot/pkg/xds/ads.go#L659-L666"><code>shouldProcessRequest</code></a> 中我们可以看到如下代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> features.WorkloadEntryHealthChecks &#123;</span><br><span class="line">  event := workloadentry.HealthEvent&#123;&#125;</span><br><span class="line">  event.Healthy = req.ErrorDetail == <span class="literal">nil</span> <span class="comment">// 如果 ErrorDetail 不为 null 就是不健康</span></span><br><span class="line">  <span class="keyword">if</span> !event.Healthy &#123;</span><br><span class="line">    event.Message = req.ErrorDetail.Message </span><br><span class="line">  &#125;</span><br><span class="line">  s.WorkloadEntryController.QueueWorkloadEntryHealth(proxy, event) <span class="comment">// 触发到 QueueWorkloadEntryHealth 中 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在 <a href="https://github.com/istio/istio/blob/release-1.13/pilot/pkg/controller/workloadentry/workloadentry_controller.go#L414-L427"><code>QueueWorkloadEntryHealth</code></a> 中的逻辑也是非常的简单的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> QueueWorkloadEntryHealth(proxy *model.Proxy, event HealthEvent) &#123;</span><br><span class="line">	<span class="comment">// replace the updated status</span></span><br><span class="line">	wle := status.UpdateConfigCondition(*cfg, condition.condition)</span><br><span class="line">	<span class="comment">// update the status</span></span><br><span class="line">	_, err := c.store.UpdateStatus(wle)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们对于 <code>workloadEntry</code> 的逻辑已经完全完成。</p>
<h3 id="ServiceRegistry-Controller"><a class="header-anchor" href="#ServiceRegistry-Controller">¶</a>ServiceRegistry Controller</h3>
<p>在 <a href="https://github.com/istio/istio/blob/release-1.13/pilot/pkg/serviceregistry/kube/controller/controller.go#L923-L947"><code>InstancesByPort</code></a> 这里我们并不回返回哪些不健康的实例，那这部分是如何实现的呢？</p>
<p>在 <a href="https://github.com/istio/istio/blob/1dbd193cf990ce42810b2627d2251f0ad67d496a/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go#L162-L277"><code>workloadEntryHandler</code></a> 中，我们发现处理的地方。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceEntryStore)</span></span> workloadEntryHandler(old, curr config.Config, event model.Event) &#123;</span><br><span class="line">	<span class="comment">// If an entry is unhealthy, we will mark this as a delete instead</span></span><br><span class="line">	<span class="comment">// This ensures we do not track unhealthy endpoints</span></span><br><span class="line">	<span class="keyword">if</span> features.WorkloadEntryHealthChecks &amp;&amp; !isHealthy(curr) &#123;</span><br><span class="line">		event = model.EventDelete</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面太长了，可以阅读原文，大致上触发了删除内存中的 ServiceInstance，并且触发一个 EdsUpdate</span></span><br><span class="line"></span><br><span class="line">  s.serviceInstances.deleteInstances(key, instancesDeleted)</span><br><span class="line">	<span class="keyword">if</span> event == model.EventDelete &#123;</span><br><span class="line">		s.workloadInstances.<span class="built_in">delete</span>(types.NamespacedName&#123;Namespace: curr.Namespace, Name: curr.Name&#125;)</span><br><span class="line">		s.serviceInstances.deleteInstances(key, instancesUpdated)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		s.workloadInstances.update(wi)</span><br><span class="line">		s.serviceInstances.updateInstances(key, instancesUpdated)</span><br><span class="line">	&#125;</span><br><span class="line">	s.mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>


<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: ',
	 'pliotAgent->workloadController: 1. registy',
	 'workloadController->kube: 2. create workload entry',
   'pliotAgent->workloadController: 3. send HealthInfoType',
   'workloadController->kube: 4. update status',
   'workloadController->configStore: 5. delete or create service Instance',
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://github.com/istio/istio/blob/release-1.13/pilot/pkg/serviceregistry/serviceregistry_test.go#L890-L923">Service selects WorkloadEntry</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>isito</category>
        <category>how-it-work</category>
      </categories>
      <tags>
        <tag>isito</tag>
        <tag>how-it-work</tag>
      </tags>
  </entry>
  <entry>
    <title>Isito 1.10.x 更新解读</title>
    <url>/2021/05/19/networking/istio/upgrade/1.10.x/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210519134744.png" alt=""></p>
<p>原文: <a href="https://istio.io/latest/news/releases/1.10.x/announcing-1.10/">https://istio.io/latest/news/releases/1.10.x/announcing-1.10/</a></p>
<span id="more"></span>
<h2 id="新功能"><a class="header-anchor" href="#新功能">¶</a>新功能</h2>
<h3 id="Discovery-Selectors"><a class="header-anchor" href="#Discovery-Selectors">¶</a>Discovery Selectors</h3>
<p>针对大规模的集群下，有部分的 Namespace 会经常的进行快速变动，创建很多临时的 Pod/Service，会带来 Istiod 监听之后Push xDS 的压力变大。因此增加了一个新特性，来忽略部分 namespace</p>
<ol>
<li>我们首先对 Ns 标记上特定标签</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label namespace default istio-discovery=enabled</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改 Istio 的全局配置</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">meshConfig:</span></span><br><span class="line">  <span class="attr">discoverySelectors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">matchLabels:</span></span><br><span class="line">        <span class="attr">istio-discovery:</span> <span class="string">enabled</span></span><br></pre></td></tr></table></figure>
<p>这样 istiod 仅仅会监听 default 这个 namespace</p>
<h4 id="Discovery-Selectors-vs-Sidecar-Resource"><a class="header-anchor" href="#Discovery-Selectors-vs-Sidecar-Resource">¶</a>Discovery Selectors vs Sidecar Resource</h4>
<p><code>discoverySelectors</code> 是全局性配置并且仅仅针对 <code>istiod</code> 生效，和 <code>sidecarResource</code> 功能有重叠，<br>
<code>Discovery Selectors</code> 相较于 <code>Sidecar</code> 的使用难度，低了很多，对于大部分的场景下，我们仅仅希望忽略一些 <code>namespace</code>，会比 <code>sidecar</code> 要好用些。</p>
<h3 id="Stable-revision-labels-experimental"><a class="header-anchor" href="#Stable-revision-labels-experimental">¶</a>Stable revision labels (experimental)</h3>
<p>在以前的版本中，我们也讨论过灰度升级的方案，<a href="https://istio.io/v1.9/docs/setup/upgrade/canary/">Istioldie 1.9 / Canary Upgrades</a></p>
<p>我们部署多个版本，通过 <code>revision</code> 进行区分。</p>
<figure class="highlight bash"><figcaption><span>istio-1.9.x</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl get pods -n istio-system -l app=istiod</span><br><span class="line"></span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">istiod-786779888b-p9s5n                 1/1     Running   0          114m</span><br><span class="line">istiod-canary-6956db645c-vwhsk          1/1     Running   0          1m</span><br></pre></td></tr></table></figure>
<p>而在这个版本中，我们增加一个新的映射 (by Label)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">istioctl x revision tag <span class="built_in">set</span> prod --revision 1-7-6</span><br><span class="line">istioctl x revision tag <span class="built_in">set</span> canary --revision 1-8-0</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210519135037.png" alt=""></p>
<p>Namespaces A and B -&gt; 1-7-6,<br>
Namespace C -&gt; 1-8-0</p>
<p>我们现在仅仅需要修改 <code>tag</code> 即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">istioctl x revision tag <span class="built_in">set</span> prod --revision 1-8-0</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210519135117.png" alt=""></p>
<p>相较于之前的版本，我们多一层抽象，这样可以保持 <code>Namespace</code> <code>Label</code> 的稳定，对于升级的行为就完全控制在 istio 的 scope 内。</p>
<h3 id="Sidecar-Networking-Changes"><a class="header-anchor" href="#Sidecar-Networking-Changes">¶</a>Sidecar Networking Changes</h3>
<p>在 istio 1.10 之前，所有的外部流量都会被重定向到 lo</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210519135150.png" alt=""></p>
<p>这样有个问题，就是导致了如果应用仅仅 listen on eth0 就会导致无法处理，从 1.10 之后</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210519135216.png" alt=""></p>
<p>所有的流量都从 eth0 进出，这样要注意，如果在 localhost 进行模拟测试会导致未经过 istio sidecar 的处理。</p>
<h2 id="废弃项"><a class="header-anchor" href="#废弃项">¶</a>废弃项</h2>
<ul>
<li>Kubernetes 第一方 JWT 支持（values.global.jwtPolicy=first-party-jwt）将被删除；它的安全性较低，仅用于向后兼容旧版 Kubernetes。</li>
<li>values.global.arch 选项已经被 Kubernetes 配置中的 Affinity 设置所取代。</li>
</ul>
<h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2>
<ul>
<li>更新了网站的UI，变的更好看些</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>isito</category>
      </categories>
      <tags>
        <tag>isito</tag>
      </tags>
  </entry>
  <entry>
    <title>Isito 1.11.x 更新解读</title>
    <url>/2021/09/10/networking/istio/upgrade/1.11.x/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210910154051.png" alt=""></p>
<span id="more"></span>
<h2 id="CNI-plugin-Beta"><a class="header-anchor" href="#CNI-plugin-Beta">¶</a>CNI plugin (Beta)</h2>
<p>Istio / Install Istio with the Istio CNI plugin<br>
CNI 依然是 Beta ……</p>
<h2 id="External-control-plane-Beta"><a class="header-anchor" href="#External-control-plane-Beta">¶</a>External control plane (Beta)</h2>
<p><a href="https://istio.io/latest/docs/setup/install/external-controlplane/">Istio / Install Istio with an External Control Plane</a><br>
相较于我们现在的 多集群 部署方式，此次更新增加了一个独立的新模式</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210910153835.png" alt=""></p>
<p>而这样部署的缺点是，因为我们所有的配置项都需要配置在主集群中，因此我们为整个网格配置一个独立的 ETCD</p>
<p>现在社区增加了一个独立模式</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210910153926.png" alt=""></p>
<p>区别在于我们可以将 istiod 完全的独立部署出来，因此我们可以在一个独立集群中部署多个istiod给不同的集群，值得注意的是，配置项也不再配置在 istiod 的集群中，而是选择一个 remote cluster 作为配置源（vs 等）。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">install.istio.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IstioOperator</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">external-istiod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">profile:</span> <span class="string">external</span></span><br><span class="line">  <span class="attr">values:</span></span><br><span class="line">    <span class="attr">global:</span></span><br><span class="line">      <span class="attr">istioNamespace:</span> <span class="string">external-istiod</span></span><br><span class="line">      <span class="attr">configCluster:</span> <span class="literal">true</span>  <span class="string">&lt;-----</span> <span class="string">配置源</span></span><br></pre></td></tr></table></figure>
<h2 id="Gateway-injection"><a class="header-anchor" href="#Gateway-injection">¶</a>Gateway injection</h2>
<p>1.11 之前的版本 ingress 组件是直接和 istiod 连接，下发配置，从而进行转发，不需要额外的 sidecar ，而此版本将此和普通pod一样处理，作为一个 sidecar 注入 gateway 之中，就可以把 gateway 想象成一个空 程序 + sidecar。<br>
带来最大的区别是， sidecar 的注入是由 istiod (webhook + template) 控制的，因此我们升级 istiod 之后可以直接删除 gateway 以更新到最新版，而之前的模式需要更新 Deployment 镜像。</p>
<h2 id="Kubernetes-Multi-cluster-Services-MCS-support-Experimental"><a class="header-anchor" href="#Kubernetes-Multi-cluster-Services-MCS-support-Experimental">¶</a>Kubernetes Multi-cluster Services (MCS) support (Experimental)</h2>
<p>对官网 MCS 的支持，Experimental 还比较早期</p>
<h2 id="Sneak-peek-new-APIs"><a class="header-anchor" href="#Sneak-peek-new-APIs">¶</a>Sneak peek: new APIs</h2>
<p>社区也发现 EnvoyFilter 贼用了，<a href="https://docs.google.com/document/d/1jFuZM4UCKw6AMDmXMIYqbdlyJk95ut2zMPLSNdrUtW8/edit">Istio Extensions API - Google 文档</a><br>
试图使用新的 API 来替换</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>isito</category>
      </categories>
      <tags>
        <tag>isito</tag>
      </tags>
  </entry>
  <entry>
    <title>LSM Tree 与 LevelDB</title>
    <url>/2020/11/08/algorithm/lsm-tree/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/11/09/Sgjak.png" alt="Sgjak.png"></p>
<p>我们在 <a href="/2020/10/16/rust/talent-plan/project-2/"><code>Rust Project 2: Log-structured file I/O 解读</code></a> 中已经实践过一个 <code>log-structed map</code>，我们今天看看真实世界的 <code>log-structured merge-tree</code>，这是一个优化 <code>写</code> 操作的数据结构。</p>
<span id="more"></span>
<h2 id="LSM-Tree"><a class="header-anchor" href="#LSM-Tree">¶</a>LSM Tree</h2>
<p>在原始的 <a href="http://paperhub.s3.amazonaws.com/18e91eb4db2114a06ea614f0384f2784.pdf"><code>The Log-Structured Merge-Tree (LSM Tree)</code></a> 的设计中，我们在内存中维护一个 C<sub>0</sub>  树，我们不断的向这个树中  <code>Append</code> 数据，当内存中的 C<sub>0</sub> 超过一定大小，我们将部分数据落入磁盘的 C<sub>1</sub> 树，分级之后还有 C<sub>2</sub> 树 C<sub>3</sub> 树 C<sub>K</sub> 树，每一颗树都比前一颗树更大。不过在 <code>LevelDB</code> 中的设计有所形变。</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201108220445.png" alt="lsm tree"></p>
<h3 id="SSTables"><a class="header-anchor" href="#SSTables">¶</a>SSTables</h3>
<p>在 <code>LevelDB</code> 的 <code>LSM Tree</code> 的数据结构中，我们映射到持久化的磁盘对象时候用的对象叫 <code>SSTable [Sorted Strings Table]</code> 在 <code>SSTABLE</code> 中由多个 <code>Segement</code> 构成，这和我们在 <code>LS file system</code> 中一样，减少小碎片文件的写入。</p>
<p><img src="https://s3.jpg.cm/2020/11/08/S4nBu.png" alt="S4nBu.png"></p>
<p>不过值得注意的，在 <code>Segment</code> 中的 <code>KV</code> 对象都是排序好的。</p>
<h3 id="写入数据"><a class="header-anchor" href="#写入数据">¶</a>写入数据</h3>
<p>所有的数据在一开始，我们都先通过 <code>WAL LOG</code> 落盘，方便断电恢复。</p>
<p>和大部分的数据库一样，我们还是要在内存中维护一个 <code>索引</code> 关系，这里我们一般使用 <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree"><code>红黑树</code></a></p>
<p>写操作被存储在这个红黑树中，直到树达到预定义的大小。一旦红黑树有了足够的条目，它将作为磁盘上排序后的一个段刷新到磁盘上。</p>
<p><img src="https://s3.jpg.cm/2020/11/08/S4dmX.png" alt="S4dmX.png"></p>
<p>在内存中的阶段一般也称之为 <code>memtable</code>，因为此时还没写入磁盘，我们依然需要提供可检索的能力。</p>
<h4 id="Write-In-LevelDB"><a class="header-anchor" href="#Write-In-LevelDB">¶</a>Write In LevelDB</h4>
<p>在 <code>leveldb</code> 的实现定义中，写入的操作如下定义</p>
<figure class="highlight cpp"><figcaption><span>db_impl.cc</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Put</span><span class="params">(<span class="type">const</span> WriteOptions&amp; o, <span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> DB::<span class="built_in">Put</span>(o, key, val);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>WriteOptions 控制着我们是否需要 <code>sync</code>，也就是刷到磁盘上</li>
</ul>
<h5 id="Write-Log"><a class="header-anchor" href="#Write-Log">¶</a>Write Log</h5>
<p>真实的写操作</p>
<figure class="highlight cpp"><figcaption><span>db_impl.cc</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>&#123;</span><br><span class="line">  <span class="function">Writer <span class="title">w</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  w.batch = updates;</span><br><span class="line">  w.sync = options.sync;</span><br><span class="line">  w.done = <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  writers_.<span class="built_in">push_back</span>(&amp;w);</span><br><span class="line">  <span class="comment">// 排队写入，直到我们在 front</span></span><br><span class="line">  <span class="keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.<span class="built_in">front</span>()) &#123;</span><br><span class="line">    w.cv.<span class="built_in">Wait</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果已经完成，就直接返回，这里注意就是因为上面的Wait，有可能在队列里面已经被其他人消费了。</span></span><br><span class="line">  <span class="keyword">if</span> (w.done) &#123;</span><br><span class="line">    <span class="keyword">return</span> w.status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// May temporarily unlock and wait.</span></span><br><span class="line">  Status status = <span class="built_in">MakeRoomForWrite</span>(updates == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">uint64_t</span> last_sequence = versions_-&gt;<span class="built_in">LastSequence</span>(); <span class="comment">// 拿到最新的序列号</span></span><br><span class="line">  Writer* last_writer = &amp;w;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; updates != <span class="literal">nullptr</span>) &#123;  <span class="comment">// nullptr batch is for compactions</span></span><br><span class="line">    WriteBatch* write_batch = <span class="built_in">BuildBatchGroup</span>(&amp;last_writer); <span class="comment">// 这里会把 writers 队列中的其他适合的写操作一起执行</span></span><br><span class="line">    WriteBatchInternal::<span class="built_in">SetSequence</span>(write_batch, last_sequence + <span class="number">1</span>); <span class="comment">// 将序号 +1</span></span><br><span class="line">    last_sequence += WriteBatchInternal::<span class="built_in">Count</span>(write_batch); <span class="comment">// 因为这里有聚合操作，所以序号 + N</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      mutex_.<span class="built_in">Unlock</span>(); <span class="comment">// 把锁释放了，因为我们已经从 writers 中拿到了我们想要的数据，而且 SEQ 也已经定下来的了</span></span><br><span class="line">      status = log_-&gt;<span class="built_in">AddRecord</span>(WriteBatchInternal::<span class="built_in">Contents</span>(write_batch)); <span class="comment">// 写入 WAL Log</span></span><br><span class="line">      <span class="type">bool</span> sync_error = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; options.sync) &#123;</span><br><span class="line">        status = logfile_-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          sync_error = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        status = WriteBatchInternal::<span class="built_in">InsertInto</span>(write_batch, mem_); <span class="comment">// 这里写入，mem_ 是 MemTable，也就是在内存中的那些数据</span></span><br><span class="line">      &#125;</span><br><span class="line">      mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (sync_error) &#123;</span><br><span class="line">        <span class="built_in">RecordBackgroundError</span>(status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (write_batch == tmp_batch_) tmp_batch_-&gt;<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">    versions_-&gt;<span class="built_in">SetLastSequence</span>(last_sequence);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .... 唤醒机制</span></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div>
    <label class="author-mark-label">作者注</label>
    <p class="author-mark">如果希望通过 Debug 来阅读代码，可以在 db_test.cc 中设定断点。</p>
</div>
<p>从上面的代码我们可以看到如何处理 <code>WAL log</code> 的逻辑，下一步就是如何写入我们的 <code>memtable</code> 中了。</p>
<figure class="highlight cpp"><figcaption><span>write_batch.cc</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteBatchInternal::InsertInto</span><span class="params">(<span class="type">const</span> WriteBatch* b, MemTable* memtable)</span> </span>&#123;</span><br><span class="line">  MemTableInserter inserter;</span><br><span class="line">  inserter.sequence_ = WriteBatchInternal::<span class="built_in">Sequence</span>(b);</span><br><span class="line">  inserter.mem_ = memtable;</span><br><span class="line">  <span class="keyword">return</span> b-&gt;<span class="built_in">Iterate</span>(&amp;inserter); <span class="comment">//创建一个 Inserter，然后将其插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Write-MemTable"><a class="header-anchor" href="#Write-MemTable">¶</a>Write MemTable</h5>
<p>跳过中间那些 foreach 执行的部分，我们看看真正的 <code>PUT</code> 逻辑，在 <code>MemTableInserter::Put</code> 中</p>
<figure class="highlight cpp"><figcaption><span>MemTableInserter::Put</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  mem_-&gt;<span class="built_in">Add</span>(sequence_, kTypeValue, key, value);</span><br><span class="line">  sequence_++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MemTable Add 的逻辑很简单，开辟空间，扔进去</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemTable::Add</span><span class="params">(SequenceNumber s, ValueType type, <span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> key_size = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">size_t</span> val_size = value.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">size_t</span> internal_key_size = key_size + <span class="number">8</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> encoded_len = <span class="built_in">VarintLength</span>(internal_key_size) +</span><br><span class="line">                             internal_key_size + <span class="built_in">VarintLength</span>(val_size) +</span><br><span class="line">                             val_size;</span><br><span class="line">  <span class="comment">// 开辟一个 buf 空间给这个 kv</span></span><br><span class="line">  <span class="type">char</span>* buf = arena_.<span class="built_in">Allocate</span>(encoded_len);</span><br><span class="line">  <span class="type">char</span>* p = <span class="built_in">EncodeVarint32</span>(buf, internal_key_size);</span><br><span class="line">  <span class="comment">// copy 进去</span></span><br><span class="line">  std::<span class="built_in">memcpy</span>(p, key.<span class="built_in">data</span>(), key_size);</span><br><span class="line">  p += key_size;</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(p, (s &lt;&lt; <span class="number">8</span>) | type);</span><br><span class="line">  p += <span class="number">8</span>;</span><br><span class="line">  p = <span class="built_in">EncodeVarint32</span>(p, val_size);</span><br><span class="line">  std::<span class="built_in">memcpy</span>(p, value.<span class="built_in">data</span>(), val_size);</span><br><span class="line">  <span class="built_in">assert</span>(p + val_size == buf + encoded_len);</span><br><span class="line">  <span class="comment">// 将索引写入 Table 中 [其实是SkipList] </span></span><br><span class="line">  table_.<span class="built_in">Insert</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>SkipList</code> 就不做多解释了。</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201109171348.png" alt=""></p>
<p>详细<a href="#%E5%8F%82%E8%80%83">参考</a>。</p>
<h5 id="Write-Disk"><a class="header-anchor" href="#Write-Disk">¶</a>Write Disk</h5>
<p>而对于 <code>MemTable</code> 满了如何写入磁盘，这里的操作在我们略过的 <code>MakeRoomForWrite</code> 中</p>
<figure class="highlight cpp"><figcaption><span>DBImpl::MakeRoomForWrite</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::MakeRoomForWrite</span><span class="params">(<span class="type">bool</span> force)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="type">bool</span> allow_delay = !force;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="comment">// ... 中间跳过了很多 case</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Attempt to switch to a new memtable and trigger compaction of old</span></span><br><span class="line">      <span class="comment">// 尝试创建一个新的 memtable，并且将 旧数据进行压实</span></span><br><span class="line">      <span class="built_in">assert</span>(versions_-&gt;<span class="built_in">PrevLogNumber</span>() == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建了一个新的日志文件</span></span><br><span class="line">      <span class="type">uint64_t</span> new_log_number = versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">      WritableFile* lfile = <span class="literal">nullptr</span>;</span><br><span class="line">      s = env_-&gt;<span class="built_in">NewWritableFile</span>(<span class="built_in">LogFileName</span>(dbname_, new_log_number), &amp;lfile);</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        versions_-&gt;<span class="built_in">ReuseFileNumber</span>(new_log_number);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> log_;</span><br><span class="line">      <span class="keyword">delete</span> logfile_;</span><br><span class="line">      logfile_ = lfile;</span><br><span class="line">      logfile_number_ = new_log_number;</span><br><span class="line">      log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(lfile);</span><br><span class="line">      imm_ = mem_;</span><br><span class="line">      has_imm_.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建一个新的 MemTable</span></span><br><span class="line">      mem_ = <span class="keyword">new</span> <span class="built_in">MemTable</span>(internal_comparator_);</span><br><span class="line">      mem_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">      force = <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找寻恰当的时候进行压实</span></span><br><span class="line">      <span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CompactMemTable"><a class="header-anchor" href="#CompactMemTable">¶</a>CompactMemTable</h5>
<figure class="highlight cpp"><figcaption><span>DBImpl::CompactMemTable</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::CompactMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="built_in">assert</span>(imm_ != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the memtable as a new Table</span></span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  Version* base = versions_-&gt;<span class="built_in">current</span>();</span><br><span class="line">  base-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  Status s = <span class="built_in">WriteLevel0Table</span>(imm_, &amp;edit, base); <span class="comment">// 内存的数据往 level0 写，最近的数据嘛</span></span><br><span class="line">  base-&gt;<span class="built_in">Unref</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    s = Status::<span class="built_in">IOError</span>(<span class="string">&quot;Deleting DB during memtable compaction&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除值"><a class="header-anchor" href="#删除值">¶</a>删除值</h4>
<p>和之前处理逻辑一样，我们增加一个特殊的值，<code>append</code> 到 <code>log</code> 中，标记此值已死亡。</p>
<h3 id="读取数据"><a class="header-anchor" href="#读取数据">¶</a>读取数据</h3>
<p>为了方便在 <code>SSTable</code> 中查询数据。<code>Index Table</code> 被放置于每一个 <code>SSTable</code> 的尾端，一般是 <code>sparse index [稀疏索引]</code>，我们载入这个块的时候，讲 <code>Index Table</code> 载入内存，提供查询的能力。</p>
<p><img src="https://s3.jpg.cm/2020/11/08/S4e9D.png" alt="S4e9D.png"></p>
<p>当我们查找某个 <code>Key</code>，比如 <code>Dollar</code> 这个值势必在 <code>dog</code> 和 <code>downgrade</code> 之间，因此我们只需要扫描 <code>17208</code> 到 <code>19504</code> 但是如果数据没有的情况下，我们可能会扫描全表，因此我们加入 <a href="https://yetanotherdevblog.com/bloom-filters/"><code>bloom filter</code></a> 来帮助我们快速确认是否某个值根本不存在。</p>
<h4 id="精准读"><a class="header-anchor" href="#精准读">¶</a>精准读</h4>
<p>考虑下这样数据结构下的读操作</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201108222116.png" alt=""></p>
<p>如果我们想要读取 <code>23</code> 的值得话，按照图中标示的顺序，会先读取内存，在从<code>Level0</code>依次往高层读取，直到找到<code>key=23</code>的数据。</p>
<blockquote>
<p>这大概也是 LevelDB 的由来吧</p>
</blockquote>
<hr>
<p>不过显然每次去磁盘读取并不会快。因此至少有一些部分可以优化</p>
<ul>
<li>将所有的 <code>SSTable</code> 的 <code>Index</code>  保存在内存中</li>
<li>尽可能的多缓存我们的 <code>SSTable</code> 在内存中</li>
</ul>
<h4 id="Read-In-LevelDB"><a class="header-anchor" href="#Read-In-LevelDB">¶</a>Read In LevelDB</h4>
<figure class="highlight cpp"><figcaption><span>DBImpl::Get</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Get</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options, <span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::string* value)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先限制下最新的数据到哪里</span></span><br><span class="line">  <span class="keyword">if</span> (options.snapshot != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    snapshot =</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;<span class="built_in">sequence_number</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    snapshot = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemTable* mem = mem_;</span><br><span class="line">  MemTable* imm = imm_;</span><br><span class="line">  Version* current = versions_-&gt;<span class="built_in">current</span>();</span><br><span class="line">  mem-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  current-&gt;<span class="built_in">Ref</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> have_stat_update = <span class="literal">false</span>;</span><br><span class="line">  Version::GetStats stats;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">    <span class="comment">// 这里我们先去 mem 中获取也就是内存中的</span></span><br><span class="line">    <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">      <span class="comment">// 然后尝试从 imm，也就是即将持久化的内存对象中找</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">nullptr</span> &amp;&amp; imm-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 最后才从其他地方找</span></span><br><span class="line">      s = current-&gt;<span class="built_in">Get</span>(options, lkey, value, &amp;stats);</span><br><span class="line">      have_stat_update = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  mem-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  current-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 <code>mem</code> 和 <code>imm</code> 中没办法找到之后采去 <code>level</code> 文件中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Version::Get</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options, <span class="type">const</span> LookupKey&amp; k,</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::string* value, GetStats* stats)</span> </span>&#123;</span><br><span class="line">  stats-&gt;seek_file = <span class="literal">nullptr</span>;</span><br><span class="line">  stats-&gt;seek_file_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Match</span><span class="params">(<span class="type">void</span>* arg, <span class="type">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">      State* state = <span class="built_in">reinterpret_cast</span>&lt;State*&gt;(arg);</span><br><span class="line"></span><br><span class="line">      state-&gt;last_file_read = f;</span><br><span class="line">      state-&gt;last_file_read_level = level;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 从内存缓存的 `table cache`中查找，不过这里我们只缓存了 `key`，`value` 在里面还需要取一下</span></span><br><span class="line">      <span class="comment">// PS: Table Cache 是基于 LRU 实现的</span></span><br><span class="line">      state-&gt;s = state-&gt;vset-&gt;table_cache_-&gt;<span class="built_in">Get</span>(*state-&gt;options, f-&gt;number,</span><br><span class="line">                                                f-&gt;file_size, state-&gt;ikey,</span><br><span class="line">                                                &amp;state-&gt;saver, SaveValue);</span><br><span class="line">      <span class="keyword">if</span> (!state-&gt;s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">ForEachOverlapping</span>(state.saver.user_key, state.ikey, &amp;state, &amp;State::Match);</span><br><span class="line">  <span class="keyword">return</span> state.found ? state.s : Status::<span class="built_in">NotFound</span>(<span class="built_in">Slice</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TableCache::Get</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options, <span class="type">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">uint64_t</span> file_size, <span class="type">const</span> Slice&amp; k, <span class="type">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">void</span> (*handle_result)(<span class="type">void</span>*, <span class="type">const</span> Slice&amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> Slice&amp;))</span> </span>&#123;</span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 找到对应的 Table</span></span><br><span class="line">  Status s = <span class="built_in">FindTable</span>(file_number, file_size, &amp;handle);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// 找到了 Table，我们下面就去取这个 Value 在 InternalGet，这里不展开了。</span></span><br><span class="line">    Table* t = <span class="built_in">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;<span class="built_in">Value</span>(handle))-&gt;table;</span><br><span class="line">    s = t-&gt;<span class="built_in">InternalGet</span>(options, k, arg, handle_result);</span><br><span class="line">    cache_-&gt;<span class="built_in">Release</span>(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们没有找到，那种按照层级查找的代码啊？其实我们漏了一个很重要的函数也就是 <code>ForEachOverlapping</code></p>
<figure class="highlight cpp"><figcaption><span>Version::ForEachOverlapping</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Version::ForEachOverlapping</span><span class="params">(Slice user_key, Slice internal_key, <span class="type">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">bool</span> (*func)(<span class="type">void</span>*, <span class="type">int</span>, FileMetaData*))</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> Comparator* ucmp = vset_-&gt;icmp_.<span class="built_in">user_comparator</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search level-0 in order from newest to oldest.</span></span><br><span class="line">  <span class="comment">// 从 Level-0 开始的逆序查找，因为大部分时候，Level-0 能找到，局部性原则嘛</span></span><br><span class="line">  std::vector&lt;FileMetaData*&gt; tmp;</span><br><span class="line">  tmp.<span class="built_in">reserve</span>(files_[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    FileMetaData* f = files_[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">if</span> (ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;smallest.<span class="built_in">user_key</span>()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;largest.<span class="built_in">user_key</span>()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      tmp.<span class="built_in">push_back</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tmp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), NewestFirst);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(*func)(arg, <span class="number">0</span>, tmp[i])) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search other levels. 查找其他的层级</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">1</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="type">size_t</span> num_files = files_[level].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找 INdex</span></span><br><span class="line">    <span class="type">uint32_t</span> index = <span class="built_in">FindFile</span>(vset_-&gt;icmp_, files_[level], internal_key);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; num_files) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][index];</span><br><span class="line">      <span class="keyword">if</span> (ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;smallest.<span class="built_in">user_key</span>()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// All of &quot;f&quot; is past any data for user_key</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(*func)(arg, level, f)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="压缩"><a class="header-anchor" href="#压缩">¶</a>压缩</h3>
<p>很多值会变的重复起来，和我们之前遇见的情况一样。</p>
<p><img src="https://s3.jpg.cm/2020/11/08/S46Qp.png" alt="S46Qp.png"></p>
<p>我们进行压缩并且删除老数据。</p>
<h3 id="流程"><a class="header-anchor" href="#流程">¶</a>流程</h3>
<ul>
<li>写入的时候，我们在内存中使用 <code>RD Tree / SkipList</code> 在必要的时候触发持久化</li>
<li>持久化的时候，按照排序的方式进行写入</li>
<li>读取数据的时候，先通过 <code>bloom</code> 过滤，然后再遍历 <code>offset</code>，把所有的 <code>Key</code> 放在内存里也可以</li>
<li>读取 <code>offset</code> 范围内的对象，然后找到再返回</li>
</ul>
<p>在 <code>Read</code> <code>Write</code> <code>Space</code> 也有类似于 <code>CAP</code> 的定理</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201108223732.png" alt=""></p>
<hr>
<p>讲了一大串和 <code>时序数据库</code>  有啥关系呢？时序数据库是一个大规模写的系统，查询也有，不过倒是容忍多高，因此大多数的 <code>TSDB [Time Series Database]</code> 都是使用 <code>LSM</code> 来进行储存的。解决完单机的储存，对于分布式系统，靠一台机器肯定是不行的，因此我们就要想到如何把数据分散到不同的机器上。</p>
<h2 id="分布式存储"><a class="header-anchor" href="#分布式存储">¶</a>分布式存储</h2>
<p>分布式存储首先要考虑的是如何将数据分布到多台机器上面，也就是 <code>分片（sharding）</code>问题</p>
<ul>
<li>哈希分片：这种方法实现简单，均衡性较好，但是集群不易扩展。[因为增加机器就涉及到Hash值改变]</li>
<li>一致性哈希：这种方案均衡性好，集群扩展容易，迁移的数据会少一些</li>
<li>范围划分：通常配合全局有序，复杂度在于合并和分裂。代表有Hbase。</li>
<li>结合时序数据库的特点，根据 <code>metric</code> + <code>tags</code> 分片。</li>
</ul>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="http://paperhub.s3.amazonaws.com/18e91eb4db2114a06ea614f0384f2784.pdf">The Log-Structured Merge-Tree (LSM Tree)</a></li>
<li><a href="https://yetanotherdevblog.com/lsm/">Understanding LSM Trees: What Powers Write-Heavy Databases</a></li>
<li><a href="https://www.geeksforgeeks.org/skip-list/">skip-list-set-1</a></li>
<li><a href="https://www.geeksforgeeks.org/skip-list-set-2-insertion/?ref=rp">skip-list-set-2-insertion</a></li>
<li><a href="https://www.geeksforgeeks.org/skip-list-set-3-searching-deletion">skip-list-set-3-searching-deletion</a></li>
<li><a href="https://arxiv.org/pdf/1907.05443.pdf">Learning Key-Value Store Design</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>algorithm</category>
        <category>lsm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>lsm</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始学Docker</title>
    <url>/2017/02/07/docker/getting-started-with-docker/</url>
    <content><![CDATA[<h1>目录</h1>
<ul>
<li><a href="#%E5%85%B3%E4%BA%8EDocker">关于Docker</a></li>
<li>[Docker 架构](#Docker 架构)</li>
<li><a href="#%E8%B5%B7%E8%88%AA">起航</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">其他常用命令</a></li>
<li><a href="#DOCKER%E9%9B%86%E7%BE%A4">DOCKER集群</a></li>
</ul>
<span id="more"></span>
<h3 id="SECTION-1"><a class="header-anchor" href="#SECTION-1">¶</a>SECTION 1</h3>
<h1>关于Docker</h1>
<p>一夜之间，Docker俨然成为开发，打包，部署应用的一种既成标准。为DevOps提供了便捷快速启动轻量级虚拟机环境-容器，容器包含了应用本身与之所依赖的一切，<br>
这种轻量级的虚拟机易于测试，也方便运维人员的部署发布。</p>
<p>Docker让自动化的基础设施，应用隔离，保持一致性，提高资源利用都变的更加简单。</p>
<p>与广受欢迎的源码控制工具Git相似，Docker也有其协作性，开发者和运维人员都可以通过 <a href="https://hub.docker.com/">Docker Hub</a> 分享镜像。</p>
<p>Docker是开源的解决方案，不仅仅可以运行在Linux上，也可以在 Windows 和 Mac 使用轻量级Linux发行版或者VirtualBox来运行。Docker也复杂的应用为提供了众多的管理与编排工具。</p>
<hr>
<h3 id="SECTION-2"><a class="header-anchor" href="#SECTION-2">¶</a>SECTION 2</h3>
<h1>Docker 架构</h1>
<p>Docker使用client-server的架构，使用远程API在Linux容器之上来管理，创建Docker容器。Docker容器使用Docker镜像创建。容器和镜像的关系非常像 面向对象语言中  Class 和 Object的概念。</p>
<p><img src="https://dzone.com/storage/temp/576507-docker1.png" alt="docker architecture"></p>
<ul>
<li>Docker Images(镜像)<br>
创建容器的模版，包含了安装步骤和运行所必须的软件。</li>
<li>Docker Container(容器)<br>
像是小型的虚拟机，从镜像中创建而来。</li>
<li>Docker Client(客户端)<br>
命令行工具，或者一系列和Docker守护进程交互的<a href="https://docs.docker.com/reference/api/docker_remote_api">API</a></li>
<li>Docker Host(主机)<br>
运行Docker daemon的物理机或者是虚拟机，包含已缓存的镜像已经在运行的容器。</li>
<li>Docker Registry(镜像仓库)<br>
用来创建docker容器的镜像仓库，<a href="https://hub.docker.com">Docker Hub</a> 是最受欢迎的Docker镜像仓库。</li>
<li>Docker Machine(集群)<br>
用来管理多个Docker主机的工具，可以运行在本地的VirtualBox中也可以在各种云平台中。</li>
</ul>
<hr>
<h3 id="SECTION-3"><a class="header-anchor" href="#SECTION-3">¶</a>SECTION 3</h3>
<h1>起航</h1>
<h3 id="安装-Docker"><a class="header-anchor" href="#安装-Docker">¶</a>安装 Docker</h3>
<p>对于Mac和Windows用户来说，安装已经不能再简单了。<br>
需要下载 Docker Toolbox 在 <a href="https://www.docker.com/toolbox%E3%80%82">https://www.docker.com/toolbox。</a><br>
此安装包包含Docker Client, Docker Machine, Compose (Mac only) 和 VirtualBox。</p>
<p>因为Docker基于Linux容器技术，所以不能够直接运行在Mac 和 Windows上，VirtualBox使用一个小型Linux内核来运行Docker服务。</p>
<p>于此同时，在Linux安装Docker可能就是没有这么容易，为了安装Docker在Linux上，我们必须要安装一些依赖。从 <a href="https://docs.docker.com/installation">https://docs.docker.com/installation</a> 文中我们可以查看详细，对于某些发行版可能在包管理中已经有Docker,对于其他的发行版通用的方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sSL https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>
<p>在Linux上安装Docker-Machine需要root权限，使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/machine/releases/download/v0.4.0/docker-machine_linux-amd64 &gt; /usr/local/bin/docker-machine</span><br><span class="line">chmod +x /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure>
<p>截止至此文发布，Docker-Machine仍在beta中不建议在生产环节中使用。</p>
<h3 id="运行容器"><a class="header-anchor" href="#运行容器">¶</a>运行容器</h3>
<p>Docker已经安装好，我们开始运行容器，如果你没有必要的镜像来创建容器，Docker会从Hub仓库中下载镜像，然后组建并运行。<br>
为了运行最简单的 hello-world 容器，来证明我们的环境已经安装完毕，我们执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<p>最终这个命令将打印一系列消息在标准输出上。</p>
<h3 id="典型工作流"><a class="header-anchor" href="#典型工作流">¶</a>典型工作流</h3>
<p>Docker对于创建镜像，推送镜像，发布镜像，运行容器有一套典型的工作流。</p>
<p><img src="https://dzone.com/storage/temp/576516-docker2.png" alt="Workflow"></p>
<p>Docker构建镜像的典型方式是从Dockerfile，Dockerfile是一系列指令包含如何配置容器或者从Docker仓库中拉取镜像。当Docker 镜像在你的Docker环境中，那你就可以运行容器了，运行容器创建运行时操作系统，软件，和一些配置。比如你可以Debian操作系统上运行Mysql 5.5. 并且为你的应用创建指定的数据库，用户和表结构。这些可运行的容器能够象一个虚拟机一样启动和关闭。如果你手动的配置或者手动安装软件，容器能够通过提交的方式创建一个新的镜像再下一次使用。当然，你也可以通过Docker Hub 仓库分享你的镜像。</p>
<h3 id="从Docker仓库拉取镜像"><a class="header-anchor" href="#从Docker仓库拉取镜像">¶</a>从Docker仓库拉取镜像</h3>
<p>你可以通过访问 <a href="https://hub.docker.com">https://hub.docker.com</a> 查找是否已经你所需要的镜像。仓库内有许多已经被认证的官方镜像，比如 MySQL, Node.js, Java, Nginx, WordPress 当然也有数以万记个人用户创建的镜像，如果你找到你需要的镜像，那就将之拉取下来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>
<p>如果你本地还没有缓存这些镜像，Docker会自动从Hub上下载当前最新版本并缓存之，如果你想要指定某个特殊版本，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.5.45</span><br></pre></td></tr></table></figure>
<p>如果你并不想立即运行镜像，那这个命令将比Run节约一步，并且会在后台自动下载镜像。</p>
<h3 id="从Dockerfile构建一个镜像"><a class="header-anchor" href="#从Dockerfile构建一个镜像">¶</a>从Dockerfile构建一个镜像</h3>
<p>如果你没有找到任何你需要或者信任的镜像在DockerHub上，你可以通过创建Dokcerfile构建自己的镜像。Dockerfiles可以从已有的镜像中继续编写，从而添加你需要的软件或者自定义配置。</p>
<p>下面就是一个简单的 Dokcerfile 例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM mysql:5.5.45</span><br><span class="line">RUN echo America/New_York | tee /etc/timezone &amp;&amp; dpkg-reconfigure --frontend noninteractive tzdata</span><br></pre></td></tr></table></figure>
<p>这个Dockerfile展示了如何从官方mysql仓库（指定的  5.5.45 版本）创建一个 时区为 America/New_York的新镜像。</p>
<p>关于 Dockerfile 详细的介绍，我们在后面再谈。</p>
<p>为了在目录内构建我们的镜像，我们需要执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build .</span><br></pre></td></tr></table></figure>
<p>这个命令将创建一个未命名的镜像，我们可以通过下面这个命令查看我们的镜像列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>这个命令列出我们本地所有缓存的镜像，包括我们自己创建的那个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPOSITORY  TAG     IMAGE ID      VIRTUAL SIZE</span><br><span class="line">&lt;none&gt;      &lt;none&gt;  4b9b8b27fb42  214.4 MB</span><br><span class="line">mysql       5.5.45  0da0b10c6fd8  213.5 MB</span><br></pre></td></tr></table></figure>
<p>如上所示，我们build命令创建一个 REPOSITORY 和  TAG 都是 none 的镜像，这种方式并不推荐，更建议使用下面这种方式，使用 -t 为镜像打上标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build –t est-mysql .</span><br><span class="line"></span><br><span class="line">REPOSITORY   TAG     IMAGE ID      VIRTUAL SIZE</span><br><span class="line">est-mysql    latest  4b9b8b27fb42  214.4 MB</span><br><span class="line">mysql        5.5.45  0da0b10c6fd8  213.5 MB</span><br></pre></td></tr></table></figure>
<p>这是用还有另外一种创建镜像的方式，我们可以通过一个已经存在的镜像，通过Bash命令安装我们的自己的软件或者更改配置，最后使用Docker Commit为正在运行的容器创建一个新的镜像。不过这种方式并非是最佳实践，因为不能够重复而且文档也是一种自解释。</p>
<h1>运行镜像</h1>
<p>为了运行这个镜像，我们首先需要的在本地找到此镜像的缓存或者从Docker Hub找到。通常 Docker镜像总会需要一些额外的环境配置，我们通过 -e 的方式传入，而一切需要象守护进程需要长期运行的需要 -d 选项。<br>
为了运行我们 est-mysql 镜像，我们需要配置 Mysql root用户密码，我们可以从  Docker Hub 中Mysql文档里查看到具体的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -e +1 -d est-mysql</span><br></pre></td></tr></table></figure>
<p>查看运行中的容器，我们使用ps命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p>ps命令将列出所有运行的镜像，包括从什么镜像创建，哪些命令在运行，哪些端口正在被监听，还有这个容器的名字。<br>
CONTAINER ID    IMAGE     COMMAND<br>
30645f307114    est-mysql “/entrypoint.sh mysql”<br>
PORTS       NAMES<br>
3306/tcp    serene_brahmagupta<br>
从上面的执行进程结果来看，容器名称为serene_brahmagupta。这是一个自动生成的名字，其维护便利性受到质疑。因此明确的指定容器名称被认为是一种更好的方式，通常使用<code>--name</code>选项在容器启动的时候提供其名称。</p>
<pre><code>docker run --name my-est-mysql -e MYSQL_ROOT_ PASSWORD=root+1 -d est-mysql
</code></pre>
<p>你会注意到ps命令的输出内容中该容器监听端口3306，但是这并不意味着你能够在本地运用MySQL的命令行或者MySQL的工作台直接和数据库进行交互了，因为该端口只能在运行它的安全的docker环境中才能够使用。为了使得该端口在该环境外部可用，你需要使用<code>-p</code>选项将端口映射出去。</p>
<pre><code>docker run --name my-est-mysql -e MYSQL_ROOT_ PASSWORD=root+1 -p 3306:3306 -d est-mysql
</code></pre>
<p>现在你可以连接到MySQL正在监听的端口了，但是你仍然需要知道你要连接的IP地址。为了明确IP你可以使用<code>docker- machine ip</code>命令去查询。</p>
<pre><code>docker-machine ip default
</code></pre>
<p>使用default作为machine的名称，默认的machine安装自Docker Toolbox，你将会获得运行该容器的machine的IP地址。利用这个IP地址，你就能够利用本地MySQL命令行去链接MySQL了。</p>
<pre><code>mysql -h 192.168.99.100 -u root -proot+1
</code></pre>
<h3 id="暂停和启动容器"><a class="header-anchor" href="#暂停和启动容器">¶</a>暂停和启动容器</h3>
<p>现在你有一个运行着的容器了，接下来你可以使用Docker的<code>stop</code>命令和容器名称去暂停它。</p>
<pre><code>docker stop my-est-mysql
</code></pre>
<p>容器的全部状态都记录在磁盘上，如果你想由关闭状态再次开启它，你可以使用start命令。</p>
<pre><code>docker start my-est-mysql
</code></pre>
<h3 id="标记镜像"><a class="header-anchor" href="#标记镜像">¶</a>标记镜像</h3>
<p>现在你有一个执行过且被验证过的镜像，在上传到镜像仓库之前，建议使用用户名，镜像名和版本号作为其标签。你可以使用Docker的<code>tag</code>命令来实现这一点。</p>
<pre><code>docker tag est-mysql javajudd/est-mysql:1.0
</code></pre>
<h3 id="提交镜像到仓库"><a class="header-anchor" href="#提交镜像到仓库">¶</a>提交镜像到仓库</h3>
<p>最后，你已经准备好将你的镜像提交到Docker Hub供世界范围内的开发者使用或者提交到私有仓库供你的团队成员内部使用。<br>
首先，你需要前往https://hub.docker.com/ 注册一个免费的账号，接着利用<code>login</code>命令登入。</p>
<pre><code>docker login
</code></pre>
<p>接着输入用户名，密码和你注册时候的电子邮箱。<br>
然后就可以利用<code>push</code>命令推送镜像了，同时指定你的用户名，镜像名和版本号。</p>
<pre><code>docker push javajudd/est-mysql:1.0
</code></pre>
<p>不久你就会收到一封邮件，说明镜像已经成功提交到仓库了。这时如果你从网页登录Docker Hub，你会看到这个新的仓库。</p>
<hr>
<h3 id="SECTION-4"><a class="header-anchor" href="#SECTION-4">¶</a>SECTION 4</h3>
<h1>其他常用命令</h1>
<h3 id="查询容器"><a class="header-anchor" href="#查询容器">¶</a>查询容器</h3>
<p>你已经看到ps命令能够查看正在运行的容器，但是如果要无视状态查看全部的容器呢，这时候就需要添加 <code>-a</code>选项了。</p>
<pre><code>docker ps -a
</code></pre>
<p>列出全部容器之后，你就能够确定启动或者移除哪一个。</p>
<h3 id="移除容器"><a class="header-anchor" href="#移除容器">¶</a>移除容器</h3>
<p>当你使用完一个容器之后，相比于让它留在那里占据磁盘空间，不如将其移除，你可以利用<code>rm</code>命令。</p>
<pre><code>docker rm my-est-mysql
</code></pre>
<h3 id="移除镜像"><a class="header-anchor" href="#移除镜像">¶</a>移除镜像</h3>
<p>你已经了解如何列出所有本地缓存的镜像，这些镜像会占据很大的空间，几MB到几百MB不等，因此你会需要使用<code>rmi</code>命令去清除不需要的镜像。</p>
<pre><code>docker rmi est-mysql
</code></pre>
<p>在创建镜像的DEBUG过程中，通常会产生大量的不理想或者标记为<none>的未命名镜像。你可以使用下面的命令来删除这些虚悬的镜像。</p>
<pre><code>docker rmi $(docker images -q -f dangling=true)
</code></pre>
<h3 id="查询端口"><a class="header-anchor" href="#查询端口">¶</a>查询端口</h3>
<p>查看容器暴露的端口也是常用的需求，例如端口3306常用来链接MySQL数据库或者端口80常用来链接网站服务器。<code>port</code>命令能够用来展示暴露的端口号。</p>
<pre><code>docker port my-est-mysql
</code></pre>
<h3 id="查询进程"><a class="header-anchor" href="#查询进程">¶</a>查询进程</h3>
<p>如果你想查看容器中正在运行的进程情况，你可以使用<code>top</code>命令（和Linux中的top命令相似）</p>
<pre><code>docker top my-est-mysql
</code></pre>
<h3 id="执行命令"><a class="header-anchor" href="#执行命令">¶</a>执行命令</h3>
<p>你能够通过<code>exec</code>命令在一个运行的容器内部执行指令。例如为了列出硬盘驱动器根目录，你可以使用下面的命令。</p>
<pre><code>docker exec my-est-mysql ls /
</code></pre>
<p>如果你想在容器中进行root认证，仍然可以使用等效的<code>exec</code>命令去开启使用bash shell的权限。同时，因为Docker client和Docker daemon之间的通信都是加密的，所以安全性也得到了保证。</p>
<pre><code>docker exec -it my-est-mysql bash
</code></pre>
<h3 id="启动容器"><a class="header-anchor" href="#启动容器">¶</a>启动容器</h3>
<p><code>run</code>命令是最复杂且最有特色的Docker命令。它能够用来管理网络配置，系统资源（例如容量，CPU，文件系统），配置安全等。访问https://docs.docker.com/reference/run/查看完整的可用选项。</p>
<h2 id="DOCKERFILE"><a class="header-anchor" href="#DOCKERFILE">¶</a>DOCKERFILE</h2>
<p>前文已经介绍，Dockerfile是首选的创建Docker镜像的方式。它包括一些说明，例如安装和配置软件的Linux命令。<code>build</code>命令能够查阅你的路径或者类似GitHub仓库的URL下的Dockerfile。和Dockerfile一起，任何同一文件夹和子文件夹下的内容都会被视为构造过程的一部分。如果你希望将执行脚本或者对于部署有用的文件一同构造进去的时候会非常有用。</p>
<h3 id="HOT-TIP"><a class="header-anchor" href="#HOT-TIP">¶</a>HOT TIP</h3>
<p>如果你希望在包含的路径中排除部分文件或者目录，可以使用<code>.dockerignore file</code>来实现。</p>
<h2 id="指令"><a class="header-anchor" href="#指令">¶</a>指令</h2>
<p>指令会按照Dockerfile中的顺序被执行。Dockerfile同样可以包含以字符#开头的行命令，下表包含了一些可用的命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>FROM</td>
<td>这条指令必须位于Dockerfile的第一行，它指定了基础镜像</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>指定了镜像作者的信息</td>
</tr>
<tr>
<td>RUN</td>
<td>执行一条linux命令用于配置和安装</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>启动容器的脚本或应用(最后执行)，它可以让容器变成可执行的应用</td>
</tr>
<tr>
<td>CMD</td>
<td>以JSON数组的格式为ENTRYPOINT提供默认参数</td>
</tr>
<tr>
<td>LABEL</td>
<td>镜像元信息，以键值对的形式</td>
</tr>
<tr>
<td>ENV</td>
<td>设置环境变量</td>
</tr>
<tr>
<td>COPY</td>
<td>将文件拷贝至容器内</td>
</tr>
<tr>
<td>ADD</td>
<td>COPY的替代选择</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>为RUN,ENTRYPOINT,CMD,COPY,和（或）ADD指令设置工作目录</td>
</tr>
<tr>
<td>EXPOSR</td>
<td>容器将要监听的端口</td>
</tr>
<tr>
<td>VOLUME</td>
<td>创建一个挂载点</td>
</tr>
<tr>
<td>USER</td>
<td>运行RUN，CMD，和（或）ENTRYPOINT指令的用户</td>
</tr>
</tbody>
</table>
<h2 id="DOCKERFILE-示例"><a class="header-anchor" href="#DOCKERFILE-示例">¶</a>DOCKERFILE 示例</h2>
<p>这是MySQL 5.5官方版的一个示例Dockerfile,使用了许多可用的命令，你可以在 <a href="https://github.com/docker-library/mysql/blob/5836bc9af9deb67b68c32bebad09a0f7513da36e/5.5/%E6%89%BE%E5%88%B0%E5%AE%83%E3%80%82">https://github.com/docker-library/mysql/blob/5836bc9af9deb67b68c32bebad09a0f7513da36e/5.5/找到它。</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line"><span class="comment"># add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added</span></span><br><span class="line">RUN groupadd -r mysql &amp;&amp; useradd -r -g mysql mysql</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">mkdir</span> /docker-entrypoint-initdb.d</span><br><span class="line"></span><br><span class="line"><span class="comment"># FATAL ERROR: please install the following Perl modules before executing /usr/local/mysql/scripts/mysql_install_db:</span></span><br><span class="line"><span class="comment"># File::Basename</span></span><br><span class="line"><span class="comment"># File::Copy</span></span><br><span class="line"><span class="comment"># Sys::Hostname</span></span><br><span class="line"><span class="comment"># Data::Dumper</span></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y perl --no-install-recommends &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory</span></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y libaio1 &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># gpg: key 5072E1F5: public key &quot;MySQL Release Engineering &lt;mysql-build@oss.oracle.com&gt;&quot; imported</span></span><br><span class="line">RUN gpg --keyserver ha.pool.sks-keyservers.net --recv-keys A4A9406876FCBD3C456770C88C718D3B5072E1F5</span><br><span class="line"></span><br><span class="line">ENV MYSQL_MAJOR 5.5</span><br><span class="line">ENV MYSQL_VERSION 5.5.45</span><br><span class="line"></span><br><span class="line"><span class="comment"># note: we&#x27;re pulling the *.asc file from mysql.he.net instead of dev.mysql.com because the official mirror 404s that file for whatever reason - maybe it&#x27;s at a different path?</span></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y curl --no-install-recommends &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* \</span><br><span class="line">	&amp;&amp; curl -SL <span class="string">&quot;http://dev.mysql.com/get/Downloads/MySQL-<span class="variable">$MYSQL_MAJOR</span>/mysql-<span class="variable">$MYSQL_VERSION</span>-linux2.6-x86_64.tar.gz&quot;</span> -o mysql.tar.gz \</span><br><span class="line">	&amp;&amp; curl -SL <span class="string">&quot;http://mysql.he.net/Downloads/MySQL-<span class="variable">$MYSQL_MAJOR</span>/mysql-<span class="variable">$MYSQL_VERSION</span>-linux2.6-x86_64.tar.gz.asc&quot;</span> -o mysql.tar.gz.asc \</span><br><span class="line">	&amp;&amp; apt-get purge -y --auto-remove curl \</span><br><span class="line">	&amp;&amp; gpg --verify mysql.tar.gz.asc \</span><br><span class="line">	&amp;&amp; <span class="built_in">mkdir</span> /usr/local/mysql \</span><br><span class="line">	&amp;&amp; tar -xzf mysql.tar.gz -C /usr/local/mysql --strip-components=1 \</span><br><span class="line">	&amp;&amp; <span class="built_in">rm</span> mysql.tar.gz* \</span><br><span class="line">	&amp;&amp; <span class="built_in">rm</span> -rf /usr/local/mysql/mysql-test /usr/local/mysql/sql-bench \</span><br><span class="line">	&amp;&amp; <span class="built_in">rm</span> -rf /usr/local/mysql/bin/*-debug /usr/local/mysql/bin/*_embedded \</span><br><span class="line">	&amp;&amp; find /usr/local/mysql -<span class="built_in">type</span> f -name <span class="string">&quot;*.a&quot;</span> -delete \</span><br><span class="line">	&amp;&amp; apt-get update &amp;&amp; apt-get install -y binutils &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* \</span><br><span class="line">	&amp;&amp; &#123; find /usr/local/mysql -<span class="built_in">type</span> f -executable -<span class="built_in">exec</span> strip --strip-all <span class="string">&#x27;&#123;&#125;&#x27;</span> + || <span class="literal">true</span>; &#125; \</span><br><span class="line">	&amp;&amp; apt-get purge -y --auto-remove binutils</span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:/usr/local/mysql/bin:/usr/local/mysql/scripts</span><br><span class="line"></span><br><span class="line"><span class="comment"># replicate some of the way the APT package configuration works</span></span><br><span class="line"><span class="comment"># this is only for 5.5 since it doesn&#x27;t have an APT repo, and will go away when 5.5 does</span></span><br><span class="line">RUN <span class="built_in">mkdir</span> -p /etc/mysql/conf.d \</span><br><span class="line">	&amp;&amp; &#123; \</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&#x27;[mysqld]&#x27;</span>; \</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&#x27;skip-host-cache&#x27;</span>; \</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&#x27;skip-name-resolve&#x27;</span>; \</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&#x27;user = mysql&#x27;</span>; \</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&#x27;datadir = /var/lib/mysql&#x27;</span>; \</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&#x27;!includedir /etc/mysql/conf.d/&#x27;</span>; \</span><br><span class="line">	&#125; &gt; /etc/mysql/my.cnf</span><br><span class="line"></span><br><span class="line">VOLUME /var/lib/mysql</span><br><span class="line"></span><br><span class="line">COPY docker-entrypoint.sh /entrypoint.sh</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/entrypoint.sh&quot;</span>]</span><br><span class="line"></span><br><span class="line">EXPOSE 3306</span><br><span class="line">CMD [<span class="string">&quot;mysqld&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个示例的Dockerfile会产生以下动作：</p>
<ul>
<li>继承一个已存在的名叫debian:jessie的Debian镜像</li>
<li>使用RUN指令去配置镜像：增加用户组，创建目录以及使用Debian的包管理工具apt-get安装必要的软件</li>
<li>运行gpg对PGP进行加密</li>
<li>使用ENV指令去设置该镜像所代表的MYSQL的最高和最低版本</li>
<li>运行一长行命令去安装和配置系统，后面紧接着另外一个环境变量去设置系统PATH</li>
<li>使用RUN指令去创建配置文件</li>
<li>使用VOLUME命令去映射一个文件系统</li>
<li>使用COPY命令去复制和重命名一个脚本，它将在容器启动的时候运行。ENTRYPOINT指定了该脚本。</li>
<li>使用EXPOSE指令声明端口3306作为MYSQL的标准端口</li>
<li>使用CMD指令去指定容器启动时传给ENTRYPOINT的命令行参数，字符串mysqld</li>
</ul>
<hr>
<h3 id="SECTION-5"><a class="header-anchor" href="#SECTION-5">¶</a>SECTION 5</h3>
<h1>DOCKER集群</h1>
<p>Docker Machine是另外一个命令行工具用以管理一个或多个本地或远程服务器。本地机器通常运行在不同的VirtualBox实例中。远程机器通常运行在诸如Amazon Web Services (AWS), Digital Ocean, or Microsoft Azure提供的云服务器中。</p>
<h3 id="创建本地-Machine"><a class="header-anchor" href="#创建本地-Machine">¶</a>创建本地 Machine</h3>
<p>安装Docker Toolbox的同时，你将会得到一个名叫&quot;default&quot;的默认Docker Machine。它很容易上手，但在一定程度上，你需要多个 Machine分割你将要运行的不同容器。你可以使用<code>docker-machine create</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-machine create -d virtualbox qa</span><br></pre></td></tr></table></figure>
<p>它将使用一个名叫qa的VirtualBox镜像去新建一个本地Machine</p>
<h3 id="列出-MACHINES"><a class="header-anchor" href="#列出-MACHINES">¶</a>列出 MACHINES</h3>
<p>如果你需要查看你所配置的所有machine，可以使用<code>docker-machine ls</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-machine <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<h3 id="启动和停止-Machine"><a class="header-anchor" href="#启动和停止-Machine">¶</a>启动和停止 Machine</h3>
<p>Docker Machines可以用<code>docker-machine start</code>启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-machine start qa</span><br></pre></td></tr></table></figure>
<p>一旦machine启动起来了，你需要去配置docker命令行，以便和docker守护进程进行交互。你可以使用<code>docker-machine env</code>命令进行此动作并使用eval对其求值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-machine <span class="built_in">env</span> qa</span><br><span class="line"><span class="built_in">eval</span> “$(docker-machine <span class="built_in">env</span> qa)”</span><br></pre></td></tr></table></figure>
<p>使用<code>docker-machine stop</code>去停止machine。</p>
<h3 id="HOT-TIP-v2"><a class="header-anchor" href="#HOT-TIP-v2">¶</a>HOT TIP</h3>
<p>docker-machine start 和 stop命令实际上会启动或停止VirtualBox VMs。如果你开启了VirtualBox管理器，你可以在运行上述命令的时候看到VM的变化。</p>
<blockquote>
<p>原文 <a href="https://dzone.com/refcardz/getting-started-with-docker-1">Getting Started With Docker</a></p>
</blockquote>
<p><strong>译者：</strong></p>
<ul>
<li><a href="https://github.com/misha913loki">misha913loki</a></li>
<li><a href="https://github.com/renlulu">renlulu</a></li>
<li><a href="https://github.com/yannxia">yannxia</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Docker</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次有趣的 Java 面试</title>
    <url>/2020/07/31/java/java-interview/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/08/03/bHP5z.png" alt="bHP5z.png"></p>
<p>笔者很久没有面试的时候被问过深度的 <code>GC</code> 知识了，看看腾讯的高级技术专家是如何面试 <code>Java</code> 的。</p>
<span id="more"></span>
<h1>Q1: new 之后发生了什么？</h1>
<p>面试的时候没有理解面试官想问的问题，回答的比较糟糕，反思一下，用下面的例子来说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        DemoApplication.class.getClassLoader().loadClass(<span class="string">&quot;io.xxx.xxx&quot;</span>).newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先：我们需要使用 <code>Classloader</code> 去加载这个类 <code>loadClass</code> 这里会涉及到 <a href="https://www.cnblogs.com/lanxuezaipiao/p/4138511.html"><code>双亲委派模型</code></a> 因为我们应用的启动都是通过 <code>AppClassLoader</code> 进行启动，因此哪怕我们自定实现了一个 <code>Classloader</code> 在其内部载入一个 <code>魔改的String</code> 类，但是因为不同的 <code>ClassLoader</code> 载入的同名类并不作为同一个对象，也不能算我们重写的 <code>String.class</code>。</p>
<p>不过还有一个值得注意的在我们 <code>defineClass</code> 的内置函数中，我们尝试定义如下代码</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        defineClass
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TestClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;java.lang.String&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Main.class.getClassLoader().getResourceAsStream(<span class="string">&quot;java/lang/String.class&quot;</span>);</span><br><span class="line">                <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10000</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(buf);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getParent().loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<p>结果是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.SecurityException: Prohibited package name: java.lang</span><br><span class="line">	at java.lang.ClassLoader.preDefineClass(ClassLoader.java:662)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:761)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:642)</span><br><span class="line">	at test.Main<span class="variable">$TestClassLoader</span>.loadClass(Main.java:24)</span><br><span class="line">	at test.Main.main(Main.java:10)</span><br></pre></td></tr></table></figure>
<p>其实方法的注释上，我们也可以发现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="meta">@throws</span>  SecurityException</span><br><span class="line">*          If an attempt is made to add <span class="built_in">this</span> <span class="keyword">class</span> <span class="title class_">to</span> a <span class="keyword">package</span> that</span><br><span class="line">*          contains classes that were signed by a different set of</span><br><span class="line">*          certificates than <span class="built_in">this</span> <span class="title function_">class</span> <span class="params">(which is unsigned)</span>, or <span class="keyword">if</span></span><br><span class="line">*          &lt;tt&gt;name&lt;/tt&gt; begins with <span class="string">&quot;&lt;tt&gt;java.&lt;/tt&gt;&quot;</span>.</span><br></pre></td></tr></table></figure>
<p>我们是没办法绕过JVM的安全机制的。</p>
<h1>Q2：那我们如何热替换Class</h1>
<p>从上一Q中，我们知道不同的 <code>ClassLoader</code> 载入的同名类是属于不同的类，那我们 <code>Hot Swap Class</code></p>
<h2 id="第一种方式：每次调用的时候都是-LoadClass，但是这样的方式相当于我们每一次都是载入一个新的Class。"><a class="header-anchor" href="#第一种方式：每次调用的时候都是-LoadClass，但是这样的方式相当于我们每一次都是载入一个新的Class。">¶</a>第一种方式：每次调用的时候都是 <code>LoadClass</code>，但是这样的方式相当于我们每一次都是载入一个新的Class。</h2>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        方法一: loadclass
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TestClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.equals(<span class="string">&quot;test.Test1&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Test.class.getClassLoader().getResourceAsStream(<span class="string">&quot;test/Test1.class&quot;</span>);</span><br><span class="line">                    <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10000</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(buf);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, buf, <span class="number">0</span>, len);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> getParent().loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestClassLoader</span>().loadClass(<span class="string">&quot;test.Test1&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">            cls.getMethod(<span class="string">&quot;hello&quot;</span>).invoke(obj);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<p>不过值得注意的是对于已经 <code>defineClass</code> 的对象我们必须要构建出一个新的 <code>ClassLoader</code> 才能再次 <code>reload</code> 这个class。而且不同的 <code>Classloader</code> 载入的相同的 <code>Class</code> 在对比的时候并不是 <code>相等</code> 的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Class&lt;?&gt; aClass = <span class="keyword">new</span> <span class="title class_">TestClassLoader</span>().loadClass(<span class="string">&quot;test.Test&quot;</span>);</span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt; bClass = <span class="keyword">new</span> <span class="title class_">TestClassLoader</span>().loadClass(<span class="string">&quot;test.Test&quot;</span>);</span><br><span class="line">System.out.println(aClass.equals(bClass));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="第二种方法：instrumentation-redefine"><a class="header-anchor" href="#第二种方法：instrumentation-redefine">¶</a>第二种方法：instrumentation::redefine</h2>
<p>Arthas 热更新背后的原理就是 JavaAgent 技术。对于上面的方法我们是没有办法在运行时去修改逻辑，我们必须要在 <code>Coding</code> 的时候就将这个过程给固化下来，而Java提供了另外一种完全热更新的方案 <code>Java Instrumentation</code> 一种为 pre-main 方式，这种方式需要在虚拟机参数指定 Instrumentation 程序，然后程序启动之前将会完成修改或替换类，Skywalking就是这么个工作原理。JDK6 针对这种情况作出了改进，增加 agent-main 方式。我们可以在应用启动之后，再运行 <code>Instrumentation</code> 程序。启动之后，只有连接上相应的应用，我们才能做出相应改动，这里我们就需要使用 Java 提供 <code>attach API</code>。<br>
详细可以参考 <a href="https://www.cnblogs.com/goodAndyxublog/p/11880314.html">手把手教你实现热更新功能，带你了解 Arthas 热更新背后的原理</a></p>
<h1>继续 Q1：New阶段在我们载入Class之后做了些什么</h1>
<h2 id="方法区开辟空间存入缓存"><a class="header-anchor" href="#方法区开辟空间存入缓存">¶</a>方法区开辟空间存入缓存</h2>
<p><code>Class文件</code> 被我们载入的 <code>Class(Method) Area</code>。不过 <code>方法区（Permanent Generation）</code> 的大小默认是无限制的，但是和普通的 <code>GC</code> 一样，这里也会发生 <code>GC</code>，常见的是在启动的时候载入的大量的 <code>Class</code> 就会出现频繁的 <code>GC</code>。</p>
<h2 id="初始化对象"><a class="header-anchor" href="#初始化对象">¶</a>初始化对象</h2>
<p>首先第一步我们需要在 <code>Stack</code> 分配一个指向 <code>Heap</code> 的引用对象。</p>
<p><img src="https://s3.jpg.cm/2020/08/02/bbokE.png" alt="bbokE.png"></p>
<p>然后再去 <code>Heap</code> 开辟一个新空间。不过从这里在这次的面试中就有点自己知识的盲区了，我尝试着带着 <code>Google</code> 重新回顾一下。</p>
<p>按照理解的话 <code>Linux</code> 提供了 <code>malloc</code> 的标准函数进行内存的分配，但是这样的返回仅仅是一个 <code>Address of a chunk memory</code>，对于 <code>Jvm</code> 这样的虚拟机应该将这些地址都存储起来并且在恰当的时候进行 <code>GC</code>。</p>
<figure class="highlight java"><figcaption><span>malloc</span></figcaption><table><tr><td class="code"><pre><span class="line">ptr_to_container = (Container *) malloc(sizeof(Container));</span><br></pre></td></tr></table></figure>
<p>在 <a href="https://juejin.im/post/6844903982905688071">What happened when new an object in JVM</a> 有说过这个，在 <code>Hotspot</code> 实现过程中，真实的 <code>object</code> 对象，包含了一些额外的信息在 <code>object  header</code> 中，不过并没有在中发现具体的 <code>Memoery Address</code> 应该是被一个统一的管理器管理起来了。</p>
<p>因为 <code>Class</code> 的类型一定定义了数据的长度，<code>Sizeof</code> 函数对于 <code>Java</code> 显然是非必要的，我们如何从空闲的内存中获取数据呢？</p>
<blockquote>
<p>The Java heap memory is regular (using a markup or a garbage collector with compression), using a pointer to the free location, and allocating memory moves the pointer equal to the allocated size.<br>
The memory is not regular (the garbage collector using the markup cleanup), the virtual machine maintains a list of available memory blocks, and when the memory is allocated, a large enough memory space is found from the list to allocate the object and update the available memory list.<br>
A GC is triggered when sufficient memory cannot be found</p>
</blockquote>
<p>对于不同的GC算法，内存区域的开辟也有不同，常规模式下<code>内存管理器</code>维护者 <code>Free Point</code> 指向空闲的区域，然后开辟空间移动指针即可，非常规的模式下直接将 <code>block</code> 块合并返回。不过下面那种模式更快，不过也会产生更多的碎片。</p>
<h1>Q：那JVM为何要分代</h1>
<p>在 <a href="https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/garbage_collect.html"><code>Understanding Memory Management</code></a> 中有提到。</p>
<p><img src="https://s3.jpg.cm/2020/08/02/bb3uH.png" alt="bb3uH.png"></p>
<div>
    <label class="author-mark-label">小声比比</label>
    <p class="author-mark">以前我没太理解，我认为之所以要分分代是因为对于不同的区域的 GC 算法应该有所不同。</p>
</div>
<p>在 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html">HotSpot Virtual Machine Garbage Collection Tuning Guide</a> 中说道：</p>
<blockquote>
<p>Throughput is the percentage of total time not spent in garbage collection considered over long periods of time. Throughput includes time spent in allocation (but tuning for speed of allocation is generally not needed).<br>
Pauses are the times when an application appears unresponsive because garbage collection is occurring.</p>
</blockquote>
<p>对于GC算法来说，<code>暂停时间</code> 和 <code>吞吐量</code> 是最为核心的诉求，不同的搭配会产生不一样的效果</p>
<ul>
<li>Serial GC for both the Young and Old generations</li>
<li>Parallel GC for both the Young and Old generations</li>
<li>Parallel New for Young + Concurrent Mark and Sweep (CMS) for the Old Generation</li>
<li>G1, which encompasses collection of both Young and Old generations</li>
</ul>
<h3 id="Serial-GC"><a class="header-anchor" href="#Serial-GC">¶</a>Serial GC</h3>
<h4 id="young-generation"><a class="header-anchor" href="#young-generation">¶</a>young generation</h4>
<p><code>youg</code> 又分为 <code>eden</code> 和 <code>S0</code>/<code>S1</code>，<code>Young</code> 的运行机制如下：</p>
<ul>
<li>创建的对象都在 <code>Eden</code></li>
<li><code>Eden</code> 满的时候触发 <code>Minor garbage collection</code>，将存活的移动到 <code>Survivor Space</code></li>
<li>后续的 <code>Minor GC</code> 会回收所有的 <code>Young</code> 的对象，并且将 <code>S0</code>在 <code>S1</code> 来回倒腾对象</li>
<li>当对象活超过 <code>max age threshold</code> 会将对象从 <code>Survivor</code> 移动到 <code>Tenured Space</code></li>
</ul>
<p>对于 <code>JRockit</code> 实现的时候并没有 <code>S0</code> 和 <code>S1</code> 的说法，只有一个 <code>survivor</code>，为什么 <code>Hotspot</code> 需要呢？</p>
<p>在 <a href="https://stackoverflow.com/questions/10695298/java-gc-why-two-survivor-regions">Java GC: why two survivor regions?</a> 中又说到，当我们出发了 <code>Minor GC</code> 之后，杀掉了一些对象之后，<code>Eden</code> 和 <code>Survivor</code> 都会出现碎片，为了减少碎片，<code>Sun</code> 折中选择了将 <code>S0/S1</code> 进行移动的过程中进行 <code>压实</code>。</p>
<p><img src="https://s3.jpg.cm/2020/08/02/bbOuy.png" alt="bbOuy.png"></p>
<p>对于 <code>eden</code> 的对象要么选择去 <code>survivor</code> 要么选择 <code>killed</code>，每一次应该 <code>eden</code> 是清空的。</p>
<h4 id="Old-generation"><a class="header-anchor" href="#Old-generation">¶</a>Old generation</h4>
<p>上面对于 <code>Serial GC</code> 只是 <code>Minor GC</code> 的部分，当我们的 <code>Eden/Survior</code> 都满的情况下会触发 <code>Full GC</code></p>
<p><img src="https://s3.jpg.cm/2020/08/02/buSAf.png" alt="buSAf.png"></p>
<h3 id="Parallel-GC"><a class="header-anchor" href="#Parallel-GC">¶</a>Parallel GC</h3>
<p><code>Parallel GC</code> 和 <code>Serial GC</code> 一样对于 <code>young</code> 采用的是 <code>mark-copy</code>，对于 <code>old</code> 采用的 <code>mark-sweep-compact</code> 和 <code>Serial GC</code> 不一样是采用了多线程的方式进行操作，在多核系统上较好。</p>
<h3 id="Concurrent-Mark-and-Sweep"><a class="header-anchor" href="#Concurrent-Mark-and-Sweep">¶</a>Concurrent Mark and Sweep</h3>
<p><code>CMS</code> 对于 <code>Young</code> 采用的还是 <code>mark-copy</code> 的算法，<code>Old Generation</code> 部分就是 <code>mostly concurrent mark-sweep</code>。 <code>young</code> 部分就不多说，对于 <code>old</code> 部分。</p>
<p>因为 <code>compact</code> 很慢的一个过程，比较涉及到 <code>move</code> 对象，<code>CMS</code> 的设计目标是为了防止长时间的停顿( long pauses) 不过因为对于 <code>Young</code> 其实没啥区别，就主要看看 <code>Old Generation</code></p>
<h4 id="Old-Generation"><a class="header-anchor" href="#Old-Generation">¶</a>Old Generation</h4>
<ul>
<li>采用 <code>free-lists</code> 算法管理空闲空间</li>
<li>大部分的操作是不停止应用工作的</li>
</ul>
<h5 id="第一步：初始化标记，这一部分会-SOW，不过只需要找到所有在-Old-中的-Root"><a class="header-anchor" href="#第一步：初始化标记，这一部分会-SOW，不过只需要找到所有在-Old-中的-Root">¶</a>第一步：初始化标记，这一部分会 SOW，不过只需要找到所有在 <code>Old</code> 中的 <code>Root</code></h5>
<p><img src="https://s3.jpg.cm/2020/08/02/buvHe.png" alt="buvHe.png"></p>
<h5 id="第二步：并发标记"><a class="header-anchor" href="#第二步：并发标记">¶</a>第二步：并发标记</h5>
<p>这一步不会 SOW<br>
<img src="https://s3.jpg.cm/2020/08/02/buwfy.png" alt="buwfy.png"></p>
<h5 id="第三步：重新标记"><a class="header-anchor" href="#第三步：重新标记">¶</a>第三步：重新标记</h5>
<p>重新标记处理并发标记过程中因为用户程序同时运行而导致标记产生变动的对象的标记记录。stop-the-world。<br>
<img src="https://s3.jpg.cm/2020/08/02/buoZr.png" alt="buoZr.png"></p>
<h5 id="第四步：并发清除-Concurrent-sweep"><a class="header-anchor" href="#第四步：并发清除-Concurrent-sweep">¶</a>第四步：并发清除 Concurrent sweep</h5>
<p><img src="https://s3.jpg.cm/2020/08/02/buBX5.png" alt="buBX5.png"></p>
<p>对于 <code>CMS</code> 来说，肉眼即可的问题就是 <code>Free-List</code> 带来的碎片化问题。当然我们可以设置 <code>UseCMSCompactAtFullCollection</code> 来开启 <code>压实</code>操作。</p>
<div>
    <label class="author-mark-label">小声比比3</label>
    <p class="author-mark"> 这里如果注意的话，可以发现不同的算法，开辟内存的方式是不同的。</p>
</div>
<h3 id="G1-–-Garbage-First"><a class="header-anchor" href="#G1-–-Garbage-First">¶</a>G1 – Garbage First</h3>
<p>G1按固定大小把内存划分为很多小区域(region)，这个堆大概有2000多块；在逻辑上，某些小区域构成Eden，某些构成Survivor，某些构成老年代，这些小区域物理上是不相连的，并且构成新生代和老年代的区域可以动态改变。</p>
<p><code>G1</code> 的过程和 <code>CMS</code> 是类似的，但是因为空间不再是连续的，我们可以将空间的属性进行变换。G1从整体来看是基于“标记-整理”算法实现收集，从局部（两个Region）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片。并且很多时候是重新定义Zone属于什么区域，因此会快很多。</p>
<h4 id="YoungGC"><a class="header-anchor" href="#YoungGC">¶</a>YoungGC</h4>
<p>YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC。</p>
<h4 id="MixedGC"><a class="header-anchor" href="#MixedGC">¶</a>MixedGC</h4>
<p>不是FullGC，老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full GC。</p>
<h3 id="分代算法"><a class="header-anchor" href="#分代算法">¶</a>分代算法</h3>
<p><code>JVM</code> 的分代算法和 <code>Ungar</code> 论文中一样。侧重在 <code>Young</code> 区域的回收，因此对于 <code>COPY</code> 到 <code>OLD</code> 区域的对象并不是放在 <code>Root</code> 对象上进行关联的，通过了一种名为 <code>记录集</code> 的东西记录了所有的 <code>OLD</code> 区域对象对新生代对象的集合。</p>
<h1>继续回答</h1>
<p>对于完成了对象的分配之后，我们只是开辟了一个空间（Allocate the memory space of the object），下一步我们需要的是对对象进行初始化。包括默认值等，执行构造函数等。之后一步才是将这个对象的地址挂到那个命名变量上。</p>
<h1>Q: Netty 有哪些优化手段</h1>
<h2 id="内存零拷贝"><a class="header-anchor" href="#内存零拷贝">¶</a>内存零拷贝</h2>
<ol>
<li>Netty的接收和发送ByteBuffer使用直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用JVM的堆内存进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于使用直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</li>
<li>Netty的文件传输调用FileRegion包装的transferTo方法，可以直接将文件缓冲区的数据发送到目标Channel，避免通过循环write方式导致的内存拷贝问题。</li>
<li>Netty提供CompositeByteBuf类, 可以将多个ByteBuf合并为一个逻辑上的ByteBuf, 避免了各个ByteBuf之间的拷贝。</li>
<li>通过wrap操作, 我们可以将byte[]数组、ByteBuf、ByteBuffer等包装成一个Netty ByteBuf对象, 进而避免拷贝操作。</li>
<li>ByteBuf支持slice操作，可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf, 避免内存的拷贝。</li>
</ol>
<h2 id="FastThreadLocal"><a class="header-anchor" href="#FastThreadLocal">¶</a>FastThreadLocal</h2>
<p>FastThreadLocal 在创建 Thread 时候给每个对象分配了一个 index，之后通过这个 index 会比原生的 <code>hashcode</code> 方式好很多。</p>
<h2 id="IntObjectMap"><a class="header-anchor" href="#IntObjectMap">¶</a>IntObjectMap</h2>
<p>这里还没来得及看，先 Mark</p>
<h1>Q：解释下 强引用 、软引用、弱引用、虚引用</h1>
<ul>
<li>正常都是 强引用</li>
<li>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。比较适合缓存的场景。</li>
<li>弱引用在垃圾回收时，如果这个对象只被弱引用关联（没有任何强引用关联他），那么这个对象就会被回收。</li>
<li>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象的实例。</li>
</ul>
<h1>附录1：</h1>
<h2 id="Mark-Sweep-GC"><a class="header-anchor" href="#Mark-Sweep-GC">¶</a>Mark Sweep GC</h2>
<p>标记清除应该最容易理解的算法了，对于 <code>GC</code> 的实现来说，是最为稳妥的方案，为了降低 <code>STW</code> 的时间。但是对于 <code>JVM</code> 来说，增加了很多子步骤</p>
<ul>
<li>标记阶段可以采用 <code>初始化标记</code> 和 <code>并发标记</code> 和 <code>Final Remark</code> 分成三段，这样我们需要 <code>STW</code> 的时间仅仅需要 <code>初始化标记</code> 阶段和<code>Final Remark</code>阶段。</li>
<li><code>Concurrent Preclean / Concurrent Abortable Preclean</code> 都是为了老年代处理引用 <code>年轻代</code> 的问题。</li>
<li>最终再进行 <code>Concurrent Sweep</code></li>
</ul>
<p>对于 MarkSweep 有很明显的几个缺点</p>
<ul>
<li>碎片化问题：因为在 <code>Sweep</code> 结束之后会导致内存碎片化，解决这个问题最常见的就是采用 <code>压实</code>，不过这个成本很高，只有在  <code>FullGC</code> 阶段才会触发。</li>
<li>停滞问题：<code>MarkSweep</code> 的 <code>STW</code> 跟着 <code>Heap</code>的增加，小对象的变多就会越来越慢。</li>
</ul>
<h1>参考</h1>
<ul>
<li><a href="https://dzone.com/articles/permgen-and-metaspace">PermGen and Metaspace</a></li>
<li><a href="https://juejin.im/post/6844903982905688071">What happened when new an object in JVM</a></li>
<li><a href="https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/garbage_collect.html">Understanding Memory Management</a></li>
<li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">从实际案例聊聊Java应用的GC优化</a></li>
<li><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations">garbage collection algorithms implementations</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
        <category>interview</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>interview</tag>
        <tag>jvm</tag>
        <tag>classloader</tag>
        <tag>gc</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Project Lombok</title>
    <url>/2017/06/07/java/lombok-project/</url>
    <content><![CDATA[<h2 id="目录"><a class="header-anchor" href="#目录">¶</a>目录</h2>
<ul>
<li><a href="#Lombok%E7%AE%80%E4%BB%8B">Lombok简介</a></li>
<li><a href="#Lombok%E5%AE%89%E8%A3%85">Lombok安装</a></li>
<li><a href="#Lombok%E4%BD%BF%E7%94%A8">Lombok使用</a></li>
<li><a href="#Lombok%E5%8E%9F%E7%90%86">Lombok原理</a></li>
</ul>
<h2 id="Lombok简介"><a class="header-anchor" href="#Lombok简介">¶</a>Lombok简介</h2>
<blockquote>
<p>Project Lombok makes java a spicier language by adding ‘handlers’ that know &gt;how to build and compile simple, boilerplate-free, not-quite-java code.</p>
</blockquote>
<p>如Github上项目介绍所言，Lombok项目通过添加“处理程序”，使java成为一种更为简单的语言。作为一个Old Java Developer,我们都知道我们经常需要定义一系列的套路，比如定义如下的格式对象。</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataExample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line">  <span class="keyword">private</span> String[] tags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们往往需要定义一系列的Get和Set方法最终展示形式如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataExample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line">  <span class="keyword">private</span> String[] tags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DataExample</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">double</span> score)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String[] getTags() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.tags;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTags</span><span class="params">(String[] tags)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.tags = tags;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们有没有可以简化的办法呢，第一种就是使用IDEA等IDE提供的一键生成的快捷键，第二种就是我们今天介绍的 Lombok项目：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataExample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="meta">@Setter(AccessLevel.PACKAGE)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line">  <span class="keyword">private</span> String[] tags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Wow…这样就可以完成我们的需求，简直是太棒了，仅仅需要几个注解，我们就拥有了完整的GetSet方法，还包含了ToString等方法的生成。</p>
<hr>
<h2 id="Lombok安装"><a class="header-anchor" href="#Lombok安装">¶</a>Lombok安装</h2>
<p>整个Lombok只有一个Jar包，<a href="https://projectlombok.org/download">从此处下载</a><br>
Lombok支持多种使用安装方式，这里我们讲最常见的对两大IDE的支持</p>
<h4 id="1-Eclipse-（含延伸版本）"><a class="header-anchor" href="#1-Eclipse-（含延伸版本）">¶</a>1. Eclipse （含延伸版本）</h4>
<p>双击打开 lombok.jar （前提：你得装了JDK）, 可见如下页面点击 Install/Update<br>
<img src="https://projectlombok.org/img/lombok-installer.png" alt="lombok-installer"></p>
<p>恭喜你，已经安装成功了。我们打开 Eclipse 的 About 页面我们可以看见。<br>
<img src="https://projectlombok.org/img/eclipse-about.png" alt="eclipse-about"></p>
<h4 id="2-IntelliJ-IDEA"><a class="header-anchor" href="#2-IntelliJ-IDEA">¶</a>2. IntelliJ IDEA</h4>
<ul>
<li>定位到 File &gt; Settings &gt; Plugins</li>
<li>点击 Browse repositories…</li>
<li>搜索 Lombok Plugin</li>
<li>点击 Install plugin</li>
<li>重启 IDEA</li>
</ul>
<p><img src="https://imgtn.gxnotes.com/images/2017/06/134ddf9134f65a7edfb655faac149d6b.jpg" alt="lombok-Plugin"></p>
<p>更多安装请参考：<a href="https://projectlombok.org/">https://projectlombok.org/</a></p>
<hr>
<h2 id="Lombok使用"><a class="header-anchor" href="#Lombok使用">¶</a>Lombok使用</h2>
<p>Lombok 其实也不能算是一个特别新的项目从 2011 开始在中心仓库提供支持开始，现在也分为<br>
stable 和 experimental 两个版本，本文侧重介绍 stable 功能：</p>
<h4 id="1-val"><a class="header-anchor" href="#1-val">¶</a>1. val</h4>
<p>如果对其他的语言有研究的会发现，很多语言是使用 var 作为变量申明，val作为常量申明。这里的val也是这个作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">example</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    example.add(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    <span class="type">val</span> <span class="variable">foo</span> <span class="operator">=</span> example.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> foo.toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译成 Java 程序是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">example</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;String&gt; example = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    example.add(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">foo</span> <span class="operator">=</span> example.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> foo.toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>作者注：也就是类型推导啦。</p>
</blockquote>
<h4 id="2-NonNull"><a class="header-anchor" href="#2-NonNull">¶</a>2. @NonNull</h4>
<blockquote>
<p>Null 即是罪恶</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonNullExample</span> <span class="keyword">extends</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">NonNullExample</span><span class="params">(<span class="meta">@NonNull</span> Person person)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.name = person.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译成 Java 程序是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonNullExample</span> <span class="keyword">extends</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">NonNullExample</span><span class="params">(<span class="meta">@NonNull</span> Person person)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (person == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.name = person.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-Cleanup"><a class="header-anchor" href="#3-Cleanup">¶</a>3. @Cleanup</h4>
<blockquote>
<p>自动化才是生产力</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CleanupExample</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="meta">@Cleanup</span> <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="meta">@Cleanup</span> <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(args[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> in.read(b);</span><br><span class="line">      <span class="keyword">if</span> (r == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">      out.write(b, <span class="number">0</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译成 Java 程序是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CleanupExample</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(args[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> in.read(b);</span><br><span class="line">          <span class="keyword">if</span> (r == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">          out.write(b, <span class="number">0</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">          out.close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">        in.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>作者注： JKD7里面就已经提供 try with resource</p>
</blockquote>
<h4 id="4-Getter-Setter"><a class="header-anchor" href="#4-Getter-Setter">¶</a>4. @Getter/@Setter</h4>
<blockquote>
<p>再也不写 <code>public int getFoo() &#123;return foo;&#125;</code>.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetterSetterExample</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Getter</span> <span class="meta">@Setter</span> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Setter(AccessLevel.PROTECTED)</span> <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;%s (age: %d)&quot;</span>, name, age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译成 Java 程序是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetterSetterExample</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;%s (age: %d)&quot;</span>, name, age);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-ToString"><a class="header-anchor" href="#5-ToString">¶</a>5. @ToString</h4>
<blockquote>
<p>Debug Log 最强帮手</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ToString(exclude=&quot;id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringExample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATIC_VAR</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">private</span> String[] tags;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ToString(callSuper=true, includeFieldNames=true)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> width, height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Square</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.width = width;</span><br><span class="line">      <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringExample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATIC_VAR</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">private</span> String[] tags;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> width, height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Square</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.width = width;</span><br><span class="line">      <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Square(super=&quot;</span> + <span class="built_in">super</span>.toString() + <span class="string">&quot;, width=&quot;</span> + <span class="built_in">this</span>.width + <span class="string">&quot;, height=&quot;</span> + <span class="built_in">this</span>.height + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ToStringExample(&quot;</span> + <span class="built_in">this</span>.getName() + <span class="string">&quot;, &quot;</span> + <span class="built_in">this</span>.shape + <span class="string">&quot;, &quot;</span> + Arrays.deepToString(<span class="built_in">this</span>.tags) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>作者注：其实和 org.apache.commons.lang3.builder.ReflectionToStringBuilder 很像。</p>
</blockquote>
<h4 id="6-NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor"><a class="header-anchor" href="#6-NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor">¶</a>6. @NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor(staticName = &quot;of&quot;)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor(access = AccessLevel.PROTECTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorExample</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> x, y;</span><br><span class="line">  <span class="meta">@NonNull</span> <span class="keyword">private</span> T description;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NoArgsConstructor</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NoArgsExample</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span> <span class="keyword">private</span> String field;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorExample</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> x, y;</span><br><span class="line">  <span class="meta">@NonNull</span> <span class="keyword">private</span> T description;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">ConstructorExample</span><span class="params">(T description)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (description == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.description = description;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ConstructorExample&lt;T&gt; <span class="title function_">of</span><span class="params">(T description)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstructorExample</span>&lt;T&gt;(description);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@java</span>.beans.ConstructorProperties(&#123;<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;description&quot;</span>&#125;)</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">ConstructorExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, T description)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (description == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">    <span class="built_in">this</span>.description = description;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NoArgsExample</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span> <span class="keyword">private</span> String field;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NoArgsExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-Data"><a class="header-anchor" href="#7-Data">¶</a>7. @Data</h4>
<p>这个就相当的简单啦，因为我们发现 @ToString, @EqualsAndHashCode, @Getter 都很常用，这个一个注解就相当于</p>
<p>@ToString, @EqualsAndHashCode, @Getter(所有字段), @Setter (所有非final字段), @RequiredArgsConstructor!</p>
<h4 id="8-Value"><a class="header-anchor" href="#8-Value">¶</a>8. @Value</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValueExample</span> &#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="meta">@Wither(AccessLevel.PACKAGE)</span> <span class="meta">@NonFinal</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="type">double</span> score;</span><br><span class="line">  <span class="keyword">protected</span> String[] tags;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ToString(includeFieldNames=true)</span></span><br><span class="line">  <span class="meta">@Value(staticConstructor=&quot;of&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Exercise</span>&lt;T&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    T value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ValueExample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> score;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> String[] tags;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@java</span>.beans.ConstructorProperties(&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;score&quot;</span>, <span class="string">&quot;tags&quot;</span>&#125;)</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ValueExample</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> score, String[] tags)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">    <span class="built_in">this</span>.tags = tags;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String[] getTags() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.tags;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@java</span>.lang.Override</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="built_in">this</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ValueExample)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ValueExample</span> <span class="variable">other</span> <span class="operator">=</span> (ValueExample)o;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">this$name</span> <span class="operator">=</span> <span class="built_in">this</span>.getName();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">other$name</span> <span class="operator">=</span> other.getName();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>$name == <span class="literal">null</span> ? other$name != <span class="literal">null</span> : !<span class="built_in">this</span>$name.equals(other$name)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.getAge() != other.getAge()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Double.compare(<span class="built_in">this</span>.getScore(), other.getScore()) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Arrays.deepEquals(<span class="built_in">this</span>.getTags(), other.getTags())) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@java</span>.lang.Override</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRIME</span> <span class="operator">=</span> <span class="number">59</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">$name</span> <span class="operator">=</span> <span class="built_in">this</span>.getName();</span><br><span class="line">    result = result * PRIME + ($name == <span class="literal">null</span> ? <span class="number">43</span> : $name.hashCode());</span><br><span class="line">    result = result * PRIME + <span class="built_in">this</span>.getAge();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">$score</span> <span class="operator">=</span> Double.doubleToLongBits(<span class="built_in">this</span>.getScore());</span><br><span class="line">    result = result * PRIME + (<span class="type">int</span>)($score &gt;&gt;&gt; <span class="number">32</span> ^ $score);</span><br><span class="line">    result = result * PRIME + Arrays.deepHashCode(<span class="built_in">this</span>.getTags());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@java</span>.lang.Override</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ValueExample(name=&quot;</span> + getName() + <span class="string">&quot;, age=&quot;</span> + getAge() + <span class="string">&quot;, score=&quot;</span> + getScore() + <span class="string">&quot;, tags=&quot;</span> + Arrays.deepToString(getTags()) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ValueExample <span class="title function_">withAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age == age ? <span class="built_in">this</span> : <span class="keyword">new</span> <span class="title class_">ValueExample</span>(name, age, score, tags);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Exercise</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Exercise</span><span class="params">(String name, T value)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Exercise&lt;T&gt; <span class="title function_">of</span><span class="params">(String name, T value)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Exercise</span>&lt;T&gt;(name, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@java</span>.lang.Override</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (o == <span class="built_in">this</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ValueExample.Exercise)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">final</span> Exercise&lt;?&gt; other = (Exercise&lt;?&gt;)o;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">this$name</span> <span class="operator">=</span> <span class="built_in">this</span>.getName();</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">other$name</span> <span class="operator">=</span> other.getName();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>$name == <span class="literal">null</span> ? other$name != <span class="literal">null</span> : !<span class="built_in">this</span>$name.equals(other$name)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">this$value</span> <span class="operator">=</span> <span class="built_in">this</span>.getValue();</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">other$value</span> <span class="operator">=</span> other.getValue();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>$value == <span class="literal">null</span> ? other$value != <span class="literal">null</span> : !<span class="built_in">this</span>$value.equals(other$value)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@java</span>.lang.Override</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRIME</span> <span class="operator">=</span> <span class="number">59</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">$name</span> <span class="operator">=</span> <span class="built_in">this</span>.getName();</span><br><span class="line">      result = result * PRIME + ($name == <span class="literal">null</span> ? <span class="number">43</span> : $name.hashCode());</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">$value</span> <span class="operator">=</span> <span class="built_in">this</span>.getValue();</span><br><span class="line">      result = result * PRIME + ($value == <span class="literal">null</span> ? <span class="number">43</span> : $value.hashCode());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@java</span>.lang.Override</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ValueExample.Exercise(name=&quot;</span> + getName() + <span class="string">&quot;, value=&quot;</span> + getValue() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现了 @Value 就是 @Data 的不可变版本。至于不可变有什么好处。可有参看<a href="https://blogs.msdn.microsoft.com/ericlippert/2007/11/13/immutability-in-c-part-one-kinds-of-immutability/">此篇</a></p>
<h4 id="9-Builder"><a class="header-anchor" href="#9-Builder">¶</a>9. @Builder</h4>
<blockquote>
<p>我的最爱</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuilderExample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="meta">@Singular</span> <span class="keyword">private</span> Set&lt;String&gt; occupations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuilderExample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> Set&lt;String&gt; occupations;</span><br><span class="line"></span><br><span class="line">  BuilderExample(String name, <span class="type">int</span> age, Set&lt;String&gt; occupations) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.occupations = occupations;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> BuilderExampleBuilder <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BuilderExampleBuilder</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BuilderExampleBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> java.util.ArrayList&lt;String&gt; occupations;</span><br><span class="line"></span><br><span class="line">    BuilderExampleBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BuilderExampleBuilder <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BuilderExampleBuilder <span class="title function_">age</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BuilderExampleBuilder <span class="title function_">occupation</span><span class="params">(String occupation)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.occupations == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.occupations = <span class="keyword">new</span> <span class="title class_">java</span>.util.ArrayList&lt;String&gt;();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.occupations.add(occupation);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BuilderExampleBuilder <span class="title function_">occupations</span><span class="params">(Collection&lt;? extends String&gt; occupations)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.occupations == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.occupations = <span class="keyword">new</span> <span class="title class_">java</span>.util.ArrayList&lt;String&gt;();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.occupations.addAll(occupations);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BuilderExampleBuilder <span class="title function_">clearOccupations</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.occupations != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.occupations.clear();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BuilderExample <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// complicated switch statement to produce a compact properly sized immutable set omitted.</span></span><br><span class="line">      <span class="comment">// go to https://projectlombok.org/features/Singular-snippet.html to see it.</span></span><br><span class="line">      Set&lt;String&gt; occupations = ...;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BuilderExample</span>(name, age, occupations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@java</span>.lang.Override</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;BuilderExample.BuilderExampleBuilder(name = &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;, age = &quot;</span> + <span class="built_in">this</span>.age + <span class="string">&quot;, occupations = &quot;</span> + <span class="built_in">this</span>.occupations + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>builder是现在比较推崇的一种构建值对象的方式。</p>
<blockquote>
<p>作者注：<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F">生成器模式</a></p>
</blockquote>
<h4 id="10-SneakyThrows"><a class="header-anchor" href="#10-SneakyThrows">¶</a>10. @SneakyThrows</h4>
<blockquote>
<p>to RuntimeException 小助手</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SneakyThrowsExample</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="meta">@SneakyThrows(UnsupportedEncodingException.class)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">utf8ToString</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SneakyThrows</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SneakyThrowsExample</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">utf8ToString</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> Lombok.sneakyThrow(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> Lombok.sneakyThrow(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很好的隐藏了异常，有时候的确会有这样的烦恼，从某种程度上也是遵循的了 <a href="http://wiki.c2.com/?LetItCrash">let is crash</a></p>
<h4 id="11-Synchronized"><a class="header-anchor" href="#11-Synchronized">¶</a>11. @Synchronized</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">readLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Synchronized</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Synchronized</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">answerToLife</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Synchronized(&quot;readLock&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">$LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">$lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">readLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>($LOCK) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">answerToLife</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>($lock) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(readLock) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就比较简单直接添加了synchronized关键字就Ok啦。不过现在JDK也比较推荐的是 Lock 对象，这个可能用的不是特别多。</p>
<h4 id="12-Getter-lazy-true"><a class="header-anchor" href="#12-Getter-lazy-true">¶</a>12. @Getter(lazy=true)</h4>
<blockquote>
<p>节约是美德</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetterLazyExample</span> &#123;</span><br><span class="line">  <span class="meta">@Getter(lazy=true)</span> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span>[] cached = expensive();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span>[] expensive() &#123;</span><br><span class="line">    <span class="type">double</span>[] result = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">      result[i] = Math.asin(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetterLazyExample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> java.util.concurrent.AtomicReference&lt;java.lang.Object&gt; cached = <span class="keyword">new</span> <span class="title class_">java</span>.util.concurrent.AtomicReference&lt;java.lang.Object&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span>[] getCached() &#123;</span><br><span class="line">    java.lang.<span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.cached.get();</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="built_in">this</span>.cached) &#123;</span><br><span class="line">        value = <span class="built_in">this</span>.cached.get();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="type">double</span>[] actualValue = expensive();</span><br><span class="line">          value = actualValue == <span class="literal">null</span> ? <span class="built_in">this</span>.cached : actualValue;</span><br><span class="line">          <span class="built_in">this</span>.cached.set(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>[])(value == <span class="built_in">this</span>.cached ? <span class="literal">null</span> : value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span>[] expensive() &#123;</span><br><span class="line">    <span class="type">double</span>[] result = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">      result[i] = Math.asin(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-Log"><a class="header-anchor" href="#13-Log">¶</a>13. @Log</h4>
<blockquote>
<p>再也不用写那些差不多的LOG啦</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Log</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogExample</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Something&#x27;s wrong here&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogExampleOther</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Something else is wrong here&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CommonsLog(topic=&quot;CounterLog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogExampleCategory</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Calling the &#x27;CounterLog&#x27; with a message&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogExample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.util.logging.<span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> java.util.logging.Logger.getLogger(LogExample.class.getName());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Something&#x27;s wrong here&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogExampleOther</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.<span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> org.slf4j.LoggerFactory.getLogger(LogExampleOther.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Something else is wrong here&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogExampleCategory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.commons.logging.<span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> org.apache.commons.logging.LogFactory.getLog(<span class="string">&quot;CounterLog&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Calling the &#x27;CounterLog&#x27; with a message&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Lombok原理"><a class="header-anchor" href="#Lombok原理">¶</a>Lombok原理</h2>
<p>说道 Lombok，我们就得去提到 <a href="https://www.jcp.org/en/jsr/detail?id=269">JSR 269: Pluggable Annotation Processing API</a>  JSR 269 之前我们也有注解这样的神器，可是我们比如想要做什么必须使用反射，反射的方法局限性较大。首先，它必须定义@Retention为RetentionPolicy.RUNTIME，只能在运行时通过反射来获取注解值，使得运行时代码效率降低。其次，如果想在编译阶段利用注解来进行一些检查，对用户的某些不合理代码给出错误报告，反射的使用方法就无能为力了。而 JSR 269 之后我们可以在 Javac的编译期利用注解做这些事情。所以我们发现核心的区分是在 <strong>运行期</strong> 还是 <strong>编译期</strong></p>
<p><img src="http://openjdk.java.net/groups/compiler/doc/compilation-overview/javac-flow.png" alt="javac-flow"></p>
<p>从上图可知，Annotation Processing 是在解析和生成之间的一个步骤。</p>
<p><img src="http://4.bp.blogspot.com/_c3fRh9YnHfU/TSZEbT0mC2I/AAAAAAAAABk/VGcO_dLIo9k/s1600/Compile%2BProcess.gif" alt="Compile%2BProcess"></p>
<p>上图是 Lombok 处理流程，在Javac 解析成抽象语法树之后(AST), Lombok 根据自己的注解处理器，动态的修改 AST，增加新的节点(所谓代码)，最终通过分析和生成字节码。</p>
<p>关于原理我们大致上的描述下，如果有兴趣可以参考 作者注。</p>
<blockquote>
<p>作者注：<br>
<a href="http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html">jdk-compilation-overview</a>.<br>
<a href="http://notatube.blogspot.jp/2010/12/project-lombok-creating-custom.html">Project Lombok: Creating Custom Transformations</a></p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes-Calico-网络原理(2) - Container &amp; Pod</title>
    <url>/2019/03/17/kubernetes/how-kubernetes-network-2/</url>
    <content><![CDATA[<p>在 <a href="">kubernetes 网络原理(0) - 网络知识预备</a> 和 <a href="">kubernetes 网络原理(1) - 环境预备 &amp; 初窥网络</a> 中我们将基础的知识已经知悉，我们就来看看我们的网络通讯。</p>
<p>我们已知道 <code>Kubernetes</code> 的逻辑架构如下：<br>
<img src="https://i.loli.net/2019/03/17/5c8e1371f3af1.png" alt="arc"></p>
<span id="more"></span>
<h2 id="Container-Container"><a class="header-anchor" href="#Container-Container">¶</a>Container &lt;-&gt; Container</h2>
<p>在<code>Kubernetes</code>中我们知道一个 <code>Pod</code> 由多个 <code>Container</code> 构成，而在 <code>Pod</code> 内的<code>Container</code>和<code>Container</code> 的通讯是通过 <code>localhost</code> 这个虚拟独立出来的 <code>namespace</code> 。</p>
<p><img src="https://i.loli.net/2019/03/18/5c8ef761d3bae.png" alt=""></p>
<p>我们来做个实验确认下。<br>
我们使用如下的 <code>yaml</code> 部署一个 <code>Pod</code></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Pod部署Yaml文件
    </div>
    <div class='spoiler-content'>
        <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">c2c-network-demo</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">c2c-network-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello-world-server</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">python:2.7</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">command:</span> [<span class="string">&quot;/bin/bash&quot;</span>]</span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo \&quot;&lt;p&gt;Hi from $(hostname)&lt;/p&gt;\&quot; &gt; index.html; python -m SimpleHTTPServer 8080&quot;</span>]</span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">curl-client</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">yannxia/ubuntu-with-tcpdump</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>]</span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;while true; do echo &#x27;GET / HTTP/1.1\r\n\r\n&#x27; | nc localhost 8080; sleep 10; done;&quot;</span>]</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>我们使用如下脚本进入系统内部</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> c2c-network-demo -c curl-client -it bash</span><br></pre></td></tr></table></figure>
<p>我们先看看我们的网卡信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@c2c-network-demo:/<span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    <span class="built_in">link</span>/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">4: eth0@if13: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1440 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether aa:43:a3:65:96:87 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 192.168.1.10/32 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>我们发现了我们有 <code>3</code> 张网卡，分别是 <code>lo</code>,<code>tunl0</code>,<code>eth0</code>，我们监听下我们的 <code>lo</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@c2c-network-demo:/<span class="comment"># tcpdump -i lo</span></span><br></pre></td></tr></table></figure>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        TcpDump信息
    </div>
    <div class='spoiler-content'>
        <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">08:08:42.491989 IP localhost.51366 &gt; localhost.8080: Flags [S], <span class="built_in">seq</span> 350716622, win 43690, options [mss 65495,sackOK,TS val 196496407 ecr 0,nop,wscale 7], length 0</span><br><span class="line">08:08:42.492014 IP localhost.8080 &gt; localhost.51366: Flags [S.], <span class="built_in">seq</span> 1782151785, ack 350716623, win 43690, options [mss 65495,sackOK,TS val 196496407 ecr 196496407,nop,wscale 7], length 0</span><br><span class="line">08:08:42.492035 IP localhost.51366 &gt; localhost.8080: Flags [.], ack 1, win 342, options [nop,nop,TS val 196496407 ecr 196496407], length 0</span><br><span class="line">08:08:42.492084 IP localhost.51366 &gt; localhost.8080: Flags [P.], <span class="built_in">seq</span> 1:20, ack 1, win 342, options [nop,nop,TS val 196496407 ecr 196496407], length 19: HTTP: GET / HTTP/1.1</span><br><span class="line">08:08:42.492886 IP localhost.8080 &gt; localhost.51366: Flags [P.], <span class="built_in">seq</span> 1:18, ack 20, win 342, options [nop,nop,TS val 196496407 ecr 196496407], length 17: HTTP: HTTP/1.0 200 OK</span><br><span class="line">08:08:42.492908 IP localhost.51366 &gt; localhost.8080: Flags [.], ack 18, win 342, options [nop,nop,TS val 196496407 ecr 196496407], length 0</span><br><span class="line">08:08:42.492995 IP localhost.8080 &gt; localhost.51366: Flags [P.], <span class="built_in">seq</span> 18:56, ack 20, win 342, options [nop,nop,TS val 196496407 ecr 196496407], length 38: HTTP</span><br><span class="line">08:08:42.493006 IP localhost.51366 &gt; localhost.8080: Flags [.], ack 56, win 342, options [nop,nop,TS val 196496407 ecr 196496407], length 0</span><br><span class="line">08:08:42.493768 IP localhost.8080 &gt; localhost.51366: Flags [P.], <span class="built_in">seq</span> 56:93, ack 20, win 342, options [nop,nop,TS val 196496407 ecr 196496407], length 37: HTTP</span><br><span class="line">08:08:42.493786 IP localhost.51366 &gt; localhost.8080: Flags [.], ack 93, win 342, options [nop,nop,TS val 196496407 ecr 196496407], length 0</span><br><span class="line">08:08:42.493883 IP localhost.8080 &gt; localhost.51366: Flags [P.], <span class="built_in">seq</span> 93:118, ack 20, win 342, options [nop,nop,TS val 196496407 ecr 196496407], length 25: HTTP</span><br><span class="line">08:08:42.494702 IP localhost.8080 &gt; localhost.51366: Flags [P.], <span class="built_in">seq</span> 138:184, ack 20, win 342, options [nop,nop,TS val 196496407 ecr 196496407], length 46: HTTP</span><br><span class="line">08:08:42.494717 IP localhost.51366 &gt; localhost.8080: Flags [.], ack 184, win 342, options [nop,nop,TS val 196496407 ecr 196496407], length 0</span><br><span class="line">08:08:42.494980 IP localhost.8080 &gt; localhost.51366: Flags [P.], <span class="built_in">seq</span> 184:186, ack 20, win 342, options [nop,nop,TS val 196496408 ecr 196496407], length 2: HTTP</span><br><span class="line">08:08:42.494999 IP localhost.51366 &gt; localhost.8080: Flags [.], ack 186, win 342, options [nop,nop,TS val 196496408 ecr 196496408], length 0</span><br><span class="line">08:08:42.495134 IP localhost.8080 &gt; localhost.51366: Flags [P.], <span class="built_in">seq</span> 186:218, ack 20, win 342, options [nop,nop,TS val 196496408 ecr 196496408], length 32: HTTP</span><br><span class="line">08:08:42.495151 IP localhost.51366 &gt; localhost.8080: Flags [.], ack 218, win 342, options [nop,nop,TS val 196496408 ecr 196496408], length 0</span><br><span class="line">08:08:42.495397 IP localhost.8080 &gt; localhost.51366: Flags [F.], <span class="built_in">seq</span> 218, ack 20, win 342, options [nop,nop,TS val 196496408 ecr 196496408], length 0</span><br><span class="line">08:08:42.495464 IP localhost.51366 &gt; localhost.8080: Flags [F.], <span class="built_in">seq</span> 20, ack 219, win 342, options [nop,nop,TS val 196496408 ecr 196496408], length 0</span><br><span class="line">08:08:42.495499 IP localhost.8080 &gt; localhost.51366: Flags [.], ack 21, win 342, options [nop,nop,TS val 196496408 ecr 196496408], length 0</span><br></pre></td></tr></table></figure>
    </div>
</div>
<p>切换监听另外一个 <code>eth0</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@c2c-network-demo:/<span class="comment"># tcpdump -i eth0</span></span><br></pre></td></tr></table></figure>
<p>我们发现并没有任何的输出，（虽然如同一个废话）</p>
<h2 id="Pod-Pod"><a class="header-anchor" href="#Pod-Pod">¶</a>Pod &lt;-&gt; Pod</h2>
<h3 id="嗅探蛛丝马迹"><a class="header-anchor" href="#嗅探蛛丝马迹">¶</a>嗅探蛛丝马迹</h3>
<p>因为在一个 Pod 内的通讯是简单的，我们来看看我们我们下面需要去进阶的一个网络，<code>Pod</code> 和 <code>Pod</code> 之间的通讯。</p>
<p><img src="https://i.loli.net/2019/03/18/5c8fb5f3aa88e.png" alt=""></p>
<p>现在我们就想知道 <code>Pod</code> 和 <code>Pod</code> 之间他们是怎么通讯的。<br>
在容器内进行 <code>ip a</code> 的时候，我们发现除了 <code>lo</code> 的回环地址之外，就还有一个我们所熟悉的 <code>eth0</code> 网卡，而这个网卡的<code>IP</code> 也显得颇为特别。<code>192.168.1.10/32</code>，我们在定位下这个 POD 所在的机器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods -o wide</span><br><span class="line">NAME               READY   STATUS    RESTARTS   AGE     IP             NODE           NOMINATED NODE   READINESS GATES</span><br><span class="line">c2c-network-demo   2/2     Running   0          7h34m   192.168.1.10   k8s-worker-1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>还记得 <code>k8s-worker-1</code> 这个机器的 <code>Tun0</code> 的 <code>IP</code> 是 <code>192.168.1.1</code>，Wow，我们发现 <code>Pod</code>的 IP 和<code>Tun0</code> 的 <code>IP</code> 在同一个网段中。我们在 <code>c2c-network-demo</code> 检查下网络状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@c2c-network-demo:/<span class="comment"># route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         169.254.1.1     0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">169.254.1.1     0.0.0.0         255.255.255.255 UH    0      0        0 eth0</span><br></pre></td></tr></table></figure>
<p>我们可以发现我们网络包的网关是一个 <code>169.254.1.1</code> 的私有地址，实际上应该也不对应任何的设备，从路由表中可以得到的信息是，我们所有的数据包都会从 <code>eth0</code> 的网卡发出去。</p>
<p>我们新起一个 <code>pod</code> 尝试访问下我们的 <code>echo-server</code></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        部署一个Tools-Pod
    </div>
    <div class='spoiler-content'>
        <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">test-tools</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">test-tools</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">curl-client</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">yannxia/ubuntu-with-tcpdump</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>]</span><br><span class="line">  <span class="attr">args:</span> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;while true; do sleep 10; done;&quot;</span>]</span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">  <span class="attr">worker:</span> <span class="literal">no</span><span class="number">-1</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>我们在新启动的 <code>test-tools</code> 中检查下网络状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@test-tools:/<span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    <span class="built_in">link</span>/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">4: eth0@if15: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1440 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether ee:c9:6c:15:ea:ca brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 192.168.1.12/32 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>不出意外的话，我们可以看的出来 <code>192.168.1.12/32</code> 和上述的 <code>192.168.1.10/32</code> 看起来就像是在同一个网段内，子网掩码是<code>32</code>又在无处的命中我们的内心，他们的确是隔离的网络，我们来看看这<strong>两个网络怎么相通</strong>吧。</p>
<ul>
<li>
<p>Ping 一下，是成功的网络是相通</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@test-tools:/<span class="comment"># ping 192.168.1.10</span></span><br><span class="line">PING 192.168.1.10 (192.168.1.10): 56 data bytes</span><br><span class="line">64 bytes from 192.168.1.10: icmp_seq=0 ttl=63 time=0.270 ms</span><br><span class="line">64 bytes from 192.168.1.10: icmp_seq=1 ttl=63 time=0.083 ms</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>抓个包看看（上文已经知道出口是 eth0）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 请求一个HTTP</span></span><br><span class="line">root@test-tools:/<span class="comment"># curl 192.168.1.10:8080</span></span><br><span class="line">&lt;p&gt;Hi from c2c-network-demo&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时抓包网卡，没有获得什么有用的信息，网络是直接相通的</span></span><br><span class="line">root@test-tools:/<span class="comment"># tcpdump -i eth0</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">03:21:20.695727 IP test-tools.33968 &gt; 192.168.1.10.http-alt: Flags [S], <span class="built_in">seq</span> 1375634196, win 28000, options [mss 1400,sackOK,TS val 235385958 ecr 0,nop,wscale 7], length 0</span><br><span class="line">03:21:20.695831 IP 192.168.1.10.http-alt &gt; test-tools.33968: Flags [S.], <span class="built_in">seq</span> 2004093135, ack 1375634197, win 27760, options [mss 1400,sackOK,TS val 235385958 ecr 235385958,nop,wscale 7], length 0</span><br><span class="line">03:21:20.695847 IP test-tools.33968 &gt; 192.168.1.10.http-alt: Flags [.], ack 1, win 219, options [nop,nop,TS val 235385958 ecr 235385958], length 0</span><br><span class="line">03:21:20.695904 IP test-tools.33968 &gt; 192.168.1.10.http-alt: Flags [P.], <span class="built_in">seq</span> 1:82, ack 1, win 219, options [nop,nop,TS val 235385958 ecr 235385958], length 81: HTTP: GET / HTTP/1.1</span><br><span class="line">03:21:20.695916 IP 192.168.1.10.http-alt &gt; test-tools.33968: Flags [.], ack 82, win 217, options [nop,nop,TS val 235385958 ecr 235385958], length 0</span><br><span class="line">03:21:20.696182 IP test-tools.55118 &gt; kube-dns.kube-system.svc.cluster.local.domain: 42450+ PTR? 10.1.168.192.in-addr.arpa. (43)</span><br><span class="line">03:21:20.696341 IP 192.168.1.10.http-alt &gt; test-tools.33968: Flags [P.], <span class="built_in">seq</span> 1:18, ack 82, win 217, options [nop,nop,TS val 235385958 ecr 235385958], length 17: HTTP: HTTP/1.0 200 OK</span><br><span class="line">03:21:20.714519 IP test-tools.35007 &gt; kube-dns.kube-system.svc.cluster.local.domain: 29106+ PTR? 10.0.96.10.in-addr.arpa. (41)</span><br><span class="line">03:21:20.715149 IP kube-dns.kube-system.svc.cluster.local.domain &gt; test-tools.35007: 29106* 1/0/0 PTR kube-dns.kube-system.svc.cluster.local. (116)</span><br></pre></td></tr></table></figure>
<p>既然中间没有什么 TCP 的中继，那显然是通过路由表实现这样的功能，我们再来看看路由是怎么跳的。</p>
</li>
</ul>
<p>没有发现什么内容，显然如果就这么放弃显然也为之过早，我们回到宿主机上检查下。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        网卡信息
    </div>
    <div class='spoiler-content'>
        <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ ~ ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line"><span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">inet 127.0.0.1/8 scope host lo</span><br><span class="line">valid_lft forever preferred_lft forever</span><br><span class="line">inet6 ::1/128 scope host</span><br><span class="line">valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">2: ens192: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line"><span class="built_in">link</span>/ether 00:50:56:b4:07:5f brd ff:ff:ff:ff:ff:ff</span><br><span class="line">inet 10.12.22.2/16 brd 10.12.255.255 scope global ens192</span><br><span class="line">valid_lft forever preferred_lft forever</span><br><span class="line">inet6 fe80::250:56ff:feb4:75f/64 scope <span class="built_in">link</span></span><br><span class="line">valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class="line"><span class="built_in">link</span>/ether 02:42:fb:53:a2:33 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">4: tunl0@NONE: &lt;NOARP,UP,LOWER_UP&gt; mtu 1440 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line"><span class="built_in">link</span>/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">inet 192.168.1.1/32 brd 192.168.1.1 scope global tunl0</span><br><span class="line">valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">5: cali0005aea454a@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1440 qdisc noqueue state UP group default</span><br><span class="line"><span class="built_in">link</span>/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">inet6 fe80::ecee:eeff:feee:eeee/64 scope <span class="built_in">link</span></span><br><span class="line">valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">13: calid9d486e54a8@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1440 qdisc noqueue state UP group default</span><br><span class="line"><span class="built_in">link</span>/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">inet6 fe80::ecee:eeff:feee:eeee/64 scope <span class="built_in">link</span></span><br><span class="line">valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">15: calied9d42cb137@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1440 qdisc noqueue state UP group default</span><br><span class="line"><span class="built_in">link</span>/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 2</span><br><span class="line">inet6 fe80::ecee:eeff:feee:eeee/64 scope <span class="built_in">link</span></span><br><span class="line">valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
    </div>
</div>
<p>再次执行 <code>ip link type veth</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">5: cali0005aea454a@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1440 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    <span class="built_in">link</span>/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">13: calid9d486e54a8@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1440 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    <span class="built_in">link</span>/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">15: calied9d42cb137@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1440 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    <span class="built_in">link</span>/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 2</span><br></pre></td></tr></table></figure>
<p>我们发现了我们其实多了一些 <code>veth</code>，让我们嗅到了一些蛛丝马迹的感觉，我们知道<code>veth</code>设备总是成对出现的。那我们<code>eth0</code>的关联的又是哪一个虚拟网卡呢？我们借助<code>ifindex</code> 这个全局唯一的信息来查看。</p>
<p>在容器内执行如下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@test-tools:/<span class="comment"># cat /sys/class/net/eth0/iflink</span></span><br><span class="line">15 <span class="comment">#iflink</span></span><br></pre></td></tr></table></figure>
<p>我们再回到宿主机上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ grep -l 13 /sys/class/net/cali*/ifindex</span><br><span class="line">/sys/class/net/calid9d486e54a8/ifindex</span><br></pre></td></tr></table></figure>
<p>我们发现了容器内的 <code>eth0</code> 绑定到了 <code>calid9d486e54a8</code> 这个虚网卡上了。<br>
<img src="https://i.loli.net/2019/03/20/5c91f0d27c90e.png" alt=""></p>
<p>现在我们知道所有的网卡设备的网络请求都通过 容器的<code>eth0</code> &lt;-&gt; 宿主机 <code>calid9d486e54a8</code> 上。</p>
<h3 id="Pod-的通讯"><a class="header-anchor" href="#Pod-的通讯">¶</a>Pod 的通讯</h3>
<p>我们现在对 <code>calid9d486e54a8</code> 抓个包，可以轻易获得数据流量，也验证了我们上述的证明事情。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        网卡信息
    </div>
    <div class='spoiler-content'>
        <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ ~ tcpdump -i calid9d486e54a8</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on calid9d486e54a8, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">15:53:54.987899 IP 192.168.1.12.50360 &gt; 192.168.1.10.http-alt: Flags [S], <span class="built_in">seq</span> 1365715020, win 28000, options [</span><br><span class="line">mss 1400,sackOK,TS val 239474531 ecr 0,nop,wscale 7], length 0</span><br><span class="line">15:53:54.987928 IP 192.168.1.10.http-alt &gt; 192.168.1.12.50360: Flags [S.], <span class="built_in">seq</span> 3189753753, ack 1365715021, win</span><br><span class="line">27760, options [mss 1400,sackOK,TS val 239474531 ecr 239474531,nop,wscale 7], length 0</span><br><span class="line">15:53:54.987965 IP 192.168.1.12.50360 &gt; 192.168.1.10.http-alt: Flags [.], ack 1, win 219, options [nop,nop,TS</span><br><span class="line">val 239474531 ecr 239474531], length 0</span><br><span class="line">15:53:54.988232 IP 192.168.1.12.50360 &gt; 192.168.1.10.http-alt: Flags [P.], <span class="built_in">seq</span> 1:82, ack 1, win 219, options [</span><br><span class="line">nop,nop,TS val 239474531 ecr 239474531], length 81: HTTP: GET / HTTP/1.1</span><br><span class="line">15:53:54.988277 IP 192.168.1.10.http-alt &gt; 192.168.1.12.50360: Flags [.], ack 82, win 217, options [nop,nop,TS</span><br><span class="line">val 239474531 ecr 239474531], length 0</span><br><span class="line">15:53:54.988802 IP 192.168.1.10.http-alt &gt; 192.168.1.12.50360: Flags [P.], <span class="built_in">seq</span> 1:18, ack 82, win 217, options</span><br><span class="line">[nop,nop,TS val 239474531 ecr 239474531], length 17: HTTP: HTTP/1.0 200 OK</span><br><span class="line">15:53:54.988852 IP 192.168.1.12.50360 &gt; 192.168.1.10.http-alt: Flags [.], ack 18, win 219, options [nop,nop,TS</span><br><span class="line">val 239474531 ecr 239474531], length 0</span><br><span class="line">15:54:00.222860 ARP, Request who-has 192.168.1.10 tell k8s-worker-1, length 28</span><br><span class="line">15:54:00.222974 ARP, Request who-has 169.254.1.1 tell 192.168.1.10, length 28</span><br><span class="line">15:54:00.222981 ARP, Reply 169.254.1.1 is-at ee:ee:ee:ee:ee:ee (oui Unknown), length 28</span><br><span class="line">15:54:00.222994 ARP, Reply 192.168.1.10 is-at aa:43:a3:65:96:87 (oui Unknown), length 28</span><br></pre></td></tr></table></figure>
    </div>
</div>
<p>那这个数据到了 <code>calid9d486e54a8</code> 之后又是怎么扭转的呢？既然<code>IP</code>没有任何改变，应该是通过路由表实现的。<br>
我们查询下路由表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         10.12.0.1       0.0.0.0         UG    0      0        0 ens192</span><br><span class="line">10.12.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens192</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.0.0     10.12.22.1      255.255.255.0   UG    0      0        0 tunl0</span><br><span class="line">192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 *</span><br><span class="line">192.168.1.2     0.0.0.0         255.255.255.255 UH    0      0        0 cali0005aea454a</span><br><span class="line">192.168.1.10    0.0.0.0         255.255.255.255 UH    0      0        0 calid9d486e54a8</span><br><span class="line">192.168.1.12    0.0.0.0         255.255.255.255 UH    0      0        0 calied9d42cb137</span><br><span class="line">192.168.2.0     10.12.22.3      255.255.255.0   UG    0      0        0 tunl0</span><br></pre></td></tr></table></figure>
<p>因为我们的 <code>dest ip</code> 是 <code>192.168.1.12</code>，显而易见的我们命中了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.1.12    0.0.0.0         255.255.255.255 UH    0      0        0 calied9d42cb137</span><br></pre></td></tr></table></figure>
<p>我们现在的网络显然就是这样的：<br>
<img src="https://i.loli.net/2019/03/20/5c91f7f31eea6.png" alt=""></p>
<p>轻而易举的可以补全这个图：<br>
<img src="https://i.loli.net/2019/03/20/5c9262addd093.png" alt=""></p>
<h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2>
<ul>
<li><a href="https://superuser.com/questions/1183454/finding-out-the-veth-interface-of-a-docker-container">finding-out-the-veth-interface-of-a-docker-container</a></li>
<li><a href="https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking/">Introduction to Linux interfaces for virtual networking</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>kubernetes</category>
        <category>network</category>
        <category>calico</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>network</tag>
        <tag>calico</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊服务端热更新</title>
    <url>/2020/06/12/other/hot-restart/</url>
    <content><![CDATA[<p>随着Devops以及微服务的普及，应用上线周期变短，对于以前那种需要停机升级的忍受度也在不断的降低，话不多说，进入主题。</p>
<h1>我们需要解决的</h1>
<p><img src="https://s1.ax1x.com/2020/06/12/tXcilt.png" alt="tXcilt.png"><br>
对于我们来说，我们所需要解决的是：当我们运行着一个服务进程的时候，我们期望这个进程能够突然之间变成新的(新的代码逻辑)，并且外部无感知。至少包含几点：</p>
<ul>
<li>服务状态不丢失：比如监控状态，正在处理的数据状态</li>
<li>服务不中断：用户不能够感知到服务被中断</li>
</ul>
<p>抱着这样的目的，我们来看看我们是怎么解决的。</p>
<span id="more"></span>
<h1>方案一：逻辑热更新</h1>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+-------------------------------------------------+</span><br><span class="line">|                                                 |</span><br><span class="line">|                 动 态 脚 本 运 行 层              |</span><br><span class="line">|                                                 |</span><br><span class="line">+-------------------------------------------------+</span><br><span class="line">+-------------------------------------------------+</span><br><span class="line">|                                                 |</span><br><span class="line">|               C++/Java/Go 数 据 接 收 层          |</span><br><span class="line">|                                                 |</span><br><span class="line">+-------------------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种方案是比较常见的一种解决方案，由于嵌入到进程里面的脚本语言引擎，本质上是将脚本语言代码翻译成内存中的Opcode来执行，因此这类型服务器实现“热更新”方案很简单：将新的脚本同步到服务器上，然后给服务器发出一个信号，重新读取脚本代码到内存中即可。</p>
<p><img src="https://s1.ax1x.com/2020/06/12/tXRJ78.png" alt="tXRJ78.png"></p>
<h2 id="注意点"><a class="header-anchor" href="#注意点">¶</a>注意点</h2>
<ol>
<li>脚本应该是在测试环境验证过的，如果上传了错误的脚本很容易带来灾难性的后果，笔者的公司对此需要走上线审计流程</li>
<li>对于长时间运行的请求需要保留旧的脚本，直到处理完成。</li>
<li>对于运行层本身的升级就需要停机或者是自举的方式了。</li>
</ol>
<h2 id="例子"><a class="header-anchor" href="#例子">¶</a>例子</h2>
<p>其实这种热更新方案是有很多的类似或者是说形变的例子，我们就探讨一两个。</p>
<h3 id="Log4j2-日志系统"><a class="header-anchor" href="#Log4j2-日志系统">¶</a>Log4j2 日志系统</h3>
<p>对于日志系统来说，我们经常需要动态的更新日志系统的 <code>Level</code>，比如将 <code>Info</code> -&gt; <code>Warn</code> 这样的操作，如果大家记得话，我们在服务器上将 <code>Logback.xml</code> 的文件进行修改，大概在一段时间之后，我们的日志级别就会变成我们想要的。这里就是一个标准的动态能力的形变。</p>
<p>在 <code>org.apache.logging.log4j.core.LoggerContext</code> 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateLoggers</span><span class="params">()</span> &#123;</span><br><span class="line">    updateLoggers(<span class="built_in">this</span>.configuration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateLoggers</span><span class="params">(<span class="keyword">final</span> Configuration config)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Configuration</span> <span class="variable">old</span> <span class="operator">=</span> <span class="built_in">this</span>.configuration;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Logger logger : loggerRegistry.getLoggers()) &#123;</span><br><span class="line">        logger.updateConfiguration(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于所有的 <code>Logger</code> 对象来说，都有一个相对应的 <code>Configuration</code> 对象，这就是对 <code>Logger</code> 对象的配置，此配置就是我们在 <code>Logback.xml</code> 中的配置，对于 <code>Logback</code>来说，我们需要监听我们的文件是否有所变动即可，代码在 <code>org.apache.logging.log4j.core.util.WatchManager</code> 不做展开了。</p>
<h3 id="Shardingsphere-动态配置"><a class="header-anchor" href="#Shardingsphere-动态配置">¶</a>Shardingsphere 动态配置</h3>
<p>WIP</p>
<h1>方案二：来个网关</h1>
<p>软件工程中不能解决的问题就加一个中间层来解决(:doge)，来吧我们看看一个中间层的解决方案</p>
<p><img src="https://s1.ax1x.com/2020/06/12/tXWfIS.png" alt="tXWfIS.png"></p>
<p>基于网关控制新的流量，因为我们启动了2个版本的服务实例，此时我们按照时间线切分，在特定时间之后的请求都转发到新的服务器上去。这样对于用户来说是无感知的，不过我们增加一个需要共享内存的操作，对于简单的业务系统来说，我们可以将所有的数据持久化到数据中作为状态的储存，但是还是有一些，比如 <code>prometheus</code> 这一类型的系统，本身就是很多状态数据的，此时我们势必要加入一个共享内容的机制。</p>
<h2 id="例子-v2"><a class="header-anchor" href="#例子-v2">¶</a>例子</h2>
<p>这个实现在很多公司来说叫 <code>灰度发布</code></p>
<h3 id="isito-灰度发布"><a class="header-anchor" href="#isito-灰度发布">¶</a>isito 灰度发布</h3>
<p>现在做灰度发布的方案很多种，我们举一个现在流行的 <code>isito</code> 的解决之道。<br>
<img src="https://s1.ax1x.com/2020/06/12/tXIoDA.png" alt="tXIoDA.png"></p>
<p>比如我们有一个 <code>addedvalues</code> 的服务<br>
<img src="https://s1.ax1x.com/2020/06/13/txmtIJ.png" alt="txmtIJ.png">，在线上已经有了 50%/50% 的对于 V1和V2版本来说，这个时候我们需要上线一个新版，将所有的流量转发到新的服务上。<br>
<img src="https://s1.ax1x.com/2020/06/13/txmHoQ.png" alt="txmHoQ.png"></p>
<p>这个时候，我们所需要做的很简单，直接修改<code>CRD</code>即可</p>
<div class="tabs" id="灰度发布"><ul class="nav-tabs"><li class="tab active"><a href="#灰度发布-1">原CRD</a></li><li class="tab"><a href="#灰度发布-2">新CRD</a></li></ul><div class="tab-content"><div class="tab-pane active" id="灰度发布-1"><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">addedvalues</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">addedvalues</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">addedvalues</span></span><br><span class="line">        <span class="attr">Sub set:</span> <span class="string">v2</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">50</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">addedvalues</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="灰度发布-2"><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">addedvalues</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">addedvalues</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">addedvalues</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v3</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure></div></div></div>
<p>一切是如此的简单，<code>CNCF</code>的魅力真是糟糕的藏不住啊。</p>
<h3 id="Spring-Cloud-优雅停机"><a class="header-anchor" href="#Spring-Cloud-优雅停机">¶</a>Spring Cloud 优雅停机</h3>
<p><img src="https://s1.ax1x.com/2020/06/13/txK3sP.png" alt="txK3sP.png"><br>
对于 <code>Spring Cloud</code> 体系来说，因为我们增加服务发现组件，此时我们并不一定需要网关才能做到这样的事情，我们可以采用一种变形实现方式，其实本质上都是类似的采用所谓的中间层，让外部无感知。如果有兴趣可以参考 <a href="2020/05/31/java/spring/gracefully-shutdown/">Spring的优雅停机</a></p>
<h1>方案三： Socket 所有权转让</h1>
<p>我们之前都是通过用户侧的方案来实现，其实还有一种实现方式，笔者也是查阅 <code>Envoy</code> 的实现才发现有这么个机制。</p>
<p>让我们回忆一下远古的 <code>Socket</code> 编程。<br>
<img src="https://s1.ax1x.com/2020/06/13/txlHoT.png" alt="txlHoT.png"></p>
<p>对于 <code>Socket</code> 编程来说，按照 <code>Linux</code>的 一切皆文件的朴质的哲学思想，对用户体系暴露的是一个 <code>FD</code>，如下图<br>
<a href="https://imgchr.com/i/txlvl9"><img src="https://s1.ax1x.com/2020/06/13/txlvl9.png" alt="txlvl9.png"></a></p>
<p>我们在内核用户之间是一个管理关系的，这层就是为了做到我们可以在多个进程之间共享我们打开的FD的句柄，比如我们两个程序同时打开一个文件，其实对于内核来说我们仅仅打开一个文件，只是维护了不同的 <code>sek</code>。<br>
<a href="https://imgchr.com/i/tx1iFO"><img src="https://s1.ax1x.com/2020/06/13/tx1iFO.png" alt="tx1iFO.png"></a></p>
<p>因此我们可以发现对于用户态看到的 <code>FD</code> 其实是一个内核 <code>FD</code> 的一个影子代号，那我们是不是可以用一种方式分享我们 <code>ServerSocket</code> 给不同的用户。以达到这样的效果：</p>
<p><a href="https://imgchr.com/i/tx1a7V"><img src="https://s1.ax1x.com/2020/06/13/tx1a7V.png" alt="tx1a7V.png"></a></p>
<h2 id="例子-v3"><a class="header-anchor" href="#例子-v3">¶</a>例子</h2>
<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>
<h3 id="转让-ServerSocket-基于Enovy的简化"><a class="header-anchor" href="#转让-ServerSocket-基于Enovy的简化">¶</a>转让 ServerSocket: 基于Enovy的简化</h3>
<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: 转让Socket',
	 'Main->Children: 1. Main启动接收Socket的实例',
     'Children->Unix Socket: 2. Children准备好 Unix Socket 管道用来接收 FD',
	 'Main->Parent: 3. 就绪网络服务',
     'Parent->Unix Socket: 4: 就绪 Unix socket 准备进行 FD 传递',
     'Parent->Children: 5. 传递 ServerSocket 的 FD',
     'Parent->Parent: 6. 停止处理 accept 事件',
     'Children->Children: 6. 就绪网络服务，开始处理 accept 事件',
     'Parent->Parent: 7. 等待处理中的请求结束'
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>
<div class="tabs" id="转让socket"><ul class="nav-tabs"><li class="tab active"><a href="#转让socket-1">Main</a></li><li class="tab"><a href="#转让socket-2">Parent</a></li><li class="tab"><a href="#转让socket-3">Children</a></li></ul><div class="tab-content"><div class="tab-pane active" id="转让socket-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sp = subprocess.Popen([<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;children.py&quot;</span>])</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    sp = subprocess.Popen([<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;parent.py&quot;</span>])</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">99999</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="转让socket-2"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket, select</span><br><span class="line"><span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pwd</span><br><span class="line"><span class="keyword">import</span> grp</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=<span class="string">&#x27;%(asctime)-15s pid=%(process)d %(side)s: %(message)s&#x27;</span>, level=logging.INFO)</span><br><span class="line"></span><br><span class="line">EOL1 = <span class="string">b&#x27;\n\n&#x27;</span></span><br><span class="line">EOL2 = <span class="string">b&#x27;\n\r\n&#x27;</span></span><br><span class="line">response = <span class="string">b&#x27;HTTP/1.0 200 OK\r\nDate: Mon, 1 Jan 1996 01:01:01 GMT\r\n&#x27;</span></span><br><span class="line">response += <span class="string">b&#x27;Content-Type: text/plain\r\nContent-Length: 13\r\n\r\n&#x27;</span></span><br><span class="line">response += <span class="string">b&#x27;Hello, world!&#x27;</span></span><br><span class="line"></span><br><span class="line">running = <span class="literal">True</span></span><br><span class="line">shutdonwing = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Function from https://docs.python.org/3/library/socket.html#socket.socket.sendmsg</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_fds</span>(<span class="params">sock, msg, fds</span>):</span><br><span class="line">    <span class="keyword">return</span> sock.sendmsg([msg], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, array.array(<span class="string">&quot;i&quot;</span>, fds))])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_send_fd</span>(<span class="params">socket_filename, send_sock</span>):</span><br><span class="line">    sock = socket.socket(family=socket.AF_UNIX)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;Connecting to socket file &#x27;%s&#x27;&quot;</span> % socket_filename, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;SEND ==&gt;&quot;</span>&#125;)</span><br><span class="line">    e = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sock.connect(socket_filename)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(<span class="string">&quot;Socket file &#x27;%s&#x27; not available yet, try %d/10 (%s)&quot;</span> % (socket_filename, _, e),</span><br><span class="line">                         extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;SEND ==&gt;&quot;</span>&#125;)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># nobreak</span></span><br><span class="line">        <span class="keyword">raise</span> e</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;Connected&quot;</span>, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;SEND ==&gt;&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;Sender delaying 10s to demonstrate a blocking receiver...&quot;</span>, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;SEND ==&gt;&quot;</span>&#125;)</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    file_descriptor_int = send_sock.fileno()</span><br><span class="line">    logger.info(<span class="string">&quot;Sending file descriptors %d&quot;</span> % file_descriptor_int, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;SEND ==&gt;&quot;</span>&#125;)</span><br><span class="line">    send_fds(sock, <span class="string">b&quot;some payload&quot;</span>, [file_descriptor_int])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> running</span><br><span class="line">    running = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">global</span>  shutdonwing</span><br><span class="line">    shutdonwing = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shutdonw</span>():</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">global</span> shutdonwing</span><br><span class="line">    shutdonwing = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        serversocket.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line">        serversocket.listen(<span class="number">1</span>)</span><br><span class="line">        serversocket.setblocking(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        threading.Thread(target=new_send_fd, args=(<span class="string">&quot;/tmp/uds_socket&quot;</span>, serversocket)).start()</span><br><span class="line"></span><br><span class="line">        epoll = select.epoll()</span><br><span class="line">        epoll.register(serversocket.fileno(), select.EPOLLIN)</span><br><span class="line">        connections = &#123;&#125;</span><br><span class="line">        requests = &#123;&#125;</span><br><span class="line">        responses = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> running:</span><br><span class="line">            events = epoll.poll(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> fileno, event <span class="keyword">in</span> events:</span><br><span class="line">                <span class="keyword">if</span> fileno == serversocket.fileno():</span><br><span class="line">                    connection, address = serversocket.accept()</span><br><span class="line">                    connection.setblocking(<span class="number">0</span>)</span><br><span class="line">                    epoll.register(connection.fileno(), select.EPOLLIN)</span><br><span class="line">                    connections[connection.fileno()] = connection</span><br><span class="line">                    requests[connection.fileno()] = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">                    responses[connection.fileno()] = response</span><br><span class="line">                <span class="keyword">elif</span> event &amp; select.EPOLLIN:</span><br><span class="line">                    requests[fileno] += connections[fileno].recv(<span class="number">1024</span>)</span><br><span class="line">                    <span class="keyword">if</span> EOL1 <span class="keyword">in</span> requests[fileno] <span class="keyword">or</span> EOL2 <span class="keyword">in</span> requests[fileno]:</span><br><span class="line">                        epoll.modify(fileno, select.EPOLLOUT)</span><br><span class="line">                        <span class="comment">#print(&#x27;-&#x27; * 40 + &#x27;\n&#x27; + requests[fileno].decode()[:-2])</span></span><br><span class="line">                <span class="keyword">elif</span> event &amp; select.EPOLLOUT:</span><br><span class="line">                    byteswritten = connections[fileno].send(responses[fileno])</span><br><span class="line">                    responses[fileno] = responses[fileno][byteswritten:]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(responses[fileno]) == <span class="number">0</span>:</span><br><span class="line">                        epoll.modify(fileno, <span class="number">0</span>)</span><br><span class="line">                        connections[fileno].shutdown(socket.SHUT_RDWR)</span><br><span class="line">                <span class="keyword">elif</span> event &amp; select.EPOLLHUP:</span><br><span class="line">                    epoll.unregister(fileno)</span><br><span class="line">                    connections[fileno].close()</span><br><span class="line">                    <span class="keyword">del</span> connections[fileno]</span><br><span class="line">        threading.Thread(target=shutdonw).start()</span><br><span class="line">        <span class="keyword">while</span> shutdonwing:</span><br><span class="line">            events = epoll.poll(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> fileno, event <span class="keyword">in</span> events:</span><br><span class="line">                <span class="keyword">if</span> fileno == serversocket.fileno():</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">elif</span> event &amp; select.EPOLLIN:</span><br><span class="line">                    requests[fileno] += connections[fileno].recv(<span class="number">1024</span>)</span><br><span class="line">                    <span class="keyword">if</span> EOL1 <span class="keyword">in</span> requests[fileno] <span class="keyword">or</span> EOL2 <span class="keyword">in</span> requests[fileno]:</span><br><span class="line">                        epoll.modify(fileno, select.EPOLLOUT)</span><br><span class="line">                        <span class="comment"># print(&#x27;-&#x27; * 40 + &#x27;\n&#x27; + requests[fileno].decode()[:-2])</span></span><br><span class="line">                <span class="keyword">elif</span> event &amp; select.EPOLLOUT:</span><br><span class="line">                    byteswritten = connections[fileno].send(responses[fileno])</span><br><span class="line">                    responses[fileno] = responses[fileno][byteswritten:]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(responses[fileno]) == <span class="number">0</span>:</span><br><span class="line">                        epoll.modify(fileno, <span class="number">0</span>)</span><br><span class="line">                        connections[fileno].shutdown(socket.SHUT_RDWR)</span><br><span class="line">                <span class="keyword">elif</span> event &amp; select.EPOLLHUP:</span><br><span class="line">                    epoll.unregister(fileno)</span><br><span class="line">                    connections[fileno].close()</span><br><span class="line">                    <span class="keyword">del</span> connections[fileno]</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        epoll.unregister(serversocket.fileno())</span><br><span class="line">        epoll.close()</span><br><span class="line">        <span class="comment"># serversocket.close()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;parent will stopping........&quot;</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="转让socket-3"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket, select</span><br><span class="line"><span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pwd</span><br><span class="line"><span class="keyword">import</span> grp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=<span class="string">&#x27;%(asctime)-15s pid=%(process)d %(side)s: %(message)s&#x27;</span>, level=logging.INFO)</span><br><span class="line"></span><br><span class="line">EOL1 = <span class="string">b&#x27;\n\n&#x27;</span></span><br><span class="line">EOL2 = <span class="string">b&#x27;\n\r\n&#x27;</span></span><br><span class="line">response = <span class="string">b&#x27;HTTP/1.0 200 OK\r\nDate: Mon, 1 Jan 1996 01:01:01 GMT\r\n&#x27;</span></span><br><span class="line">response += <span class="string">b&#x27;Content-Type: text/plain\r\nContent-Length: 13\r\n\r\n&#x27;</span></span><br><span class="line">response += <span class="string">b&#x27;Hello, world!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Function from https://docs.python.org/3/library/socket.html#socket.socket.recvmsg</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv_fds</span>(<span class="params">sock, msglen, maxfds</span>):</span><br><span class="line">    fds = array.array(<span class="string">&quot;i&quot;</span>)  <span class="comment"># Array of ints</span></span><br><span class="line">    msg, ancdata, flags, addr = sock.recvmsg(msglen, socket.CMSG_LEN(maxfds * fds.itemsize))</span><br><span class="line">    <span class="keyword">for</span> cmsg_level, cmsg_type, cmsg_data <span class="keyword">in</span> ancdata:</span><br><span class="line">        <span class="keyword">if</span> (cmsg_level == socket.SOL_SOCKET <span class="keyword">and</span> cmsg_type == socket.SCM_RIGHTS):</span><br><span class="line">            <span class="comment"># Append data, ignoring any truncated integers at the end.</span></span><br><span class="line">            fds.fromstring(cmsg_data[:<span class="built_in">len</span>(cmsg_data) - (<span class="built_in">len</span>(cmsg_data) % fds.itemsize)])</span><br><span class="line">    <span class="keyword">return</span> msg, <span class="built_in">list</span>(fds)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_recv_fd</span>(<span class="params">socket_filename</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.remove(<span class="string">&quot;/tmp/uds_socket&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&#x27;Starting privledges: %d/%d = %s/%s&#x27;</span> % \</span><br><span class="line">                (os.getuid(),</span><br><span class="line">                 os.getgid(),</span><br><span class="line">                 pwd.getpwuid(os.getuid())[<span class="number">0</span>],</span><br><span class="line">                 grp.getgrgid(os.getgid())[<span class="number">0</span>]), extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.getuid() == <span class="number">0</span>:</span><br><span class="line">        running_uid = pwd.getpwnam(<span class="string">&quot;nobody&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">        running_gid = grp.getgrnam(<span class="string">&quot;nogroup&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">        os.setgid(running_gid)</span><br><span class="line">        os.setuid(running_uid)</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&#x27;Dropped privledges: currently %d/%d = %s/%s&#x27;</span> % \</span><br><span class="line">                    (os.getuid(),</span><br><span class="line">                     os.getgid(),</span><br><span class="line">                     pwd.getpwuid(os.getuid())[<span class="number">0</span>],</span><br><span class="line">                     grp.getgrgid(os.getgid())[<span class="number">0</span>]), extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;Receiver delaying creation of socket to demonstrate sender retries...&quot;</span>, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line">    logger.info(<span class="string">&quot;Binding to (and creating) AF_UNIX socket socket file &#x27;%s&#x27;&quot;</span> % socket_filename,</span><br><span class="line">                extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line">    sock = socket.socket(family=socket.AF_UNIX)</span><br><span class="line">    sock.bind(socket_filename)</span><br><span class="line">    sock.listen()</span><br><span class="line">    logger.info(<span class="string">&quot;Socket listening %s&quot;</span> % sock, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Waste a file descriptor, so the fd numbers on source and receive sides don&#x27;t match (they&#x27;ll be both 6 by default)</span></span><br><span class="line">    leak_a_file_descriptor = <span class="built_in">open</span>(<span class="string">&quot;/etc/hosts&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(sock, <span class="string">&quot;recvmsg&quot;</span>):</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">            <span class="string">&quot;We don&#x27;t have a `Socket.recvmsg` in this implementation of python (eg, system python 2.7 on OSX&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Accept exactly 1 connection</span></span><br><span class="line">    client, info = sock.accept()</span><br><span class="line">    logger.info(<span class="string">&quot;Connected, client=%s&quot;</span> % client, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;Blocking until message is received&quot;</span>, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line">    msg, fds = recv_fds(client, <span class="number">100</span>, <span class="number">4</span>)</span><br><span class="line">    logger.info(<span class="string">&quot;Received message msg=%s fds=%s&quot;</span> % (msg, fds), extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> fds[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    fdno = new_recv_fd(<span class="string">&quot;/tmp/uds_socket&quot;</span>)</span><br><span class="line">    logger.info(<span class="string">&quot;got from parent fd %d&quot;</span> % (fdno), extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line">    serversocket = socket.socket(fileno=fdno)</span><br><span class="line">    <span class="comment"># serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span></span><br><span class="line">    <span class="comment"># serversocket.bind((&#x27;0.0.0.0&#x27;, 8080))</span></span><br><span class="line">    <span class="comment"># serversocket.listen(1)</span></span><br><span class="line">    <span class="comment"># serversocket.setblocking(True)</span></span><br><span class="line"></span><br><span class="line">    epoll = select.epoll()</span><br><span class="line">    epoll.register(serversocket.fileno(), select.EPOLLIN)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        connections = &#123;&#125;</span><br><span class="line">        requests = &#123;&#125;</span><br><span class="line">        responses = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            events = epoll.poll(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> fileno, event <span class="keyword">in</span> events:</span><br><span class="line">                <span class="keyword">if</span> fileno == serversocket.fileno():</span><br><span class="line">                    connection, address = serversocket.accept()</span><br><span class="line">                    connection.setblocking(<span class="number">0</span>)</span><br><span class="line">                    epoll.register(connection.fileno(), select.EPOLLIN)</span><br><span class="line">                    connections[connection.fileno()] = connection</span><br><span class="line">                    requests[connection.fileno()] = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">                    responses[connection.fileno()] = response</span><br><span class="line">                <span class="keyword">elif</span> event &amp; select.EPOLLIN:</span><br><span class="line">                    requests[fileno] += connections[fileno].recv(<span class="number">1024</span>)</span><br><span class="line">                    <span class="keyword">if</span> EOL1 <span class="keyword">in</span> requests[fileno] <span class="keyword">or</span> EOL2 <span class="keyword">in</span> requests[fileno]:</span><br><span class="line">                        epoll.modify(fileno, select.EPOLLOUT)</span><br><span class="line">                        <span class="comment">#print(&#x27;-&#x27; * 40 + &#x27;\n&#x27; + requests[fileno].decode()[:-2])</span></span><br><span class="line">                <span class="keyword">elif</span> event &amp; select.EPOLLOUT:</span><br><span class="line">                    byteswritten = connections[fileno].send(responses[fileno])</span><br><span class="line">                    responses[fileno] = responses[fileno][byteswritten:]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(responses[fileno]) == <span class="number">0</span>:</span><br><span class="line">                        epoll.modify(fileno, <span class="number">0</span>)</span><br><span class="line">                        connections[fileno].shutdown(socket.SHUT_RDWR)</span><br><span class="line">                <span class="keyword">elif</span> event &amp; select.EPOLLHUP:</span><br><span class="line">                    epoll.unregister(fileno)</span><br><span class="line">                    connections[fileno].close()</span><br><span class="line">                    <span class="keyword">del</span> connections[fileno]</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        epoll.unregister(serversocket.fileno())</span><br><span class="line">        epoll.close()</span><br><span class="line">        serversocket.close()</span><br></pre></td></tr></table></figure></div></div></div>
<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">✗ python3 main.py</span><br><span class="line">2020-06-13 23:54:28,647 pid=114797 &lt;== RECV: Starting privledges: 1000/1000 = yanick/yanick</span><br><span class="line">2020-06-13 23:54:28,647 pid=114797 &lt;== RECV: Receiver delaying creation of socket to demonstrate sender retries...</span><br><span class="line">2020-06-13 23:54:28,647 pid=114797 &lt;== RECV: Binding to (and creating) AF_UNIX socket socket file <span class="string">&#x27;/tmp/uds_socket&#x27;</span></span><br><span class="line">2020-06-13 23:54:28,647 pid=114797 &lt;== RECV: Socket listening &lt;socket.socket fd=3, family=AddressFamily.AF_UNIX, <span class="built_in">type</span>=SocketKind.SOCK_STREAM, proto=0, laddr=/tmp/uds_socket&gt;</span><br><span class="line">2020-06-13 23:54:31,657 pid=114804 SEND ==&gt;: Connecting to socket file <span class="string">&#x27;/tmp/uds_socket&#x27;</span></span><br><span class="line">2020-06-13 23:54:31,657 pid=114804 SEND ==&gt;: Connected</span><br><span class="line">2020-06-13 23:54:31,657 pid=114804 SEND ==&gt;: Sender delaying 10s to demonstrate a blocking receiver...</span><br><span class="line">2020-06-13 23:54:31,657 pid=114797 &lt;== RECV: Connected, client=&lt;socket.socket fd=5, family=AddressFamily.AF_UNIX, <span class="built_in">type</span>=SocketKind.SOCK_STREAM, proto=0, laddr=/tmp/uds_socket&gt;</span><br><span class="line">2020-06-13 23:54:31,657 pid=114797 &lt;== RECV: Blocking until message is received</span><br><span class="line">2020-06-13 23:54:41,667 pid=114804 SEND ==&gt;: Sending file descriptors 3</span><br><span class="line">children.py:77: DeprecationWarning: fromstring() is deprecated. Use frombytes() instead.</span><br><span class="line">  msg, fds = recv_fds(client, 100, 4)</span><br><span class="line">2020-06-13 23:54:41,668 pid=114797 &lt;== RECV: Received message msg=b<span class="string">&#x27;some payload&#x27;</span> fds=[6]</span><br><span class="line">2020-06-13 23:54:41,669 pid=114797 &lt;== RECV: got from parent fd 6</span><br><span class="line">parent will stopping........</span><br></pre></td></tr></table></figure>
<p>我们查看两次监听的状态也可以发现<code>Socket</code>本身变化了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -tunlp</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      114804/python3 </span><br><span class="line"></span><br><span class="line">netstat -tunlp</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      114797/python3 </span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/yanickxia/share-socket-for-hotrestart.git">源码地址: 需要Python3+</a></p>
<h3 id="注意点-v2"><a class="header-anchor" href="#注意点-v2">¶</a>注意点</h3>
<ul>
<li>我们并没没有完整的处理好长连接的 Socket，具体可以参考 [方案四](#方案三的升级： 方案四: 方案三的升级)</li>
<li>值得注意的我们需要打开 <code>Epoll</code> 的 <code>LT</code> 模式，因为对于父亲节点有一些是不处理的，因为涉及到进程抢占，需要再次通知。</li>
<li>另外 Linux 转让  <code>FD</code> 的方式据笔者查阅也仅有 <code>Unix Socket</code> 模式，这一部分功能是平台绑定的。</li>
</ul>
<h3 id="转让-ClientSocket"><a class="header-anchor" href="#转让-ClientSocket">¶</a>转让 ClientSocket</h3>
<p>因为在方案三中我们良好的处理长连接的 <code>Socket</code>，因为我们只是简单的处理了 <code>ServerSocket</code>，但是由此可得：如果可以把正在处理的 <code>ClienSocket</code> 和 它所在的状态一同转换到新的进程上，我们也可以完成这样的事情不是么？</p>
<div style="width:100%; overflow-y:scroll;" id="diagram2"></div>
<script>
	var data =
	['Title: 转让 ClientSocket',
	 'Main->Children: 1. Main启动接收Socket的实例',
     'Children->Unix Socket: 2. Children准备好 Unix Socket 管道用来接收 FD',
	 'Main->Parent: 3. 就绪网络服务',
     'Parent->Unix Socket: 4: 就绪 Unix socket 准备进行 FD 传递',
     'Parent->Children: 5. 传递 ServerSocket 的 FD & 状态',
     'Parent->Parent: 5. 停止处理此FD的请求',
     'Children->Children: 6. 恢复状态继续处理'
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram2", {theme: 'simple', scale: 0.5});
</script>
<p>这一次我们简化下网络请求，使用简单的传统 Blocking IO, 当我们第 N 次访问的时候返回 N 的结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet 127.0.0.1 8080</span><br><span class="line">1 </span><br><span class="line">0 got message: b<span class="string">&#x27;1\r\n&#x27;</span></span><br><span class="line">2</span><br><span class="line">1 got message: b<span class="string">&#x27;2\r\n&#x27;</span></span><br></pre></td></tr></table></figure>
<div class="tabs" id="转让-clientsocket"><ul class="nav-tabs"><li class="tab active"><a href="#转让-clientsocket-1">Main</a></li><li class="tab"><a href="#转让-clientsocket-2">Parent</a></li><li class="tab"><a href="#转让-clientsocket-3">Children</a></li></ul><div class="tab-content"><div class="tab-pane active" id="转让-clientsocket-1"><p>同上略</p></div><div class="tab-pane" id="转让-clientsocket-2"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=<span class="string">&#x27;%(asctime)-15s pid=%(process)d %(side)s: %(message)s&#x27;</span>, level=logging.INFO)</span><br><span class="line"></span><br><span class="line">running = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Function from https://docs.python.org/3/library/socket.html#socket.socket.sendmsg</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_fds</span>(<span class="params">sock, msg, fds</span>):</span><br><span class="line">    <span class="keyword">return</span> sock.sendmsg([msg], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, array.array(<span class="string">&quot;i&quot;</span>, fds))])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_send_fd</span>(<span class="params">socket_filename, send_sock, i</span>):</span><br><span class="line">    sock = socket.socket(family=socket.AF_UNIX)</span><br><span class="line">    <span class="keyword">global</span> running</span><br><span class="line">    running = <span class="literal">False</span></span><br><span class="line">    logger.info(<span class="string">&quot;Connecting to socket file &#x27;%s&#x27;&quot;</span> % socket_filename, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;SEND ==&gt;&quot;</span>&#125;)</span><br><span class="line">    e = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sock.connect(socket_filename)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(<span class="string">&quot;Socket file &#x27;%s&#x27; not available yet, try %d/10 (%s)&quot;</span> % (socket_filename, _, e),</span><br><span class="line">                         extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;SEND ==&gt;&quot;</span>&#125;)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># nobreak</span></span><br><span class="line">        <span class="keyword">raise</span> e</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;Connected&quot;</span>, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;SEND ==&gt;&quot;</span>&#125;)</span><br><span class="line">    logger.info(<span class="string">&quot;Sender delaying 10s to demonstrate a blocking receiver...&quot;</span>, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;SEND ==&gt;&quot;</span>&#125;)</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    file_descriptor_int = send_sock.fileno()</span><br><span class="line">    logger.info(<span class="string">&quot;Sending file descriptors %d, state: %d&quot;</span> % (file_descriptor_int, i), extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;SEND ==&gt;&quot;</span>&#125;)</span><br><span class="line">    send_fds(sock, <span class="string">b&quot;some payload&quot;</span>, [file_descriptor_int, i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_connection</span>(<span class="params">conn, status</span>):</span><br><span class="line">    i = status</span><br><span class="line">    threading.Thread(target=new_send_fd, args=(<span class="string">&quot;/tmp/uds_socket&quot;</span>, conn, i)).start()</span><br><span class="line">    <span class="keyword">while</span> running:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        logger.info(<span class="string">&quot;Got Message At %d&quot;</span> % os.getpid(), extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;SEND ==&gt;&quot;</span>&#125;)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        conn.sendall(<span class="built_in">bytes</span>((<span class="string">&quot;%d got message: %s\n&quot;</span> % (i, data)), <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)  <span class="comment"># 设置了 reusea 简化配置</span></span><br><span class="line">        serversocket.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line">        serversocket.listen()</span><br><span class="line">        logger.info(<span class="string">&quot;server listening at 8080&quot;</span>, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;SEND ==&gt;&quot;</span>&#125;)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            conn, addr = serversocket.accept()</span><br><span class="line">            threading.Thread(target=new_connection, args=(conn, <span class="number">0</span>)).start()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        serversocket.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="转让-clientsocket-3"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pwd</span><br><span class="line"><span class="keyword">import</span> grp, time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=<span class="string">&#x27;%(asctime)-15s pid=%(process)d %(side)s: %(message)s&#x27;</span>, level=logging.INFO)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Function from https://docs.python.org/3/library/socket.html#socket.socket.recvmsg</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv_fds</span>(<span class="params">sock, msglen, maxfds</span>):</span><br><span class="line">    fds = array.array(<span class="string">&quot;i&quot;</span>)  <span class="comment"># Array of ints</span></span><br><span class="line">    msg, ancdata, flags, addr = sock.recvmsg(msglen, socket.CMSG_LEN(maxfds * fds.itemsize))</span><br><span class="line">    <span class="keyword">for</span> cmsg_level, cmsg_type, cmsg_data <span class="keyword">in</span> ancdata:</span><br><span class="line">        <span class="keyword">if</span> (cmsg_level == socket.SOL_SOCKET <span class="keyword">and</span> cmsg_type == socket.SCM_RIGHTS):</span><br><span class="line">            <span class="comment"># Append data, ignoring any truncated integers at the end.</span></span><br><span class="line">            fds.fromstring(cmsg_data[:<span class="built_in">len</span>(cmsg_data) - (<span class="built_in">len</span>(cmsg_data) % fds.itemsize)])</span><br><span class="line">    <span class="keyword">return</span> msg, <span class="built_in">list</span>(fds)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_recv_fd</span>(<span class="params">socket_filename</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.remove(<span class="string">&quot;/tmp/uds_socket&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&#x27;Starting privledges: %d/%d = %s/%s&#x27;</span> % \</span><br><span class="line">                (os.getuid(),</span><br><span class="line">                 os.getgid(),</span><br><span class="line">                 pwd.getpwuid(os.getuid())[<span class="number">0</span>],</span><br><span class="line">                 grp.getgrgid(os.getgid())[<span class="number">0</span>]), extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.getuid() == <span class="number">0</span>:</span><br><span class="line">        running_uid = pwd.getpwnam(<span class="string">&quot;nobody&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">        running_gid = grp.getgrnam(<span class="string">&quot;nogroup&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">        os.setgid(running_gid)</span><br><span class="line">        os.setuid(running_uid)</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&#x27;Dropped privledges: currently %d/%d = %s/%s&#x27;</span> % \</span><br><span class="line">                    (os.getuid(),</span><br><span class="line">                     os.getgid(),</span><br><span class="line">                     pwd.getpwuid(os.getuid())[<span class="number">0</span>],</span><br><span class="line">                     grp.getgrgid(os.getgid())[<span class="number">0</span>]), extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;Receiver delaying creation of socket to demonstrate sender retries...&quot;</span>, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line">    logger.info(<span class="string">&quot;Binding to (and creating) AF_UNIX socket socket file &#x27;%s&#x27;&quot;</span> % socket_filename,</span><br><span class="line">                extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line">    sock = socket.socket(family=socket.AF_UNIX)</span><br><span class="line">    sock.bind(socket_filename)</span><br><span class="line">    sock.listen()</span><br><span class="line">    logger.info(<span class="string">&quot;Socket listening %s&quot;</span> % sock, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Waste a file descriptor, so the fd numbers on source and receive sides don&#x27;t match (they&#x27;ll be both 6 by default)</span></span><br><span class="line">    leak_a_file_descriptor = <span class="built_in">open</span>(<span class="string">&quot;/etc/hosts&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(sock, <span class="string">&quot;recvmsg&quot;</span>):</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">            <span class="string">&quot;We don&#x27;t have a `Socket.recvmsg` in this implementation of python (eg, system python 2.7 on OSX&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Accept exactly 1 connection</span></span><br><span class="line">    client, info = sock.accept()</span><br><span class="line">    logger.info(<span class="string">&quot;Connected, client=%s&quot;</span> % client, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;Blocking until message is received&quot;</span>, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line">    msg, fds = recv_fds(client, <span class="number">100</span>, <span class="number">4</span>)</span><br><span class="line">    logger.info(<span class="string">&quot;Received message msg=%s fds=%s&quot;</span> % (msg, fds), extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> fds[<span class="number">0</span>], fds[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_connection</span>(<span class="params">conn, status</span>):</span><br><span class="line">    i = status</span><br><span class="line">    is_running = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">with</span> conn:</span><br><span class="line">        <span class="keyword">while</span> is_running:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            logger.info(<span class="string">&quot;Got Message At %d&quot;</span> % os.getpid(), extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;SEND ==&gt;&quot;</span>&#125;)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            conn.sendall(<span class="built_in">bytes</span>((<span class="string">&quot;%d got message: %s\n&quot;</span> % (i, data)), <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fdno = new_recv_fd(<span class="string">&quot;/tmp/uds_socket&quot;</span>)</span><br><span class="line">    logger.info(<span class="string">&quot;got from parent fd: %d status: %d&quot;</span> % (fdno[<span class="number">0</span>], fdno[<span class="number">1</span>]), extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line">    threading.Thread(target=new_connection, args=(socket.socket(fileno=fdno[<span class="number">0</span>]), fdno[<span class="number">1</span>])).start()</span><br><span class="line">    logger.info(<span class="string">&quot;startup server..&quot;</span>, extra=&#123;<span class="string">&quot;side&quot;</span>: <span class="string">&quot;&lt;== RECV&quot;</span>&#125;)</span><br><span class="line">    time.sleep(<span class="number">100</span>)</span><br></pre></td></tr></table></figure></div></div></div>
<p>访问可得如下的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ telnet 127.0.0.1 8080</span><br><span class="line">0 got message: b<span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">1 got message: b<span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">2 got message: b<span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">3 got message: b<span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">4 got message: b<span class="string">&#x27;\r\n&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="注意点-v3"><a class="header-anchor" href="#注意点-v3">¶</a>注意点</h3>
<ul>
<li>这里值得注意的是需要处理 <code>clientsocket</code> 的状态：当我们转让 socket 的时候也需要处理好，此时的socket处于的状态。</li>
</ul>
<h1>总结</h1>
<p>对于我们来说热升级的集中方案对比</p>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:right">脚本运行层</th>
<th style="text-align:center">基于网关</th>
<th style="text-align:center">基于Socket</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">开发效率</td>
<td style="text-align:right">高</td>
<td style="text-align:center">高</td>
<td style="text-align:center">低</td>
</tr>
<tr>
<td style="text-align:left">性能</td>
<td style="text-align:right">低</td>
<td style="text-align:center">低</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td style="text-align:left">架构难度</td>
<td style="text-align:right">中</td>
<td style="text-align:center">低</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td style="text-align:left">备注</td>
<td style="text-align:right">常见在多变的逻辑层</td>
<td style="text-align:center">微服务系统常见</td>
<td style="text-align:center">使用的比较少，容易出错</td>
</tr>
</tbody>
</table>
<h1>参考</h1>
<ul>
<li><a href="https://home1-oss.github.io/home1-oss-gitbook/release/docs/oss-eureka/GRACEFUL_SHUTDOWN.html">Eureka Graceful Shutdown</a></li>
<li><a href="https://medium.com/@Alibaba_Cloud/traffic-management-with-istio-2-grayscale-release-of-applications-by-istio-management-cf587606be5d">Traffic Management with Istio</a></li>
<li><a href="https://blog.envoyproxy.io/envoy-hot-restart-1d16b14555b5?gi=9dcc652a15f1">Envoy hot restart</a></li>
<li><a href="https://ops.tips/blog/how-linux-creates-sockets/">how-linux-creates-sockets</a></li>
<li><a href="https://medium.com/@copyconstruct/nonblocking-i-o-99948ad7c957">non-blocking-io</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>server</category>
        <category>hot_restart</category>
      </categories>
      <tags>
        <tag>server</tag>
        <tag>hot_restart</tag>
      </tags>
  </entry>
  <entry>
    <title>编写git commit message的七条建议 [译]</title>
    <url>/2016/12/22/other/how-to-write-a-git-commit-message/</url>
    <content><![CDATA[<h2 id="引言：为什么说提交信息很重要"><a class="header-anchor" href="#引言：为什么说提交信息很重要">¶</a>引言：为什么说提交信息很重要</h2>
<p>如果你随机的去浏览一下git仓库的日志，你会发现提交信息都或多或少有点糟糕。举个例子，看一下下面这些<a href="https://github.com/spring-projects/spring-framework/commits/e5f4b49?author=cbeams">“哥儿们儿”</a>，它们来自于我早期对Spring的提交：</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline -5 --author cbeams --before <span class="string">&quot;Fri Mar 26 2009&quot;</span></span><br><span class="line">e5f4b49 Re-adding ConfigurationPostProcessorTests after its brief removal <span class="keyword">in</span> r814. @Ignore-ing the testCglibClassesAreLoadedJustInTimeForEnhancement() method as it turns out this was one of the culprits <span class="keyword">in</span> the recent build breakage. The classloader hacking causes subtle downstream effects, breaking unrelated tests. The <span class="built_in">test</span> method is still useful, but should only be run on a manual basis to ensure CGLIB is not prematurely classloaded, and should not be run as part of the automated build.</span><br><span class="line">2db0f12 fixed two build-breaking issues: + reverted ClassMetadataReadingVisitor to revision 794 + eliminated ConfigurationPostProcessorTests until further investigation determines why it causes downstream tests to fail (such as the seemingly unrelated ClassPathXmlApplicationContextTests)</span><br><span class="line">147709f Tweaks to package-info.java files</span><br><span class="line">22b25e0 Consolidated Util and MutableAnnotationUtils classes into existing AsmUtils</span><br><span class="line">7f96f57 polishing</span><br></pre></td></tr></table></figure>
<p>来对比一下来自同一仓库的最近的提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline -5 --author pwebb --before <span class="string">&quot;Sat Aug 30 2014&quot;</span></span><br><span class="line">5ba3db6 Fix failing CompositePropertySourceTests</span><br><span class="line">84564a0 Rework @PropertySource early parsing logic</span><br><span class="line">e142fd1 Add tests <span class="keyword">for</span> ImportSelector meta-data</span><br><span class="line">887815f Update docbook dependency and generate epub</span><br><span class="line">ac8326d Polish mockito usage</span><br></pre></td></tr></table></figure>
<p>你更喜欢看哪个？<br>
前者的提交记录在长度和形式上都相差甚远；后者在这些方面保持了简介和一致。前者是在不经思考的情况下提交的，而后者的提交却从来不是偶然。</p>
<p>虽然大多数仓库的日志看起来都和前者一样，但也有一些例外的。 <a href="https://github.com/torvalds/linux/commits/master">Linux kernel</a> 和<a href="https://github.com/git/git/commits/master">git仓库</a>自己就是很好的例子。也可以看一下<a href="https://github.com/spring-projects/spring-boot/commits/master">spring-boot</a>或者 <a href="https://github.com/tpope/vim-pathogen/commits/master">Tim Pope</a>维护的任何仓库。</p>
<p>这些仓库的贡献者知道对于后来的开发者（也恰恰是以后的自己）来说，风格良好的提交信息是在上下文中传达变化的最好方式。Diff命令可以告诉你什么地方改变了,但是只有提交信息可以恰当的告诉你这些改变的原因。Peter Hutterer 很好的阐述了这一点：</p>
<blockquote>
<p>重现一段代码的上下文是浪费的，但是我们不能完全避免它，我们要做的是尽力减少这些情况的发生。提交信息可以做到这一点，因此，提交消息显示开发人员是否是一个好的合作者。</p>
</blockquote>
<p>如果你没有考虑到什么是一个良好的git提交，可能是你没有花很多时间使用git log和相关工具。这里有一个恶性循环：由于提交历史是非结构化和不一致的，所以人们不会花很多时间使用或留意它。而它们越没有被使用和小心维护，就越保持非结构化和不一致。</p>
<p>但是一个被小心维护的日志是漂亮和有用的。git blame, revert, rebase, log, shortlog和其他的子命令使生活变得更加美好。审查他人的提交和推送请求变成一件值得去做的事情，也因此突然可以被独立的完成。理解数月甚至数年之间的代码含义不仅变得可能，而且变得更加高效。</p>
<p>一个项目的长时间的成功得益于（除其他事项外）它的可维护性，而对于维护者来说，很少有工具比他的项目日志来得更加有力。花点时间学习一下怎么去合理的关注它是值得的。开始的麻烦很快就会变成习惯，最后会变成骄傲的来源和相关方面的生产力的提高。</p>
<p>风格。标记规则，边距，语法，大小写以及标点符号。拼写出这些东西，去除掉不确定的部分，然后尽量让它们变得简单。最后你的日志将明显保持一致，这不仅有利于阅读，也真切的让你对日常基础有更深的理解。</p>
<p>内容。什么样的信息才是提交主体应该包含的呢（如果有的话）？而什么样的是不应该被包含的呢？</p>
<p>元数据。怎样去追踪诸如ID、推送请求数这些信息来作为参考？</p>
<p>幸运的是，这里有一些良好的习惯使你的提交信息变得更加地道。事实上，许多这些习惯都已经被git命令行函数预设了。你不需要再重复发明。你只要遵循下面的<a href="http://chris.beams.io/posts/git-commit/#seven-rules">七条规则</a>，然后像一个专业人员一样用你的方式去提交。</p>
<h2 id="Git提交信息格式的7条优良规范"><a class="header-anchor" href="#Git提交信息格式的7条优良规范">¶</a>Git提交信息格式的7条优良规范</h2>
<blockquote>
<p>Keep in mind:<br>
<a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">This</a> <a href="http://www.git-scm.com/book/en/Distributed-Git-Contributing-to-a-Project#Commit-Guidelines">has</a><br>
<a href="https://github.com/torvalds/subsurface/blob/master/README#L82-109">all</a><br>
<a href="http://who-t.blogspot.co.at/2009/12/on-commit-messages.html">been</a><br>
<a href="https://github.com/erlang/otp/wiki/writing-good-commit-messages">said</a><br>
<a href="https://github.com/spring-projects/spring-framework/blob/30bce7/CONTRIBUTING.md#format-commit-messages">before</a>.<br>
请牢记：以下7条均经考验.</p>
</blockquote>
<ol>
<li>采用空行将主题和详情分隔开</li>
<li>限制主题长度在50个字符以内</li>
<li>主题首字母大写</li>
<li>主题不要用句号结尾</li>
<li>主题使用祈使语气</li>
<li>详情任何一行都不要超过72个字符</li>
<li>利用详情去说明三点： 是什么 为什么 如何做</li>
</ol>
<p>举个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Summarize changes <span class="keyword">in</span> around 50 characters or less</span><br><span class="line"></span><br><span class="line">More detailed explanatory text, <span class="keyword">if</span> necessary. Wrap it to about 72</span><br><span class="line">characters or so. In some contexts, the first line is treated as the</span><br><span class="line">subject of the commit and the rest of the text as the body. The</span><br><span class="line">blank line separating the summary from the body is critical (unless</span><br><span class="line">you omit the body entirely); various tools like `<span class="built_in">log</span>`, `shortlog`</span><br><span class="line">and `rebase` can get confused <span class="keyword">if</span> you run the two together.</span><br><span class="line"></span><br><span class="line">Explain the problem that this commit is solving. Focus on why you</span><br><span class="line">are making this change as opposed to how (the code explains that).</span><br><span class="line">Are there side effects or other unintuitive consequences of this</span><br><span class="line">change? Here<span class="string">&#x27;s the place to explain them.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Further paragraphs come after blank lines.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> - Bullet points are okay, too</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> - Typically a hyphen or asterisk is used for the bullet, preceded</span></span><br><span class="line"><span class="string">   by a single space, with blank lines in between, but conventions</span></span><br><span class="line"><span class="string">   vary here</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If you use an issue tracker, put references to them at the bottom,</span></span><br><span class="line"><span class="string">like this:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Resolves: #123</span></span><br><span class="line"><span class="string">See also: #456, #789</span></span><br></pre></td></tr></table></figure>
<h3 id="1-采用空行将主题和详情分隔开"><a class="header-anchor" href="#1-采用空行将主题和详情分隔开">¶</a>1.采用空行将主题和详情分隔开</h3>
<p><code>git commit</code>的说明中写道：</p>
<blockquote>
<p>Though not required, it’s a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, git-format-patch(1) turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.</p>
</blockquote>
<p>首先，并不是每一次提交都需要主题和详情,有时候单行描述就可以了，尤其是当改动比较简单时，复杂的说明是不必要的。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Fix typo <span class="keyword">in</span> introduction to user guide</span><br></pre></td></tr></table></figure>
<p>瞧，无需多言。如果读者好奇到底修复了什么错误，那么她可以直接去看看改动本身就好，比如使用<code>git show</code>或者<code>git diff</code>或者<code>git log -p</code>。</p>
<p>如果你在git上想提交上面的说明信息，那么可以采用<code>-m</code>将其附加到<code>git commit</code>之上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m<span class="string">&quot;Fix typo in introduction to user guide&quot;</span></span><br></pre></td></tr></table></figure>
<p>然而，当一个提交需要较多的解释和说明的时候，你需要书写一个详情，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Derezz the master control program</span><br><span class="line"></span><br><span class="line">MCP turned out to be evil and had become intent on world domination.</span><br><span class="line">This commit throws Tron<span class="string">&#x27;s disc into MCP (causing its deresolution)</span></span><br><span class="line"><span class="string">and turns it back into a chess game.</span></span><br></pre></td></tr></table></figure>
<p>这时候利用<code>-m</code>去提交就显得比较困难了，你需要一个合适的编辑器。如果你还没有安装一个在git命令行运行的编辑器，那么请阅读<a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration">Pro Git</a></p>
<p>任何情况下，将主题和详情分离对于浏览查看日志都是有益的。以下是完整的日志体：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 42e769bdf4894310333942ffc5a15151222a87be</span><br><span class="line">Author: Kevin Flynn &lt;kevin@flynnsarcade.com&gt;</span><br><span class="line">Date:   Fri Jan 01 00:00:00 1982 -0200</span><br><span class="line"></span><br><span class="line">Derezz the master control program</span><br><span class="line"></span><br><span class="line">MCP turned out to be evil and had become intent on world domination.</span><br><span class="line">This commit throws Tron<span class="string">&#x27;s disc into MCP (causing its deresolution)</span></span><br><span class="line"><span class="string">and turns it back into a chess game.</span></span><br></pre></td></tr></table></figure>
<p>当采用<code>git log --oneline</code>，其只能打印出主题行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">42e769 Derezz the master control program</span><br></pre></td></tr></table></figure>
<p>或者<code>git shortlog</code>，它可以显示一系列的用户提交记录，但是也仅仅展示简洁的主题行信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ git shortlog</span><br><span class="line">Kevin Flynn (1):</span><br><span class="line">   Derezz the master control program</span><br><span class="line">Alan Bradley (1):</span><br><span class="line">   Introduce security program <span class="string">&quot;Tron&quot;</span></span><br><span class="line">Ed Dillinger (3):</span><br><span class="line">   Rename chess program to <span class="string">&quot;MCP&quot;</span></span><br><span class="line">   Modify chess program</span><br><span class="line">   Upgrade chess program</span><br><span class="line">Walter Gibbs (1):</span><br><span class="line">   Introduce protoype chess program</span><br></pre></td></tr></table></figure>
<p>当然，在不同的git语境中主题行和详情的差异还有很多，但是如果没有空行将其隔开，它们中任何一个都将工作不正常。</p>
<h3 id="2-限制主题长度在50个字符以内"><a class="header-anchor" href="#2-限制主题长度在50个字符以内">¶</a>2.限制主题长度在50个字符以内</h3>
<p>50个字符并不是一个硬性限制，只是一个规则要求。限制主题行的长度在这个范围内可以保证其可读性，并且要求作者认真去思考如何简洁的表述本次提交的内容。</p>
<blockquote>
<p>Tip: If you’re having a hard time summarizing, you might be committing too many changes at once. Strive for atomic commits (a topic for a separate post).</p>
</blockquote>
<p>GitHub的UI就充分考虑了这个约定，当你提交主题超过50字符的长度时会发出警告：</p>
<p><img src="http://i.imgur.com/zyBU2l6.png" alt="1"><br>
并且会将长于72字符的主题截断，并以省略号代替：<br>
<img src="http://i.imgur.com/27n9O8y.png" alt="2"><br>
因此，争取在50字符以内，记住72字节是硬性上限。</p>
<h3 id="3-主题首字母大写"><a class="header-anchor" href="#3-主题首字母大写">¶</a>3.主题首字母大写</h3>
<p>这条规则和听上去一样简单。所有主题行请以大写字母开始，例如：</p>
<ul>
<li>Accelerate to 88 miles per hour</li>
</ul>
<p>去代替：</p>
<ul>
<li>accelerate to 88 miles per hour</li>
</ul>
<h3 id="4-主题不要用句号结尾"><a class="header-anchor" href="#4-主题不要用句号结尾">¶</a>4.主题不要用句号结尾</h3>
<p>在主题行中末尾的标点是不需要的，毕竟，当你绞尽脑汁尽力缩减字数在50字符以内的时候空间就显得那么重要了不是么。例如：</p>
<ul>
<li>Open the pod bay doors</li>
</ul>
<p>去代替：</p>
<ul>
<li>Open the pod bay doors.</li>
</ul>
<h3 id="5-主题使用祈使语气"><a class="header-anchor" href="#5-主题使用祈使语气">¶</a>5.主题使用祈使语气</h3>
<p>所谓祈使语气就是“像发布命令或指令一样的说和写”。下面是一些示例：</p>
<ul>
<li>打扫你的房间</li>
<li>关上门</li>
<li>把垃圾丢出去</li>
</ul>
<p>我们一开始说的7条规则也都是用祈使句来书写的（“将详情折叠到72字符以内”等等）。<br>
也许有时候祈使句会听起来有点粗鲁，这也是我们为什么不经常使用它的原因。但是用它书写git提交的主题行说明却很合适，因为当你利用git命令创建提交的时候它自己本身也是采用祈使语气的。</p>
<p>例如当你使用<code>git merge</code>的时候创建的默认信息如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Merge branch <span class="string">&#x27;myfeature&#x27;</span></span><br></pre></td></tr></table></figure>
<p>当使用<code>git revert</code>时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Revert <span class="string">&quot;Add the thing with the stuff&quot;</span></span><br><span class="line">This reverts commit cc87791524aedd593cff5a74532befe7ab69ce9d.</span><br></pre></td></tr></table></figure>
<p>又或者点击GitHub拉取请求的“Merge”按钮时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Merge pull request <span class="comment">#123 from someuser/somebranch</span></span><br></pre></td></tr></table></figure>
<p>因此当你使用祈使语句书写你的提交信息的时候，你正是按照了git自己的内置约定而已。例如：</p>
<ul>
<li>为了可读性重构子系统X</li>
<li>更新入门指南</li>
<li>移除弃用方法</li>
<li>发布版本1.0.0</li>
</ul>
<p>一开始这样写可能会有点尴尬，因为我们常常都只使用陈述语气来陈述事实，这就是为什么提交信息常常被表述成这样：</p>
<ul>
<li>修复了Y的bug</li>
<li>改变了X的行为</li>
</ul>
<p>有时候提交信息被写成了内容的描述：</p>
<ul>
<li>对损坏组件的一些修复</li>
<li>很棒的API新方法</li>
</ul>
<p>为了避免迷惑，以下的简单原则能够保证每次都正确的进行描述。</p>
<h3 id="一个格式正确的git提交主题行应该能够用来组成以下句子："><a class="header-anchor" href="#一个格式正确的git提交主题行应该能够用来组成以下句子：">¶</a>一个格式正确的git提交主题行应该能够用来组成以下句子：</h3>
<ul>
<li>
<p>如果被应用，这个提交将 ___________(在这里书写你的主题行)<br>
例如：</p>
</li>
<li>
<p>如果被应用，这个提交将为了可读性重构子系统X</p>
</li>
<li>
<p>如果被应用，这个提交将更新入门指南</p>
</li>
<li>
<p>如果被应用，这个提交将移除弃用方法</p>
</li>
<li>
<p>如果被应用，这个提交将发布版本1.0.0</p>
</li>
<li>
<p>如果被应用，这个提交将从user/branch分支合并拉取请求#123</p>
</li>
</ul>
<p>注意，对于不是祈使语气的结构，这个句子将不再通顺：</p>
<ul>
<li>如果被应用，这个提交将修复了Y的bug</li>
<li>如果被应用，这个提交将改变了X的行为</li>
<li>如果被应用，这个提交将对损坏组件的一些修复</li>
<li>如果被应用，这个提交将很棒的API新方法</li>
</ul>
<blockquote>
<p>记住，只需要在主题行中使用祈使语态，在书写详情的时候不需要如此严格。</p>
</blockquote>
<h3 id="6-详情任何一行都不要超过72个字符"><a class="header-anchor" href="#6-详情任何一行都不要超过72个字符">¶</a>6.详情任何一行都不要超过72个字符</h3>
<p>git不会自动去折叠文字。因此当你书写提交信息的详情时，请记得右对齐，然后手动对文字换行。<br>
我们建议在72字符的位置进行换行，这样git可以在保证所有内容都在80字符范围内的情况下有足够的缩进空间。<br>
对此一个好的文本编辑器能够帮助你。例如可以很轻松的对Vim进行设置，让其在你书写git提交的时候自动进行每72字符一次的换行。然而，传统的IDEs对于提交信息时候文字换行的智能支持表现得非常弱（虽然在最近的版本中， IntelliJ IDEA的表现终于让人比较满意了）。</p>
<h3 id="7-利用详情去说明三点：-是什么-为什么-如何做"><a class="header-anchor" href="#7-利用详情去说明三点：-是什么-为什么-如何做">¶</a>7.利用详情去说明三点： 是什么 为什么 如何做</h3>
<p>这个<a href="https://github.com/bitcoin/bitcoin/commit/eb0b56b19017ab5c16c745e6da39c53126924ed6">比特币核心代码</a>的提交记录是解释改变了什么和为什么改变的一个很好的例子:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit eb0b56b19017ab5c16c745e6da39c53126924ed6</span><br><span class="line">Author: Pieter Wuille &lt;pieter.wuille@gmail.com&gt;</span><br><span class="line">Date:   Fri Aug 1 22:57:55 2014 +0200</span><br><span class="line"></span><br><span class="line">   Simplify serialize.h<span class="string">&#x27;s exception handling</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   Remove the &#x27;</span>state<span class="string">&#x27; and &#x27;</span>exceptmask<span class="string">&#x27; from serialize.h&#x27;</span>s stream</span><br><span class="line">   implementations, as well as related methods.</span><br><span class="line"></span><br><span class="line">   As exceptmask always included <span class="string">&#x27;failbit&#x27;</span>, and setstate was always</span><br><span class="line">   called with bits = failbit, all it did was immediately raise an</span><br><span class="line">   exception. Get rid of those variables, and replace the setstate</span><br><span class="line">   with direct exception throwing (<span class="built_in">which</span> also removes some dead</span><br><span class="line">   code).</span><br><span class="line"></span><br><span class="line">   As a result, good() is never reached after a failure (there are</span><br><span class="line">   only 2 calls, one of <span class="built_in">which</span> is <span class="keyword">in</span> tests), and can just be replaced</span><br><span class="line">   by !eof().</span><br><span class="line"></span><br><span class="line">   fail(), clear(n) and exceptions() are just never called. Delete</span><br><span class="line">them.</span><br></pre></td></tr></table></figure>
<p>看看<code>full diff</code>，想想因为作者提供的这个提交说明，为他的同伴和未来的代码提交者节约了多少时间。如果他没有这么做，那么有些信息可能永远的无法找回了。<br>
通常，你可以忽略如何进行修改的细节，因为代码通常是不言自明的（如果代码过于复杂以至于需要进行必要的解释，这就需要进行代码注释了）。无论如何，请将重点放在说明你为什么要进行修改，请说明修改前的运行状态（以及存在的问题），当前的运行状态和你为什么选择该方式进行修改。</p>
<p>也许未来作为维护者的你会感谢做了以上这些工作的自己的。</p>
<h2 id="Tips"><a class="header-anchor" href="#Tips">¶</a>Tips</h2>
<h3 id="学习并热爱命令行，远离IDE"><a class="header-anchor" href="#学习并热爱命令行，远离IDE">¶</a>学习并热爱命令行，远离IDE</h3>
<p>因为许多原因比如git subcommands这些命令，总是希望可以拥抱命令行。Git极具威力，IDE显然也是，但侧重在不同的方向上，我每天都使用IDE(IntelliJ IDEA)也使用一些额外的选择(Eclipse)，但是我从未见过有IDE将Git集成比命令行本身更强大的。（建立在你了解Git命令）</p>
<p>Git与IDE集成毫无疑问是极具意义的，比如使用 git rm删除某一个文件，或者给某个文件重命名的时候。但如果你尝试通过IDE去使用commit,merge,rebase,分析日志的时候，IDE所提供的那些便捷都将不复存在。</p>
<p>一旦当你想要 <del> 控制雷电</del> 学会使用Git的全部能力的时候，那命令行就是你唯一的选择。</p>
<p>记住无论你使用的是Base或者是Zshell，tab的自动补全都能够提示你那些子命令和切换。</p>
<h2 id="阅读《Read-Pro-Git》"><a class="header-anchor" href="#阅读《Read-Pro-Git》">¶</a>阅读《Read Pro Git》</h2>
<p><a href="http://git-scm.com/book">《The Pro Git book》</a> 已经有线上免费版本，非常棒，尝试下吧。</p>
<blockquote>
<p>原文 <a href="http://chris.beams.io/posts/git-commit/">How to Write a Git Commit Message</a></p>
</blockquote>
<p><strong>译者：</strong> <a href="https://github.com/misha913loki">misha913loki</a> <a href="https://github.com/renlulu">renlulu</a> <a href="https://github.com/yannxia">yannxia</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>git</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>SOLID, GRASP和其他面向对象设计的基本原则</title>
    <url>/2017/02/20/other/object-oriented-design/</url>
    <content><![CDATA[<p>##学习面向对象的设计原则，并牢牢掌握SOLID和GRASP规则背后的思想</p>
<p>今天开始编程，体验与Qlik合作带来的驱动数据应用开发的强大引擎。</p>
<p>从一些老生常谈的事情开始说起来吧，软件代码应该符合以下特质：</p>
<ul>
<li>可维护性</li>
<li>可扩展性</li>
<li>模块化</li>
</ul>
<span id="more"></span>
<p>每当你想要质问代码是否满足以上标准的时候，就会将自己置于困难之中。</p>
<p>如果要使软件代码在其生命周期内维护起来更简单，可拓展更强且模块化，那么我们认为这种代码必须具有高于平均代码质量的一些特征。</p>
<p>我曾经编写过难以阅读，难以拓展，并且充满了坏味道的代码。在经历了大约6个月的开发学习后，才终于有了一些改善。因此，开发过程中的经历对于理解项目代码质量来说是至关重要的。</p>
<p>高级开发工程师，他们理解什么是代码质量，因此不会有上述问题。他们感到自豪，因为可以写出初级开发者所不能及的高质量代码。因此高级开发者和专家们总结出一系列原则，以供初级开发者们学习，便于他们写出高质量的代码。</p>
<p>在本篇文章中，我将阐述SOLID原则，这些原则由Robert C. Martin提出，同时我也将阐述GRASP原则，而这一部分由Craig Larman和一些面向对象的设计原则构成，我将用我个人的经验所得来举例，因此你不会看到经常在书本上被滥用的Animal和Duck的例子。</p>
<p>示例代码比较接近Java和C#，但是适用于有面向对象编程基础的任何开发者。</p>
<p>以下是完整的原则列表：</p>
<ol>
<li>Single Responsibility Principle (SOLID) 单一责任性原则</li>
<li>High Cohesion (GRASP) 高内聚</li>
<li>Low Coupling (GRASP) 低耦合</li>
<li>Open Closed Principle (SOLID) 开闭原则</li>
<li>Liskov Substitution principle (SOLID)  里氏替换原则</li>
<li>Interface Segregation Principle (SOLID) 接口分离原则</li>
<li>Dependency Inversion Principle (SOLID) 依赖倒置原则</li>
<li>Program to an Interface, not to an Implementation 面向接口编程</li>
<li>Hollywood Principle 好莱坞原则</li>
<li>Polymorphism (GRASP) 多态模式</li>
<li>Information Expert (GRASP) 信息专家模式</li>
<li>Creator (GRASP) 创造者模式</li>
<li>Pure Fabrication (GRASP) 纯虚构模式</li>
<li>Controller (GRASP) 控制器模式</li>
<li>Favor composition over inheritance 组合优于继承</li>
<li>Indirection (GRASP) 中介模式</li>
</ol>
<p>在我早期职业生涯中我经常犯一个错误，总说试图一次性使用这些所有的原则。这是一个巨大的认知错误，我希望你引以为戒。</p>
<p>#Single Responsibility Principle（单一责任原则）<br>
单一责任原则（SRP）定义：</p>
<p><strong>每个类应该只负责一种单一的功能</strong></p>
<p>一个类利用它的函数或者契约（以及函数相关的成员变量）来执行其功能。<br>
我们来看下面这个类</p>
<pre><code>Class Simulation&#123;
	Public LoadSimulationFile()
	Public Simulate()
	Public ConvertParams()
&#125;
</code></pre>
<p>这个类有两个功能。第一，装载仿真数据，第二，执行仿真算法（使用Simulate和ConvertParams方法）。</p>
<p>类使用一个或多个函数来执行功能。在上例中，加载仿真数据是一个功能，执行仿真算法是另一个功能。加载仿真数据需要一个函数（LoadSimulationFile），而剩下的两个函数用来实现算法的功能。</p>
<p>那么如何分辨自己的类有哪些功能呢？参考功能的定义短语为“改变的原因”。因此，寻找一个类改变的所有原因，如果有一个以上的理由需要改动这个类，那么这意味着这个类并没有遵守单一功能原则。</p>
<p>上面的示例中，这个类不应该包含LoadSimulationFile函数（或者装载仿真数据的功能）。如果我们创建一个单独的类来加载模拟数据，那么这个类就不再违反SRP原则了。</p>
<p><strong>一个类只能有一个功能</strong>，那么在设计软件的时候我们如何去遵守这个严格的规则？<br>
让我们考虑另一个与SRP密切相关的原则：高内聚。高内聚给了你一个主观的尺度，而不像SRP那样是一个客观指标。极低内聚意味着这个类执行了很多的功能，例如一个类负责了超过10个功能。低内聚意味着一个类执行大约5个功能，而中等内聚大约执行3个功能，而高内聚则一个类只有单一功能。因此，设计的经验法则是努力实现高内聚。</p>
<p>另一个需要在这里讨论的原则是低耦合。这个原则表明一个类应该独立完成特定的功能，使得类之间保持低依赖性。再次审视上面的示例类，在应用SRP和高内聚规则之后，我们决定创建一个独立的类来处理模拟数据文件。这样，我们就创建了两个互相依赖的类。<br>
看起来采用高内聚似乎和低耦合原则相抵触了。因为原则是最小化耦合，并不是使耦合为零，因此这种程度的耦合是可以接受的。对于创建一个通过对象之间协作完成任务的面向对象的程序设计来说，一定程度的耦合是正常的。</p>
<p>另一方面，考虑一个链接数据库的GUI类，通过HTTP协议链接远程客户端并处理屏幕布局。这个GUI类依赖了太多的类，很明显违反了低耦合原则。如果不包含所有的相关类则该类不能被重用，任何对数据库组件的改变都将改变这个GUI类。</p>
<p>#Open-Closed Principle（开闭原则）</p>
<p>开闭原则的描述为：</p>
<p><strong>一个软件模块（类或者方法）应该对拓展开放而对修改关闭</strong></p>
<p>换句话说，你无法对已经编写的工程代码进行修改，但是你能够为工程添加新的代码。</p>
<p>有两种方法可以实现开闭原则，即继承或组合。</p>
<p>下面的示例采用继承来实现开闭原则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class DataStream&#123;</span><br><span class="line">	Public byte[] Read()</span><br><span class="line">&#125;</span><br><span class="line">Class NetworkDataStream:DataStream&#123;</span><br><span class="line">	Public byte[] Read()&#123;</span><br><span class="line">	//Read from the network</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class Client &#123;</span><br><span class="line">	Public void ReadData(DataStream ds)&#123;</span><br><span class="line">	ds.Read();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，客户端读取（ds.Read()）来自于网络数据流。如果我想要扩展这个客户端的功能使之能够读取其他数据流的内容，例如PCI数据流，那么我需要添加另外继承自DataStream的子类，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class PCIDataStream:DataStream&#123;</span><br><span class="line">	Publc byte[] Read()&#123;</span><br><span class="line">	//Read data from PCI</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，客户端代码的运行没有任何错误。客户端认识基类，因此可以传递DataStream两个子类中的任何一个的对象，这样，客户端可以在未知子类的情况下读取数据。这是在不修改任何现有代码的情况下实现的。</p>
<p>我们还可以使用组合来实现这个原则，并且还有其他方法和设计模式来应用该原则，这些方法中的一部分将在本文中进行讨论。</p>
<p>然而，你必须将这个原则应用于每一段代码吗？当然不，因为大部分的代码其实是不怎么变动的，你只需要战略性的将这个原则应用到那些你预计将来会有变动的代码片上即可。</p>
<p>#Liskov Substitution Principle（里氏替换原则）</p>
<p>里氏替换原则的描述为：</p>
<p><strong>子类应当可以替换父类并出现在父类能够出现的任何地方</strong></p>
<p>这个定义还可以理解为对一个客户端来说需要有足够的抽象（接口或抽象类）。</p>
<p>为了详细说明，让我们考虑一个例子，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Public Interface IDevice&#123;</span><br><span class="line">	Void Open();</span><br><span class="line">	Void Read();</span><br><span class="line">	Void Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子是数据采集装置的抽象。数据采集装置按其接口类型不同而区分，它能够使用USB接口，网络接口（TCP 或者 UDP），PIC接口或者另外的计算机接口。然而，客户端设备不需要知道与其链接的是何种数据采集装置。为了在不改变客户端代码的情况下适应新的采集装置，这就需要程序员给接口提供极大的灵活性。</p>
<p>当只有两个具体的类实现iDevice接口的情况如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PCIDevice:IDevice &#123;</span><br><span class="line">	public void Open()&#123;</span><br><span class="line">	// Device specific opening logic</span><br><span class="line">	&#125;</span><br><span class="line">public void Read()&#123;</span><br><span class="line">	// Reading logic specific to this device</span><br><span class="line">	&#125;</span><br><span class="line">public void Close()&#123;</span><br><span class="line">	// Device specific closing logic.</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class NetWorkDevice:IDevice&#123;</span><br><span class="line">	public void Open()&#123;</span><br><span class="line">	// Device specific opening logic</span><br><span class="line">	&#125;</span><br><span class="line">public void Read()&#123;</span><br><span class="line">	// Reading logic specific to this device</span><br><span class="line">	&#125;</span><br><span class="line">public void Close()&#123;</span><br><span class="line">	// Device specific closing logic.</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三个方法（打开、读取和关闭）对于处理设备传入的数据已经足够了。然后，假设需要添加基于USB接口的另一个数据采集设备。</p>
<p>USB设备的问题在于，当你打开连接时，来自先前连接的数据仍保留在缓冲区中。因此，在对USB设备的第一次读取调用时，返回来自上一个会话的数据。有针对性的采集行为会破坏这些数据。幸运的是，基于USB的设备驱动程序提供刷新功能，预先清除了基于USB的采集设备中的缓冲区。那么如何在代码中实现这个功能，并使代码的改动最小？</p>
<p>一个简单但是草率的解决方案是更新代码，通过标识识别是否调用USB设备，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class USBDevice:IDevice&#123;</span><br><span class="line">	public void Open()&#123;</span><br><span class="line">		// Device specific opening logic</span><br><span class="line">	&#125;</span><br><span class="line">	public void Read()&#123;</span><br><span class="line">   		// Reading logic specific to this device&lt;br&gt;</span><br><span class="line">	&#125;</span><br><span class="line">	public void Close()&#123;</span><br><span class="line">		// Device specific closing logic.</span><br><span class="line">	&#125;</span><br><span class="line">	public void Refresh()&#123;</span><br><span class="line">		// specific only to USB interface Device</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Client code..</span><br><span class="line">Public void Acquire(IDevice aDevice)&#123;</span><br><span class="line">       aDevice.Open();</span><br><span class="line">       // Identify if the object passed here is USBDevice class Object.    </span><br><span class="line">	if(aDevice.GetType() == typeof(USBDevice))&#123;</span><br><span class="line">	USBDevice aUsbDevice = (USBDevice) aDevice;</span><br><span class="line">	aUsbDevice.Refresh();</span><br><span class="line">	&#125;</span><br><span class="line">       // remaining code….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个解决方案中，客户端代码直接使用具体类以及接口（或抽象类），这意味着抽象程度不足以使客户端执行其功能。</p>
<p>另一种陈述方式是基类无法满足需求（刷新操作），但是子类可以，实际上，子类有该项行为。因此，派生类和基类不兼容且子类不能被代替。所以，该解决方案违反了里氏替换原则。</p>
<p>下面这个示例中，客户端依赖于更多的实体（iDevices 和 USB Devices），一个实体的任何一点改变都将影响其他实体。因此，违反LSP原则将导致类之间的互相依赖。</p>
<p>下面我列出一种遵循LSP原则的解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   Public Interface IDevice&#123;</span><br><span class="line">	Void Open();</span><br><span class="line">	Void Refresh();</span><br><span class="line">	Void Read();</span><br><span class="line">	Void Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在客户端如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Public void Acquire(IDevice aDevice)&#123;</span><br><span class="line">	aDevice.open();</span><br><span class="line">	aDevice.refresh();</span><br><span class="line">	aDevice.acquire()</span><br><span class="line">	//Remaining code..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在客户端不再依赖于设备的具体实现了，因此，这个方案中，我们的接口（设备）对于客户端来说是完备的了。</p>
<p>从面向对象分析的视角来看，有另一个不同的角度去解释LSP原则。总的来说，通过OOA，类和它们的层级结构将会是我们软件设计需要考虑的一个部分。</p>
<p>当我们考虑类和层级结构的时候我们可能会设计一些违反LSP规则的类。</p>
<p>让我们思考一个古典的例子，即长方形和正方形。一开始看起来正方形是长方形的特例，于是一个乐观的程序设计师将绘制出下面的层级继承关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Public class Rectangle&#123;</span><br><span class="line">	Public void SetWidth(int width)&#123;&#125;</span><br><span class="line">	Public void SetHeight(int height)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Public Class Square:Rectangle&#123;</span><br><span class="line">	//</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来你会发现你不能使用这个正方形的对象去代替长方形的对象了。因为正方形继承自长方形，所以它也继承了设置长度和宽度的方法。于是一个正方形的客户端能够随意改变自己的长和宽为不同的大小，但是实际上正方形的长宽应该是相同的，因此我们软件的这个正常行为就失败了。</p>
<p>这个问题只能根据不同的使用场景和条件具体分析类来避免。因此如果你孤立的设计一个类很可能在实际运行中将会出错。就像我们的正方形和长方形那样，一开始认为很完美的关系设计，在不同的条件下，这种关系设计最终被认定并不符合我们软件正常运行的要求。</p>
<p>#Interface Segregation Principle（接口隔离原则）<br>
接口隔离原则（ISP）描述为：</p>
<p><strong>客户端不应该被强迫依赖他们不使用的接口</strong></p>
<p>还是考虑前一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Public Interface IDevice&#123;</span><br><span class="line">	Void Open();</span><br><span class="line">	Void Read();</span><br><span class="line">	Void Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口有三个实现类，USB设备、网络设备和PCID设备。这个接口对于网络和PCID设备来说够用，但是USB设备还需要另一个函数（Refresh()）才能运行正常。</p>
<p>和USB设备一样，也许还有另外的设备也需要这个函数来支持工作。为此，接口被更新如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Public Interface IDevice&#123;</span><br><span class="line">	Void Open();</span><br><span class="line">	Void Refresh();</span><br><span class="line">	Void Read();</span><br><span class="line">	Void Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么问题来了，任何一个实现该接口的类都需要去实现Refresh函数。</p>
<p>例如为了满足以上的设计，必须对网络设备和PCID设备添加下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public  void Refresh()&#123;</span><br><span class="line">	// Yes nothing here… just a useless blank function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，这个设备基类被视为一个胖接口（过多的函数）。这种设计违反了接口隔离原则，因为它造成了客户端不必要的依赖。</p>
<p>有很多方法可以解决这个问题，不过我将在预定义的面向对象的解决方案范畴内处理这个问题。</p>
<p>我们知道在open操作之后就会直接调用refresh函数，因此，我改变逻辑将设备客户端的refresh函数迁移至具体的实现类内部。在本例中我将调用refresh的逻辑移动到USB设备的具体实现类中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Public Interface IDevice&#123;</span><br><span class="line">	Void Open();</span><br><span class="line">	Void Read();</span><br><span class="line">	Void Close();</span><br><span class="line">&#125;</span><br><span class="line">Public class USBDevice:IDevice&#123;</span><br><span class="line">	Public void Open&#123;</span><br><span class="line">		// open the device here…</span><br><span class="line">		// refresh the device</span><br><span class="line">		this.Refresh();</span><br><span class="line">	 &#125;</span><br><span class="line">	Private void Refresh()&#123;</span><br><span class="line">		// make the USb Device Refresh</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个方式，我减少了基类中的函数数目，让它变得更轻了。</p>
<h1>Dependency Inversion Principle（依赖反转）</h1>
<p>这条原则是对上面所讨论的原则的一个概述。
<p>在我们给出DIP的书面定义之前，请让我介绍一个与此紧密相连的一条原则，以帮助我们理解DIP。
<p>这条原则是：面向接口编程，而不是面向实现编程。
<p>考虑下面这个简单的例子：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class PCIDevice&#123;</span><br><span class="line">    Void open()&#123;&#125;</span><br><span class="line">    Void close()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Static void Main()&#123;</span><br><span class="line">    PCIDevice aDevice = new PCIDevice();</span><br><span class="line">    aDevice.open();</span><br><span class="line">    //do some work</span><br><span class="line">    aDevice.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例代码违背了面向接口编程，因为我们正在操作的引用是具体的类对象PCIDevice，下面的代码则遵循了这个原则：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Interface IDevice&#123;</span><br><span class="line">    Void open();</span><br><span class="line">    Void close();</span><br><span class="line">&#125;</span><br><span class="line">Class PCIDevice implements IDevice&#123;</span><br><span class="line">    Void open()&#123; // PCI device opening code &#125;</span><br><span class="line">    Void close()&#123; // PCI Device closing code &#125;</span><br><span class="line">&#125;</span><br><span class="line">Static void Main()&#123;</span><br><span class="line">    IDevice aDevice = new PCIDevice();</span><br><span class="line">    aDevice.open();</span><br><span class="line">    //do some work</span><br><span class="line">    aDevice.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 所以这条原则很容易去遵循。依赖反转与此类似，但需要我们做的更多。
<p>依赖反转：高级模块不应该依赖低级模块。二者应该依赖于抽象。
<p>你可以把"两者都应该依赖于抽象"简单的理解成面向接口编程。那么什么是高级模块和低级模块？
<p>为了这条原则的第一部分，我们需要理解高级模块和低级模块实际上是什么。看如下代码：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class TransferManager&#123;</span><br><span class="line">public void TransferData(USBExternalDevice usbExternalDeviceObj,SSDDrive  ssdDriveObj)&#123;</span><br><span class="line">            Byte[] dataBytes = usbExternalDeviceObj.readData();</span><br><span class="line">           // work on dataBytes e.g compress, encrypt etc..</span><br><span class="line">            ssdDriveObj.WrtieData(dataBytes);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">Class USBExternalDevice&#123;</span><br><span class="line">Public byte[] readData()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">Class SSDDrive&#123;</span><br><span class="line">Public void WriteData(byte[] data)&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码有三个类，TransferManager代表高级模块，因为它在一个方法中用了其它两个类。因此其他两个类则是低级模块。
<p>上面的代码中，高级模块是直接使用低级模块的(没有任何抽象)，因此违背了依赖反转原则。
<p>违背了依赖反转这条原则会让你的软件系统变得难以更改。比如，如果你想增加其他的外部设备，你将不得不
改变高级模块。因此你的高级模块将会依赖于低级模块，依赖会让代码变得难以改变。
<p>如果你理解了上面的原则"面向接口编程"，那么就很容易解决这个问题:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class USBExternalDevice implements IExternalDevice&#123;</span><br><span class="line">Public byte[] readData()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Class SSDDrive implements IInternalDevice&#123;</span><br><span class="line">Public void WriteData(byte[] data)&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Class TransferManager implements ITransferManager&#123;</span><br><span class="line">public void Transfer(IExternalDevice externalDeviceObj, IInternalDevice internalDeviceObj)&#123;</span><br><span class="line">           Byte[] dataBytes = externalDeviceObj.readData();</span><br><span class="line">           // work on dataBytes e.g compress, encrypt etc..</span><br><span class="line">           internalDeviceObj.WrtieData(dataBytes);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">Interface IExternalDevice&#123;</span><br><span class="line">        Public byte[] readData();</span><br><span class="line">&#125;</span><br><span class="line">Interfce IInternalDevice&#123;</span><br><span class="line">Public void WriteData(byte[] data);</span><br><span class="line">&#125;</span><br><span class="line">Interface ITransferManager &#123;</span><br><span class="line">public void Transfer(IExternalDevice usbExternalDeviceObj,SSDDrive  IInternalDevice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，高级模块和低级模块都依赖于抽象，符合了依赖反转原则。</p>
<h1>Hollywood（好莱坞原则）</h1>
<p>这条原则和依赖反转原则类似：不要调用我们，我们会给你。
<p>这意味着高级组件可以以一种互不依赖的方式去支配低级组件。
<p>这条原则可以防止依赖恶化。依赖恶化发生在每个组件都依赖于其他各个组件。换句话说，依赖恶化是让依赖发生在各个方向(向上，横向，向下)。
Hollywood原则可以让我们时依赖只向一个方向。
<p>DIP和Hollywood之间的差异给了我们一条通用原则：无论是高级组件还是低级组件，都要依赖于抽象而不是具体的类。另一方面，Hollywood原则
强调了高级组件和低级组件应该以不产生依赖的方式交互。
<h1>Polymorphism（多态）</h1>
<p>什么？多态也是设计原则？对的，多态是任何面向对象语言都要提供的基础特征，它可以让父类的引用指向子类。
<p>它同时也是GRASP的设计原则之一。这条原则为你在面向对象设计中提供了知道方针。
<p>这条原则严格限制了运行时类型信息的使用(RTTI)。在C#中，我们用如下方式实现RTTI：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(aDevice.GetType() == typeof(USBDevice))&#123;</span><br><span class="line">//This type is of USBDEvice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在java中，RTTI由getClass()或者instanceOf()完成：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(aDevice.getClass() == USBDevice.class)&#123;</span><br><span class="line">    // Implement USBDevice</span><br><span class="line">     Byte[] data = USBDeviceObj.ReadUART32();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你曾在你的项目中编写了类似的代码，那么现在是时候重构你的代码以符合多态原则，看如下例图:
<img src="http://www.objectorienteddesign.org/wp-content/uploads/2016/12/PolymorphismDiagram.jpg"/>
<p>在此我在接口中生成了read方法，然后委托他们的实现类去实现该方法，现在，我只用方法Read:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//RefactoreCode</span><br><span class="line">IDevice aDevice = dm.getDeviceObject();</span><br><span class="line">aDevice.Read();</span><br></pre></td></tr></table></figure>
<p>getDeviceObject()的实现来自哪里？这是我们即将要讨论的创造者原则和信息专家原则</p>
<h1>Information Expert（信息专家原则）</h1>
<p>这是GRASP的一条简易原则，它在如何给予类权限方面给我们提供指导。它表明你应该在一个类有足够的信息去满足某项职能的时候才能赋予它该只能。考虑下面的类：
<img src="http://www.objectorienteddesign.org/wp-content/uploads/2016/12/InformationExpert.jpg"/>
<p>在我们的场景中，一个模式全速启动（每秒600次循环），而用户的显示器以降低的速度更新。那么，我将不得不指定一个职责以决定下一帧需不需要展示。
<p>哪一个类负责担任这项职责？我有两个选择:Simulation类或者SpeedControl类。
<p>既然SpeedControl类有关于当前顺序下已经被展示的帧，那么依据信息专家原则，SpeedControl负责该职责。
<h1>Creator（创造者原则）</h1>
<p>创造者是GRASP中负责决定某类负责创造另一个类的实例。对象的创造是非常重要的，因此有原则的去决定创造者的角色是很有用的。
<p>根据Larman所言，类B在以下任何一个条件为真时，应该负担起对A的创造：
<ul>
<li>B包含A</li>
<li>B聚合A</li>
<li>B含有初始化A所需有的信息</li>
<li>B记录A</li>
<li>B闭合式的使用A</li>
</ul>
<p>在我们多态的例子中，我使用了信息专家原则和创造者原则，使得DeviceManager类得到创建Device对象的职责。
这是因为DeviceManger有创建Device所需要的信息。
<h1>Pure Fabrication（纯虚构模式）</h1>
<p>为了理解纯制造，首先你要理解面向对象分析（OOA）
<p>面向对象分析是一个通过问题领域去确定类的过程。举个例子，银行系统的领域模型应该包含诸如类Account, Branch, Cash, Check, Transaction
等等。这些领域类需要存储关于客户的信息。实现该原则的一个选择是把数据的存储委托给领域类。这个选择会降低领域类的粘性。
最后这个选择违背了SRP原则。
<p>另一个选择是引入其他不含任何领域概念的类。在银行系统中，我们可以引入被称为持久化提供者的类。这个类不带便任何领域实体。其目的是为了处理存储方法。因此
PersistenceProvider是符合纯制造原则的。
<h1>Controller（控制器原则）</h1>
<p>当我开始开发软件系统时，我最常写的就是使用java swing组件，大部分逻辑都在监听器后面。
<p>然后我学习了有关领域类模型的知识。也由此将我的逻辑从监听器移到领域类。然而我直接从监听器里调用领域对象，这就使得GUI组件(监听器)和领域模型之间产生了依赖。
控制器设计模型有助于最小化这种依赖。
<p>控制器有两个目的，其一是封装系统操作。系统操作是指你的用户想要达到某个目的，例如购买某件商品给或者将某个东西加入购物车。
这种系统操作是通过调用系统对象的一个或者多个方法来完成的。控制器的第二个目的是为UI和领域模型提供一层。
<p>UI可以让用户进行系统操作。控制器是UI层之后的第一个处理系统操作请求的对象然后将职责委托给底层的领域对象。
<p>例如，下面是一个MAP类，代表着一个控制器：
<imag src="http://www.objectorienteddesign.org/wp-content/uploads/2016/12/Controller.jpg"/>
<p>我们在UI层将职责"移动光标"委托给控制器，紧接着由控制器去调用底层的领域对象去移动游标。
<p>通过使用控制器原则，会使得你在增加其他用户接口（如命令行接口或者web接口）变得更加灵活。
<h1>Favor Composition Over Inheritance（组合优于继承原则）</h1>
<p>在面向对象编程中，基本上有两种扩展已有代码功能的方法，第一个是继承。
<p>第二个方法是组合，用编程术语来说，你可以通过获取对象的一个引用来扩展这个对象的功能。组合的一个很有用的特征是它的行为可以在运行时才设定。而在继承中，你只有在编译器才能确定它的行为。我们将通过多个例子来说明这一点。
<p>当我是一个新手，我通过集成来扩展行为，如下：
<img src="http://www.objectorienteddesign.org/wp-content/uploads/2016/12/FavorCompositionOverInheritance1.jpg"/>
<p>最初，我只知道将要处理一段数据输入流，而数据有两种类型。过了几个星期之后，我意识到数据的字节顺序需要被处理。
因此按照如下图例改变了类设计：
<img src="http://www.objectorienteddesign.org/wp-content/uploads/2016/12/FavorCompositionOverInheritance2.jpg"/>
<p>之后，一个新的变量被增加到需求中。这次我需要处理数据的极性，极性有两种：Stream A, StreamB，流有很多种字节顺序，如此一来，类就爆炸了。我将不得不去维护
一大批类。
<p>如果我使用组合来处理相同的问题，类设计如下：
<img src="http://www.objectorienteddesign.org/wp-content/uploads/2016/12/FavorCompositionOverInheritance3.jpg"/>
<p>我新增了一些类，然后在我的代码中使用它们的引用：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clientData.setPolarity(new PolarityOfTypeA); // or clientData.setPolarity(new PolarityOfTypeB)</span><br><span class="line">clientData.FormatPolarity;</span><br><span class="line">clientData.setEndianness(new LittleEndiannes());// setting the behavior at run-time</span><br><span class="line">clientData.FormatStream();</span><br></pre></td></tr></table></figure>
<p>如此一来，我就可以根据的想要的行为来提供类的实例，这个特征使得类的总数下降了，最终保证了可维护性。因此组合优于继承将会减少不可维护问题的发生，并且让你能更加灵活的在运行时设定你的行为。
<h1>Indirection（间接原则）</h1>
<p>这个原则回答了一个问题：你如何使对象以解耦的方式进行交互。答案是：将交互的职责交给中间对象，使得相关组件的耦合度降低。
<p>例如，一个软件应用在多个配置和选择下都可以工作。要将领域代码与配置分离，需要添加一个特定的类，如下面的列表所示：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Public Configuration&#123;</span><br><span class="line">  public int GetFrameLength()&#123;</span><br><span class="line">    // implementation</span><br><span class="line">  &#125;</span><br><span class="line">  public string GetNextFileName()&#123;</span><br><span class="line">  &#125;</span><br><span class="line"> // Remaining configuration methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，如果任何领域对象需要读取某个配置，只要让它去请求Configuration对象即可。因此，主要代码与配置代码完成了解耦。
<p>如果你已经阅读了纯构造原则，那么配置类就是该原则的一个实例。但是间接原则的目的是完成解耦，而纯构造原则的目的是为了维持领域模型的简介。
<p>许多软件设计模式诸如适配器模式，外观模式以及观察者模式都是间接原则的更专业化的体现。
<blockquote>
<p>原文 <a href="https://dzone.com/articles/solid-grasp-and-other-basic-principles-of-object-o">原文链接</a></p>
</blockquote>
<p><strong>译者：</strong></p>
<ul>
<li><a href="https://github.com/misha913loki">misha913loki</a></li>
<li><a href="https://github.com/renlulu">renlulu</a></li>
<li><a href="https://github.com/yannxia">yannxia</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>OO</category>
      </categories>
      <tags>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员的自我修养： 如何写好单元测试</title>
    <url>/2022/08/06/other/unittest/</url>
    <content><![CDATA[<p><img src="https://fastly.jsdelivr.net/gh/yanickxia/picture-bed@master/2022/202208061311334.png" alt=""></p>
<p>今天我们来聊聊程序员中最讨论的一个部分，单元测试</p>
<span id="more"></span>
<h2 id="概论"><a class="header-anchor" href="#概论">¶</a>概论</h2>
<p>首先先摆明一个立场，<code>CodeReview</code> 的作用大于单元测试，但是因为测试框架的存在，我们可以通过单元测试发现更多类型的错误。</p>
<blockquote>
<p>The primary purpose of collaborative construction is to improve software quality. As<br>
noted in Chapter 20, “The Software-Quality Landscape,” software testing has limited<br>
effectiveness when used alone—the average defect-detection rate is only about 30 percent for unit testing, 35 percent for integration testing, and 35 percent for low-volume<br>
beta testing. In contrast, the average effectivenesses of design and code inspections are<br>
55 and 60 percent (Jones 1996). The secondary benefit of collaborative construction<br>
is that it decreases development time, which in turn lowers development costs.<br>
by《Code Complete》</p>
</blockquote>
<p>单元测试通常占用整个项目的 8% - 35%，从开发者的角度的看起来，大概会消耗 50% 的研发时间，因此在估算时间的时候不要太过于乐观。</p>
<p>绝大多数的开发者习惯于在业务逻辑写完之后进行单元测试的编写，认为可以节约时间，根据 Kent Beck 的<a href="https://book.douban.com/subject/1230036/">《Test Driven Development》</a> 中的调查，实则在编写代码之前完成测试Case 的编写是降低整体研发时间的。</p>
<ul>
<li>在编码之前编写单元测试不用考虑代码的实现逻辑，可以写出更加代码测试</li>
<li>单侧让你考虑代码实现的时候更加的全面</li>
<li>单侧可以迫使代码更利于测试，减少后续重构的返工</li>
</ul>
<h3 id="测试的方法论"><a class="header-anchor" href="#测试的方法论">¶</a>测试的方法论</h3>
<p>当前的测试方法论主要有如下两种 <code>TDD</code> <code>BDD</code></p>
<h4 id="TDD"><a class="header-anchor" href="#TDD">¶</a>TDD</h4>
<p><img src="https://fastly.jsdelivr.net/gh/yanickxia/picture-bed@master/2022/202208061204841.png" alt=""></p>
<p>TDD是测试驱动开发（Test-Driven Development）的英文简称。TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。</p>
<p><code>TDD</code> 是我们最为常用的一种测试方式，也是非常符合设计思路的一种测试，我们在 Coding 具体逻辑之前，我们就会考虑我们的系统抽象，针对抽象接口编写测试。</p>
<h4 id="BDD"><a class="header-anchor" href="#BDD">¶</a>BDD</h4>
<p><img src="https://fastly.jsdelivr.net/gh/yanickxia/picture-bed@master/2022/202208061207614.png" alt=""></p>
<p>行为驱动开发(BDD)是测试驱动开发的延伸，开发使用简单的，特定于领域的脚本语言。这些DSL将结构化自然语言语句转换为可执行测试。结果是与给定功能的验收标准以及用于验证该功能的测试之间的关系更密切。因此，它一般是测试驱动开发(TDD)测试的自然延伸。</p>
<p>这两者在行为上区别也并没有想象中那么大，往往这两者在一个系统中会同时存在。</p>
<table>
<thead>
<tr>
<th>TDD</th>
<th>BDD</th>
</tr>
</thead>
<tbody>
<tr>
<td>该过程从编写测试用例开始。</td>
<td>该过程从编写行为场景开始。</td>
</tr>
<tr>
<td>TDD 专注于如何实现功能。</td>
<td>BDD 专注于最终用户的应用程序行为。</td>
</tr>
<tr>
<td>测试用例是用编程语言编写的。</td>
<td>场景更具可读性。</td>
</tr>
<tr>
<td>TDD 中的测试只能被具有编程知识的人理解。</td>
<td>任何人都可以理解 BDD 中的测试，包括没有任何编程知识的人。</td>
</tr>
<tr>
<td>应用程序功能的变化对TDD 中的测试用例影响很大。</td>
<td>BDD 场景受功能更改的影响不大。</td>
</tr>
<tr>
<td>仅开发测试人员之间需要协作。</td>
<td>需要所有利益相关者之间的协作。</td>
</tr>
<tr>
<td>一些支持 TDD 的工具有：JUnit、TestNG、NUnit 等。</td>
<td>支持 BDD 的一些工具是 SpecFlow、Cucumber、MSpec 等。</td>
</tr>
</tbody>
</table>
<p>从实践的角度上，我们一般在对无副作用的函数采用 <code>TDD</code>， 对一些小型点的 e2e 测试会采用 <code>BDD</code></p>
<h3 id="场景分析"><a class="header-anchor" href="#场景分析">¶</a>场景分析</h3>
<p>比如我们在项目中常见的 <code>utils</code> 工具包，包装一些静态函数，因此我们尝尝使用如下方式进行测试</p>
<p>首先我们先定义好我们的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListToMap</span><span class="params">(conditions []<span class="type">string</span>)</span></span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在测试文件中，定义好测试类</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestListToMap</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	result := ListToMap([]<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;)</span><br><span class="line">	assert.NotNil(t, result)</span><br><span class="line">	assert.Equal(t, <span class="number">2</span>, <span class="built_in">len</span>(result))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们编写我们的主题逻辑即可，不过这里的测试其实就犯了一个场景的单侧的问题。</p>
<blockquote>
<p>Developer tests tend to be “clean tests” Developers tend to test for whether the code<br>
works (clean tests) rather than test for all the ways the code breaks (dirty tests).<br>
Immature testing organizations tend to have about five clean tests for every dirty test.<br>
Mature testing organizations tend to have five dirty tests for every clean test. This ratio<br>
is not reversed by reducing the clean tests; it’s done by creating 25 times as many dirty<br>
tests (Boris Beizer in Johnson 1994).</p>
</blockquote>
<p>我们编写的是一个被称为 <code>happly test</code> 的 <code>case</code>，因为我们接受了一个最为普通的 <code>case</code>，我们只能保证在一个非常适用的场景下的可靠性，而真正有经验的开发同学会需要增加更多的边界测试。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestListToMap</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	result := ListToMap([]<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;)</span><br><span class="line">	assert.NotNil(t, result)</span><br><span class="line">	assert.Equal(t, <span class="number">2</span>, <span class="built_in">len</span>(result))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nil get nil</span></span><br><span class="line">    assert.IsNil(t, ListToMap(<span class="literal">nil</span>))</span><br><span class="line">    <span class="comment">// empty get empty</span></span><br><span class="line">    assert.Equal(t, <span class="keyword">map</span>[]<span class="type">string</span>&#123;&#125;, ListToMap([]<span class="type">string</span>&#123;&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里列举一些常见的边界</p>
<ol>
<li>入参为 Nil</li>
<li>入参为 Empty</li>
<li>入参超长（IntMax）</li>
<li>复杂条件冲突存在</li>
</ol>
<h3 id="工具箱"><a class="header-anchor" href="#工具箱">¶</a>工具箱</h3>
<p>除了上面提到的 <code>TDD</code> <code>BDD</code> 这样的方法论，我们在测试的过程中，我们也会相当的使用一些常见的测试范式。</p>
<h4 id="Table-Driven-Tests"><a class="header-anchor" href="#Table-Driven-Tests">¶</a>Table Driven Tests</h4>
<p>当我们编写一个工具函数的时候，我们按照 <code>TDD</code>的思维已经编写了一个单元测试如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">string</span></span><br><span class="line">    i := strings.Index(s, sep)</span><br><span class="line">    <span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">        s = s[i+<span class="built_in">len</span>(sep):]</span><br><span class="line">        i = strings.Index(s, sep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(result, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    got := Split(<span class="string">&quot;a/b/c&quot;</span>, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">    want := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123;</span><br><span class="line">         t.Fatalf(<span class="string">&quot;expected: %v, got: %v&quot;</span>, want, got)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候我们需要增加一个新的测试项目，就需要在下面再加一行，或者新增一个测试函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplitWrongSep</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    got := Split(<span class="string">&quot;a/b/c&quot;</span>, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    want := []<span class="type">string</span>&#123;<span class="string">&quot;a/b/c&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123;</span><br><span class="line">        t.Fatalf(<span class="string">&quot;expected: %v, got: %v&quot;</span>, want, got)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随着我们测试边界的增加，会导致我们的测试函数无休止的增加。而 <code>Table Driven test</code> 就是将测试变成一个表格来进行测试。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">        input <span class="type">string</span></span><br><span class="line">        sep   <span class="type">string</span></span><br><span class="line">        want  []<span class="type">string</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tests := []test&#123;</span><br><span class="line">        &#123;input: <span class="string">&quot;a/b/c&quot;</span>, sep: <span class="string">&quot;/&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;input: <span class="string">&quot;a/b/c&quot;</span>, sep: <span class="string">&quot;,&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;a/b/c&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;input: <span class="string">&quot;abc&quot;</span>, sep: <span class="string">&quot;/&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;abc&quot;</span>&#125;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        got := Split(tc.input, tc.sep)</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">            t.Fatalf(<span class="string">&quot;expected: %v, got: %v&quot;</span>, tc.want, got)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对<code>无副作用</code>的函数测试中，推荐采用这种测试方式。</p>
<h4 id="Data-Driven-Tests"><a class="header-anchor" href="#Data-Driven-Tests">¶</a>Data Driven Tests</h4>
<p>对于一些入参比较的复杂的对象，比如我们经常需要从 <code>Yaml</code> 构建一个相对复杂的对象的时候，这样的测试方式就会显得有点不足。这个时候我们可以引入 <code>Data Driven</code> 的模式。</p>
<p><img src="https://fastly.jsdelivr.net/gh/yanickxia/picture-bed@master/2022/202208061240356.png" alt=""></p>
<p>举个例子，我们有如下的一个测试函数，我们的测试源是 <code>loginData</code>，当前是固化在代码之中的，维护起来不是很方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataProvider</span></span><br><span class="line"><span class="keyword">public</span> Object[][] loginData()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>[][] &#123;</span><br><span class="line">        &#123; <span class="string">&quot;valid_email&quot;</span>, <span class="string">&quot;valid_pass&quot;</span>, <span class="string">&quot;success_login&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;valid_phone&quot;</span>, <span class="string">&quot;valid_pass&quot;</span>, <span class="string">&quot;success_login&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;invalid_email&quot;</span>, <span class="string">&quot;valid_pass&quot;</span>, <span class="string">&quot;failed_login&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;invalid_phone&quot;</span>, <span class="string">&quot;valid_pass&quot;</span>, <span class="string">&quot;failed_login&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;valid_email&quot;</span>, <span class="string">&quot;invalid_pass&quot;</span>, <span class="string">&quot;failed_login&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;valid_phone&quot;</span>, <span class="string">&quot;invalid_pass&quot;</span>, <span class="string">&quot;failed_login&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;null_email_phone&quot;</span>, <span class="string">&quot;valid_pass&quot;</span>, <span class="string">&quot;failed_login&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;valid_email&quot;</span>, <span class="string">&quot;null_pass&quot;</span>, <span class="string">&quot;failed_login&quot;</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//passing value dari DataProvider ke parameter di method test</span></span><br><span class="line"><span class="meta">@Test(dataProvider = &quot;loginData&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String phoneEmail, String pass, String expected)</span>&#123;</span><br><span class="line">    driver.findElement(By.id(<span class="string">&quot;email&quot;</span>)).sendKeys(phoneEmail);</span><br><span class="line">    driver.findElement(By.id(<span class="string">&quot;pass&quot;</span>)).sendKeys(pass);</span><br><span class="line">    driver.findElement(By.name(<span class="string">&quot;login&quot;</span>)).click();</span><br><span class="line"><span class="comment">//compare expected result dengan actual result dari website</span></span><br><span class="line">    <span class="keyword">if</span> (expected.equals(<span class="string">&quot;failed_login&quot;</span>))&#123;</span><br><span class="line">       <span class="type">WebElement</span> <span class="variable">errorBox</span> <span class="operator">=</span> driver.findElement(By.id(<span class="string">&quot;error_box&quot;</span>));                   </span><br><span class="line">       Assert.assertTrue(errorBox.isDisplayed());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expected.equals(<span class="string">&quot;success_login&quot;</span>))&#123;</span><br><span class="line">       <span class="type">WebElement</span> <span class="variable">searchBox</span> <span class="operator">=</span> driver.findElement(By.xpath(<span class="string">&quot;//input[@aria-label = &#x27;Cari di Facebook&#x27;]&quot;</span>));</span><br><span class="line">       Assert.assertTrue(searchBox.isDisplayed());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们可以将测试集变成一个外部文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;phoneEmail&quot;</span> : <span class="string">&quot;valid_email&quot;</span>, <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;valid_pass&quot;</span>, <span class="string">&quot;expected&quot;</span> : <span class="string">&quot;success_login&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;phoneEmail&quot;</span> : <span class="string">&quot;valid_phone&quot;</span>, <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;valid_pass&quot;</span>, <span class="string">&quot;expected&quot;</span> : <span class="string">&quot;success_login&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;phoneEmail&quot;</span> : <span class="string">&quot;invalid_email&quot;</span>, <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;valid_pass&quot;</span>, <span class="string">&quot;expected&quot;</span> : <span class="string">&quot;failed_login&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;phoneEmail&quot;</span> : <span class="string">&quot;invalid_phone&quot;</span>, <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;valid_pass&quot;</span>, <span class="string">&quot;expected&quot;</span> : <span class="string">&quot;failed_login&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;phoneEmail&quot;</span> : <span class="string">&quot;valid_email&quot;</span>, <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;invalid_pass&quot;</span>, <span class="string">&quot;expected&quot;</span> : <span class="string">&quot;failed_login&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;phoneEmail&quot;</span> : <span class="string">&quot;valid_phone&quot;</span>, <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;invalid_pass&quot;</span>, <span class="string">&quot;expected&quot;</span> : <span class="string">&quot;failed_login&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;phoneEmail&quot;</span> : <span class="string">&quot;null_email_phone&quot;</span>, <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;invalid_pass&quot;</span>, <span class="string">&quot;expected&quot;</span> : <span class="string">&quot;failed_login&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;phoneEmail&quot;</span> : <span class="string">&quot;valid_email&quot;</span>, <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;null_pass&quot;</span>, <span class="string">&quot;expected&quot;</span> : <span class="string">&quot;failed_login&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>将数据集从硬编码转化为读取文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataProvider</span></span><br><span class="line"><span class="keyword">public</span> Object[][] loginData()&#123;</span><br><span class="line">    <span class="keyword">return</span> File.ReadAll(<span class="string">&quot;/example.json&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//passing value dari DataProvider ke parameter di method test</span></span><br><span class="line"><span class="meta">@Test(dataProvider = &quot;loginData&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String phoneEmail, String pass, String expected)</span>&#123;</span><br><span class="line">    driver.findElement(By.id(<span class="string">&quot;email&quot;</span>)).sendKeys(phoneEmail);</span><br><span class="line">    driver.findElement(By.id(<span class="string">&quot;pass&quot;</span>)).sendKeys(pass);</span><br><span class="line">    driver.findElement(By.name(<span class="string">&quot;login&quot;</span>)).click();</span><br><span class="line"><span class="comment">//compare expected result dengan actual result dari website</span></span><br><span class="line">    <span class="keyword">if</span> (expected.equals(<span class="string">&quot;failed_login&quot;</span>))&#123;</span><br><span class="line">       <span class="type">WebElement</span> <span class="variable">errorBox</span> <span class="operator">=</span> driver.findElement(By.id(<span class="string">&quot;error_box&quot;</span>));                   </span><br><span class="line">       Assert.assertTrue(errorBox.isDisplayed());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expected.equals(<span class="string">&quot;success_login&quot;</span>))&#123;</span><br><span class="line">       <span class="type">WebElement</span> <span class="variable">searchBox</span> <span class="operator">=</span> driver.findElement(By.xpath(<span class="string">&quot;//input[@aria-label = &#x27;Cari di Facebook&#x27;]&quot;</span>));</span><br><span class="line">       Assert.assertTrue(searchBox.isDisplayed());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Behavior-Driven-Development"><a class="header-anchor" href="#Behavior-Driven-Development">¶</a>Behavior-Driven Development</h4>
<p>当我们尝试使用一些模拟用户行为的测试方式时，我们可以考虑采用 <a href="https://github.com/onsi/ginkgo">ginkgo</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    . <span class="string">&quot;github.com/onsi/ginkgo/v2&quot;</span></span><br><span class="line">    . <span class="string">&quot;github.com/onsi/gomega&quot;</span></span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Describe(<span class="string">&quot;Checking books out of the library&quot;</span>, Label(<span class="string">&quot;library&quot;</span>), <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> library *libraries.Library</span><br><span class="line">    <span class="keyword">var</span> book *books.Book</span><br><span class="line">    <span class="keyword">var</span> valjean *users.User</span><br><span class="line">    BeforeEach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        library = libraries.NewClient()</span><br><span class="line">        book = &amp;books.Book&#123;</span><br><span class="line">            Title: <span class="string">&quot;Les Miserables&quot;</span>,</span><br><span class="line">            Author: <span class="string">&quot;Victor Hugo&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        valjean = users.NewUser(<span class="string">&quot;Jean Valjean&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    When(<span class="string">&quot;the library has the book in question&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        BeforeEach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Expect(library.Store(book)).To(Succeed())</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        Context(<span class="string">&quot;and the book is available&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            It(<span class="string">&quot;lends it to the reader&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                Expect(valjean.Checkout(library, <span class="string">&quot;Les Miserables&quot;</span>)).To(Succeed())</span><br><span class="line">                Expect(valjean.Books()).To(ContainElement(book))</span><br><span class="line">                Expect(library.UserWithBook(book)).To(Equal(valjean))</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        Context(<span class="string">&quot;but the book has already been checked out&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">var</span> javert *users.User</span><br><span class="line">            BeforeEach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                javert = users.NewUser(<span class="string">&quot;Javert&quot;</span>)</span><br><span class="line">                Expect(javert.Checkout(library, <span class="string">&quot;Les Miserables&quot;</span>)).To(Succeed())</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            It(<span class="string">&quot;tells the user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                err := valjean.Checkout(library, <span class="string">&quot;Les Miserables&quot;</span>)</span><br><span class="line">                Expect(<span class="type">error</span>).To(MatchError(<span class="string">&quot;Les Miserables is currently checked out&quot;</span>))</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            It(<span class="string">&quot;lets the user place a hold and get notified later&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                Expect(valjean.Hold(library, <span class="string">&quot;Les Miserables&quot;</span>)).To(Succeed())</span><br><span class="line">                Expect(valjean.Holds()).To(ContainElement(book))</span><br><span class="line"></span><br><span class="line">                By(<span class="string">&quot;when Javert returns the book&quot;</span>)</span><br><span class="line">                Expect(javert.Return(library, book)).To(Succeed())</span><br><span class="line"></span><br><span class="line">                By(<span class="string">&quot;it eventually informs Valjean&quot;</span>)</span><br><span class="line">                notification := <span class="string">&quot;Les Miserables is ready for pick up&quot;</span></span><br><span class="line">                Eventually(valjean.Notifications).Should(ContainElement(notification))</span><br><span class="line"></span><br><span class="line">                Expect(valjean.Checkout(library, <span class="string">&quot;Les Miserables&quot;</span>)).To(Succeed())</span><br><span class="line">                Expect(valjean.Books()).To(ContainElement(book))</span><br><span class="line">                Expect(valjean.Holds()).To(BeEmpty())</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)  </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    When(<span class="string">&quot;the library does not have the book in question&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        It(<span class="string">&quot;tells the reader the book is unavailable&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            err := valjean.Checkout(library, <span class="string">&quot;Les Miserables&quot;</span>)</span><br><span class="line">            Expect(<span class="type">error</span>).To(MatchError(<span class="string">&quot;Les Miserables is not in the library catalog&quot;</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="Mock"><a class="header-anchor" href="#Mock">¶</a>Mock</h4>
<p>对于测试中我们需要依赖的第三方函数来说，如果需要在测试过程中初始化，可能到来的负担是极大的，因此我们可以考虑采用 <code>Mock</code> 的方式。<br>
比如我们有如下函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f<span class="comment">// RegisterUser if the user is not registered before</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterUser</span><span class="params">(user User)</span></span> <span class="type">error</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> userdb.UserExist(user.Email) &#123;  </span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;email &#x27;%s&#x27; already registered&quot;</span>, </span><br><span class="line">        user.Email)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...code for registering the user...</span></span><br><span class="line">    log.Println(user) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>Register</code> 来说，我们主要逻辑并不是 Db 相关，因此，我们如果要去测试这个需要跑一个数据库，然后初始化系统很烦，因此，我们会选择将 <code>userdb</code> mock 掉。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRegisterUser</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  ctrl := gomock.NewController(t)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assert that Bar() is invoked.</span></span><br><span class="line">  <span class="keyword">defer</span> ctrl.Finish()</span><br><span class="line"></span><br><span class="line">  db := NewMockUserDB(ctrl)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Asserts that the first and only call to Bar() is passed 99.</span></span><br><span class="line">  <span class="comment">// Anything else will fail.</span></span><br><span class="line">  db.</span><br><span class="line">    EXPECT().</span><br><span class="line">    UserExist(gomock.Any()).</span><br><span class="line">    Return(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里我们就可以测试我们的逻辑了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最佳实践"><a class="header-anchor" href="#最佳实践">¶</a>最佳实践</h2>
<h3 id="代码需要易于测试"><a class="header-anchor" href="#代码需要易于测试">¶</a>代码需要易于测试</h3>
<p>比如我们有如下代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将某个特定的错误转为通用错误 JSON，并且返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bindingErrToStandardError</span><span class="params">(ctx *gin.RequestContext, bindingErr *binding.Error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> bindingErr.ErrType == BindingErr &amp;&amp; isMissingParamErr(bindingErr.Msg) &#123;</span><br><span class="line">		standardError = errors.ToCommonError(errors.MissingParameter_parameter(bindingErr.FailField))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		standardError = errors.ToCommonError(errors.InvalidParameter_parameter(bindingErr.FailField))</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    ctx.AbortWithStatusJSON(<span class="type">int</span>(standardError.GetHTTPCode()), response)<span class="keyword">return</span> standardError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样的代码其实并不适合测试，因此我们的代码没有返回，我们测试的化，需要间接的依赖 gin.Context 这个对象。因此将代码重构为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bindingErrToStandardError</span><span class="params">(bindingErr *binding.Error)</span></span> (standardError *errors.Error) &#123;</span><br><span class="line">	<span class="comment">// binding err including missing param, parameter type err and so on</span></span><br><span class="line">	<span class="comment">// here we only handle missing param, other kind of err we all regard as</span></span><br><span class="line">	<span class="comment">// invalid param</span></span><br><span class="line">	<span class="keyword">if</span> bindingErr.ErrType == BindingErr &amp;&amp; isMissingParamErr(bindingErr.Msg) &#123;</span><br><span class="line">		standardError = errors.ToCommonError(errors.MissingParameter_parameter(bindingErr.FailField))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		standardError = errors.ToCommonError(errors.InvalidParameter_parameter(bindingErr.FailField))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> standardError</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更为方便我们进行测试，也是 <code>TDD</code> 的优点，当我们如果一开始在代码的适合，非常的习惯写出上面一种代码，而如果我们基于测试进行开发，我们就会很自然的写出下面一种代码。</p>
<h3 id="Table-Driven"><a class="header-anchor" href="#Table-Driven">¶</a>Table Driven</h3>
<p>对于如下最为简单的一个函数，我们进行测试。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckSucceed</span><span class="params">(rm *v1alpha1.RegistryManager, reason <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	meta.SetStatusCondition(&amp;rm.Status.Conditions,</span><br><span class="line">		v1.Condition&#123;</span><br><span class="line">			Type:    <span class="type">string</span>(v1alpha1.RegistryManagerChecking),</span><br><span class="line">			Status:  v1.ConditionFalse,</span><br><span class="line">			Message: <span class="string">&quot;Finished health check, waiting for next turn&quot;</span>,</span><br><span class="line">			Reason:  reason,</span><br><span class="line">		&#125;)</span><br><span class="line">	meta.SetStatusCondition(&amp;rm.Status.Conditions,</span><br><span class="line">		v1.Condition&#123;</span><br><span class="line">			Type:    <span class="type">string</span>(v1alpha1.RegistryManagerHealthy),</span><br><span class="line">			Status:  v1.ConditionTrue,</span><br><span class="line">			Message: <span class="string">&quot;Finished health check. CR is healthy&quot;</span>,</span><br><span class="line">			Reason:  reason,</span><br><span class="line">		&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们写成如下模式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCheckSucceed</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">		rm     *v1alpha1.RegistryManager</span><br><span class="line">		reason <span class="type">string</span></span><br><span class="line">	&#125;</span><br><span class="line">	tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="type">string</span></span><br><span class="line">		args args</span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			name: <span class="string">&quot;Checking-&gt; Waiting&quot;</span>,</span><br><span class="line">			args: args&#123;</span><br><span class="line">				rm: &amp;v1alpha1.RegistryManager&#123;</span><br><span class="line">					Status: v1alpha1.RegistryManagerStatus&#123;</span><br><span class="line">						Conditions: []v1.Condition&#123;</span><br><span class="line">							&#123;</span><br><span class="line">								Type:   <span class="type">string</span>(v1alpha1.RegistryManagerChecking),</span><br><span class="line">								Status: v1.ConditionTrue,</span><br><span class="line">							&#125;,</span><br><span class="line">						&#125;,</span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;,</span><br><span class="line">				reason: <span class="string">&quot;&quot;</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">			CheckSucceed(tt.args.rm, tt.args.reason)</span><br><span class="line">			healthy := meta.FindStatusCondition(tt.args.rm.Status.Conditions, <span class="type">string</span>(v1alpha1.RegistryManagerHealthy))</span><br><span class="line">			assert.Equal(t, v1.ConditionTrue, healthy.Status)</span><br><span class="line">			checking := meta.FindStatusCondition(tt.args.rm.Status.Conditions, <span class="type">string</span>(v1alpha1.RegistryManagerChecking))</span><br><span class="line">			assert.Equal(t, v1.ConditionFalse, checking.Status)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看上去使用了 Table Test Driven，但是实际上并没有，因为我们将主要的逻辑都扔到了 <code>Run</code> 之中，而更好的方式应该是如下方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">unc TestCheck(t *testing.T) &#123;</span><br><span class="line">	tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="type">string</span></span><br><span class="line">		args args</span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			name: <span class="string">&quot;Succeed&quot;</span>,</span><br><span class="line">			args: args&#123;</span><br><span class="line">				rm:     states[checking].DeepCopy(),</span><br><span class="line">				reason: <span class="string">&quot;&quot;</span>,</span><br><span class="line">				expect: &amp;v1alpha1.RegistryManager&#123;</span><br><span class="line">					Status: v1alpha1.RegistryManagerStatus&#123;</span><br><span class="line">						Conditions: []v1.Condition&#123;</span><br><span class="line">							&#123;</span><br><span class="line">								Type:    <span class="type">string</span>(v1alpha1.RegistryManagerChecking),</span><br><span class="line">								Status:  v1.ConditionFalse,</span><br><span class="line">								Message: <span class="string">&quot;Finished health check, waiting for next turn&quot;</span>,</span><br><span class="line">							&#125;,</span><br><span class="line">							&#123;</span><br><span class="line">								Type:    <span class="type">string</span>(v1alpha1.RegistryManagerHealthy),</span><br><span class="line">								Status:  v1.ConditionTrue,</span><br><span class="line">								Message: <span class="string">&quot;Finished health check. CR is healthy&quot;</span>,</span><br><span class="line">							&#125;,</span><br><span class="line">						&#125;,</span><br><span class="line">						Phase: v1alpha1.PhaseRunning,</span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">			CheckSucceed(tt.args.rm, tt.args.reason)</span><br><span class="line">			<span class="keyword">if</span> diff := cmp.Diff(tt.args.rm, tt.args.expect, cmputils.SkipTimeCompare); <span class="built_in">len</span>(diff) != <span class="number">0</span> &#123;</span><br><span class="line">				t.Fatalf(<span class="string">&quot;want diff is %s&quot;</span>, diff)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="推荐阅读"><a class="header-anchor" href="#推荐阅读">¶</a>推荐阅读</h2>
<ul>
<li><a href="https://dave.cheney.net/2019/05/07/prefer-table-driven-tests">Prefer table driven tests</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>unittest</category>
        <category>self-cultivation</category>
      </categories>
      <tags>
        <tag>unittest</tag>
        <tag>self-cultivation</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Rust 实现一个 CHIP-8 模拟器</title>
    <url>/2020/11/05/rust/impl-CHIP-8-emulator-in-rust/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/11/05/SUbRO.png" alt="SUbRO.png"></p>
<blockquote>
<p>CHIP-8是一个解释型语言，由Joseph Weisbecker开发。最初CHIP-8在上个世纪70年代被使用在COSMAC-VIP和Telmac 1800上。许多游戏如Pong，Space Invaders，Tetris都曾使用该语言编写。</p>
</blockquote>
<p>我们今天用 <code>Rust</code> 来模拟实现这个 <code>CHIP-8</code></p>
<span id="more"></span>
<h2 id="CHIP-8-虚拟机构成"><a class="header-anchor" href="#CHIP-8-虚拟机构成">¶</a>CHIP-8 虚拟机构成</h2>
<ul>
<li>
<p>内存 <code>Memory</code> : CHIP-8最常在4K系统上实现，如Cosmac VIP和Telmac 1800。这些机器有4096 (0x1000)内存位置，所有这些位置都是8位(字节)，这就是 <code>CHIP-8</code> 的起源。但是，<code>CHIP-8</code> 解释器本身占用这些机器上的前 <code>512</code> 字节内存空间。由于这个原因，为原始系统编写的大多数程序开始于位置 <code>512 (0x200)</code> 的内存，不访问位置 <code>512 (0x200)</code>以下的任何内存。最上面的 <code>256</code> 个字节( <code>0xF00</code>-<code>0xFFF</code>)被保留用于显示刷新，下面的96个字节(<code>0xEA0</code>-<code>0xEFF</code>)被保留用于调用堆栈、内部使用和其他变量。</p>
</li>
<li>
<p>寄存器 <code>Registers</code> : <code>16</code>个名为<code>V0</code>到 <code>VF</code> 的 <code>8</code> 位数据寄存器。<code>VF</code> 寄存器可以作为一些指令的标志，在加法操作中，<code>VF</code>是进位标志，而在减法操作中，它是“no borrow”标志。在绘制指令中，<code>VF</code>设置为像素冲突。<br>
地址寄存器，它被命名为<code>I</code>，是<code>16</code>位宽的，并且与几个涉及内存操作的操作码一起使用。</p>
</li>
<li>
<p>栈 <code>Stack</code> : 堆栈仅用于在调用子例程时存储返回地址。</p>
</li>
<li>
<p>计时器 <code>Timers</code>:</p>
<ul>
<li>延迟计时器: 这个计时器是用来计时的比赛事件。可以设置和读取它的值。</li>
<li>声音定时器: 这个定时器用于声音效果。当它的值非零时，会发出哔哔声。</li>
</ul>
</li>
<li>
<p>输入 <code>Input</code>: 输入使用<code>十六进制</code>键盘，有16个从0到f的键。“8”、“4”、“6”和“2”键通常用于定向输入。三个操作码用于检测输入。如果按了特定的键，一个跳过指令，而如果没有按特定的键，另一个也会这样做。第三个等待按键，然后将其存储在一个数据寄存器中。</p>
</li>
<li>
<p>图像 <code>Graphics and sound</code> : 分辨率为 <code>64×32</code> 像素，单色。图形被绘制到屏幕单独的 <code>sprites</code>。</p>
</li>
<li>
<p>操作符: <code>CHIP-8</code> 有 <code>35</code> 个操作符，详细的见 <a href="https://en.wikipedia.org/wiki/CHIP-8"><code>Opcode table</code></a></p>
</li>
</ul>
<h2 id="初始化结构"><a class="header-anchor" href="#初始化结构">¶</a>初始化结构</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Cpu</span> &#123;</span><br><span class="line">    <span class="comment">// register index</span></span><br><span class="line">    <span class="keyword">pub</span> i: <span class="type">u16</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// program counter</span></span><br><span class="line">    <span class="keyword">pub</span> pc: <span class="type">u16</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory</span></span><br><span class="line">    <span class="keyword">pub</span> memory: [<span class="type">u8</span>; <span class="number">4096</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">//registers, v0 - vf</span></span><br><span class="line">    <span class="keyword">pub</span> v: [<span class="type">u8</span>; <span class="number">16</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">//display</span></span><br><span class="line">    <span class="keyword">pub</span> display: Display,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//stack</span></span><br><span class="line">    <span class="keyword">pub</span> stack: [<span class="type">u16</span>; <span class="number">16</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">//stack point</span></span><br><span class="line">    <span class="keyword">pub</span> sp: <span class="type">u8</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delay timer</span></span><br><span class="line">    <span class="keyword">pub</span> delay_timer: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的硬件设备我们都用软件来模拟，因为 <code>Display</code> 相对独立，因此我们将这部分抽象出来。</p>
<p><code>CPU</code> 的执行就是一个大循环，不断的读取指令再运行。因为 <code>CHIP-8</code> 的操作码均是 <code>u16</code> 的，所以我们直接读取操作码，因此增加一个辅助函数来获得一个字节的数据。</p>
<p><img src="https://s3.jpg.cm/2020/11/08/Sog4S.png" alt="Sog4S.png"></p>
<p>整个处理过程是非常的清楚易懂的。</p>
<figure class="highlight rust"><figcaption><span>读取一个字节</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">read_word</span>(memory: [<span class="type">u8</span>; <span class="number">4096</span>], index: <span class="type">u16</span>) <span class="punctuation">-&gt;</span> <span class="type">u16</span> &#123;</span><br><span class="line">    (memory[index <span class="keyword">as</span> <span class="type">usize</span>] <span class="keyword">as</span> <span class="type">u16</span>) &lt;&lt; <span class="number">8</span></span><br><span class="line">        | (memory[(index + <span class="number">1</span>) <span class="keyword">as</span> <span class="type">usize</span>] <span class="keyword">as</span> <span class="type">u16</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行循环就很容易写出来了</p>
<figure class="highlight rust"><figcaption><span>执行循环</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Cpu</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">opcode</span> = <span class="title function_ invoke__">read_word</span>(<span class="keyword">self</span>.memory, <span class="keyword">self</span>.pc);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">process_opcode</span>(opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">process_opcode</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, opcode: <span class="type">u16</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>CPU</code> 是常驻对象，将其静态化起来非常的合理，这里用了 <code>lazy_static</code> 非常方便的一个 <code>lib</code></p>
<figure class="highlight rust"><figcaption><span>初始化</span></figcaption><table><tr><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> CPU: Mutex&lt;Cpu&gt; = Mutex::<span class="title function_ invoke__">new</span>(Cpu &#123;</span><br><span class="line">        i: <span class="number">0</span>,</span><br><span class="line">        pc: <span class="number">0</span>,</span><br><span class="line">        memory: [<span class="number">0</span>; <span class="number">4096</span>],</span><br><span class="line">        v: [<span class="number">0</span>; <span class="number">16</span>],</span><br><span class="line">        display: Display &#123;&#125;,</span><br><span class="line">        stack: [<span class="number">0</span>; <span class="number">16</span>],</span><br><span class="line">        sp: <span class="number">0</span>,</span><br><span class="line">        delay_timer: <span class="number">0</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于所有的硬件系统我们都有时钟周期，也就是多久运行一次操作，我么也将这部分抽象出来。</p>
<figure class="highlight rust"><figcaption><span>执行循环</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">emulate_cycle</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.pc &gt;= <span class="number">4094</span> &#123; <span class="comment">// 内存最大值，保护性代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">op</span> = <span class="title function_ invoke__">read_word</span>(<span class="keyword">self</span>.memory, <span class="keyword">self</span>.pc);</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">process_opcode</span>(op);</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的话我们等待每一次的时钟周期触发，会触发这个回调，那我们的主循环就很好写了。</p>
<blockquote>
<p>过下文我们会把自己嵌入别人的系统中。</p>
</blockquote>
<figure class="highlight rust"><figcaption><span>main loop</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        cpu::<span class="title function_ invoke__">execute_cycle</span>();</span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们用一个 <code>sleep</code> 来假装我们的时钟周期，我们还是尽快进入我们的核心的模拟器的部分，这部分内容我们在后续再进行优化。</p>
<h2 id="模拟器"><a class="header-anchor" href="#模拟器">¶</a>模拟器</h2>
<p>模拟器的核心就是来实现我们的 <a href="https://en.wikipedia.org/wiki/CHIP-8">Opcode table</a>，我们先来一个简单的试试水</p>
<blockquote>
<p>0NNN 操作符不怎么使用，这里就不实现了</p>
</blockquote>
<h3 id="00E0-disp-clear"><a class="header-anchor" href="#00E0-disp-clear">¶</a>00E0 disp_clear</h3>
<p>对于这种常量的处理，我们直接进行操作即可</p>
<figure class="highlight rust"><figcaption><span>disp_clear</span></figcaption><table><tr><td class="code"><pre><span class="line"> <span class="keyword">match</span> opcode &#123;</span><br><span class="line">    <span class="number">0x00E0</span> =&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.display.<span class="title function_ invoke__">clear</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    _ =&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1NNN-goto-NNN"><a class="header-anchor" href="#1NNN-goto-NNN">¶</a>1NNN goto NNN</h3>
<p>这种直接跳转的处理逻辑也非常的轻松</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> opcode &#123;</span><br><span class="line">    <span class="number">0x1000</span>...<span class="number">0x1FFF</span> =&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.pc = opcode &amp; <span class="number">0x0FFF</span></span><br><span class="line">    &#125;</span><br><span class="line">    _ =&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>&amp;</code> 将最高位的操作符 <code>1</code> 掩盖，然后将后 <code>3</code> 位赋值给 <code>PC</code> 即可。下面我们搞点难的</p>
<h3 id="函数调用"><a class="header-anchor" href="#函数调用">¶</a>函数调用</h3>
<h4 id="2NNN-Calls-subroutine-at-NNN"><a class="header-anchor" href="#2NNN-Calls-subroutine-at-NNN">¶</a>2NNN Calls subroutine at NNN.</h4>
<p>函数调用，显然需要压栈，call <code>nnn</code> 也就是移动到 <code>nnn</code>，但是在此之前记得保留上一次的 <code>pc</code> 计数器，对于 <code>CHIP8</code> 仅仅存存 <code>Ret</code> 地址，不会保留其他的寄存信息。</p>
<figure class="highlight rust"><figcaption><span>call</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="number">0x2000</span>..<span class="number">0x2FFF</span> =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nnn</span> = opcode &amp; <span class="number">0x0FFF</span>;</span><br><span class="line">    <span class="keyword">self</span>.stack[<span class="keyword">self</span>.sp <span class="keyword">as</span> <span class="type">usize</span>] = <span class="keyword">self</span>.pc;</span><br><span class="line">    <span class="keyword">self</span>.sp = <span class="keyword">self</span>.sp + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">self</span>.pc = nnn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="00EE-return"><a class="header-anchor" href="#00EE-return">¶</a>00EE return</h4>
<p>那么 <code>ret</code> 函数就更简单了，还原下 <code>SP</code> 即可</p>
<figure class="highlight rust"><figcaption><span>ret</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="number">0x00EE</span> =&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.sp = <span class="keyword">self</span>.sp - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">self</span>.pc = <span class="keyword">self</span>.stack[<span class="keyword">self</span>.sp <span class="keyword">as</span> <span class="type">usize</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件语句"><a class="header-anchor" href="#条件语句">¶</a>条件语句</h3>
<p>这里就不多写了，直接就写一个示例 <code>3XNN if(Vx==NN)</code></p>
<figure class="highlight rust"><figcaption><span>if eq than jump</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="number">0x3000</span>..<span class="number">0x3FFF</span> =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">register_index</span> = (opcode &amp; <span class="number">0x0F00</span>) &gt;&gt; <span class="number">8</span>; <span class="comment">// 拿到寄存器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nn</span> = (opcode &amp; <span class="number">0x00FF</span>); <span class="comment">// 拿到立即数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.v[register_index] == nn &#123; </span><br><span class="line">        <span class="keyword">self</span>.sp += <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="宏"><a class="header-anchor" href="#宏">¶</a>宏</h3>
<p>到这里我们发现很多操作是可以重复的，在 <code>Java</code> 里面我们就会抽一个函数出来，在 <code>Rust</code> 中，我们有强大的 <code>宏</code>，我们直接使用 <code>宏</code> 来构建这些通用的函数。</p>
<p>比如我们经常要取 <code>X</code> 作为寄存器的下标</p>
<figure class="highlight rust"><figcaption><span>arg_x</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> arg_x &#123;</span><br><span class="line">    ($opcode:expr) =&gt; &#123;</span><br><span class="line">        (($opcode &amp; <span class="number">0x0F00</span>) &gt;&gt; <span class="number">8</span>) <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他可以依次类推，因此上文获得寄存器的代码可以改为</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="number">0x3000</span>..<span class="number">0x3FFF</span> =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">register_index</span> = arg_x!(optcode); <span class="comment">// 拿到寄存器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nn</span> = (opcode &amp; <span class="number">0x00FF</span>); <span class="comment">// 拿到立即数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.v[register_index] == nn &#123; </span><br><span class="line">        <span class="keyword">self</span>.sp += <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终效果</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        process_opcode函数
    </div>
    <div class='spoiler-content'>
        <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">process_opcode</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, opcode: <span class="type">u16</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.pc += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> opcode &#123;</span><br><span class="line">        <span class="number">0x00E0</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.display.<span class="title function_ invoke__">clear</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0x00EE</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.sp = <span class="keyword">self</span>.sp - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">self</span>.pc = <span class="keyword">self</span>.stack[(<span class="keyword">self</span>.sp) <span class="keyword">as</span> <span class="type">usize</span>] + <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0x1000</span>..=<span class="number">0x1FFF</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.pc = arg_nnn!(opcode)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0x2000</span>..=<span class="number">0x2FFF</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.stack[<span class="keyword">self</span>.sp <span class="keyword">as</span> <span class="type">usize</span>] = <span class="keyword">self</span>.pc - <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">self</span>.sp = <span class="keyword">self</span>.sp + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">self</span>.pc = arg_nnn!(opcode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0x3000</span>..=<span class="number">0x3FFF</span> =&gt; &#123;</span><br><span class="line">            <span class="comment">// let nn = arg_nn!(opcode);</span></span><br><span class="line">            <span class="comment">// let vx = self.v[arg_x!(opcode)];</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.v[arg_x!(opcode)] == arg_nn!(opcode) &#123;</span><br><span class="line">                <span class="keyword">self</span>.pc += <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0x4000</span>..=<span class="number">0x4FFF</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.v[arg_x!(opcode)] != arg_nn!(opcode) &#123;</span><br><span class="line">                <span class="keyword">self</span>.pc += <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0x5000</span>..=<span class="number">0x5FFF</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.v[arg_x!(opcode)] == <span class="keyword">self</span>.v[arg_y!(opcode)] &#123;</span><br><span class="line">                <span class="keyword">self</span>.pc += <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0x6000</span>..=<span class="number">0x6FFF</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.v[arg_x!(opcode)] = arg_nn!(opcode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0x7000</span>..=<span class="number">0x7FFF</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.v[arg_x!(opcode)] += arg_nn!(opcode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="number">0x8000</span>..=<span class="number">0x8FFF</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">match</span> opcode &amp; <span class="number">0x000F</span> &#123;</span><br><span class="line">                <span class="number">0</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.v[arg_x!(opcode)] = <span class="keyword">self</span>.v[arg_y!(opcode)]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">1</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.v[arg_x!(opcode)] |= <span class="keyword">self</span>.v[arg_y!(opcode)]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">2</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.v[arg_x!(opcode)] &amp;= <span class="keyword">self</span>.v[arg_y!(opcode)]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">3</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.v[arg_x!(opcode)] ^= <span class="keyword">self</span>.v[arg_y!(opcode)]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">4</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> (res, overflow) = <span class="keyword">self</span>.v[arg_x!(opcode)].<span class="title function_ invoke__">overflowing_add</span>(<span class="keyword">self</span>.v[arg_y!(opcode)]);</span><br><span class="line">                    <span class="keyword">match</span> overflow &#123;</span><br><span class="line">                        <span class="literal">true</span> =&gt; <span class="keyword">self</span>.v[<span class="number">0xF</span>] = <span class="number">1</span>,</span><br><span class="line">                        <span class="literal">false</span> =&gt; <span class="keyword">self</span>.v[<span class="number">0xF</span>] = <span class="number">0</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">self</span>.v[arg_x!(opcode)] = res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">5</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> (res, overflow) = <span class="keyword">self</span>.v[arg_x!(opcode)].<span class="title function_ invoke__">overflowing_sub</span>(<span class="keyword">self</span>.v[arg_y!(opcode)]);</span><br><span class="line">                    <span class="keyword">match</span> overflow &#123;</span><br><span class="line">                        <span class="literal">true</span> =&gt; <span class="keyword">self</span>.v[<span class="number">0xF</span>] = <span class="number">0</span>,</span><br><span class="line">                        <span class="literal">false</span> =&gt; <span class="keyword">self</span>.v[<span class="number">0xF</span>] = <span class="number">1</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">self</span>.v[arg_x!(opcode)] = res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">6</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.v[<span class="number">0xF</span>] = <span class="keyword">self</span>.v[arg_x!(opcode)] &amp; <span class="number">0x1</span>;</span><br><span class="line">                    <span class="keyword">self</span>.v[arg_x!(opcode)] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">7</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> (res, overflow) = <span class="keyword">self</span>.v[arg_y!(opcode)].<span class="title function_ invoke__">overflowing_sub</span>(<span class="keyword">self</span>.v[arg_x!(opcode)]);</span><br><span class="line">                    <span class="keyword">match</span> overflow &#123;</span><br><span class="line">                        <span class="literal">true</span> =&gt; <span class="keyword">self</span>.v[<span class="number">0xF</span>] = <span class="number">0</span>,</span><br><span class="line">                        <span class="literal">false</span> =&gt; <span class="keyword">self</span>.v[<span class="number">0xF</span>] = <span class="number">1</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">self</span>.v[arg_x!(opcode)] = res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">0xE</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.v[<span class="number">0xF</span>] = <span class="keyword">self</span>.v[arg_x!(opcode)] &amp; <span class="number">0x80</span>;</span><br><span class="line">                    <span class="keyword">self</span>.v[arg_x!(opcode)] &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                _ =&gt; &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0x9000</span>..=<span class="number">0x9FF0</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.v[arg_x!(opcode)] != <span class="keyword">self</span>.v[arg_y!(opcode)] &#123;</span><br><span class="line">                <span class="keyword">self</span>.sp += <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0xA000</span>..=<span class="number">0xAFFF</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.i = arg_nnn!(opcode)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0xB000</span>..=<span class="number">0xBFFF</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.pc = <span class="keyword">self</span>.v[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">u16</span> + arg_nnn!(opcode)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0xC000</span>..=<span class="number">0xCFFF</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rand</span>: <span class="type">u8</span> = rand::random::&lt;<span class="type">u8</span>&gt;();</span><br><span class="line">            <span class="keyword">self</span>.v[arg_x!(opcode)] = rand &amp; arg_nn!(opcode)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0xD000</span>..=<span class="number">0xDFFF</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">collision</span> = <span class="keyword">self</span>.display.<span class="title function_ invoke__">draw</span>(<span class="keyword">self</span>.v[arg_x!(opcode)] <span class="keyword">as</span> <span class="type">usize</span>, <span class="keyword">self</span>.v[arg_y!(opcode)] <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">                                                &amp;<span class="keyword">self</span>.memory[<span class="keyword">self</span>.i <span class="keyword">as</span> <span class="type">usize</span>..(<span class="keyword">self</span>.i + arg_n!(opcode) <span class="keyword">as</span> <span class="type">u16</span>) <span class="keyword">as</span> <span class="type">usize</span>]);</span><br><span class="line">            <span class="keyword">self</span>.v[<span class="number">0xF</span>] = <span class="keyword">if</span> collision &#123; <span class="number">1</span> &#125; <span class="keyword">else</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0xE000</span>..=<span class="number">0xEFFF</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> arg_nn!(opcode) == <span class="number">0x9E</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.pc += <span class="keyword">match</span> <span class="keyword">self</span>.keypad.<span class="title function_ invoke__">get_key_state</span>(<span class="keyword">self</span>.v[arg_x!(opcode)] <span class="keyword">as</span> <span class="type">usize</span>) &#123;</span><br><span class="line">                    Keystate::Pressed =&gt; <span class="number">2</span>,</span><br><span class="line">                    Keystate::Released =&gt; <span class="number">0</span>,</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> arg_nn!(opcode) == <span class="number">0xA1</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.pc += <span class="keyword">match</span> <span class="keyword">self</span>.keypad.<span class="title function_ invoke__">get_key_state</span>(<span class="keyword">self</span>.v[arg_x!(opcode)] <span class="keyword">as</span> <span class="type">usize</span>) &#123;</span><br><span class="line">                    Keystate::Pressed =&gt; <span class="number">0</span>,</span><br><span class="line">                    Keystate::Released =&gt; <span class="number">2</span>,</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="number">0xF000</span>..=<span class="number">0xFFFF</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">match</span> opcode &amp; <span class="number">0x00FF</span> &#123;</span><br><span class="line">                <span class="number">0x07</span>..=<span class="number">0x07</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.v[arg_x!(opcode)] = <span class="keyword">self</span>.delay_timer</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">0x0A</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.wait_for_key = (<span class="literal">true</span>, arg_x!(opcode) <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line">                    <span class="keyword">self</span>.pc -= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">0x15</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.delay_timer = <span class="keyword">self</span>.v[arg_x!(opcode)]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">0x18</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.sound_timer = <span class="keyword">self</span>.v[arg_x!(opcode)]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">0x1E</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.i += <span class="keyword">self</span>.v[arg_x!(opcode)] <span class="keyword">as</span> <span class="type">u16</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">0x29</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.i = <span class="keyword">self</span>.v[arg_x!(opcode)] <span class="keyword">as</span> <span class="type">u16</span> * <span class="number">5</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">0x33</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.memory[<span class="keyword">self</span>.i <span class="keyword">as</span> <span class="type">usize</span>] = <span class="keyword">self</span>.v[arg_x!(opcode)] / <span class="number">100</span>;</span><br><span class="line">                    <span class="keyword">self</span>.memory[<span class="keyword">self</span>.i <span class="keyword">as</span> <span class="type">usize</span> + <span class="number">1</span>] = (<span class="keyword">self</span>.v[arg_x!(opcode)] / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">                    <span class="keyword">self</span>.memory[<span class="keyword">self</span>.i <span class="keyword">as</span> <span class="type">usize</span> + <span class="number">2</span>] = (<span class="keyword">self</span>.v[arg_x!(opcode)] % <span class="number">100</span>) % <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">0x55</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.memory[(<span class="keyword">self</span>.i <span class="keyword">as</span> <span class="type">usize</span>)..(<span class="keyword">self</span>.i + arg_x!(opcode) <span class="keyword">as</span> <span class="type">u16</span> + <span class="number">1</span>) <span class="keyword">as</span> <span class="type">usize</span>]</span><br><span class="line">                        .<span class="title function_ invoke__">copy_from_slice</span>(&amp;<span class="keyword">self</span>.v[<span class="number">0</span>..(arg_x!(opcode) <span class="keyword">as</span> <span class="type">usize</span> + <span class="number">1</span>)])</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="number">0x65</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.v[<span class="number">0</span>..(arg_x!(opcode) <span class="keyword">as</span> <span class="type">usize</span> + <span class="number">1</span>)]</span><br><span class="line">                        .<span class="title function_ invoke__">copy_from_slice</span>(&amp;<span class="keyword">self</span>.memory[(<span class="keyword">self</span>.i <span class="keyword">as</span> <span class="type">usize</span>)..(<span class="keyword">self</span>.i + arg_x!(opcode) <span class="keyword">as</span> <span class="type">u16</span> + <span class="number">1</span>) <span class="keyword">as</span> <span class="type">usize</span>])</span><br><span class="line">                &#125;</span><br><span class="line">                _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;got unknown opcode: &#123;&#125;&quot;</span>, opcode)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;got unknown opcode: &#123;&#125;&quot;</span>, opcode)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<p>下面我们进入我们的绘图系统</p>
<h2 id="绘图"><a class="header-anchor" href="#绘图">¶</a>绘图</h2>
<p>因为要对接 <code>GUI</code> 觉得有点烦，所以我就索性将 <a href="https://github.com/pierreyoda/rust-chip8"><code>rust-chip8</code></a> 将作为我们系统的模板，此项目已经帮我们完善了绝大多数的部分，并且使用的 <code>SDL2</code> 作为我们底层的依赖，因此我们把作文题变成填空题了。</p>
<figure class="highlight bash"><figcaption><span>rust-chip8 目录结构</span></figcaption><table><tr><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   ├── bin</span><br><span class="line">│   │   ├── chip8app.rs</span><br><span class="line">│   │   ├── chip8app_sdl2.rs</span><br><span class="line">│   │   ├── input.rs</span><br><span class="line">│   │   └── main.rs</span><br><span class="line">│   ├── display.rs</span><br><span class="line">│   ├── keypad.rs</span><br><span class="line">│   ├── lib.rs</span><br><span class="line">│   ├── vm.rs</span><br><span class="line">│   └── vm_test.rs</span><br></pre></td></tr></table></figure>
<p>我们要替换掉 <code>display | keypad | vm</code> 这三个部分</p>
<p>对于 <code>Display</code> 的定义很简单</p>
<figure class="highlight rust"><figcaption><span>display</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> gfx: [[<span class="type">u8</span>; DISPLAY_WIDTH]; DISPLAY_HEIGHT], <span class="comment">// 用 gfx 来映射 SDL2 的显存</span></span><br><span class="line">    <span class="keyword">pub</span> dirty: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心的绘图其实只有一个函数</p>
<figure class="highlight rust"><figcaption><span>Draw</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, xpos: <span class="type">usize</span>, ypos: <span class="type">usize</span>, sprite: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">collision</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">h</span> = sprite.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">0</span>..h &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">8</span> &#123;</span><br><span class="line">                <span class="comment">// 确定 X Y 位置</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">y</span> = (ypos + j) % DISPLAY_HEIGHT;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">x</span> = (xpos + i) % DISPLAY_WIDTH;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// sprite 是显存对象，当对象存在的时候 (!=0x00) 进行点绘图</span></span><br><span class="line">                <span class="title function_ invoke__">if</span> (sprite[j] &amp; (<span class="number">0x80</span> &gt;&gt; i)) != <span class="number">0x00</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">self</span>.gfx[y][x] == <span class="number">0x01</span> &#123;</span><br><span class="line">                        collision = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">self</span>.gfx[y][x] ^= <span class="number">0x01</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.dirty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        collision</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2>
<p>对于键盘的输入输出，在我们的执行 <code>VM</code> 的 <code>Loop</code> 循环中</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exec_vm</span>(</span><br><span class="line">    vm: &amp;<span class="keyword">mut</span> Vm,</span><br><span class="line">    cpu_clock: <span class="type">u32</span>,</span><br><span class="line">    tx: Sender&lt;Chip8UICommand&gt;,</span><br><span class="line">    rx: Receiver&lt;Chip8VMCommand&gt;,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="symbol">&#x27;vm</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> rx.<span class="title function_ invoke__">try_recv</span>() &#123;</span><br><span class="line">            <span class="comment">// non-blocking receiving function</span></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(vm_command) =&gt; <span class="keyword">match</span> vm_command &#123;</span><br><span class="line">                <span class="title function_ invoke__">UpdateRunStatus</span>(run) =&gt; running = run,</span><br><span class="line">                <span class="title function_ invoke__">UpdateKeyStatus</span>(index, state) =&gt; <span class="keyword">match</span> state &#123;</span><br><span class="line">                    Keystate::Pressed =&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> waiting_for_key &amp;&amp; (index != wait_for_key_last_pressed) &#123;</span><br><span class="line">                            vm.<span class="title function_ invoke__">end_wait_for_key</span>(index);</span><br><span class="line">                            wait_for_key_last_pressed = index;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            vm.keypad.<span class="title function_ invoke__">set_key_state</span>(index, state);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Keystate::Released =&gt; &#123;</span><br><span class="line">                        wait_for_key_last_pressed = <span class="number">0xFF</span>;</span><br><span class="line">                        <span class="keyword">if</span> !waiting_for_key &#123;</span><br><span class="line">                            vm.keypad.<span class="title function_ invoke__">set_key_state</span>(index, state);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            _ =&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过 <code>Channel</code> 来消费我们的键盘键入和键出。而这个 <code>Channel</code> 的入口是在</p>
<figure class="highlight rust"><figcaption><span>Chip8EmulatorBackend exec</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">exec</span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        config: &amp;Chip8Config,</span><br><span class="line">        tx: Sender&lt;Chip8VMCommand&gt;,</span><br><span class="line">        rx: Receiver&lt;Chip8UICommand&gt;,</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line"><span class="symbol">&#x27;main</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">event</span> <span class="keyword">in</span> event_pump.<span class="title function_ invoke__">poll_iter</span>() &#123;</span><br><span class="line">        <span class="keyword">match</span> event &#123;</span><br><span class="line">            Event::Quit &#123; .. &#125; =&gt; &#123;</span><br><span class="line">                paused = <span class="literal">true</span>;</span><br><span class="line">                tx.<span class="title function_ invoke__">send</span>(Quit).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            Event::KeyDown &#123; keycode, .. &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> keys_pressed.<span class="title function_ invoke__">contains</span>(&amp;keycode) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">match</span> keycode.<span class="title function_ invoke__">unwrap</span>() &#123;</span><br><span class="line">                    <span class="comment">// quit on Escape</span></span><br><span class="line">                    Keycode::Escape =&gt; &#123;</span><br><span class="line">                        paused = <span class="literal">true</span>;</span><br><span class="line">                        tx.<span class="title function_ invoke__">send</span>(Quit).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// toggle pause on Return</span></span><br><span class="line">                    Keycode::Return =&gt; &#123;</span><br><span class="line">                        tx.<span class="title function_ invoke__">send</span>(<span class="title function_ invoke__">UpdateRunStatus</span>(paused)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                        paused = !paused;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// reset on backspace</span></span><br><span class="line">                    Keycode::Backspace =&gt; &#123;</span><br><span class="line">                        info!(<span class="string">&quot;Reinitializing the virtual machine.&quot;</span>);</span><br><span class="line">                        tx.<span class="title function_ invoke__">send</span>(Reset).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    _ =&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> !paused &#123;</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(index) = key_binds.<span class="title function_ invoke__">get</span>(&amp;keycode.<span class="title function_ invoke__">unwrap</span>()) &#123;</span><br><span class="line">                                tx.<span class="title function_ invoke__">send</span>(<span class="title function_ invoke__">UpdateKeyStatus</span>(*index, Pressed)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                keys_pressed.<span class="title function_ invoke__">push</span>(keycode);</span><br><span class="line">            &#125;</span><br><span class="line">            Event::KeyUp &#123; keycode, .. &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..keys_pressed.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">                    <span class="keyword">if</span> keys_pressed[i] == keycode &#123;</span><br><span class="line">                        keys_pressed.<span class="title function_ invoke__">remove</span>(i);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(index) = key_binds.<span class="title function_ invoke__">get</span>(&amp;keycode.<span class="title function_ invoke__">unwrap</span>()) &#123;</span><br><span class="line">                    tx.<span class="title function_ invoke__">send</span>(<span class="title function_ invoke__">UpdateKeyStatus</span>(*index, Released)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="让我们看看最终效果吧"><a class="header-anchor" href="#让我们看看最终效果吧">¶</a>让我们看看最终效果吧</h2>
<p>最终源码: <a href="https://github.com/yanickxia/impl-chip8">https://github.com/yanickxia/impl-chip8</a></p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201108151702.gif" alt="Kapture 2020-11-08 at 13.41.06.gif"></p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="http://mattmik.com/files/chip8/mastering/chip8.html">mastering chip8</a></li>
<li><a href="https://blog.scottlogic.com/2017/12/13/chip8-emulator-webassembly-rust.html">Writing a CHIP-8 emulator with Rust and WebAssembly</a></li>
<li><a href="https://en.wikipedia.org/wiki/CHIP-8">wikipedia</a></li>
<li><a href="http://devernay.free.fr/hacks/chip8/C8TECH10.HTM">Chip-8 Technical Reference</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rust</category>
        <category>CHIP-8</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>CHIP-8</tag>
      </tags>
  </entry>
  <entry>
    <title>真实世界中的 Rust 异步编程</title>
    <url>/2020/09/08/rust/poller-in-tokio/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/09/08/1zH7t.png" alt="1zH7t.png"></p>
<p>在上一篇 <a href="/2020/09/04/rust/understanding-rust-async/">解密 Rust 异步编程</a> 中我们已经知道了 <code>Funture</code> 工作的原理，让我们看看真实世界里面是如何工作的。</p>
<span id="more"></span>


<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>



<blockquote>
<p>本文基于 <code>Tokio 0.3.0</code> 版本</p>
</blockquote>
<h2 id="Example"><a class="header-anchor" href="#Example">¶</a>Example</h2>
<p><code>Tokio</code> 启动一个最基础的 <code>TCP Echo</code> 服务如下代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">addr</span> = env::<span class="title function_ invoke__">args</span>()</span><br><span class="line">        .<span class="title function_ invoke__">nth</span>(<span class="number">1</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap_or_else</span>(|| <span class="string">&quot;127.0.0.1:8080&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(&amp;addr).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Listening on: &#123;&#125;&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> socket, _) = listener.<span class="title function_ invoke__">accept</span>().<span class="keyword">await</span>?;</span><br><span class="line">        tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0</span>; <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// In a loop, read data from the socket and write the data back.</span></span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">n</span> = socket</span><br><span class="line">                    .<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf)</span><br><span class="line">                    .<span class="keyword">await</span></span><br><span class="line">                    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to read data from socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                socket</span><br><span class="line">                    .<span class="title function_ invoke__">write_all</span>(&amp;buf[<span class="number">0</span>..n])</span><br><span class="line">                    .<span class="keyword">await</span></span><br><span class="line">                    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to write data to socket&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Read-Funture"><a class="header-anchor" href="#Read-Funture">¶</a>Read Funture</h2>
<p>我们很容易定位到，我们在处理这个可停止的系统要处理的就是 <code>read</code> 和 <code>write</code> 这两个操作，因此这2个操作都是使用 <code>.await</code> 返回了一个 <code>Future</code> 对象，我们看看 <code>read</code> 部分返回的。</p>
<figure class="highlight rust"><figcaption><span>Read</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;R&gt; Future <span class="keyword">for</span> <span class="title class_">Read</span>&lt;<span class="symbol">&#x27;_</span>, R&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    R: AsyncRead + Unpin + ?<span class="built_in">Sized</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = io::<span class="type">Result</span>&lt;<span class="type">usize</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">mut</span> <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;io::<span class="type">Result</span>&lt;<span class="type">usize</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">me</span> = &amp;<span class="keyword">mut</span> *<span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = ReadBuf::<span class="title function_ invoke__">new</span>(me.buf);</span><br><span class="line">        <span class="comment">// ready!(Pin::new(&amp;mut *me.reader).poll_read(cx, &amp;mut buf))?; 方便理解我把宏展开了</span></span><br><span class="line">        <span class="keyword">match</span> Pin::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">mut</span> *me.reader).<span class="title function_ invoke__">poll_read</span>(cx, &amp;<span class="keyword">mut</span> buf) &#123;</span><br><span class="line">            std::task::Poll::<span class="title function_ invoke__">Ready</span>(t) =&gt; t,</span><br><span class="line">            std::task::Poll::Pending =&gt; <span class="keyword">return</span> std::task::Poll::Pending,</span><br><span class="line">        &#125;</span><br><span class="line">        Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Ok</span>(buf.<span class="title function_ invoke__">filled</span>().<span class="title function_ invoke__">len</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>Read</code> 的逻辑也很简单，我们尝试用 <code>self.reader</code> 中获得数据，如果就绪就返回 <code>Ready</code> 不然就是 <code>Pending</code>。而逻辑主要是在 <code>reader</code>中，我们定位进去。</p>
<figure class="highlight rust"><figcaption><span>TcpStream</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">poll_read_priv</span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;,</span><br><span class="line">        buf: &amp;<span class="keyword">mut</span> ReadBuf&lt;<span class="symbol">&#x27;_</span>&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> Poll&lt;io::<span class="type">Result</span>&lt;()&gt;&gt; &#123;</span><br><span class="line">    ready!(<span class="keyword">self</span>.io.<span class="title function_ invoke__">poll_read_ready</span>(cx, mio::Ready::<span class="title function_ invoke__">readable</span>()))?; <span class="comment">// ➊ 如果不可读直接返回 Pending，同上</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> *(buf.<span class="title function_ invoke__">unfilled_mut</span>() <span class="keyword">as</span> *<span class="keyword">mut</span> [std::mem::MaybeUninit&lt;<span class="type">u8</span>&gt;] <span class="keyword">as</span> *<span class="keyword">mut</span> [<span class="type">u8</span>]) &#125;;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.io.<span class="title function_ invoke__">get_ref</span>().<span class="title function_ invoke__">read</span>(b) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                buf.<span class="title function_ invoke__">assume_init</span>(n);</span><br><span class="line">            &#125;</span><br><span class="line">            buf.<span class="title function_ invoke__">add_filled</span>(n);</span><br><span class="line">            Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Ok</span>(())) <span class="comment">//➋ 获得到数据即是 Ready</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Err</span>(e)), <span class="comment">// ➌ 如何是异常就是返回就绪的异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段就是我们底层的逻辑，对于 <code>self.io.poll_read_ready(cx, mio::Ready::readable())</code> 来说，是我们所依赖的 <code>Mio</code> 对于 <code>Epoll</code> 封装，这里就不做展开。</p>
<p>我们既然知道了在读取的过程中，我们有一个客户被暂停的对象的话，那我们此时我们就要看下我们的执行器以及<code>wake</code></p>
<h2 id="Executor-Scheduler-Worker"><a class="header-anchor" href="#Executor-Scheduler-Worker">¶</a>Executor (Scheduler Worker)</h2>
<p>我们这里也不用和代码死磕了，从官方的设计文档中 <a href="https://docs.rs/tokio/0.2.22/tokio/runtime/index.html">runtime</a> 中我们可以得知，对于我们在上文中分析的 <code>Executor</code> 也就是对应到 <code>Runtime</code> 这个抽象，而这个抽象有两个具体的实现: <code>Basic Scheduler</code> 和 <code>Threaded Scheduler</code>，而这两者最大的区别是 <code>Basic Scheduler</code> 是一个 <em><code>single-threaded</code></em> 的设计，因此社区也推荐对于大部分的时候，我们都应该使用 <code>Threaded Scheduler</code>，我们先分析下 <code>Threaded Scheduler</code>，然后再看看 <code>Basic Scheduler</code></p>
<h3 id="Threaded-Scheduler"><a class="header-anchor" href="#Threaded-Scheduler">¶</a>Threaded Scheduler</h3>
<p>对于 <code>Threaded Scheduler</code> 来说，对于每一个线程都是对等的，每个线程都会生成一个 <code>Worker</code> 对象。</p>
<figure class="highlight rust"><figcaption><span>tokio/src/runtime/thread_pool/worker.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    shared: Arc&lt;Shared&gt;,</span><br><span class="line">    index: <span class="type">usize</span>,</span><br><span class="line">    core: AtomicCell&lt;Core&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Worker"><a class="header-anchor" href="#Worker">¶</a>Worker</h4>
<p>对于 <code>worker</code> 运行的逻辑同文件中，如下所示：</p>
<figure class="highlight rust"><figcaption><span>tokio/src/runtime/thread_pool/worker.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> core: <span class="type">Box</span>&lt;Core&gt;) <span class="punctuation">-&gt;</span> RunResult &#123;</span><br><span class="line">    <span class="keyword">while</span> !core.is_shutdown &#123; <span class="comment">//当系统未停机的时候</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 检查当前线程是否有可以可以运行的任务</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = core.<span class="title function_ invoke__">next_task</span>(&amp;<span class="keyword">self</span>.worker) &#123;</span><br><span class="line">            core = <span class="keyword">self</span>.<span class="title function_ invoke__">run_task</span>(task, core)?;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本地没有可以运行的任务的话，就去其他的Worker偷一个回来</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = core.<span class="title function_ invoke__">steal_work</span>(&amp;<span class="keyword">self</span>.worker) &#123;</span><br><span class="line">            core = <span class="keyword">self</span>.<span class="title function_ invoke__">run_task</span>(task, core)?;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他的 Worker 也没有，就 Park</span></span><br><span class="line">            core = <span class="keyword">self</span>.<span class="title function_ invoke__">park</span>(core);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Signal shutdown</span></span><br><span class="line">    <span class="keyword">self</span>.worker.shared.<span class="title function_ invoke__">shutdown</span>(core, <span class="keyword">self</span>.worker.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过在这个 <code>park</code> 中另有玄机，在代码处，我们可以发现</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tokio/src/io/driver/mod.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">park</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">turn</span>(<span class="literal">None</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tokio/src/io/driver/mod.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">turn</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, max_wait: <span class="type">Option</span>&lt;Duration&gt;) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">//获得我们的 IO Event</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">events</span> = <span class="keyword">self</span>.events.<span class="title function_ invoke__">take</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;i/o driver event store missing&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里等待 IO 的事件的发生， 这里的 max_wait 对于 Tokio 传入的是 0，无限制等待</span></span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.inner.io.<span class="title function_ invoke__">poll</span>(&amp;<span class="keyword">mut</span> events, max_wait) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; &#123;&#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理我们获取到的事件</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">event</span> <span class="keyword">in</span> events.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">token</span> = event.<span class="title function_ invoke__">token</span>();</span><br><span class="line">        <span class="keyword">if</span> token == TOKEN_WAKEUP &#123;</span><br><span class="line">            <span class="keyword">self</span>.inner</span><br><span class="line">                .wakeup</span><br><span class="line">                .<span class="title function_ invoke__">set_readiness</span>(mio::Ready::<span class="title function_ invoke__">empty</span>())</span><br><span class="line">                .<span class="title function_ invoke__">unwrap</span>(); <span class="comment">//唤醒 Task</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">dispatch</span>(token, event.<span class="title function_ invoke__">readiness</span>()); <span class="comment">//这里其实也是在用 wake 唤醒，不过这里需要使用  Token 进行转换一下</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.events = <span class="title function_ invoke__">Some</span>(events);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过值得注意的这里的 <code>Poller</code> 是作为 <code>Worker</code> 的私有属性的存在的，这样的话我们可以明白了 <em><code>非阻塞</code></em> 原理是怎么工作的。</p>
<p><img src="https://s3.jpg.cm/2020/09/10/1jmGR.png" alt="1jmGR.png"></p>
<ol>
<li>获取本地的工作队列，如果有就进入 3，如果没有就跳转到 2</li>
<li>获取其他Worker的工作队列中的任务，如果有就进入 3，没有就进入 4</li>
<li>执行 Poll 逻辑</li>
<li>进入 Park 逻辑，等待就绪实践的完成</li>
</ol>
<p>这里仍有一个小问题，工作队列的填充工作势必是由 <code>Wake</code> 进行填充的，这段逻辑我们再接下来分析一下</p>
<h4 id="Wake"><a class="header-anchor" href="#Wake">¶</a>Wake</h4>
<p>而对于 <code>Tokio</code> 而言，<code>Wake</code> 对象的创建在我们创建 <code>Task</code> 进行 <code>Spwan</code> 的时候已经创建完成</p>
<figure class="highlight rust"><figcaption><span>tokio/src/runtime/task/core.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">fn</span> <span class="title function_">poll</span>(&amp;<span class="keyword">self</span>, header: &amp;Header) <span class="punctuation">-&gt;</span> Poll&lt;T::Output&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = &#123;</span><br><span class="line">        <span class="keyword">self</span>.stage.<span class="title function_ invoke__">with_mut</span>(|ptr| &#123;</span><br><span class="line">            <span class="comment">// 在我们调用的外侧封装一层 Poll，我们的额 Waker 就是 Header 这个对象</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">waker_ref</span> = waker_ref::&lt;T, S&gt;(header);</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cx</span> = Context::<span class="title function_ invoke__">from_waker</span>(&amp;*waker_ref);</span><br><span class="line"></span><br><span class="line">            future.<span class="title function_ invoke__">poll</span>(&amp;<span class="keyword">mut</span> cx)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>wake</code> 的逻辑如下</p>
<figure class="highlight rust"><figcaption><span>wake_by_ref</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">fn</span> <span class="title function_">wake_by_ref</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">header</span>().state.<span class="title function_ invoke__">transition_to_notified</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">core</span>().<span class="title function_ invoke__">schedule</span>(<span class="title function_ invoke__">Notified</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">to_task</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中也很容易看出来，我们将 <code>Header</code> 对象转化成了 <code>Task</code>，然后重新回到了调度器中进行调度，而这里又引入了一个新的理念了 <code>Scheduler</code>，这个我们晚一点再来解释，先看看 <code>Header</code>，<code>Header</code> 其实就是这个 <code>Task</code> 的状态数据。</p>
<figure class="highlight rust"><figcaption><span>Task Init</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Future, S: Schedule&gt; Cell&lt;T, S&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">fn</span> <span class="title function_">new</span>(future: T, state: State) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;Cell&lt;T, S&gt;&gt; &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Cell &#123;</span><br><span class="line">            header: Header &#123;</span><br><span class="line">                state,</span><br><span class="line">                owned: UnsafeCell::<span class="title function_ invoke__">new</span>(linked_list::Pointers::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">                queue_next: UnsafeCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">                stack_next: UnsafeCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">                vtable: raw::vtable::&lt;T, S&gt;(),</span><br><span class="line">            &#125;,</span><br><span class="line">            core: Core &#123;</span><br><span class="line">                scheduler: UnsafeCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">                stage: UnsafeCell::<span class="title function_ invoke__">new</span>(Stage::<span class="title function_ invoke__">Running</span>(future)),</span><br><span class="line">            &#125;,</span><br><span class="line">            trailer: Trailer &#123;</span><br><span class="line">                waker: UnsafeCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Scheduler"><a class="header-anchor" href="#Scheduler">¶</a>Scheduler</h4>
<p>在真正实现 <code>NoBlocking</code> 的时候，我们需要将 <code>Task</code> 放置到相关的 <code>Task queue</code>中，而这部分的逻辑就交付给 <code>Scheduler</code> 这个抽象对象进行处理。</p>
<figure class="highlight rust"><figcaption><span>tokio/src/runtime/thread_pool/worker.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">schedule</span>(&amp;<span class="keyword">self</span>, task: Notified) &#123;</span><br><span class="line">    <span class="keyword">self</span>.shared.<span class="title function_ invoke__">schedule</span>(task, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">fn</span> <span class="title function_">schedule</span>(&amp;<span class="keyword">self</span>, task: Notified, is_yield: <span class="type">bool</span>) &#123;</span><br><span class="line">    CURRENT.<span class="title function_ invoke__">with</span>(|maybe_cx| &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(cx) = maybe_cx &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">ptr_eq</span>(&amp;cx.worker.shared) &#123;</span><br><span class="line">                <span class="comment">// 属于当前线程的任务就在本地进行调度</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(core) = cx.core.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">as_mut</span>() &#123;</span><br><span class="line">                    <span class="keyword">self</span>.<span class="title function_ invoke__">schedule_local</span>(core, task, is_yield);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他情况就置于队列，然后唤醒其他的 Worker</span></span><br><span class="line">        <span class="keyword">self</span>.inject.<span class="title function_ invoke__">push</span>(task);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">notify_parked</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Harness"><a class="header-anchor" href="#Harness">¶</a>Harness</h4>
<p>特地的分出了一个章节和大家再聊聊一个和 <code>Wake</code> 对等的抽象 <code>Harness</code>，对于我们系统来说，Wake是进行线程唤醒的，涉及到 <code>Task</code> 的状态修改，而这个对象就是 <code>Harness</code> (而实际上 Harness 也是我们具象化的 Wake 对象)。</p>
<figure class="highlight rust"><figcaption><span>Harness Poll</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">//如果是第一次运行就需要在下面进行 Core 绑定</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_not_bound</span> = !<span class="keyword">self</span>.<span class="title function_ invoke__">core</span>().<span class="title function_ invoke__">is_bound</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transition the task to the running state.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 恢复 Task 到运行状态</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">snapshot</span> = <span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">header</span>().state.<span class="title function_ invoke__">transition_to_running</span>(is_not_bound) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(snapshot) =&gt; snapshot,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">drop_reference</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_not_bound &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">core</span>().<span class="title function_ invoke__">bind_scheduler</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">to_task</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就是执行我们真正的 Task 的逻辑</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = panic::<span class="title function_ invoke__">catch_unwind</span>(panic::<span class="title function_ invoke__">AssertUnwindSafe</span>(|| &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> snapshot.<span class="title function_ invoke__">is_cancelled</span>() &#123; <span class="comment">// 已经取消就返回</span></span><br><span class="line">            Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Err</span>(JoinError::<span class="title function_ invoke__">cancelled2</span>()))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">res</span> = guard.core.<span class="title function_ invoke__">poll</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">header</span>()); <span class="comment">// 这里又回到我们上面的 创建 Wake 的地方，又是一轮循环</span></span><br><span class="line">            res.<span class="title function_ invoke__">map</span>(<span class="literal">Ok</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> res &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Poll::<span class="title function_ invoke__">Ready</span>(out)) =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">complete</span>(out, snapshot.<span class="title function_ invoke__">is_join_interested</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Poll::Pending) =&gt; &#123; <span class="comment">// 如果真实的逻辑是 返回 Pending</span></span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">header</span>().state.<span class="title function_ invoke__">transition_to_idle</span>() &#123; <span class="comment">// 将Task的状态保存</span></span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(snapshot) =&gt; &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">cancel_task</span>(),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">complete</span>(<span class="title function_ invoke__">Err</span>(JoinError::<span class="title function_ invoke__">panic2</span>(err)), snapshot.<span class="title function_ invoke__">is_join_interested</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Worker-Launch"><a class="header-anchor" href="#Worker-Launch">¶</a>Worker Launch</h4>
<p>我们的 <code>Worker</code> 是如何启动的？还得我们最开始的 <code>Example</code> 中的 <code>tokio::spawn()</code> 吗？</p>
<figure class="highlight rust"><figcaption><span>tokio/src/runtime/builder.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_threaded_runtime</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;Runtime&gt; &#123;</span><br><span class="line">    <span class="comment">//根据 CPU CORE 启动 WORKER 的线程数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">core_threads</span> = <span class="keyword">self</span>.core_threads.<span class="title function_ invoke__">unwrap_or_else</span>(|| cmp::<span class="title function_ invoke__">min</span>(<span class="keyword">self</span>.max_threads, <span class="title function_ invoke__">num_cpus</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (io_driver, io_handle) = io::<span class="title function_ invoke__">create_driver</span>(<span class="keyword">self</span>.enable_io)?;</span><br><span class="line">    <span class="keyword">let</span> (driver, time_handle) = time::<span class="title function_ invoke__">create_driver</span>(<span class="keyword">self</span>.enable_time, io_driver, clock.<span class="title function_ invoke__">clone</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一组Worker 和 一个启动器</span></span><br><span class="line">    <span class="keyword">let</span> (scheduler, launch) = ThreadPool::<span class="title function_ invoke__">new</span>(core_threads, Parker::<span class="title function_ invoke__">new</span>(driver));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spawner</span> = Spawner::<span class="title function_ invoke__">ThreadPool</span>(scheduler.<span class="title function_ invoke__">spawner</span>().<span class="title function_ invoke__">clone</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Blocking Pool</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">blocking_pool</span> = blocking::<span class="title function_ invoke__">create_blocking_pool</span>(<span class="keyword">self</span>, <span class="keyword">self</span>.max_threads);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">blocking_spawner</span> = blocking_pool.<span class="title function_ invoke__">spawner</span>().<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the runtime handle</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = Handle &#123;</span><br><span class="line">        spawner,</span><br><span class="line">        io_handle,</span><br><span class="line">        time_handle,</span><br><span class="line">        clock,</span><br><span class="line">        blocking_spawner,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里开始启动 Worker</span></span><br><span class="line">    handle.<span class="title function_ invoke__">enter</span>(|| launch.<span class="title function_ invoke__">launch</span>());</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(Runtime &#123;</span><br><span class="line">        kind: Kind::<span class="title function_ invoke__">ThreadPool</span>(scheduler),</span><br><span class="line">        handle,</span><br><span class="line">        blocking_pool,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此在 <code>tokio/src/runtime/blocking/pool.rs:spawn</code> 中，我们创建出来所有的 <code>Worker</code>，而 <code>Worker</code> 的逻辑是我上面所使用的的 <code>Example</code> 部分。因此最后我们会生成多个 <code>Worker</code></p>
<p><img src="https://s3.jpg.cm/2020/09/09/1KeIQ.png" alt="1KeIQ.png"></p>
<h4 id="COOP"><a class="header-anchor" href="#COOP">¶</a>*COOP</h4>
<p>从官方的 <a href="https://docs.rs/tokio/0.2.22/src/tokio/coop.rs.html"><code>Docs</code></a> 中得知，为了防止某个 <code>Funture</code> 一直返回 <code>Ready</code> 状态（这样就变成了一个 Loop 了），因此增加了一个 <code>COOP</code>机制，也比较容易理解。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">poll_proceed</span>(cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;RestoreOnPending&gt; &#123;</span><br><span class="line">    CURRENT.<span class="title function_ invoke__">with</span>(|cell| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">budget</span> = cell.<span class="title function_ invoke__">get</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> budget.<span class="title function_ invoke__">decrement</span>() &#123; <span class="comment">// 当 Rem 可减的时候正常返回</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">restore</span> = <span class="title function_ invoke__">RestoreOnPending</span>(Cell::<span class="title function_ invoke__">new</span>(cell.<span class="title function_ invoke__">get</span>()));</span><br><span class="line">            cell.<span class="title function_ invoke__">set</span>(budget);</span><br><span class="line">            Poll::<span class="title function_ invoke__">Ready</span>(restore)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cx.<span class="title function_ invoke__">waker</span>().<span class="title function_ invoke__">wake_by_ref</span>(); <span class="comment">// 当 Rem 不可减的时候就强制返回 Pending</span></span><br><span class="line">            Poll::Pending</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">decrement</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(num) = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.<span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> *num &gt; <span class="number">0</span> &#123;</span><br><span class="line">            *num -= <span class="number">1</span>;</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">initial</span>() <span class="punctuation">-&gt;</span> Budget &#123;</span><br><span class="line">    <span class="title function_ invoke__">Budget</span>(<span class="title function_ invoke__">Some</span>(<span class="number">128</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是如果一个 <code>Funture</code> 一直返回 <code>Ready</code>，当返回 <code>128</code> 次 <code>Ready</code> 之后就强制返回 <code>Pending</code>。</p>
<h4 id="流程小结"><a class="header-anchor" href="#流程小结">¶</a>流程小结</h4>
<p>当我们启动就绪什么都没有发生的时候，此时我们系统所有的 <code>Worker</code> 都进入了 <code>Waiting</code> 的状态等待任务被创建再执行。<br>
我们执行 <code>nc localhost 8080</code> 尝试建立连接之后系统就开始真正的工作起来。</p>
<h5 id="创建任务"><a class="header-anchor" href="#创建任务">¶</a>创建任务</h5>
<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: Task创建流程',
     'Spawn#task->Worker#schedule: 1. 创建任务然后放入调度器队列',
     'Worker#schedule->Worker#notify_parked: 2. 选择某个Worker启动线程开始运行',
     'Note right of Spawn#task: Thread main',
     'Note right of Worker#schedule: Thread main',
     'Note right of Worker#notify_parked: Thread main',
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>
<p>执行完成之后，主线程因为等待 <code>accept</code> 事件就 <code>parking</code> 过去了。</p>
<h5 id="运行任务"><a class="header-anchor" href="#运行任务">¶</a>运行任务</h5>
<div style="width:100%; overflow-y:scroll;" id="diagram2"></div>
<script>
	let data2 =
	['Title: Task运行流程',
     'Worker#run->Worker#run_task: 1. 被唤醒运行任务',
     'Worker#run_task->Worker#parking: 2. 等待Read事件就绪',
     'Worker#parking->Worker#wake: 3. 通过wake唤醒Task继续运行',
     'Worker#wake->Worker#schedule_local: 4. 将任务放入本地的队列中，继续执行',
     'Worker#run->Worker#run_task: 5. 执行任务',
     'Note right of Worker#run: Thread Worker N',
    ].join('\n');
  	let diagram2 = Diagram.parse(data2);
  	diagram2.drawSVG("diagram2", {theme: 'simple', scale: 0.5});
</script>
<h5 id="选读-Switch-Thread"><a class="header-anchor" href="#选读-Switch-Thread">¶</a><em>[选读] Switch Thread</em></h5>
<p>在正在的执行过程中，我们会观察到一个有趣的现状，比如我们修改下 <code>Example</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0</span>; <span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">n</span> = socket</span><br><span class="line">            .<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf)</span><br><span class="line">            .<span class="keyword">await</span></span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to read data from socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;current thread: &#123;:?&#125;&quot;</span>, thread::<span class="title function_ invoke__">current</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行的时候我们会观察到一个有趣的情况：</p>
<figure class="highlight bash"><figcaption><span>read thread</span></figcaption><table><tr><td class="code"><pre><span class="line">Listening on: 127.0.0.1:8080</span><br><span class="line">current thread: Thread &#123; <span class="built_in">id</span>: ThreadId(4), name: Some(<span class="string">&quot;tokio-runtime-worker&quot;</span>) &#125;</span><br><span class="line">current thread: Thread &#123; <span class="built_in">id</span>: ThreadId(12), name: Some(<span class="string">&quot;tokio-runtime-worker&quot;</span>) &#125;</span><br><span class="line">current thread: Thread &#123; <span class="built_in">id</span>: ThreadId(4), name: Some(<span class="string">&quot;tokio-runtime-worker&quot;</span>) &#125;</span><br><span class="line">current thread: Thread &#123; <span class="built_in">id</span>: ThreadId(12), name: Some(<span class="string">&quot;tokio-runtime-worker&quot;</span>) &#125;</span><br><span class="line">current thread: Thread &#123; <span class="built_in">id</span>: ThreadId(4), name: Some(<span class="string">&quot;tokio-runtime-worker&quot;</span>) &#125;</span><br><span class="line">current thread: Thread &#123; <span class="built_in">id</span>: ThreadId(12), name: Some(<span class="string">&quot;tokio-runtime-worker&quot;</span>) &#125;</span><br><span class="line">current thread: Thread &#123; <span class="built_in">id</span>: ThreadId(4), name: Some(<span class="string">&quot;tokio-runtime-worker&quot;</span>) &#125;</span><br><span class="line">current thread: Thread &#123; <span class="built_in">id</span>: ThreadId(12), name: Some(<span class="string">&quot;tokio-runtime-worker&quot;</span>) &#125;</span><br><span class="line">current thread: Thread &#123; <span class="built_in">id</span>: ThreadId(4), name: Some(<span class="string">&quot;tokio-runtime-worker&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>并不是很符合我们的直觉，这里的设计是在</p>
<figure class="highlight rust"><figcaption><span>tokio/src/runtime/thread_pool/worker.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run_task</span>(&amp;<span class="keyword">self</span>, task: Notified, <span class="keyword">mut</span> core: <span class="type">Box</span>&lt;Core&gt;) <span class="punctuation">-&gt;</span> RunResult &#123;</span><br><span class="line">        <span class="comment">// 让这个Worker的状态置于可以被窃取的状态</span></span><br><span class="line">        core.<span class="title function_ invoke__">transition_from_searching</span>(&amp;<span class="keyword">self</span>.worker);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">transition_worker_from_searching</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.idle.<span class="title function_ invoke__">transition_worker_from_searching</span>() &#123;</span><br><span class="line">        <span class="comment">// 唤醒一个 Worker 让其窃取</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">notify_parked</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>看到这里我们做一个全景性质的小结<br>
<img src="https://s3.jpg.cm/2020/09/12/1MTqk.png" alt="1MTqk.png"></p>
<h3 id="Basic-Scheduler"><a class="header-anchor" href="#Basic-Scheduler">¶</a>Basic Scheduler</h3>
<p>有了上面的 <code>Threaded Scheduler</code>,对于 <code>Basic Scheduler</code> 的理解就简单很多了。</p>
<h4 id="Spawner"><a class="header-anchor" href="#Spawner">¶</a>Spawner</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">struct</span> <span class="title class_">Spawner</span> &#123;</span><br><span class="line">    shared: Arc&lt;Shared&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Spawner</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">spawn</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, future: F) <span class="punctuation">-&gt;</span> JoinHandle&lt;F::Output&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: Future + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">        F::Output: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> (task, handle) = task::<span class="title function_ invoke__">joinable</span>(future);</span><br><span class="line">        <span class="keyword">self</span>.shared.<span class="title function_ invoke__">schedule</span>(task); <span class="comment">// ➊ cx.tasks.borrow_mut().queue.push_back(task);</span></span><br><span class="line">        handle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>Spawner</code> 来说蛮简单的就是直接将任务 <code>PUSH</code> 进  <code>Task Queue</code> 即可。</p>
<h4 id="EventLoop"><a class="header-anchor" href="#EventLoop">¶</a>EventLoop</h4>
<p>对于 <code>Basic Scheduler</code> 逻辑理解起来更为的简单一些。</p>
<figure class="highlight rust"><figcaption><span>tokio/src/runtime/basic_scheduler.rs:run</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">_enter</span> = runtime::<span class="title function_ invoke__">enter</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">waker</span> = <span class="title function_ invoke__">waker_ref</span>(&amp;scheduler.spawner.shared);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cx</span> = std::task::Context::<span class="title function_ invoke__">from_waker</span>(&amp;waker);</span><br><span class="line"><span class="symbol">&#x27;outer</span>: </span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ready</span>(v) = crate::coop::<span class="title function_ invoke__">budget</span>(|| future.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">poll</span>(&amp;<span class="keyword">mut</span> cx)) &#123;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ➊ MAX_TASKS_PER_TICK 单个唤醒周期内处理多少任务</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..MAX_TASKS_PER_TICK &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">tick</span> = scheduler.tick;</span><br><span class="line">            scheduler.tick = scheduler.tick.<span class="title function_ invoke__">wrapping_add</span>(<span class="number">1</span>); <span class="comment">// 将 tick + 1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// ➋ REMOTE_FIRST_INTERVAL = 31，经过 31 轮之后检查 Spawner 队列，是 else 部分</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">next</span> = <span class="keyword">if</span> tick % REMOTE_FIRST_INTERVAL == <span class="number">0</span> &#123; </span><br><span class="line">                scheduler</span><br><span class="line">                    .spawner</span><br><span class="line">                    .<span class="title function_ invoke__">pop</span>()</span><br><span class="line">                    .<span class="title function_ invoke__">or_else</span>(|| context.tasks.<span class="title function_ invoke__">borrow_mut</span>().queue.<span class="title function_ invoke__">pop_front</span>()) <span class="comment">// 没有就去 全局队列 取</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                context</span><br><span class="line">                    .tasks</span><br><span class="line">                    .<span class="title function_ invoke__">borrow_mut</span>()</span><br><span class="line">                    .queue</span><br><span class="line">                    .<span class="title function_ invoke__">pop_front</span>()</span><br><span class="line">                    .<span class="title function_ invoke__">or_else</span>(|| scheduler.spawner.<span class="title function_ invoke__">pop</span>())</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ➌ 获取到任务，就处理， 没有就直接 Park ，等待下次唤起</span></span><br><span class="line">            <span class="keyword">match</span> next &#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(task) =&gt; crate::coop::<span class="title function_ invoke__">budget</span>(|| task.<span class="title function_ invoke__">run</span>()),</span><br><span class="line">                <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                    <span class="comment">// Park until the thread is signaled</span></span><br><span class="line">                    scheduler.park.<span class="title function_ invoke__">park</span>().<span class="title function_ invoke__">ok</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to park&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Try polling the `block_on` future next</span></span><br><span class="line">                    <span class="keyword">continue</span> <span class="symbol">&#x27;outer</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有任务直接直接 Park 了</span></span><br><span class="line">        scheduler</span><br><span class="line">            .park</span><br><span class="line">            .<span class="title function_ invoke__">park_timeout</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">0</span>))</span><br><span class="line">            .<span class="title function_ invoke__">ok</span>()</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to park&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>Basic Scheduler</code> 来说唯一有些复杂的就是，在 <code>Spwan</code> 和 <code>BasicScheduler</code> 中都会有任务，因为会涉及到在一定轮数下就会切换到 <code>Spwan</code>中，不过从实际的运行过程中，会发现我们几乎都是在 <code>cx.tasks.borrow_mut().queue.push_back(task)</code> 进行工作，因为每一次运行都涉及到 <code>bind</code>，不过值得注意的是 <code>Spawner</code> 是会在多个线程之间共享的。</p>
<h4 id="Wake-v2"><a class="header-anchor" href="#Wake-v2">¶</a>Wake</h4>
<p>对于 <code>wake</code> 就很简单了，将 <code>unpark</code> 对象进行 <code>unpark</code> 即可。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Wake</span> <span class="keyword">for</span> <span class="title class_">Shared</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">wake</span>(<span class="keyword">self</span>: Arc&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        Wake::<span class="title function_ invoke__">wake_by_ref</span>(&amp;<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Wake by reference</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">wake_by_ref</span>(arc_self: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        arc_self.unpark.<span class="title function_ invoke__">unpark</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="流程小结-v2"><a class="header-anchor" href="#流程小结-v2">¶</a>流程小结</h4>
<p>正常使用 <code>Spawner</code> 会从 <code>Context</code> 也就是当前线程中创建出来一个 <code>Spawner</code> 进行任务提交的时候，并不会将 <code>Task</code> 放入 <code>Spanwer</code> 内置的队列中。</p>
<p><img src="https://s1.ax1x.com/2020/09/12/walqRH.png" alt="walqRH.png"></p>
<h2 id="线程模型"><a class="header-anchor" href="#线程模型">¶</a>线程模型</h2>
<p>在 <a href="/2020/08/10/networking/epoll-thread/">Epoll 之下的线程模型</a> 中，我们也提及过，对于利用多核的能力，我们可以对 <code>accept()</code> 或者 <code>read()</code> 进行负载均衡，对于 <code>Tokio</code> 来说，我们实际上并没有像 <code>Netty</code> 那样限制了 <code>BossGroup</code> 和 <code>WorkGroup</code>，<code>Tokio</code> 作为一个底层框架并没有限制这样的工作模式，比如我们就可以按照自己的想法进行定制。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">boss</span> = runtime::Builder::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">threaded_scheduler</span>()</span><br><span class="line">        .<span class="title function_ invoke__">enable_all</span>()</span><br><span class="line">        .<span class="title function_ invoke__">core_threads</span>(<span class="number">2</span>)</span><br><span class="line">        .<span class="title function_ invoke__">build</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = runtime::Builder::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">threaded_scheduler</span>()</span><br><span class="line">        .<span class="title function_ invoke__">enable_all</span>()</span><br><span class="line">        .<span class="title function_ invoke__">core_threads</span>(<span class="number">4</span>)</span><br><span class="line">        .<span class="title function_ invoke__">build</span>()?;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">addr</span> = env::<span class="title function_ invoke__">args</span>()</span><br><span class="line">        .<span class="title function_ invoke__">nth</span>(<span class="number">1</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap_or_else</span>(|| <span class="string">&quot;127.0.0.1:8080&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(&amp;addr).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Listening on: &#123;&#125;&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">    boss.<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> (<span class="keyword">mut</span> socket, _) = listener.<span class="title function_ invoke__">accept</span>()</span><br><span class="line">                .<span class="keyword">await</span>.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to accept from socket&quot;</span>);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;accept thread: &#123;:?&#125;&quot;</span>, thread::<span class="title function_ invoke__">current</span>());</span><br><span class="line">            workers.<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0</span>; <span class="number">1024</span>];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">loop</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">n</span> = socket.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf).<span class="keyword">await</span>.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to read data from socket&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                socket.<span class="title function_ invoke__">shutdown</span>(Shutdown::Write);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(thread::<span class="title function_ invoke__">park</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">accept thread: Thread &#123; <span class="built_in">id</span>: ThreadId(14), name: Some(<span class="string">&quot;tokio-runtime-worker&quot;</span>) &#125;</span><br><span class="line">accept thread: Thread &#123; <span class="built_in">id</span>: ThreadId(14), name: Some(<span class="string">&quot;tokio-runtime-worker&quot;</span>) &#125;</span><br><span class="line">accept thread: Thread &#123; <span class="built_in">id</span>: ThreadId(15), name: Some(<span class="string">&quot;tokio-runtime-worker&quot;</span>) &#125;</span><br><span class="line">accept thread: Thread &#123; <span class="built_in">id</span>: ThreadId(15), name: Some(<span class="string">&quot;tokio-runtime-worker&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>按照上面的代码我们就可以模拟出 <code>Netty</code> 的线程模型。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://tokio.rs/blog/2019-10-scheduler">Making the Tokio scheduler 10x faster</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>rust</category>
        <category>async</category>
        <category>tokio</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>async</tag>
        <tag>tokio</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务：Why | What | How</title>
    <url>/2020/07/07/architecture/microservice/mircoservices/</url>
    <content><![CDATA[<p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_8a4438ee9fca734d3e3693ffd6a44a30.png" alt="image.png"></p>
<blockquote>
<p>客户为「本质需求」买单。</p>
</blockquote>
<span id="more"></span>
<p>我们有一系列的思维工具，对于微服务的分析，我选择用 <code>what how why</code> 的工具进行分析，不过值得注意的是我略微调整了顺序，这绝非是开创性的的纲领，而是对于这些年对于微服务的再次反思。</p>
<h1>Why：为什么是微服务</h1>
<h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2>
<blockquote>
<p>本章大多数借鉴 <a href="#refer-anchor-1"><sup>参考1</sup></a></p>
</blockquote>
<p>远在 80 年代初，第一种重要的系统分发技术 “远程过程调用 (RPC)” 诞生的时候，微服务的历史就开始了。基本思路都是<strong>让远程调用对开发人员保持透明</strong></p>
<p>随着处理器改进和本地地址空间的扩大(当时最常用的处理器是具有 64K 地址空间的 16 位处理器)，这个问题变得不太重要。此外，DCE 和 CORBA 的第一组大型实现告诉了架构师一个有关分布式计算的重要观察结论：</p>
<p style="color:red">某个功能能够分散化，并不代表着它就应该分散化</p>
<p>随着 <code>RPC</code> 的盛行，慢慢的社区构建出了面向服务的架构 <code>SOA</code>，在 SOAP 的核心中，SOAP 只不过是一种通过 HTTP 调用对象方法的方式。它利用了 2000 年代初的计算领域的两个特征： 企业网络中对 HTTP 的支持越来越多，以及事实上此支持包含登录和调试基于文本的网络调用的机制。但 SOA 在整体上的败笔是，它脱离了简单的初衷，开始添加一层又一层脱离了简单方法调用的一些附加概念：添加了异常处理、 事务支持、安全性和数字签名，人们感觉 SOA 已经变成了一个复杂协议。正如 <code>命运给予她的全部馈赠，早已在暗中标好了价格</code>。</p>
<p style="color:red">尝试让分布式调用的行为像本地调用，这最终带来一些苦果。</p>
<p>在推出 JEE 时，许多企业已经转而采用使用应用服务器托管许多不同应用程序的概念，因为它类似于来自大型机领域的现有 IT 模型。一个操作小组控制、监视和维护来自 Oracle 或 IBM 的相同应用服务器的 “农场”，并在这个 “农场” 上部署不同的部门级应用程序。这种标准化和一致性对操作团队很有用，而且降低了总体操作成本。但这与应用程序开发 人员产生了冲突，因为开发和测试环境很大，很难创建，而且需要操作团队干预。这通常意味着新环境可能需要花几个月才能完成创建，这延缓了项目进度并增加了开发成本。此外，因为这些环境不受该团队的控制，所以不同环境的应用服务器版本、补丁级别、应用程序数据和 软件安装常常不一致。开发人员更喜欢更小的、轻量级的应用程序平台 — 通常是一些开源的应用服务器，比如 Tomcat 或 Glassfish。同时，随着控制反转和依赖注入等技术得到普及，人们避开了 JEE 的复杂性，而喜欢上了 Spring 平台所提供的简单性。这么做的收获是，开发团队发现，他们能够自行在彼此尽可能接近的开发、测试和生产环境中 一致地构建和部署应用程序，不仅速度更快，而且出错率更低，因为源于环境不一致性的所有错误都被消除了。</p>
<p style="color:red">您的程序和它们的运行时环境应尽可能完全独立。</p>
<hr>
<p>根据上面的3个观察结论，Fowler 的微服务设计原则之一是，微服务是 “围绕业务能力进行组织的”。该原则直接源于一种发现：您能够分散某项功能，并不意味着您就应该分散它。<br>
Façade 模式在其各种表现形式中的整体概念是，为系统或子系统定义一个特定的外部 API。言外之意是，这个 API 是业务驱动的 [<sup>作者注：这也就诞生了 API Gateway 这样的 Pattern</sup>] 。使用 EJB、SOAP 和其他复杂分发技术的团队最终发现，尝试让分布式系统看起来像本地系统最终会带来苦果。最后，Fowler 围绕分散化治理和分散化数据管理的规定源于一项来之不易的发现：您的程序和运行时环境应自给自足。</p>
<h2 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h2>
<h3 id="目的"><a class="header-anchor" href="#目的">¶</a>目的</h3>
<p>还记得我在 <a href="/2020/06/28/rethink/why-learn-by-self-so-hard/">为何有些软件知识自学如此的困难#什么是技术</a> 中给大家分享技术的定义吗？我们来解构一下 <code>微服务</code>　的第一要素：</p>
<p>微服务的目的：构建关注于<strong>单一目标</strong>且<strong>自然</strong>的程序，如果有人和你说微服务是为了解决高并发，那完全就是扯淡，回忆一下　<code>martinfowler</code>　在　<code>微服务</code>　的定义中所言</p>
<blockquote>
<p>We do not claim that the microservice style is novel or innovative, its roots go back at least to the design principles of Unix.</p>
</blockquote>
<p>试图回忆起来那些　<code>Unix</code>　最基本的哲学</p>
<blockquote>
<p>程序应该只关注一个目标，并尽可能把它做好。让程序能够互相协同工作。应该让程序处理文本数据流，因为这是一个通用的接口。</p>
</blockquote>
<h3 id="特征"><a class="header-anchor" href="#特征">¶</a>特征</h3>
<blockquote>
<p>本章大多数借鉴 <a href="#refer-anchor-3"><sup>参考3</sup></a></p>
</blockquote>
<h4 id="服务组件化"><a class="header-anchor" href="#服务组件化">¶</a>服务组件化</h4>
<p>当谈到组件时，我们遭遇困难的定义：组件是什么。我们的定义是：组件是一个<strong>可独立替换和独立升级的软件单元</strong>。微服务架构将使用库，但组件化软件的主要方式是分解成服务。我们把库定义为链接到程序并使用内存函数调用来调用的组件，而服务是一种进程外的组件，它通过web服务请求或rpc(远程过程调用)机制通信。</p>
<h4 id="围绕业务能力组织"><a class="header-anchor" href="#围绕业务能力组织">¶</a>围绕业务能力组织</h4>
<p>当想要把大型应用程序拆分成部件时，通常管理层聚焦在技术层面，导致UI团队、服务侧逻辑团队、数据库团队的划分。当团队按这些技术线路划分时，即使是简单的更改也会导致跨团队的时间和预算审批。一个聪明的团队将围绕这些优化，两害取其轻 - 只把业务逻辑强制放在它们会访问的应用程序中。换句话说，逻辑无处不在。</p>
<blockquote>
<p>任何设计系统(广泛定义的)的组织将产生一种设计，他的结构就是该组织的通信结构。<br>
– Melvyn Conway1967</p>
</blockquote>
<p><img src="https://s3.jpg.cm/2020/07/08/UIeZf.png" alt="UIeZf.png"></p>
<div>
    <label class="author-mark-label">作者有话说</label>
    <p class="author-mark">对于一个微服务项目应该有多大的规模？无论是亚马逊两匹萨团队还是重构二周论，都算是一种实践的体现，对于项目有多大，应该是在最终的实践过程中摸索出一套对企业适用的结果。</p>
</div>
<h4 id="交付产品不是项目"><a class="header-anchor" href="#交付产品不是项目">¶</a>交付产品不是项目</h4>
<p>我们看到大多数应用程序开发工作使用一个项目模式：目标是交付将要完成的一些软件。完成后的软件被交接给维护组织，然后它的构建团队就解散了。<br>
微服务支持者倾向于避免这种模式，而是认为一个团队应该负责产品的整个生命周期。对此一个共同的启示是亚马逊的理念 “<a href="https://queue.acm.org/detail.cfm?id=1142065">you build, you run it</a>” ，开发团队负责软件的整个产品周期。</p>
<div>
    <label class="author-mark-label">作者有话说</label>
    <p class="author-mark">这样的体系需要警惕: 团队的无限拓展导致的重复建设与疲于奔命<a target="_blank" href="/2020/07/06/rethink/stop-create-a-product/">为什么我厌倦了产品研发</a>，you build, you run it　而不是 you build everything，基础设施的完善是必须的。</p>
</div>
<h4 id="简单通讯"><a class="header-anchor" href="#简单通讯">¶</a>简单通讯</h4>
<p>微服务社区主张另一种方法：智能端点和哑管道。基于微服务构建的应用程序的目标是尽可能的解耦和尽可能的内聚 - 他们拥有自己的领域逻辑，他们的行为更像经典UNIX理念中的过滤器 - 接收请求，应用适当的逻辑并产生响应。使用简单的REST风格的协议来编排他们，而不是使用像WS-Choreography或者BPEL或者通过中心工具编制(orchestration)等复杂的协议。</p>
<p>第二种常用方法是在轻量级消息总线上传递消息。选择的基础设施是典型的哑的(哑在这里只充当消息路由器) - 像RabbitMQ或ZeroMQ这样简单的实现仅仅提供一个可靠的异步交换结构 - 在服务里，智能仍旧存活于端点中，生产和消费消息。</p>
<h4 id="去中心化治理"><a class="header-anchor" href="#去中心化治理">¶</a>去中心化治理</h4>
<p>团队在构建微服务时也更喜欢用不同的方法来达标。他们更喜欢生产有用的工具这种想法，而不是写在纸上的标准，这样其他开发者可以用这些工具解决他们所面临的相似的问题。有时，这些工具通常在实施中收获并与更广泛的群体共享，但不完全使用一个内部开源模型。现在git和github已经成为事实上的版本控制系统的选择，在内部开放源代码的实践也正变得越来越常见。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        微服务和SOA
    </div>
    <div class='spoiler-content'>
        <blockquote>
<p>当我们谈论微服务时，一个常见问题是它是否仅仅是十年前我们看到的面向服务的架构(SOA)。这一点是有可取之处的，因为微服务风格和SOA赞同的某些主张十分相似。然而，问题是SOA意味着很多不同的东西，而大多数时候，我们遇到的所谓的SOA和这里我们描述的风格明显不同，这种不同通常由于SOA专注于用于集成单体应用的ESB。</p>
</blockquote>
<blockquote>
<p>特别是我们已看到太多的搞砸的服务导向的实现，从趋向于隐藏ESB中的复杂性，到花费数百万并不产生任何价值的失败的多年举措，到积极抑制变化的集中治理模型，这有时很难看到过去的这些问题。</p>
</blockquote>
<blockquote>
<p>SOA的这种常见表现使得一些微服务倡导者完全拒绝SOA标签，尽管其他人认为微服务是SOA的一种形式，也许服务导向做得对。无论哪种方式，事实上，SOA意味着如此不同的事情，这意味着有一个术语来更清晰地定义这种架构风格是有价值的。</p>
</blockquote>

    </div>
</div>
<h4 id="去中心化数据管理"><a class="header-anchor" href="#去中心化数据管理">¶</a>去中心化数据管理</h4>
<p>数据管理的去中心化有许多不同的呈现方式。在最抽象的层面上，这意味着使系统间存在差异的世界概念模型。在整合一个大型企业时，客户的销售视图将不同于支持视图，这是一个常见的问题。客户的销售视图中的一些事情可能不会出现在支持视图中。它们确实可能有不同的属性和(更坏的)共同属性，这些共同属性在语义上有微妙的不同。</p>
<p>这个问题常见于应用程序之间，但也可能发生在应用程序内部，尤其当应用程序被划分成分离的组件时。一个有用的思维方式是有界上下文(Bounded Context)内的领域驱动设计(Domain-Driven Design, DDD)理念。DDD把一个复杂域划分成多个有界的上下文，并且映射出它们之间的关系。这个过程对单体架构和微服务架构都是有用的，但在服务和上下文边界间有天然的相关性，边界有助于澄清和加强分离，就像业务能力部分描述的那样。</p>
<p>像这样使用事务有助于一致性，但会产生显著地临时耦合，这在横跨多个服务时是有问题的。分布式事务是出了名的难以实现，因此微服务架构强调服务间的无事务协作，对一致性可能只是最后一致性和通过补偿操作处理问题有明确的认知。</p>
<p>对很多开发团队来说，选择用这样的方式管理不一致性是一个新的挑战，但这通常与业务实践相匹配。通常业务处理一定程度的不一致，以快速响应需求，同时有某些类型的逆转过程来处理错误。这种权衡是值得的，只要修复错误的代价小于更大一致性下损失业务的代价。</p>
<p><img src="https://s3.jpg.cm/2020/07/08/UI8aw.png" alt="UI8aw.png"></p>
<h4 id="基础设施自动化"><a class="header-anchor" href="#基础设施自动化">¶</a>基础设施自动化</h4>
<p>我们这里将之光住几个关键特性。我们希望有尽可能多的信心，我们的软件正在工作，所以我们运行大量的自动化测试。促进科工作软件沿管道线“向上”意味着我们自动化部署到每个新的环境中。</p>
<p>一个单体应用程序可以十分愉快地通过这些环境被构建、测试和推送。事实证明，一旦你为单体投入了自动化生产之路，那么部署更多的应用程序似乎也不会更可怕。请记住，持续部署的目标之一是使部署枯燥，所以无论是一个或三个应用程序，只要它的部署仍然枯燥就没关系。</p>
<p><img src="https://s3.jpg.cm/2020/07/08/UIcri.png" alt="UIcri.png"></p>
<h4 id="为失效设计"><a class="header-anchor" href="#为失效设计">¶</a>为失效设计</h4>
<p>使用服务作为组件的一个结果是，应用程序需要被设计成能够容忍服务失效。任何服务调用都可能因为供应者不可用而失败，客户端必须尽可能优雅的应对这种失败。与单体应用设计相比这是一个劣势，因为它引入额外的复杂性来处理它。结果是，微服务团队不断反思服务失效如何影响用户体验。Netflix的Simian Army在工作日诱导服务甚至是数据中心故障来测试应用程序的弹性和监测。</p>
<p>在生产环境中的这种自动化测试足够给大多数运营团队那种不寒而栗，通常在结束一周的工作之前。这不是说单体风格不能够进行完善的监测设置，只是在我们的经验中比较少见。</p>
<div>
    <label class="author-mark-label">作者有话说</label>
    <p class="author-mark">我们并非是保证系统永不宕机，我们是需要保证某节点故障的时候不会影响到全局系统，并且可以快速恢复。</p>
</div>
<h4 id="进化式设计"><a class="header-anchor" href="#进化式设计">¶</a>进化式设计</h4>
<p>微服务从业者，通常有进化式设计背景并且把服务分解看做是进一步的工具，使应用程序开发者能够控制他们应用程序中的变更而不减缓变更。变更控制并不一定意味着变更的减少 - 用正确的态度和工具，你可以频繁、快速且控制良好的改变软件。</p>
<h4 id="明显的缺陷"><a class="header-anchor" href="#明显的缺陷">¶</a>明显的缺陷</h4>
<ul>
<li>很难弄清楚组件边界在哪里，进化式的设计需要大量的迭代</li>
<li>重构微服务系统困难重重，跨服务边界移动代码是很困难的，任何接口变更都需要在参与者之间进行协调，需要添加向后兼容层，并且测试也变得更加复杂</li>
<li>需要基础化的自动化/基础设施</li>
<li>如果组件不组成的干净利索，那么所有你做的是将复杂度从组件内部转移到组件之间的连接。不仅仅是把复杂性移到周围，它将复杂性移动到一个不太明确、难以控制的地方</li>
<li>一个差的团队总是创建一个差的系统,(有一个合理的说法是，你不应该从微服务架构开始。相反，从单体开始，使它保持模块化，一旦单体成为问题时把它分解成微服务)</li>
</ul>
<p>还有一些关于不太明显的缺陷可以阅读<a href="#refer-anchor-9"><sup>参考9</sup></a>。</p>
<hr>
<p>上面的几个特性可以看作是微服务的<code>实践</code>，而关于微服务的元器件我们在后续的内容中继续探讨。在而这过程之中，我和大家聊一聊，我们跳出技术的层面看，微服务给我们带来什么。看看 <code>Devops</code></p>
<h3 id="微服务解决的问题"><a class="header-anchor" href="#微服务解决的问题">¶</a>微服务解决的问题</h3>
<p><img src="https://s3.jpg.cm/2020/07/08/UIUKk.png" alt="UIUKk.png"><br>
我们还记得Devops的内容吧。</p>
<blockquote>
<p>DevOps（开发 Development 与运维 Operations 的组合词）是一种文化、一场运动或实践，强调在自动化软件交付流程及基础设施变更过程中，软件开发人员与其他信息技术（IT）专业人员彼此之间的协作与沟通。它旨在建立一种文化与环境，使构建、测试、软件发布得以快速、频繁以及更加稳定地进行。</p>
</blockquote>
<p>在我的眼中，我认为 <code>微服务</code> 是 <code>Devops</code> 的环中的一些细分理念/实践。</p>
<p><code>Devops</code> 的自动化也是 <code>微服务</code> 的基石，而 <code>Devops</code> 所提出来的快速/频繁更新就要求系统能够在较小的范围内进行迭代，而这恰好与 <code>微服务</code> 小组件化的理念不谋而合，而微服务的系统因为是自然的也方便 <code>Deploy</code>，而监控这些也作为微服务必要的基石。</p>
<hr>
<p>因为其实对于我们来说，最终的价值要体现在 <code>业务侧</code>，因此 <code>Devops</code> 通过提高效率 <a href="#refer-anchor-4"><sup>参考4</sup></a> 体现价值，而 <code>Microservices</code> 通过支撑 <code>Devops</code> 而产生价值，因此 <code>Microservices</code> 本身就是一个非显性的价值，作为售卖的对象来说，可能并不是一个良好的对象。</p>
<div>
    <label class="author-mark-label">作者有话说</label>
    <p class="author-mark">我认为，Devops是一套企业的流程优化，华为40亿师从IBM，也是因为IBM有着壮士断腕的气魄且成功了，如果隔壁老王给你讲Devops，你可能就不会相信。毕竟是非经过不知难，想要给别人讲Devops，没实践是不行的。</p>
</div>
<h2 id="为何需要微服务"><a class="header-anchor" href="#为何需要微服务">¶</a>为何需要微服务</h2>
<p>从技术层面上想微服务，那就是锤子的眼里都是钉子。我们先来看看现代的应用特性。</p>
<h3 id="现代应用"><a class="header-anchor" href="#现代应用">¶</a>现代应用</h3>
<p>在 2020 年，人类迈入信息科技时代多年之后，我们对于应用的需求依然保持着朴质的需求，健壮性，安全性，高效性。但是变化的是经过这么多年的信息化熏陶，我们对于系统的易用性提出了更多的要求，可以理解成，我们对于软件性本身的要求没有本质上的变化，但是由于业务系统复杂化，现代应用所需要面临的是在如何在规模化的业务诉求下依然保持着较高软件特性 <a href="#refer-anchor-5"><sup>参考5</sup></a>。</p>
<p>可能上面的话有些抽象，说起来举一些例子</p>
<ul>
<li>淘宝商城因为功能变的越来越多导致代码激增，单一仓库连提交代码都是困难</li>
<li>因为用户规模的激增我们需要更大的吞吐量</li>
<li>因为定时秒杀的场景，我们需要更加适合的弹性扩容的基础设施等</li>
</ul>
<h3 id="现代软件的应对之策"><a class="header-anchor" href="#现代软件的应对之策">¶</a>现代软件的应对之策</h3>
<p>现代应用因为需要解决上面所列出的问题，所以不得不在最终的软件架构上做出妥协。</p>
<ul>
<li>单体应用太大不好改 -&gt; 拆分服务化</li>
<li>用户规模太大 -&gt; 分布式</li>
<li>流量不均衡 -&gt; 易于弹性伸缩</li>
</ul>
<p>但是显然一步不能走完所有的路。新的解决之道又往往带来新的问题。<code>分布式</code> 架构带来的高可用的问题，<code>弹性伸缩</code> 又依赖完善的 <code>基础设施</code>，但是如同 <code>Martin</code> 所言，这一切都是向着更正向的反馈，我们努力攻克下这些问题，诞生了<code>容器化</code>，所以就促成了 <a href="https://12factor.net/"><code>The Twelve-Factor App</code></a> <a href="https://www.habitat.sh/about/what-is-modern-app/"><code>Modern App</code></a> 这一些范式。</p>
<p>从上面我们可以看出整个技术的进步脉络：</p>
<p style="color: #000000; font-family: 'Raleway',sans-serif; font-size: 20px; font-weight: 800; line-height: 72px; margin: 0 0 24px; text-align: center; text-transform: uppercase; ">
业 务 复 杂 度 上 升 --> 技 术 尝 试 解 决 --> 形 成 最 佳 实 践
</p>
<h3 id="微服务"><a class="header-anchor" href="#微服务">¶</a>微服务</h3>
<p>从朴质的逻辑中可以简单的定义出，<code>微服务</code> 即是当前在特定规模下的软件形态的最佳实践。</p>
<div>
    <label class="author-mark-label">作者有话说</label>
    <p class="author-mark">到底多大的规模应该微服务化，这并没有标准答案，但是我认为有两点是值得肯定的，1. 如果现有的软件架构不能够完全满足业务的需求，就可以尝试微服务。2. 如果现在体系还不可以，也可以试试微服务架构也许会有一些新收获。</p>
</div>
<p>至于微服务的优势，烦请大家<code>Google</code>一下，就不做展开。</p>
<h1>What：什么是微服务的形态</h1>
<p><img src="https://s3.jpg.cm/2020/07/08/ULPIr.png" alt="ULPIr.png"></p>
<blockquote>
<p>《涅槃经》卷三○载：“其触牙者，即言象形如莱茯根（萝卜）；其触耳者，言象如箕；其触头者，言象如石；其触鼻者，言象如杵；其触脚者，言象如木臼；其触脊者，言象如床；其触腹者，言象如瓮；其触尾者，言象如绳。”</p>
</blockquote>
<!-- more -->
<p>微服务是什么，我们将微服务的特征已经在 <a href="2020/07/07/architecture/microservice/mircoservices-why/"><code>微服务：Why</code></a> 定义清楚，我们下一步看看更为具型的形态。</p>
<h2 id="微服务的形态"><a class="header-anchor" href="#微服务的形态">¶</a>微服务的形态</h2>
<p>其实对于微服务的形态，<code>Chris Richardson</code> 在 <a href="https://microservices.io/patterns/cn/microservices.html">微服务架构</a> 中已经罗列的非常的清晰了。我在这里将一些比较核心的东西再加一些个人的思考重试一下。</p>
<p><img src="https://s3.jpg.cm/2020/07/08/ULtNW.png" alt="ULtNW.png"></p>
<h3 id="服务发现"><a class="header-anchor" href="#服务发现">¶</a>服务发现</h3>
<p><img src="https://s3.jpg.cm/2020/07/08/ULN02.png" alt="ULN02.png"></p>
<p>因为微服务架构天生会导致部署的实例变多，服务实例的动态变迁这件事情还是需要自动化的。业界的实现模式常见为</p>
<ul>
<li><code>Spring Cloud Discovery</code> 基于 <code>Eureka</code> 这样的独立的服务发现软件</li>
<li><code>Kubernetes DNS</code>：因为 K8s 本身可以感知 POD 的变迁，因此直接从 <code>Api server</code> 获得也很正常</li>
</ul>
<p><img src="https://s3.jpg.cm/2020/07/08/ULrbL.png" alt="ULrbL.png"></p>
<div>
    <label class="author-mark-label">作者有话说</label>
    <p class="author-mark">不过因为 DNS 本身就是一个很不错的分布式系统套件，其实从个人角度看，我认为第二个方案还是更适合。并且有大量的新技术也是基于此技术，比如 SericeMesh，可以选的选择此方案更靠谱点。</p>
</div>
<h3 id="配置信息外部化"><a class="header-anchor" href="#配置信息外部化">¶</a>配置信息外部化</h3>
<p>上 <a href="https://github.com/ctripcorp/apollo"><code>apollo</code></a> <a href="https://github.com/alibaba/nacos"><code>nacos</code></a> <code>configmap</code></p>
<p>其实从经验看起来，在小规模的情况下，<code>Kubernetes</code> 自带的 <code>configmap</code> 反而是最好用的。</p>
<h3 id="API-网关"><a class="header-anchor" href="#API-网关">¶</a>API 网关</h3>
<p><img src="https://s3.jpg.cm/2020/07/08/ULsof.png" alt="ULsof.png"></p>
<p>API 网关是一个非常可以标准化的市场，有成熟产品的 <code>Tyk</code> <code>Kong</code>，有框架性质的 <code>Spring Gateway</code>等等，这块直接选择一个自己看着爽的用就好了，其实也没多大区别。</p>
<h3 id="熔断器"><a class="header-anchor" href="#熔断器">¶</a>熔断器</h3>
<p><img src="https://s3.jpg.cm/2020/07/08/ULEDU.png" alt="ULEDU.png"><br>
熔断器其实蛮适合从 <code>Service Mesh</code> 做的。</p>
<h3 id="链路追踪"><a class="header-anchor" href="#链路追踪">¶</a>链路追踪</h3>
<p><img src="https://s3.jpg.cm/2020/07/08/ULk6O.png" alt="ULk6O.png"></p>
<hr>
<p>Wait… 停住，为什么微服务有这么多的 <code>Pattern</code> ，不知道读者朋友们有没有疑问。我在初步接触微服务的时候，我也常常会有这样的疑问，当我搞清楚微服务其实只是一组最佳实践之后我就明白了，这些东西是其他的架构师同行们在多次的实践的过程中帮我们抽象出来的 <code>最佳模式</code>，而我们也并非是要去背上这些模式再去设计微服务架构，我们也是因为在实践的过程中遇见自己的问题之后才对症找药。</p>
<blockquote>
<p>过早的优化是一切罪恶的根源。  – by: Donald.Knuth</p>
</blockquote>
<h1>How：如何落地微服务</h1>
<p><img src="https://s3.jpg.cm/2020/07/08/ULAUp.png" alt="ULAUp.png"></p>
<p>讲完那么多的理论，我们终于到了落地的阶段，微服务怎么落地，这是大概是我们最有价值的事情了（因为微服务最有价值的恰恰就是最佳实践）。</p>
<h2 id="准则"><a class="header-anchor" href="#准则">¶</a>准则</h2>
<ul>
<li>微服务没有标准答案，阿里的微服务不一定适应所有人</li>
<li>记住微服务的第一特性：面向业务</li>
<li>微服务架构是进步式的</li>
</ul>
<blockquote>
<p>因为本章需要大量的实践经验，因地制宜</p>
</blockquote>
<h2 id="实践步骤"><a class="header-anchor" href="#实践步骤">¶</a>实践步骤</h2>
<p><img src="https://s3.jpg.cm/2020/07/08/ULJ5S.png" alt="ULJ5S.png"></p>
<div id="step-1"></div>
<h3 id="Step-1-业务梳理"><a class="header-anchor" href="#Step-1-业务梳理">¶</a>Step 1: 业务梳理</h3>
<p>将现有的业务进行梳理，业务专家或者测试专家，甚至于使用者都可以，我们需要将整个业务系统完整的展示在大家面前。</p>
<p>输出物: <code>业务流程报告</code> <code>用户故事以及用户故事地图</code></p>
<h3 id="Step-2：业务建模"><a class="header-anchor" href="#Step-2：业务建模">¶</a>Step 2：业务建模</h3>
<p>业务架构师进场，分析客户的业务，我们需要将业务划分为相对独立的业务单元，我们可以利用 <a href="https://book.douban.com/subject/25844633/">实现领域驱动设计（DDD）</a> 的技术进行划分。在此阶段一定要忘记你所拥有的技术，在此阶段我们的目标是明确的将业务划分单元。尽可能的保证 <code>保证单一业务服务高效聚合</code> <code>降低服务间的相互调用</code></p>
<p>输出物: <code>业务划分地图</code> <code>业务交互图</code></p>
<h3 id="Step-3：基础设施建设"><a class="header-anchor" href="#Step-3：基础设施建设">¶</a>Step 3：基础设施建设</h3>
<p>对于一个微服务系统，我们先看一下最简单的系统构成<br>
<img src="https://s3.jpg.cm/2020/07/08/ULcxT.png" alt="ULcxT.png"><br>
从这张图中，我们至少可以发现我们需要为这些服务准备好异步通讯的 <code>MQ</code>，和统一对外暴露的 <code>BFF</code>，并且和调用这些系统的 <code>Docker 治理平台</code>，当我们展开内部的微服务的时候</p>
<p><img src="https://s3.jpg.cm/2020/07/08/ULb6E.png" alt="ULb6E.png"></p>
<p>我们又看到了不同的数据库。因此我们首先要需要设计出这样的一套架构图。并且将这套系统内非业务属性的单元都作为基础设计进行建设。</p>
<p>常见的基础设施 <code>KV</code> <code>Databse</code> <code>Search Engine</code> <code>Steam</code> <code>Monitoring</code> <code>Tracing</code> <code>Message Queue</code> <code>Container Orchestration</code> <code>CICD</code> 等等</p>
<p>这在企业内部并不是一个很有价值的事情，但是又是耗时最多，并且在后期大部分时候大家都在忙不迭的处理这些系统的HA问题，建议大家在初期阶段就能够做完性能测试。</p>
<h3 id="Step-4：Runtime技术选型"><a class="header-anchor" href="#Step-4：Runtime技术选型">¶</a>Step 4：Runtime技术选型</h3>
<p>不同的 <code>modules</code> 自然有不同的选型，针对 <code>Go体系</code> <code>Java体系</code> 在自己的领域选择热门的技术即可。<br>
<code>Java体系</code> 选择 <code>Spring Cloud</code> 就是一个相对比较好的选择。不过也需要参考本企业内的技术专家的<code>技术体系</code>。</p>
<h3 id="Step-5-构建系统"><a class="header-anchor" href="#Step-5-构建系统">¶</a>Step 5: 构建系统</h3>
<p>按照各种范式构建系统即可。</p>
<h3 id="Step-6：持续迭代"><a class="header-anchor" href="#Step-6：持续迭代">¶</a>Step 6：持续迭代</h3>
<p><a href="#step-1">Go to Step 1</a></p>
<h2 id="关于咨询"><a class="header-anchor" href="#关于咨询">¶</a>关于咨询</h2>
<p>实际上在这一块，无论是国内外都是让参与过微服务改造的工程师对需求方进行量体裁衣。实际上并不会有什么特别的地方，这里的内容非常的像：</p>
<blockquote>
<p><a href="https://baike.baidu.com/item/%E7%8E%8B%E5%88%9A/23623830"><code>王刚</code></a>也是这么做菜的，但是你做就是不好吃的状态。</p>
</blockquote>
<p>此之过程具有价值的乃是经验，而师傅只能教你怎么做菜。</p>
<div>
    <label class="author-mark-label">作者有话说</label>
    <p class="author-mark">切记方法论千千万，八仙过海，各显神通。</p>
</div>
<h1>参考</h1>
<p><a href="https://www.ibm.com/developerworks/cn/cloud/library/cl-evolution-microservices-patterns/index.html" id="refer-anchor-1">1. 寻根溯源：微服务模式发展简史</a><br>
<a href="https://martinfowler.com/articles/microservices.html" id="refer-anchor-2">2. microservices</a><br>
<a href="http://blog.cuicc.com/blog/2015/07/22/microservices" id="refer-anchor-3">3. 微服务架构</a><br>
<a href="https://zhuanlan.zhihu.com/p/86726169" id="refer-anchor-4">4. DevOps是如何实现效率的提升</a><br>
<a href="https://zhuanlan.zhihu.com/p/32559028" id="refer-anchor-5">5. 基于服务的架构对现代软件设计的影响</a><br>
<a href="https://www.infoq.cn/article/D-cBEauI4oTVqwUsx5Fk" id="refer-anchor-6">6. 微服务落地，我们在考虑什么</a><br>
<a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/microservice-application-design" id="refer-anchor-7">7. Design a microservice-oriented application</a><br>
<a href="http://blog.itpub.net/31562044/viewspace-2650826/" id="refer-anchor-8">8. 从300万行到50万行代码，遗留系统的微服务改造</a><br>
<a href="https://scottrogowski.com/the-seven-deceptions-of-microservices" id="refer-anchor-9">9.The seven deceptions of microservices</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>architecture</category>
        <category>mircoservice</category>
      </categories>
      <tags>
        <tag>architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>Motan源码分析</title>
    <url>/2018/06/30/java/motan/motan/</url>
    <content><![CDATA[<h1>Motan</h1>
<p><code>Motan</code> 是一套基于java开发的RPC框架，除了常规的点对点调用外，<code>Motan</code> 还提供服务治理功能，包括服务节点的自动发现、摘除、高可用和负载均衡等。<code>Motan</code> 具有良好的扩展性，主要模块都提供了多种不同的实现，例如支持多种注册中心，支持多种rpc协议等。（可以看作 <code>Dubbo</code> 的复刻版）</p>
<p><a href="#%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90">跳过介绍</a></p>
<span id="more"></span>


<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<h2 id="Montan架构"><a class="header-anchor" href="#Montan架构">¶</a>Montan架构</h2>
<p><code>Motan</code> 中分为服务提供方(RPC Server)，服务调用方(RPC Client)和服务注册中心(Registry)三个角色。<br>
<img src="https://s1.ax1x.com/2018/06/30/PFWib4.png" alt="arch-motan)"></p>
<h2 id="模块概述"><a class="header-anchor" href="#模块概述">¶</a>模块概述</h2>
<p>Motan框架中主要有 <code>register</code>、<code>transport</code>、<code>serialize</code>、<code>protocol</code>几个功能模块，各个功能模块都支持通过SPI进行扩展，各模块的交互如下图所示：<br>
<img src="https://s1.ax1x.com/2018/06/30/PFWkVJ.png" alt="motan-models"></p>
<ul>
<li>
<p><code>register</code>: 用来和注册中心进行交互，包括注册服务、订阅服务、服务变更通知、服务心跳发送等功能；Server端会在系统初始化时通过register模块注册服务，Client端在系统初始化时会通过register模块订阅到具体提供服务的Server列表，当Server 列表发生变更时也由register模块通知Client。</p>
</li>
<li>
<p><code>protocol</code>: 用来进行RPC服务的描述和RPC服务的配置管理，这一层还可以添加不同功能的filter用来完成统计、并发限制等功能。</p>
</li>
<li>
<p><code>serialize</code>: 将RPC请求中的参数、结果等对象进行序列化与反序列化，即进行对象与字节流的互相转换；默认使用对java更友好的hessian2进行序列化。</p>
</li>
<li>
<p><code>transport</code>:  用来进行远程通信，默认使用Netty nio的TCP长链接方式。</p>
</li>
<li>
<p><code>cluster</code>:  Client端使用的模块，cluster是一组可用的Server在逻辑上的封装，包含若干可以提供RPC服务的Server，实际请求时会根据不同的高可用与负载均衡策略选择一个可用的Server发起远程调用。</p>
</li>
</ul>
<p>在进行RPC请求时，Client通过代理机制调用cluster模块，cluster根据配置的HA和LoadBalance选出一个可用的Server，通过serialize模块把RPC请求转换为字节流，然后通过transport模块发送到Server端。</p>
<h2 id="Demo-without-Spring"><a class="header-anchor" href="#Demo-without-Spring">¶</a>Demo without Spring</h2>
<p>一切代码的开始总是从Demo开始的</p>
<div class="tabs" id="sample-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#sample-unique-name-1">Motan Server端</a></li><li class="tab"><a href="#sample-unique-name-2">Motan Client端</a></li><li class="tab"><a href="#sample-unique-name-3">接口定义</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sample-unique-name-1"><p>这段代码可以说是最为简单的Server端了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MotanServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 使用代码形式实现, 可以不使用spring 容器</span></span><br><span class="line">        ServiceConfig&lt;MotanDemoService&gt; motanDemoService = <span class="keyword">new</span> <span class="title class_">ServiceConfig</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 配置端口及实现类</span></span><br><span class="line">        motanDemoService.setInterface(MotanDemoService.class);</span><br><span class="line">        motanDemoService.setRef(<span class="keyword">new</span> <span class="title class_">MotanDemoServiceImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 配置服务的group及版本号</span></span><br><span class="line">        motanDemoService.setGroup(<span class="string">&quot;motan-demo-rpc&quot;</span>);</span><br><span class="line">        motanDemoService.setVersion(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 配置 注册中心</span></span><br><span class="line">        <span class="type">RegistryConfig</span> <span class="variable">directRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryConfig</span>();</span><br><span class="line">        directRegistry.setRegProtocol(<span class="string">&quot;local&quot;</span>);</span><br><span class="line">        directRegistry.setCheck(<span class="string">&quot;false&quot;</span>); <span class="comment">//不检查是否注册成功</span></span><br><span class="line">        motanDemoService.setRegistry(directRegistry);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 配置RPC协议</span></span><br><span class="line">        <span class="type">ProtocolConfig</span> <span class="variable">protocol</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolConfig</span>();</span><br><span class="line">        protocol.setId(<span class="string">&quot;motan&quot;</span>);</span><br><span class="line">        protocol.setName(<span class="string">&quot;motan&quot;</span>);</span><br><span class="line">        motanDemoService.setProtocol(protocol);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 配置协议:端口 和输出</span></span><br><span class="line">        motanDemoService.setApplication(<span class="string">&quot;motan&quot;</span>);</span><br><span class="line">        motanDemoService.setExport(<span class="string">&quot;motan:8002&quot;</span>);</span><br><span class="line">        motanDemoService.export();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 设置心跳</span></span><br><span class="line">        MotanSwitcherUtil.setSwitcherValue(MotanConstants.REGISTRY_HEARTBEAT_SWITCHER, <span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;server start...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sample-unique-name-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MotanClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 引用配置</span></span><br><span class="line">        RefererConfig&lt;MotanDemoService&gt; motanDemoServiceReferer = <span class="keyword">new</span> <span class="title class_">RefererConfig</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 设置接口及实现类</span></span><br><span class="line">        motanDemoServiceReferer.setInterface(MotanDemoService.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 配置服务的group以及版本号</span></span><br><span class="line">        motanDemoServiceReferer.setGroup(<span class="string">&quot;motan-demo-rpc&quot;</span>);</span><br><span class="line">        motanDemoServiceReferer.setVersion(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">        motanDemoServiceReferer.setRequestTimeout(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 配置注册中心直连调用</span></span><br><span class="line">         <span class="type">RegistryConfig</span> <span class="variable">directRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryConfig</span>();</span><br><span class="line">         directRegistry.setRegProtocol(<span class="string">&quot;local&quot;</span>);</span><br><span class="line">         directRegistry.setPort(<span class="number">8002</span>);</span><br><span class="line">         motanDemoServiceReferer.setRegistry(directRegistry);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 5. 配置RPC 协议</span></span><br><span class="line">        <span class="type">ProtocolConfig</span> <span class="variable">protocol</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolConfig</span>();</span><br><span class="line">        protocol.setId(<span class="string">&quot;motan&quot;</span>);</span><br><span class="line">        protocol.setName(<span class="string">&quot;motan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        motanDemoServiceReferer.setProtocol(protocol);</span><br><span class="line">        motanDemoServiceReferer.setDirectUrl(<span class="string">&quot;localhost:8002&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 使用服务调用</span></span><br><span class="line">        <span class="type">MotanDemoService</span> <span class="variable">service</span> <span class="operator">=</span> motanDemoServiceReferer.getRef();</span><br><span class="line">        System.out.println(service.hello(<span class="string">&quot;motan&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sample-unique-name-3"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MotanDemoService</span> &#123;</span><br><span class="line">    String <span class="title function_">hello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MotanDemoServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MotanDemoService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello-&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p>执行结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">by-motan-motan</span><br></pre></td></tr></table></figure>
<h1>启动分析</h1>
<h2 id="启动流程分析"><a class="header-anchor" href="#启动流程分析">¶</a>启动流程分析</h2>
<p>我们从上面的代码可以看出来，在服务侧的代码中，大部分都是在声明，在 <code>motanDemoService.export();</code>这部才是开始执行暴露出 <code>RPC</code> 接口的行为，我们从这里作为一个突破口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">export</span><span class="params">()</span> &#123;</span><br><span class="line">    checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line">    List&lt;URL&gt; registryUrls = loadRegistryUrls(); ➊</span><br><span class="line">    Map&lt;String, Integer&gt; protocolPorts = getProtocolAndPort();</span><br><span class="line">    <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">port</span> <span class="operator">=</span> protocolPorts.get(protocolConfig.getId());</span><br><span class="line">        <span class="keyword">if</span> (port == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Skip</span></span><br><span class="line">        &#125;</span><br><span class="line">        doExport(protocolConfig, port, registryUrls); ➋</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    afterExport(); ➌</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑很清晰<br>
➊ 载入注册中心的地址<br>
➋ 真实暴露接口的行为，我们从这里继续分析下去<br>
➌ 暴露之后的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doExport</span><span class="params">(ProtocolConfig protocolConfig, <span class="type">int</span> port, List&lt;URL&gt; registryURLs)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">protocolName</span> <span class="operator">=</span> protocolConfig.getName();    </span><br><span class="line">    <span class="type">String</span> <span class="variable">hostAddress</span> <span class="operator">=</span> host;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    collectConfigParams(map, protocolConfig, basicService, extConfig, <span class="built_in">this</span>);</span><br><span class="line">    collectMethodConfigParams(map, <span class="built_in">this</span>.getMethods());</span><br><span class="line"></span><br><span class="line">    <span class="type">URL</span> <span class="variable">serviceUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(protocolName, hostAddress, port, interfaceClass.getName(), map);</span><br><span class="line">    List&lt;URL&gt; urls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// injvm 协议只支持注册到本地，其他协议可以注册到local、remote</span></span><br><span class="line">    <span class="keyword">if</span> (MotanConstants.PROTOCOL_INJVM.equals(protocolConfig.getId())) &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">localRegistryUrl</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (URL ru : registryURLs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (MotanConstants.REGISTRY_PROTOCOL_LOCAL.equals(ru.getProtocol())) &#123;</span><br><span class="line">                localRegistryUrl = ru.createCopy();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        urls.add(localRegistryUrl);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (URL ru : registryURLs) &#123;</span><br><span class="line">            urls.add(ru.createCopy());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (URL u : urls) &#123; ➊</span><br><span class="line">        u.addParameter(URLParamType.embed.getName(), StringTools.urlEncode(serviceUrl.toFullStr()));</span><br><span class="line">        registereUrls.add(u.createCopy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ConfigHandler</span> <span class="variable">configHandler</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(ConfigHandler.class).getExtension(MotanConstants.DEFAULT_VALUE);   ➋</span><br><span class="line"></span><br><span class="line">    exporters.add(configHandler.export(interfaceClass, ref, urls)); ➌</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 之前的代码都在在准备对象的URL，这个的URL是Motan自己实现的，在此处将URL收集起来<br>
➋ 通过SPI技术载入 <code>ConfigHandler</code> 对象<br>
➌ 暴露出接口并将其在 <code>exporters</code> 管理起来</p>
<p>我们来看看 <code>Exporter</code> 的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Exporter</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Provider&lt;T&gt; <span class="title function_">getProvider</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unexport</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2018/07/05/PZ93Y4.png" alt=""></p>
<p>原来 <code>Exporter</code> 是 <code>Provider</code> 的包装对象。迄今为止，我们值得启动流程为下图</p>
<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: Motan启动流程',
	 'ServiceConfig->ConfigHandler: 1. export(interfaceClass, ref, urls)',
	 'ConfigHandler->ServiceConfig: 2. exporters.add()',
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>
<h2 id="课间补习-SPI"><a class="header-anchor" href="#课间补习-SPI">¶</a>课间补习 SPI</h2>
<p><code>Java Service Provider</code> 主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，mysql和postgresql都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。</p>
<blockquote>
<p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader。 By 《Java中SPI机制深入及源码解析》<br>
关于详细的内容可以参考上文引用的博文 <a href="https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Java中SPI机制深入及源码解析</a></p>
</blockquote>
<h2 id="继续前进"><a class="header-anchor" href="#继续前进">¶</a>继续前进</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Exporter&lt;T&gt; <span class="title function_">export</span><span class="params">(Class&lt;T&gt; interfaceClass, T ref, List&lt;URL&gt; registryUrls)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceStr</span> <span class="operator">=</span> StringTools.urlDecode(registryUrls.get(<span class="number">0</span>).getParameter(URLParamType.embed.getName()));</span><br><span class="line">    <span class="type">URL</span> <span class="variable">serviceUrl</span> <span class="operator">=</span> URL.valueOf(serviceStr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// export service</span></span><br><span class="line">    <span class="comment">// 利用protocol decorator来增加filter特性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">protocolName</span> <span class="operator">=</span> serviceUrl.getParameter(URLParamType.protocol.getName(), URLParamType.protocol.getValue());</span><br><span class="line">    <span class="type">Protocol</span> <span class="variable">orgProtocol</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(protocolName); ➊</span><br><span class="line">    Provider&lt;T&gt; provider = getProvider(orgProtocol, ref, serviceUrl, interfaceClass);</span><br><span class="line"></span><br><span class="line">    <span class="type">Protocol</span> <span class="variable">protocol</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolFilterDecorator</span>(orgProtocol); ➋</span><br><span class="line">    Exporter&lt;T&gt; exporter = protocol.export(provider, serviceUrl); ➌</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register service</span></span><br><span class="line">    register(registryUrls, serviceUrl); ➍</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 又是熟悉的 <code>ExtensionLoader</code> 我们再次通过 <code>SPI</code> 获得我们的 <code>Protocal</code>，这里开始 <code>Protocal</code>有了多种实现，包括 <code>RPC</code>, <code>InJVM</code>, <code>Motan2</code> 等<br>
➋ 我们将  <code>Protocol</code> 包裹为 <code>ProtocolFilterDecorator</code> <a href="#Motan-Filter-%E6%9C%BA%E5%88%B6">Motan Filter 机制</a><br>
➌ 将 <code>Protocol</code> 包裹为 <code>ProtocolFilterDecorator</code> 并发布出来 <a href="#Motan-Filter-%E6%9C%BA%E5%88%B6">Motan 注册机制</a><br>
➍ 将服务注册到服务发现上</p>
<h2 id="Motan-Filter-机制"><a class="header-anchor" href="#Motan-Filter-机制">¶</a>Motan Filter 机制</h2>
<blockquote>
<p>Filter 发送/接收请求过程中增加切面逻辑，默认提供日志统计等功能<br>
Filter 是 Motan 很重要的一个实现接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Exporter&lt;T&gt; <span class="title function_">export</span><span class="params">(Provider&lt;T&gt; provider, URL url)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> protocol.export(decorateWithFilter(provider, url), url); <span class="comment">//将 provider 包装</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; Provider&lt;T&gt; <span class="title function_">decorateWithFilter</span><span class="params">(<span class="keyword">final</span> Provider&lt;T&gt; provider, URL url)</span> &#123;</span><br><span class="line">    List&lt;Filter&gt; filters = getFilters(url, MotanConstants.NODE_TYPE_SERVICE); ➊</span><br><span class="line">    <span class="keyword">if</span> (filters == <span class="literal">null</span> || filters.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line">    Provider&lt;T&gt; lastProvider = provider; ➋</span><br><span class="line">    <span class="keyword">for</span> (Filter filter : filters) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Filter</span> <span class="variable">f</span> <span class="operator">=</span> filter;</span><br><span class="line">        <span class="keyword">if</span> (f <span class="keyword">instanceof</span> InitializableFilter) &#123;</span><br><span class="line">            ((InitializableFilter) f).init(lastProvider);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Provider&lt;T&gt; lp = lastProvider;</span><br><span class="line">        lastProvider = <span class="keyword">new</span> <span class="title class_">Provider</span>&lt;T&gt;() &#123; ➌</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Response <span class="title function_">call</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> f.filter(lp, request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//SKIP</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastProvider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 这里其实是老朋友了 <code>SPI</code> 去读取了 <code>Filter</code> 的实现<br>
➋ 遍历每一个 Filter 让他们串联起来<br>
➌ 未每个Filter 创建一个 匿名的 <code>Provider</code> 让他们变成一个 <code>Chain</code></p>
<p><img src="https://s1.ax1x.com/2018/07/05/PVz3Yd.png" alt="Provider-Chain"></p>
<div style="width:100%; overflow-y:scroll;" id="diagram2"></div>
<script>
	var data2 =
	['Title: Motan启动流程',
	 'ServiceConfig->ConfigHandler: 1. export',
     'ConfigHandler->ConfigHandler: 2. 获得Protocol实现',
     'ConfigHandler->ConfigHandler: 3. Protocol 创建 Provider',
     'ConfigHandler->ProtocolFilterDecorator: 4. 构建Protocol Chain',
     'ConfigHandler->Protocol: 5. export',
	 'ConfigHandler->RegistryFactory: 6. register',
    ].join('\n');
  	var diagram2 = Diagram.parse(data2);
  	diagram2.drawSVG("diagram2", {theme: 'simple', scale: 0.5});
</script>
<h2 id="Motan-注册机制"><a class="header-anchor" href="#Motan-注册机制">¶</a>Motan 注册机制</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(List&lt;URL&gt; registryUrls, URL serviceUrl)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (URL url : registryUrls) &#123;</span><br><span class="line">        <span class="comment">// 根据check参数的设置，register失败可能会抛异常，上层应该知晓</span></span><br><span class="line">        <span class="type">RegistryFactory</span> <span class="variable">registryFactory</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(RegistryFactory.class).getExtension(url.getProtocol()); ➊</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> registryFactory.getRegistry(url);</span><br><span class="line">        registry.register(serviceUrl); ➋</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 依然通过 <code>SPI</code> 获得 <code>RegistryFactory</code><br>
➋ 根据 <code>URL</code> 获得 <code>Registry</code>并注册</p>
<h2 id="export-接口"><a class="header-anchor" href="#export-接口">¶</a>export 接口</h2>
<p><code>com.weibo.api.motan.protocol.AbstractProtocol#export</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Exporter&lt;T&gt; <span class="title function_">export</span><span class="params">(Provider&lt;T&gt; provider, URL url)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">protocolKey</span> <span class="operator">=</span> MotanFrameworkUtil.getProtocolKey(url);</span><br><span class="line">    <span class="keyword">synchronized</span> (exporterMap) &#123;</span><br><span class="line">        Exporter&lt;T&gt; exporter = (Exporter&lt;T&gt;) exporterMap.get(protocolKey);</span><br><span class="line">        exporter = createExporter(provider, url); ➊</span><br><span class="line">        exporter.init(); ➋</span><br><span class="line"></span><br><span class="line">        exporterMap.put(protocolKey, exporter); ➌</span><br><span class="line">        <span class="keyword">return</span> exporter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 这里将必要的数据传入创建一个 <code>Exporter</code><br>
➋ 最终初始化的地方 <code>Exporter</code> 执行初始化行为<br>
➌ <strong>敲黑板</strong> 这里这里将我们的 <code>protocolKey</code> 和 <code>exporter</code> 关联起来，也就是真实的 <code>Mapping</code> 关系</p>
<p>如果不慎注意，我们会忽略这里，其实在 <code>createExporter</code>中 <code>Motan</code>做了相当多的事情。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultRpcExporter</span><span class="params">(Provider&lt;T&gt; provider, URL url, ConcurrentHashMap&lt;String, ProviderMessageRouter&gt; ipPort2RequestRouter,</span></span><br><span class="line"><span class="params">                              ConcurrentHashMap&lt;String, Exporter&lt;?&gt;&gt; exporterMap)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(provider, url);</span><br><span class="line">    <span class="built_in">this</span>.exporterMap = exporterMap;</span><br><span class="line">    <span class="built_in">this</span>.ipPort2RequestRouter = ipPort2RequestRouter;</span><br><span class="line"></span><br><span class="line">    <span class="type">ProviderMessageRouter</span> <span class="variable">requestRouter</span> <span class="operator">=</span> initRequestRouter(url); ➊</span><br><span class="line">    endpointFactory =</span><br><span class="line">            ExtensionLoader.getExtensionLoader(EndpointFactory.class).getExtension(</span><br><span class="line">                    url.getParameter(URLParamType.endpointFactory.getName(), URLParamType.endpointFactory.getValue())); ➋</span><br><span class="line">    server = endpointFactory.createServer(url, requestRouter); ➌</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 根据 <code>url</code> 我们初始化了 <code>ProviderMessageRouter</code> 而 <code>ProviderMessageRouter</code> 是一个 <code>MessageHandler</code> 在后续的 <code>NettyServer</code> 会被使用到<br>
➋ 老朋友的 <code>SPI</code><br>
➌ 这里的 <code>server</code> 我们可以发现 只有一个的 <code>NettyServer</code> 实现，想必是为了后续可以支持多种 <code>Web</code> 框架</p>
<p>在  <code>createServer</code> 的时候还会 构造 <code>Codec</code>，也是一个拓展点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.weibo.api.motan.transport.AbstractServer#AbstractServer(com.weibo.api.motan.rpc.URL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AbstractServer</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.url = url;</span><br><span class="line">    <span class="built_in">this</span>.codec =</span><br><span class="line">            ExtensionLoader.getExtensionLoader(Codec.class).getExtension(</span><br><span class="line">                    url.getParameter(URLParamType.codec.getName(), URLParamType.codec.getValue()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现 我们最终操作的是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>;  <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>; <span class="comment">// 销毁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAvailable</span><span class="params">()</span>; <span class="comment">// 是否可用</span></span><br><span class="line">    String <span class="title function_">desc</span><span class="params">()</span>; <span class="comment">//描述信息</span></span><br><span class="line">    URL <span class="title function_">getUrl</span><span class="params">()</span>; <span class="comment">// 访问URL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而通过Debug发现我们知道我们最终调用的地方是<br>
<code>com.weibo.api.motan.protocol.rpc.DefaultRpcExporter#doInit</code><br>
我们发现很简单只做了一件事情</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">doInit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> server.open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就在 <code>Open</code> 函数中已经暴露了一切。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> minWorkerThread, maxWorkerThread;</span><br><span class="line">    standardThreadExecutor = (standardThreadExecutor != <span class="literal">null</span> &amp;&amp; !standardThreadExecutor.isShutdown()) ? standardThreadExecutor</span><br><span class="line">            : <span class="keyword">new</span> <span class="title class_">StandardThreadExecutor</span>(minWorkerThread, maxWorkerThread, workerQueueSize, <span class="keyword">new</span> <span class="title class_">DefaultThreadFactory</span>(<span class="string">&quot;NettyServer-&quot;</span> + url.getServerPortStr(), <span class="literal">true</span>));</span><br><span class="line">    standardThreadExecutor.prestartAllCoreThreads(); ➊</span><br><span class="line"></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                    pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">NettyDecoder</span>(codec, NettyServer.<span class="built_in">this</span>, maxContentLength)); ➋</span><br><span class="line">                    pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">NettyEncoder</span>()); ➌</span><br><span class="line">                    pipeline.addLast(<span class="string">&quot;handler&quot;</span>, <span class="keyword">new</span> <span class="title class_">NettyChannelHandler</span>(NettyServer.<span class="built_in">this</span>, messageHandler, standardThreadExecutor)); ➍</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;); </span><br><span class="line">    serverBootstrap.childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>);</span><br><span class="line">    serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(url.getPort()));</span><br><span class="line">    channelFuture.syncUninterruptibly(); ➎</span><br><span class="line">    serverChannel = channelFuture.channel();</span><br><span class="line">    state = ChannelState.ALIVE;</span><br><span class="line">    StatsUtil.registryStatisticCallback(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> state.isAliveState(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 创建一个 <code>Work</code> 线程组<br>
➋ 构造 <code>Netty</code> 的 <code>Decoder</code> 处理器，是一个 <code>ByteToMessageDecoder</code><br>
➌ 构造 <code>Netty</code> 的 <code>Encoder</code> 处理器，是一个 <code>MessageToByteEncoder</code><br>
➍ 实际上的工作 <code>Handler</code> 在这里，而<code>Handler</code> 又是我们在 <code>Exporter</code> 中的 <code>ProviderMessageRouter</code></p>
<h2 id="启动顺序总结"><a class="header-anchor" href="#启动顺序总结">¶</a>启动顺序总结</h2>
<p>阅读到此处，我们已经分析完成了关于 <code>Motan Server</code> 的启动流程</p>
<div style="width:100%; overflow-y:scroll;" id="diagram3"></div>
<script>
	var data3 =
	['Title: Motan启动流程',
	 'ServiceConfig->ConfigHandler: 1. export',
     'ConfigHandler->ConfigHandler: 2. 获得Protocol实现',
     'ConfigHandler->ConfigHandler: 3. Protocol 创建 Provider',
     'ConfigHandler->ProtocolFilterDecorator: 4. 构建Protocol Chain',
     'ConfigHandler->Protocol: 5. export',
     'Protocol->Exporter: 6. create',
     'Exporter->Server: 7. create Server(Netty)',
     'Exporter->Exporter: 8. init',
     'Exporter->Exporter: 9. open Netty Server',
	 'ConfigHandler->RegistryFactory: 10. register',
    ].join('\n');
  	var diagram3 = Diagram.parse(data3);
  	diagram3.drawSVG("diagram3", {theme: 'simple', scale: 0.5});
</script>
<p>我们回归下至今我们知道  <code>服务端</code></p>
<ul>
<li>protocol</li>
<li>serialize</li>
<li>transport<br>
这三个模块是如何工作的，值得注意的正如架构图所示，我们最终在 <code>Netty</code> 暴露出来的是 <code>ProviderMessageRouter</code> 所以最终工作的是 <code>Provider</code> 对象，而 <code>Provider</code> 在 <code>Motan</code> 中被 <code>Protocol</code> 管理起来了，而在架构图上没有体现这一点。</li>
</ul>
<h2 id="Motan-Server-接受请求"><a class="header-anchor" href="#Motan-Server-接受请求">¶</a>Motan Server 接受请求</h2>
<p>在 <code>NettyChannelHandler</code> 中接受数据请求的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.weibo.api.motan.transport.netty4.NettyChannelHandler#processRequest</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, Request request)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">processStartTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = messageHandler.handle(channel, request); ➊</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="comment">//SKIP</span></span><br><span class="line">        &#125;</span><br><span class="line">        DefaultResponse response; ➋</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> DefaultResponse) &#123;</span><br><span class="line">            response = (DefaultResponse) result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response = <span class="keyword">new</span> <span class="title class_">DefaultResponse</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">        response.setRequestId(request.getRequestId());</span><br><span class="line">        response.setProcessTime(System.currentTimeMillis() - processStartTime);</span><br><span class="line">        sendResponse(ctx, response); ➌</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        RpcContext.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 处理请求<br>
➋ 包装成返回<br>
➌ 响应请求</p>
<p>而 <code>messageHandler</code> 即是我们传入的 <code>ProviderMessageRouter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">handle</span><span class="params">(Channel channel, Object message)</span> &#123;</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> (Request) message;</span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceKey</span> <span class="operator">=</span> MotanFrameworkUtil.getServiceKey(request);</span><br><span class="line">    Provider&lt;?&gt; provider = providers.get(serviceKey);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> provider.lookupMethod(request.getMethodName(), request.getParamtersDesc());</span><br><span class="line">    fillParamDesc(request, method);</span><br><span class="line">    processLazyDeserialize(request, method);</span><br><span class="line">    <span class="keyword">return</span> call(request, provider);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Response <span class="title function_">call</span><span class="params">(Request request, Provider&lt;?&gt; provider)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> provider.call(request);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="type">DefaultResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultResponse</span>();</span><br><span class="line">        response.setException(<span class="keyword">new</span> <span class="title class_">MotanBizException</span>(<span class="string">&quot;provider call process error&quot;</span>, e));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Call 的实现在 <code>Provider</code> 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">invoke</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="type">DefaultResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultResponse</span>();</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> lookupMethod(request.getMethodName(), request.getParamtersDesc());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> method.invoke(proxyImpl, request.getArguments());</span><br><span class="line">        response.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="comment">//SKIP</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">//SKIP</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递rpc版本和attachment信息方便不同rpc版本的codec使用。</span></span><br><span class="line">    response.setRpcProtocolVersion(request.getRpcProtocolVersion());</span><br><span class="line">    response.setAttachments(request.getAttachments());</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理消息这段代码非常的清晰也就是标准的 <code>Netty</code> 的处理流程，我们获得请求的的数据。</p>
<h1>模块详解</h1>
<p>经过上文的的分析，我们已经对 <code>Motan</code> 的整体架构有了一些了解，我们下面的篇幅将对不同的具体模块进行分析。</p>
<h2 id="Registry-模块详解"><a class="header-anchor" href="#Registry-模块详解">¶</a>Registry 模块详解</h2>
<p><img src="https://s1.ax1x.com/2018/07/08/PmGFN8.png" alt="Registry Interface"></p>
<p>我们从图上可以看出来，<code>Registry</code> 提供的是 <code>注册</code> 和 <code>发现</code> 两个功能，废话不多说，我们去看看源码，因为 <code>Registry</code> 有多种实现，我挑选一个 <code>ZooKeeper</code> 的分析下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.weibo.api.motan.registry.support.AbstractRegistry#register</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">    doRegister(removeUnnecessaryParmas(url.createCopy())); ➊</span><br><span class="line">    registeredServiceUrls.add(url);</span><br><span class="line">    <span class="comment">// available if heartbeat switcher already open</span></span><br><span class="line">    <span class="keyword">if</span> (MotanSwitcherUtil.isOpen(MotanConstants.REGISTRY_HEARTBEAT_SWITCHER)) &#123;</span><br><span class="line">        available(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 这里将URL注册到ZK之上，然后再下一行将 URL 缓存在本地。<br>
而我们这里的 <code>URL</code> 是 <code>Motan</code> 自定义的格式如<br>
<code>motan://192.168.31.26:8002/top.yannxia.java.demo.motan.MotanDemoService?group=motan-demo-rpc</code><br>
我们可以看出来它由 <code>协议部分(Motan)</code> <code>地址部分(192.168.31.26:8002)</code> <code>接口信息(top.yannxia.java.demo.motan.MotanDemoService)</code> <code>分组(group=motan-demo-rpc)</code> 构成</p>
<p>那秘密也就是在 <code>doRegister</code> 函数了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegister</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        serverLock.lock();</span><br><span class="line">        <span class="comment">// 防止旧节点未正常注销</span></span><br><span class="line">        removeNode(url, ZkNodeType.AVAILABLE_SERVER);</span><br><span class="line">        removeNode(url, ZkNodeType.UNAVAILABLE_SERVER);</span><br><span class="line">        createNode(url, ZkNodeType.UNAVAILABLE_SERVER); ➊ </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MotanFrameworkException</span>(String.format(<span class="string">&quot;Failed to register %s to zookeeper(%s), cause: %s&quot;</span>, url, getUrl(), e.getMessage()), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        serverLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 前面2行也就是将原有的阶段删除，比如在异常的宕机过程，导致的数据问题。然后将这个URL在 <code>ZK</code>上创建一个新的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createNode</span><span class="params">(URL url, ZkNodeType nodeType)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">nodeTypePath</span> <span class="operator">=</span> ZkUtils.toNodeTypePath(url, nodeType);</span><br><span class="line">    <span class="keyword">if</span> (!zkClient.exists(nodeTypePath)) &#123;</span><br><span class="line">        zkClient.createPersistent(nodeTypePath, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    zkClient.createEphemeral(ZkUtils.toNodePath(url, nodeType), url.toFullStr()); ➊</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 这样也很简单，只是将节点的信息在 <code>ZK</code> 创建出一个新的节点出来。</p>
<p>但是 <strong>问题</strong> 来了，我们只是将自己的 <code>URL</code>注册到 <code>ZK</code> 上，我们怎么知道其他人注册的服务呢？</p>
<p>这个秘密就在 <code>Cliet</code> 调用过程中的 <code>discoverService()</code> 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.weibo.api.motan.registry.zookeeper.ZookeeperRegistry#discoverService</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;URL&gt; <span class="title function_">discoverService</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">parentPath</span> <span class="operator">=</span> ZkUtils.toNodeTypePath(url, ZkNodeType.AVAILABLE_SERVER);</span><br><span class="line">        List&lt;String&gt; currentChilds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (zkClient.exists(parentPath)) &#123;</span><br><span class="line">            currentChilds = zkClient.getChildren(parentPath); ➊</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodeChildsToUrls(url, parentPath, currentChilds); ➋</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也没有什么太过于神奇的地方 ➊ 在这里通过 <code>ZK</code> 树形结构，获得父亲节点，在 ➋ 获得真正的URL地址，也就是我们注册到 <code>ZK</code> 上的那个URL值，其实拿到的是我们的 <code>Object</code> 的储存值，形如 <code>motan://192.168.31.26:8002/top.yannxia.java.demo.motan.MotanDemoService?protocol=motan&amp;application=motan&amp;refreshTimestamp=1531145421643&amp;id=motan&amp;nodeType=service&amp;export=motan:8002&amp;version=1.0&amp;group=motan-demo-rpc&amp;</code> 其中还包含了一些服务的元数据。</p>
<h2 id="结语"><a class="header-anchor" href="#结语">¶</a>结语</h2>
<p>本来想着把 <code>Motan</code> 都解读一遍，但是整体上来说 <code>Motan</code> 是毕竟成熟（架构很清晰） 的一个框架，大家自行阅读起来难度也不是很大，大部分的类都很少 <code>继承</code> 的过深，整体来说，<code>Motan</code>既满足了拓展性的要求，代码量也少，比较容易掌握。如果要打分，满分 100 分的话，<code>Motan</code> 也可以得 80 分以上，是一个值得初期学习的 <code>RPC</code> 框架。</p>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ul>
<li><a href="https://github.com/weibocom/motan/wiki/zh_userguide">用户手册</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
        <category>RPC</category>
        <category>Motan</category>
      </categories>
  </entry>
  <entry>
    <title>Spring的优雅停机</title>
    <url>/2020/05/31/java/spring/gracefully-shutdown/</url>
    <content><![CDATA[<p>优雅停机是指在停止应用时，执行的一系列保证应用正常关闭的操作。这些操作往往包括等待已有请求执行完成、关闭线程、关闭连接和释放资源等，优雅停机可以避免非正常关闭程序可能造成数据异常或丢失，应用异常等问题。优雅停机本质上是JVM即将关闭前执行的一些额外的处理代码。</p>
<span id="more"></span>
<p>一般来说，优雅停机主要处理</p>
<ul>
<li>池化资源的释放：数据库连接池，HTTP 连接池</li>
<li>在处理线程的释放：已经被连接的HTTP请求</li>
<li>隐形受影响的资源的处理：Eureka实例下线等</li>
</ul>
<h1>JVM 中的实现</h1>
<p>编程语言都会提供监听当前线程终结的函数，比如在Java中，我们可以通过如下操作监听我们的退出事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">ExitHook</span>());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Do something, will exit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExitHook</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;exiting. clear resources...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会得到如下的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Do something, will <span class="built_in">exit</span></span><br><span class="line">exiting. clear resources...</span><br></pre></td></tr></table></figure>
<p>聪明的你一定发现了，我们可以在 <code>ExitHook</code> 去处理那些资源的释放。那么，在实际应用中是如何体现优雅停机呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -15 pid </span><br></pre></td></tr></table></figure>
<p>通过该命令发送一个关闭信号给到jvm, 然后就开始执行 Shutdown Hook 了，但是值得注意的是不能够使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 pid</span><br></pre></td></tr></table></figure>
<p>如果这么干的话，相当于从OS方面直接将其所有的资源回收，类比一下好比强行断电，就没有任何进行优雅停机的机会了。不过这里是最简单的实现，在实际的工作中，我们会遇见各种情况：在清理退出的时候出现异常怎么处理？清理的时间过程怎么处理？等等问题。因此在Spring中，为了简化这样的操作已经帮助我们封装了一些。</p>
<h1>Spring 的模式</h1>
<p>让我们想想，Spring一个IOC容器，他能够管理的是收到其托管的对象，因此我们也可以很合理的想到我们需要定义托管对象的解构函数才能够被Spring在退出时释放，我们将问题简单化点，有三个事情是Spring需要解决的：</p>
<ul>
<li>Spring 需要值得 Runtime 在退出</li>
<li>Spring 知道需要释放哪些资源</li>
<li>Spring 需要知道如何释放资源</li>
</ul>
<p>因为 Spring 版本繁杂，以 <code>org.springframework.boot:2.1.14.RELEASE</code> 版本分析为例。</p>
<h2 id="Spring-的-Runtime-Hook"><a class="header-anchor" href="#Spring-的-Runtime-Hook">¶</a>Spring 的 Runtime Hook</h2>
<p>毕竟 Spring 也是 JVM 上的实现，这一切势必也依赖于 JVM 的 Shuthook，秘密就在 <code>org.springframework.context.support.AbstractApplicationContext#registerShutdownHook</code> 处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerShutdownHook</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.shutdownHook == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No shutdown hook registered yet.</span></span><br><span class="line">        <span class="built_in">this</span>.shutdownHook = <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (startupShutdownMonitor) &#123;</span><br><span class="line">                    doClose();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="built_in">this</span>.shutdownHook);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring-知道需要释放哪些资源"><a class="header-anchor" href="#Spring-知道需要释放哪些资源">¶</a>Spring 知道需要释放哪些资源</h2>
<p>回忆一下 <code>Spring Bean Lifecycle</code><br>
<img src="https://s1.ax1x.com/2020/05/31/t1Pm8S.png" alt="t1Pm8S.png"></p>
<p>没错，当 Spring Context 销毁的时候，会调用 <code>destroy()</code> 函数，实际上这行函数也非常的简单也就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.context.support.AbstractApplicationContext#destroy</span></span><br><span class="line"><span class="meta">@Deprecated</span> <span class="comment">//Spring 5 即将废弃</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        doClose();</span><br><span class="line">        <span class="comment">// If we registered a JVM shutdown hook, we don&#x27;t need it anymore now:</span></span><br><span class="line">        <span class="comment">// We&#x27;ve already explicitly closed the context.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.shutdownHook != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Runtime.getRuntime().removeShutdownHook(<span class="built_in">this</span>.shutdownHook);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                <span class="comment">// ignore - VM is already shutting down</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实则我们定位到最终的释放资源处就是 <code>org.springframework.context.support.AbstractApplicationContext#doClose</code> 函数，我们在尽情的分析一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doClose</span><span class="params">()</span> &#123;</span><br><span class="line">    LiveBeansView.unregisterApplicationContext(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Publish shutdown event.</span></span><br><span class="line">        publishEvent(<span class="keyword">new</span> <span class="title class_">ContextClosedEvent</span>(<span class="built_in">this</span>)); ➀</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Stop all Lifecycle beans, to avoid delays during individual destruction.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.lifecycleProcessor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lifecycleProcessor.onClose(); ➁</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception thrown from LifecycleProcessor on context close&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy all cached singletons in the context&#x27;s BeanFactory.</span></span><br><span class="line">    destroyBeans(); ➂</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close the state of this context itself.</span></span><br><span class="line">    closeBeanFactory(); ➃</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let subclasses do some final clean-up if they wish...</span></span><br><span class="line">    onClose(); ➄</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationListeners != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationListeners.clear();</span><br><span class="line">        <span class="built_in">this</span>.applicationListeners.addAll(<span class="built_in">this</span>.earlyApplicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch to inactive.</span></span><br><span class="line">    <span class="built_in">this</span>.active.set(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剪去那些无影响的代码部分，我们可以发现对于 Spring 来说，真正关闭的顺序是</p>
<ol>
<li>发布一个关闭事件</li>
<li>调用生命周期处理器</li>
<li>销毁所有的Bean</li>
<li>关闭Bean工厂</li>
<li>调用子类的Close函数</li>
</ol>
<p>对于 ➀➁ 是回调机制，不涉及到对象的销毁，➄ 是对于继承类的调用，所有的销毁都在 ➂ 中。受到 Spring 托管的对象繁多，不一定所有的对象都需要销毁行为。进一步定位一下，我们就发现了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroySingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.removeSingleton(beanName);</span><br><span class="line">    DisposableBean disposableBean;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>.disposableBeans) &#123;</span><br><span class="line">        disposableBean = (DisposableBean)<span class="built_in">this</span>.disposableBeans.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.destroyBean(beanName, disposableBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上那些需要销毁的对象都应该是 <code>DisposableBean</code> 对象。</p>
<p>那我们对于第二个问题也知道了，Spring会销毁那些 <code>DisposableBean</code> 类型的 Bean对象。</p>
<h2 id="Spring-需要知道如何释放资源"><a class="header-anchor" href="#Spring-需要知道如何释放资源">¶</a>Spring 需要知道如何释放资源</h2>
<p>其实这是一个不是问题的问题，对于 <code>DisposableBean</code> 来说仅仅需要实现一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DisposableBean</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于需要实现释放资源的对象需要自行实现此接口。</p>
<h2 id="组合在一起"><a class="header-anchor" href="#组合在一起">¶</a>组合在一起</h2>
<p>我们已经知道我们最开始提出的 3 个问题，让我们试着用这3个问题的答案拼凑处一个 Spring Web Server 是如何优雅的停机的。那我们需要证实一件事情： Web Server内部的资源都是 DisposableBean，并且受 Spring 托管。</p>
<p>通过反向定位的办法，可以快速的定位到比如 数据库的资源 <code>org.springframework.orm.jpa.AbstractEntityManagerFactoryBean#destroy</code> 在销毁的阶段会将 Entity 对象进行销毁。对于收到 Spring 托管的对象的优雅停机的路径是：</p>
<p><code>Runtine Shutdown Hook</code> -&gt; <code>Context:destory()</code> -&gt; <code>DisposableBean:destroy()</code>， 对于大部分的资源比如数据库，服务发现，等等都是这样的销毁方式。</p>
<h2 id="进阶：-Web-容器"><a class="header-anchor" href="#进阶：-Web-容器">¶</a>进阶： Web 容器</h2>
<h3 id="一个疑问"><a class="header-anchor" href="#一个疑问">¶</a>一个疑问</h3>
<p>对于普通的 Bean 的销毁我们已经完全了解，但是对于动手做实验的不知道有没有发现，其实 <code>Web Server</code> 并不是在 <code>destroySingleton</code> 阶段进行销毁的，那他是在哪里销毁的呢？回忆一下，我们除了销毁Beans 之外，是不是还有最后一个 <code>close()</code> 函数可以调用，没有错！对于 <code>Tomcat ...</code> 这些web容器来说，本身就是 <code>ApplicationContext</code> 的一个子类并非是 <code>Bean</code> 一部分，因此他们的 <code>close()</code> 函数在 <code>org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext</code>处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onClose();</span><br><span class="line">    <span class="built_in">this</span>.stopAndReleaseWebServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的函数是直接调用底层代码就不做展开，但是隐约有些觉得不对？ <strong>如果</strong>我们在接收到一个远程访问的时候，触发了 <code>Shutdown</code> 事件，我们实际上是无法获得正确的返回的。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+------------------+          +---------------------------+         +--------------------------------------+</span><br><span class="line">|   controller     |          |       services            |         |               dao                    |</span><br><span class="line">|                  +---------&gt;+                           +---------&gt;                                      |</span><br><span class="line">|                  |          |                           | 2. Query DB                          Entitymanger</span><br><span class="line">+------------------+          +---------------------------+         +---------------------------------^----+</span><br><span class="line">                                                                                                      |</span><br><span class="line">                                                                                                      |</span><br><span class="line">                                                                                                      |</span><br><span class="line">                                 +--------------------------------------+                             |1. destory()</span><br><span class="line">                                 |                                      |                             |</span><br><span class="line">                                 |    Destory                           +-----------------------------+</span><br><span class="line">                                 |                                      |</span><br><span class="line">                                 +--------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上图所示，因为我们知道 <code>stop webserver</code> 是在 <code>destory context</code> 之后的，那我们岂不是会出现一边在接受请求但是这些请求都是会失败的吗？如果是是这样的，可真是太愚蠢的设计了。</p>
<h3 id="另辟蹊径"><a class="header-anchor" href="#另辟蹊径">¶</a>另辟蹊径</h3>
<p>对于这样的情况，我们在 shutdown 之前让 Web server 停止接受任何的请求，但可惜的是在此版本的 <code>tomcat</code> 不支持此特效，需要待 <code>9.0.33+</code> <a href="https://spring.io/blog/2020/05/15/spring-boot-2-3-0-available-now">spring-boot-2-3-0-available-now</a>。</p>
<p>在早期的版本中，我们依然可以通过一些额外的方式将这件事情做到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Gh4657Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Gh4657Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/pause&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pause</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Pause complete&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GracefulShutdown <span class="title function_">gracefulShutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GracefulShutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title function_">tomcatCustomizer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmbeddedServletContainerCustomizer</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (container <span class="keyword">instanceof</span> TomcatEmbeddedServletContainerFactory) &#123;</span><br><span class="line">                    ((TomcatEmbeddedServletContainerFactory) container)</span><br><span class="line">                            .addConnectorCustomizers(gracefulShutdown());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GracefulShutdown</span> <span class="keyword">implements</span> <span class="title class_">TomcatConnectorCustomizer</span>,</span><br><span class="line">            ApplicationListener&lt;ContextClosedEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(GracefulShutdown.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Connector connector;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(Connector connector)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.connector = connector;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.connector.pause();</span><br><span class="line">            <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="built_in">this</span>.connector.getProtocolHandler().getExecutor();</span><br><span class="line">            <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> ThreadPoolExecutor) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> (ThreadPoolExecutor) executor;</span><br><span class="line">                    threadPoolExecutor.shutdown();</span><br><span class="line">                    <span class="keyword">if</span> (!threadPoolExecutor.awaitTermination(<span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                        log.warn(<span class="string">&quot;Tomcat thread pool did not shut down gracefully within &quot;</span></span><br><span class="line">                                + <span class="string">&quot;30 seconds. Proceeding with forceful shutdown&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以自定义自己的 <code>ContextClosedEvent</code> 事件，然后将 <code>Tomcat</code> 的处理线程先暂停。</p>
<h3 id="又一个疑问？"><a class="header-anchor" href="#又一个疑问？">¶</a>又一个疑问？</h3>
<p>在 <code>Spring-Boot-2.3.0</code> 之前我们都需要这么处理吗？我的天，很多写了 Spring 已经超过十年了，难道 <code>Spring</code> 一直没有解决这个问题吗？答案也是否定的。</p>
<p>还记得我们在 Spring 的早期阶段，我们通过 XML 来构造一个Spring项目的时候吗？那时候的方案是将我们的Web 程序作为一个 War 提供给 <code>Tomcat</code> 的 webapps中，此时tomcat会尝试构造我们的 <code>DispatcherServlet</code> 将整个系统运作起来，而在 Shutdown 阶段，这样的逻辑也是由 <code>Tomcat</code> 进行处理的。也就是说，对于 <code>Embeded Web Server</code> 的 <code>Spring Boot</code> 和 传统的 <code>Web Server</code> 在 <code>Destory Spring Applicaion Context</code> 这一步的时间是不一样的，<code>Spring Boot with Embeded Web Server</code> 在 <code>2.3.0</code> 之前的版本都是先关闭 <code>Context</code> 上下文再关闭 Web容器，而传统的 <code>Web Server</code> 是先关闭 <code>Web容器</code> 再去关闭 <code>Context</code> 上下文。</p>
<p>对于 传统的 <code>Web Server</code>:</p>
<p><code>Runtime Shutdwon Hook</code> -&gt; <code>org.apache.catalina.util.LifecycleBase#stop</code> -&gt; <code>Spring Context Stop</code></p>
<p>因此出现优雅停机问题的集中在 <code>Spring Boot &lt; 2.3.0</code> 的版本内。</p>
<h1>优雅停机 in action</h1>
<h2 id="传统的-Tomcat-容器"><a class="header-anchor" href="#传统的-Tomcat-容器">¶</a>传统的 Tomcat 容器</h2>
<p>我们执行 <code>catalina.sh stop &lt;WAITING SECONDS&gt;</code> 就可以执行 Tomcat 的优雅停机</p>
<h2 id="Spring-Boot-2-3-0：内置容器"><a class="header-anchor" href="#Spring-Boot-2-3-0：内置容器">¶</a>Spring Boot &gt; 2.3.0：内置容器</h2>
<p>默认完成了优雅停机</p>
<h2 id="Spring-Boot-内置容器"><a class="header-anchor" href="#Spring-Boot-内置容器">¶</a>Spring Boot 内置容器</h2>
<h3 id="Way-1-自己实现优雅停机"><a class="header-anchor" href="#Way-1-自己实现优雅停机">¶</a>Way 1: 自己实现优雅停机</h3>
<p>请查阅参考部分，或者是上文处代码自行实现</p>
<h3 id="Way-2：基于平台实现"><a class="header-anchor" href="#Way-2：基于平台实现">¶</a>Way 2：基于平台实现</h3>
<p>现在的很多应用都跑在 <code>kubernetes</code> 这样的容器平台上，此时我们 POD 在进行 terminated 操作的时候，会首先向运行的进程发送一个 <code>SIGTERM</code> 指令，然后等待 30秒， 在30后没有终结的话，会再次发送一个 <code>SIGKILL</code> 进行强制终结，因此对于容器平台，我们要注意的这一个等待时间是否足够进行资源的回收。</p>
<p>但是我们还有一个问题，就是正在请求的流量问题，对于这个问题我们需要进行组合拳，还记得 <code>kubernetes</code> 中有 <code>readinessProbe</code> 的概念吗？当我们的Pod启动的时候，如果 <code>Readiness</code> 未就绪， <code>kubernetes</code> 也不会将我们的 POD 作为 <code>SVC</code> 的可选地址（采用SVC负债均衡的情况下）。因此我们的应用在接受到 <code>SIGTERM</code> 的第一时刻就将<br>
<code>Readiness</code> 的地址进行失败行为，并且等待一定时间之后再进行 <code>Spring Context Shutdown</code> 操作。但是对于超长时间的请求依然会有失败的可能，不过对于大部分的应用来说，优雅停机本身也只是等待固定时间，因此对于超长持续的请求让其失败也是可选的方案。</p>
<h2 id="Spring-Cloud-下的复杂场景"><a class="header-anchor" href="#Spring-Cloud-下的复杂场景">¶</a>Spring Cloud 下的复杂场景</h2>
<p>我们来看下更加复杂的 Spring Cloud 下的场景，对于 Spring Cloud 体系内有一个特殊的点： <code>Eureka Server</code> 和 <code>Eureka Client</code> 的关系，我们来看下当接入时候的 <code>destory()</code> 行为。</p>
<h3 id="Eureka-主动下线"><a class="header-anchor" href="#Eureka-主动下线">¶</a>Eureka 主动下线</h3>
<p>当 <code>Context:destory()</code> 的时候，Spring会关闭一个名为 <code>org.springframework.cloud.netflix.eureka.serviceregistry.EurekaServiceRegistry</code> 对象，此对象在 <code>org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration#eurekaAutoServiceRegistration</code> 进行初始化的。因此在 <code>destory()</code> 阶段，实例就会自动从 <code>Eureka</code> 下线。</p>
<p><img src="https://s1.ax1x.com/2020/05/31/t1OxRs.png" alt="t1OxRs.png"></p>
<h3 id="Eureka-Client-侧"><a class="header-anchor" href="#Eureka-Client-侧">¶</a>Eureka Client 侧</h3>
<p>因为 <code>Eureka</code> 的服务发现机制并没有通知客户端更新的机制，因此，此时的 <code>Eureka Client</code> 侧的实例依然会去尝试访问已经下线的 <code>Instance</code>，这是由于Eureka是AP系统导致的缺陷并没有解决之道。</p>
<p>此时当其他的服务访问到此服务的此实例的时候，会导致服务<strong>访问错误</strong>。为了避免这样的错误发生，一般来说有几种解决之道：1.我们可以为客户端制定重试机制（参考 <a href="https://medium.com/@ruhshan_ahmed/customize-feigns-retry-mechanism-f015036a33a">How To Customize Feign’s Retry Mechanism</a>）， 2. 手动提前离线：我们使用 Spring Boot Admin 手动在停机之前让实例先下线，这样等到一段时间之后我们就可以将实例进行真正的销毁，<a href="https://codecentric.github.io/spring-boot-admin/current/">Spring Boot Admin</a>，3. 不再使用 Eureka 这样的客户端负债均衡策略，使用类似 <code>K8s 的 SVC</code> 机制可以将这个时间缩短。</p>
<h1>参考</h1>
<ul>
<li><a href="https://github.com/spring-projects/spring-boot/issues/4657">Allow the embedded web server to be shut down gracefully</a></li>
<li><a href="https://dzone.com/articles/spring-bean-lifecycle">spring bean lifecycle</a></li>
<li><a href="https://github.com/SchweizerischeBundesbahnen/springboot-graceful-shutdown">springboot-graceful-shutdown</a></li>
<li><a href="https://medium.com/@ruhshan_ahmed/customize-feigns-retry-mechanism-f015036a33a">How To Customize Feign’s Retry Mechanism</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title>由表及里学 ProjectReactor</title>
    <url>/2018/06/26/java/spring/projectreactor/</url>
    <content><![CDATA[<p>我们都知道 ProjectReactor 是借鉴 Rxjava 的，这个在Android开发中一个极为重要的库，现在因为后端服务采用Netty，又在Reactive的东风之下，后端也选择采用 <a href="https://en.wikipedia.org/wiki/Reactive_programming"><code>响应式编程模式</code></a> 进行开发，响应式编程不是一个新概念，响应式编程就是用异步数据流进行编程，在传统的GUI应用中因为不能阻塞 <code>绘图IO</code> 所以有很多基于事件的编程模式，响应式编程提高了代码的抽象水平，因此能专注于那些定义业务逻辑的事件的依存关系，而无需摆弄大量的线程相关实现细节。<br>
下文简称 <code>projectreactor</code> 为 <code>PRR</code>。</p>
<span id="more"></span>


<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<h2 id="响应式编程"><a class="header-anchor" href="#响应式编程">¶</a>响应式编程</h2>
<p>本质上的 <code>响应式编程模式</code> 就是一个 <code>观察者模式</code>。<br>
<img src="https://s1.ax1x.com/2018/06/29/PFCbwQ.png" alt="观察者模式"></p>
<h3 id="为什么需要响应式编程"><a class="header-anchor" href="#为什么需要响应式编程">¶</a>为什么需要响应式编程</h3>
<p>为什么需要响应式编程，在文档也明确的表示，简而言之就是，我们针对大量的并发用户，我们可以选择</p>
<ul>
<li>并行化（parallelize）:使用更多的线程和硬件资源</li>
<li>基于<code>现有的资源</code>提高执行效率</li>
</ul>
<p>第一种方式，往往采用分布式计算，在这里不做多展开。<br>
第二种方式，通过编写 <code>异步非阻塞</code> 的代码，可以减少资源的浪费，在Java中一般采用，<code>回调（Callbacks）</code> 和 <code>Futures</code> ，但是这两种方式都有局限性，</p>
<ul>
<li>回调很难组合起来，因为很快就会导致代码难以理解和维护（即所谓的“回调地狱（callback hell）”），</li>
<li>Futures 比回调要好一点，但即使在 Java 8 引入了 CompletableFuture，它对于多个处理的组合仍不够好用。 编排多个 Futures 是可行的，但却不易。此外，Future 还有一个问题：当对 Future 对象最终调用 get() 方法时，仍然会导致阻塞，并且缺乏对多个值以及更进一步对错误的处理。</li>
<li><a href="http://projectreactor.io/docs/core/release/reference/#_asynchronicity_to_the_rescue"><code>关于原因的详细阅读</code></a></li>
</ul>
<h3 id="官方的例子"><a class="header-anchor" href="#官方的例子">¶</a>官方的例子</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userService.getFavorites(userId) ➊</span><br><span class="line">           .flatMap(favoriteService::getDetails)  ➋</span><br><span class="line">           .switchIfEmpty(suggestionService.getSuggestions())  ➌</span><br><span class="line">           .take(<span class="number">5</span>)  ➍</span><br><span class="line">           .publishOn(UiUtils.uiThreadScheduler())  ➎</span><br><span class="line">           .subscribe(uiList::show, UiUtils::errorPopup);  ➏</span><br></pre></td></tr></table></figure>
<p>➊ 根据用户ID获得喜欢的信息（打开一个 <code>Publisher</code>）<br>
➋ 使用 <code>flatMap</code> 操作获得详情信息<br>
➌ 使用 <code>switchIfEmpty</code> 操作，在没有喜欢数据的情况下，采用系统推荐的方式获得<br>
➍ 取前五个<br>
➎ 在 <code>uiThread</code> 上进行发布<br>
➏ 最终的消费行为</p>
<p>➊➋➌➍ 的行为就看起来很直观，这个和我们使用 <a href="http://www.runoob.com/java/java8-streams.html"><code>Java 8 中的 Streams 编程</code></a> 极为相近，但是这里实现和 Strem 是不同的，在后续的分析会展开。<br>
➎ 和 ➏ 在我们之前的编码（注：传统后台服务）中没有遇见过类似的，这里的行为，我们可以在后续的 <a href="http://projectreactor.io/docs/core/release/reference/#schedulers"><code>Reference#schedulers</code></a> 中可以得知，<code>publishOn</code> 将影响后续的行为操作所在的线程，那我们就明白了，之前的操作会在某个线程中执行，而最后一个 <code>subscribe()</code> 函数将在 <code>uiThread</code> 中执行。</p>
<p>如果非常着急话可以先阅读 <a href="#%E5%B0%8F%E7%BB%93%E4%B8%80%E4%B8%8B"><strong>小结图文</strong></a></p>
<h2 id="SPI-模型定义"><a class="header-anchor" href="#SPI-模型定义">¶</a>SPI 模型定义</h2>
<h3 id="Publisher-即被观察者"><a class="header-anchor" href="#Publisher-即被观察者">¶</a>Publisher 即被观察者</h3>
<p>Publisher 在 <code>PRR</code> 中 所承担的角色也就是传统的 <code>观察者模式</code> 中的 <code>被观察者对象</code>，在 <code>PRR</code> 的定义也极为简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.reactivestreams;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Publisher</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Subscriber&lt;? <span class="built_in">super</span> T&gt; s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Publisher</code> 的定义可以看出来，<code>Publisher</code> 接受 <code>Subscriber</code>，非常简单的一个接口。但是这里有个有趣的小细节，这个类所在的包是 <code>org.reactivestreams</code>，这里的做法和传统的 J2EE 标准类似，我们使用标准的 <code>Javax</code> 接口定义行为，不定义具体的实现。</p>
<h3 id="Subscriber-即观察者"><a class="header-anchor" href="#Subscriber-即观察者">¶</a>Subscriber 即观察者</h3>
<p>Subscriber 在 <code>PRR</code> 中 所承担的角色也就是传统的 <code>观察者模式</code> 中的 <code>观察者对象</code>，在 <code>PRR</code> 的定义要多一些。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subscriber</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription s)</span>; ➊</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(T t)</span>; ➋</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span>; ➍</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 订阅时被调用<br>
➋ 每一个元素接受时被触发一次<br>
➌ 当在触发错误的时候被调用<br>
➍ 在接受完最后一个元素最终完成被调用</p>
<p><code>Subscriber</code> 的定义可以看出来，<code>Publisher</code> 是主要的行为对象，用来描述我们最终的执行逻辑。</p>
<h3 id="Subscription-桥接者"><a class="header-anchor" href="#Subscription-桥接者">¶</a>Subscription 桥接者</h3>
<p>在最基础的 <code>观察者模式</code> 中，我们只是需要 <code>Subscriber 观察者</code> <code>Publisher 发布者</code>，而在 <code>PRR</code> 中增加了一个 <code>Subscription</code> 作为 <code>Subscriber</code> <code>Publisher</code> 的桥接者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subscription</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">(<span class="type">long</span> n)</span>; ➊</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>; ➋</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 获取 N 个元素往下传递<br>
➋ 取消执行</p>
<p>为什么需要这个对象，笔者觉得是一是为了解耦合，第二在 <code>Reference</code> 中有提到 <code>Backpressure</code> 也就是下游可以保护自己不受上游大流量冲击，这个在 <code>Stream</code> 编程中是无法做到的，想要做到这个，就需要可以控制流速，那秘密看起来也就是在 <code>request(long n)</code> 中。</p>
<p><img src="https://s1.ax1x.com/2018/06/27/PPboXq.png" alt="Subscriber&amp;Publisher&amp;Subscription"></p>
<h2 id="他们如何工作"><a class="header-anchor" href="#他们如何工作">¶</a>他们如何工作</h2>
<p>我们尝试使用最简单的一个例子进行我们的 <code>探险之旅</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jack&quot;</span>, <span class="string">&quot;allen&quot;</span>)</span><br><span class="line">    .map(s-&gt; s.concat(<span class="string">&quot;@qq.com&quot;</span>))</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>我们仅仅是将 <code>String</code> 对象进行增加一个邮箱后缀，然后再打印出来，这是一个非常简单的逻辑。</p>
<h3 id="声明阶段"><a class="header-anchor" href="#声明阶段">¶</a>声明阶段</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reactor.core.publisher.Flux#fromArray</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Flux&lt;T&gt; <span class="title function_">fromArray</span><span class="params">(T[] array)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查略</span></span><br><span class="line">    <span class="keyword">return</span> onAssembly(<span class="keyword">new</span> <span class="title class_">FluxArray</span>&lt;&gt;(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以清晰的发现，<code>PRR</code> 只是将 array 包裹成了一个 <code>FluxArray</code> 对象，我们来看看它的声明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FluxArray</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Flux</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Fuseable</span>, Scannable &#123;</span><br><span class="line">	<span class="keyword">final</span> T[] array;</span><br><span class="line">	<span class="meta">@SafeVarargs</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">FluxArray</span><span class="params">(T... array)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.array = Objects.requireNonNull(array, <span class="string">&quot;array&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在具体的实例中，<code>FluxArray</code> 也仅仅是将 <code>array</code> 储存了起来，然后就返回回来了，那我们紧接着去看看 <code>.map(s-&gt; s.concat(&quot;@qq.com&quot;))</code> 又做了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;V&gt; Flux&lt;V&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends V&gt; mapper)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> Fuseable) &#123;</span><br><span class="line">        <span class="keyword">return</span> onAssembly(<span class="keyword">new</span> <span class="title class_">FluxMapFuseable</span>&lt;&gt;(<span class="built_in">this</span>, mapper)); ➊</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onAssembly(<span class="keyword">new</span> <span class="title class_">FluxMap</span>&lt;&gt;(<span class="built_in">this</span>, mapper)); ➋</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ➊ ➋ 处，我们发现都是简单的将这个 <code>Function&lt;T,V&gt;</code> 包装成一个新的  <code>FluxMapFuseable/FluxMap</code> 对象返回，但是我们可以看到在 <code>FluxMap</code> 的构造函数中需要2个值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FluxMap(Flux&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; source, Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">R</span>&gt; mapper) &#123;</span><br><span class="line">    <span class="built_in">super</span>(source);</span><br><span class="line">    <span class="built_in">this</span>.mapper = Objects.requireNonNull(mapper, <span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想到了什么？这里和设计模式中的 <code>代理模式</code> 极为接近，我们每次将一个 <code>操作</code> 和 <code>源Publisher</code> 组合变成一个 <code>新Publisher</code>，到这里我们已经明白了在 <code>subscribe()</code> 之前，我们什么都没做，只是在不断的包裹 <code>Publisher</code> 将作为原始的 <code>Publisher</code> 一层又一层的返回回来。终于到了我们最为激动人心的 <code>subscribe()</code> 函数了。</p>
<h3 id="subscribe-阶段"><a class="header-anchor" href="#subscribe-阶段">¶</a>subscribe 阶段</h3>
<p>通过一顿 <code>Jump Definition</code> 大法，我们找到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reactor.core.publisher.Flux#subscribe(reactor.core.CoreSubscriber&lt;? super T&gt;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(CoreSubscriber&lt;? <span class="built_in">super</span> T&gt; actual)</span>;</span><br></pre></td></tr></table></figure>
<p>在 Flux 的 <code>抽象类</code> 中，这是一个抽象函数，也就是函数是需要子类中实现的，那我们在上面的分析过程中，我们知道每一次 <code>Operator</code> 都会包裹出一个新的 <code>Flux</code>，那我们去找到最后一次生成的 <code>FluxMapFuseable</code> 去看看它的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(CoreSubscriber&lt;? <span class="built_in">super</span> R&gt; actual)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (actual <span class="keyword">instanceof</span> ConditionalSubscriber) &#123;</span><br><span class="line">        ConditionalSubscriber&lt;? <span class="built_in">super</span> R&gt; cs = (ConditionalSubscriber&lt;? <span class="built_in">super</span> R&gt;) actual;</span><br><span class="line">        source.subscribe(<span class="keyword">new</span> <span class="title class_">MapFuseableConditionalSubscriber</span>&lt;&gt;(cs, mapper));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    source.subscribe(<span class="keyword">new</span> <span class="title class_">MapFuseableSubscriber</span>&lt;&gt;(actual, mapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 我们暂时不去关心处理 <code>Fuseable</code> 这个对象<br>
➋ 我们自己的 <code>Subscriber</code> 在这里被包裹成一个 <code>MapFuseableSubscriber</code> 对象，又订阅 <code>source</code>，还记得 <code>source</code> 这个对象吗？我们当前所在的 <code>this</code> 对象是 <code>FluxMapFuseable</code>，而他的上一次的源头也就是我们的<code>FluxArray</code> 对象，这行我们就发现了 <code>MapFuseableSubscriber</code> 只是一个中间人，将我们的源头 <code>FluxArray</code> 和 我们自定义的 <code>Subscriber</code> 关联起来，通过将 <code>Subscriber</code> 包装成新的 <code>MapFuseableSubscriber</code> 的方式</p>
<p>那我们继续看看 <code>FluxArray</code> 是如何处理 <code>subscribe()</code> 函数的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(CoreSubscriber&lt;? <span class="built_in">super</span> T&gt; s, T[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">        Operators.complete(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s <span class="keyword">instanceof</span> ConditionalSubscriber) &#123;</span><br><span class="line">        s.onSubscribe(<span class="keyword">new</span> <span class="title class_">ArrayConditionalSubscription</span>&lt;&gt;((ConditionalSubscriber&lt;? <span class="built_in">super</span> T&gt;) s, array)); ➊</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s.onSubscribe(<span class="keyword">new</span> <span class="title class_">ArraySubscription</span>&lt;&gt;(s, array)); ➋</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟悉的味道，➊ ➋ 将 <code>Subscriber</code> 和 <code>Publisher</code> 包裹成一个 <code>Subscription</code> 对象，并将其 作为<code>onSubscribe</code> 函数调用的对象，这样的话，我们就可以完整的理解，为什么 <a href="http://projectreactor.io/docs/core/release/reference/#reactive.subscribe"><code>Nothing Happens Until You subscribe()</code></a> 因为实际上在我们调用 <code>subscribe()</code> 所有的方法都只是在申明对象。只有在 <code>subscribe</code> 之后才能出发 <code>onSubscribe</code> 调用。</p>
<p>那问题又来了 <code>onSubscribe</code> 又做了什么？那我们知道现在的这个 <code>s</code> 也就是 <code>MapFuseableSubscriber</code> 我们去看看它的 <code>onSubscribe</code> 实现就明白了。</p>
<h3 id="onSubscribe-阶段"><a class="header-anchor" href="#onSubscribe-阶段">¶</a>onSubscribe 阶段</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Operators.validate(<span class="built_in">this</span>.s, s)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = (QueueSubscription&lt;T&gt;) s;</span><br><span class="line">        actual.onSubscribe(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，我们又获得了我们自己所定义的 <code>Subscriber</code> 并调用它的 <code>onSubscribe</code> 函数，因为我们采用 <code>Lambda</code> 的方式生成的 <code>Subscriber</code> 所以也就是 <code>LambdaSubscriber</code> 对象，在他的实现中是如此写到</p>
<h3 id="request-阶段"><a class="header-anchor" href="#request-阶段">¶</a>request 阶段</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Operators.validate(subscription, s)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.subscription = s;</span><br><span class="line">        <span class="keyword">if</span> (subscriptionConsumer != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                subscriptionConsumer.accept(s); ➊</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Exceptions.throwIfFatal(t);</span><br><span class="line">                s.cancel();</span><br><span class="line">                onError(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s.request(Long.MAX_VALUE); ➋</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>无论是 ➊ 还是 ➋ 最为核心的都是调用了 <code>Subscription.request()</code> 函数，还记这个 <code>Subscription</code> 吗？也就是我们上一步的 <code>MapFuseableSubscriber</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    s.request(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这这里的S又是我们最外围的 <code>FluxArray</code>，我们继续查看下去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Operators.validate(n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Operators.addCap(REQUESTED, <span class="built_in">this</span>, n) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == Long.MAX_VALUE) &#123;</span><br><span class="line">                fastPath(); ➊</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                slowPath(n); ➋</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里进行了一个简单的优化，我们直接去阅读 <code>fastPath()</code> 函数。</p>
<h3 id="调用阶段"><a class="header-anchor" href="#调用阶段">¶</a>调用阶段</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">fastPath</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> T[] a = array;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">final</span> Subscriber&lt;? <span class="built_in">super</span> T&gt; s = actual;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i != len; i++) &#123; ➊</span><br><span class="line">        <span class="keyword">if</span> (cancelled) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">/** skip **/</span>&#125;</span><br><span class="line">        s.onNext(t); ➋</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** skip **/</span></span><br><span class="line">    s.onComplete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个函数非常的简单，核心也就是一个循环体 ➊，我们在 ➋ 看出我们最终处理单一元素的 <code>onNext()</code> 函数，而这个 s 对象是 <code>FluxMapFuseable</code> 对象，在它的 onNext() 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    R v;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        v = Objects.requireNonNull(mapper.apply(t), <span class="string">&quot;The mapper returned a null value.&quot;</span>); ➊</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable e) &#123;<span class="comment">//skip</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    actual.onNext(v); ➋ </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ➊ 处进行 Mapper 变形<br>
在 ➋ 将 变形之后的结构传递给下一个 <code>Subscriber</code><br>
这里的 <code>actual</code> 也就是我们的自己所写的 <code>Subscriber</code></p>
<h3 id="小结一下"><a class="header-anchor" href="#小结一下">¶</a>小结一下</h3>
<ol>
<li>
<p>声明阶段: 当我们每进行一次 <code>Operator</code> 操作 （也就 map filter flatmap），就会将原有的 <code>FluxPublisher</code> 包裹成一个新的 <code>FluxPublisher</code><br>
<img src="https://s1.ax1x.com/2018/06/29/PiLJN8.png" alt="transfer"><br>
最后生成的对象是这样的<br>
<img src="https://s1.ax1x.com/2018/06/29/PiLCc9.png" alt="rs"></p>
</li>
<li>
<p>subscribe阶段: 当我们最终进行 <code>subscribe</code> 操作的时候，就会从最外层的 <code>Publisher</code> 一层一层的处理，从这层将 <code>Subscriber</code> 变化成需要的 <code>Subscriber</code> 直到最外层的 <code>Publisher</code><br>
<img src="https://s1.ax1x.com/2018/06/29/PiLN9g.png" alt="transfer"><br>
最后生成的对象是这样的<br>
<img src="https://s1.ax1x.com/2018/06/29/PiOBxH.png" alt="rs"></p>
</li>
<li>
<p>onSubscribe阶段: 在最外层的 <code>Publisher</code> 的时候调用 上一层 <code>Subscriber</code> 的 <code>onSubscribe</code> 函数，在此处将 <code>Publisher</code> 和 <code>Subscriber</code> 包裹成一个 <code>Subscription</code> 对象作为 <code>onSubscribe</code> 的入参数。<br>
<img src="https://s1.ax1x.com/2018/06/29/PivrM4.md.png" alt="last"></p>
</li>
<li>
<p>最终在 原始 <code>Subscriber</code> 对象调用 <code>request()</code> ，触发 <code>Subscription</code> 的 <code>Source</code> 获得数据作为 <code>onNext</code> 的参数，但是注意 <code>Subscription</code> 包裹的是我们封装的 <code>Subscriber</code> 所有的数据是从 <code>MapSubscriber</code> 进行一次转换再给我们的原始 <code>Subscriber</code> 的。<br>
<img src="https://s1.ax1x.com/2018/06/29/PixEWT.md.png" alt="Work"></p>
</li>
</ol>
<p>经过一顿分析，整个 <code>PRR</code> 是如何将操作整合起来的，我们已经有一个大致的了解，通过不断的包裹出新的 <code>Subscriber</code> 对象，在最终的 <code>request()</code> 行为中触发整个消息的处理，这个过程非常像 <code>俄罗斯套娃</code>，一层一层的将变化组合形变操作变成一个新的 <code>Subscriber</code>， 然后就和一个管道一样，一层一层的往下传递。</p>
<ol start="5">
<li>最终在 <code>Subscription</code> 开始了我们整个系统的数据处理<br>
<img src="https://s1.ax1x.com/2018/06/29/PixelF.png" alt="onNext"></li>
</ol>
<h3 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h3>
<p>读者在自行阅读代码的时候可以使用 <code>Mono</code> 进行分析，也会比较简单些，比如使用下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mono.just(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">    .map(s -&gt; s.concat(<span class="string">&quot;123&quot;</span>))</span><br><span class="line">    .filter(s -&gt; s.length() &gt; <span class="number">5</span>)</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="线程切换-Schedulers"><a class="header-anchor" href="#线程切换-Schedulers">¶</a>线程切换 Schedulers</h2>
<p>整个 <code>PPR</code> 和 竞品 <code>RxJava</code> 除了变化操作以外，最为重要的就是 <code>线程切换</code>, <code>PPR</code>内置了4中线程调度器。</p>
<ul>
<li>使用当前线程的 <code>Schedulers.immediate()</code></li>
<li>一个被复用的单一线程 <code>Schedulers.single()</code>，如果希望是创建新线程的模式请使用 <code>Schedulers.newSingle()</code></li>
<li>一个弹性线程池 <code>Schedulers.elastic()</code>，这个非常适合处理一些 <code> I/O blocking</code> 实践</li>
<li>一个固定Wokers的线程池 <code>Schedulers.parallel()</code> 这个会创建和 <code>CPU</code> 核心数一样的线程池</li>
</ul>
<p><code>PPR</code> 进行线程切换的函数也很简单，只有两个</p>
<ul>
<li><code>publishOn</code> : 这个函数将影响之后的操作</li>
<li><code>subscribeOn</code> : 这个函数仅仅影响 <code>事件源</code> 所在的线程</li>
</ul>
<h3 id="举个例子"><a class="header-anchor" href="#举个例子">¶</a>举个例子</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(concat @qq.com) at [&quot;</span> + Thread.currentThread() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s.concat(<span class="string">&quot;@qq.com&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .publishOn(Schedulers.newSingle(<span class="string">&quot;thread-a&quot;</span>))</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(concat foo) at [&quot;</span> + Thread.currentThread() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s.concat(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(startsWith f) at [&quot;</span> + Thread.currentThread() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .publishOn(Schedulers.newSingle(<span class="string">&quot;thread-b&quot;</span>))</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(to length) at [&quot;</span> + Thread.currentThread() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribeOn(Schedulers.newSingle(<span class="string">&quot;source&quot;</span>))</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>执行的结果如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(concat @qq.com) at [Thread[source-1,5,main]]  ➊</span><br><span class="line">(concat foo) at [Thread[thread-a-3,5,main]] ➋</span><br><span class="line">(startsWith f) at [Thread[thread-a-3,5,main]] ➌</span><br><span class="line">(to length) at [Thread[thread-b-2,5,main]] ➍</span><br></pre></td></tr></table></figure>
<p>➊ 正对应着  <code>.subscribeOn(Schedulers.newSingle(&quot;source&quot;))</code> 在一个 <code>source</code> 线程开始事件，和顺序无关<br>
➋ ➌ 都对应着 <code>.publishOn(Schedulers.newSingle(&quot;thread-a&quot;))</code> 在一个 <code>thread-a</code> 进行操作<br>
➍ 不言而喻</p>
<h3 id="工作原理"><a class="header-anchor" href="#工作原理">¶</a>工作原理</h3>
<p>其中会有什么黑科技呢，在阅读源码之前，我也有这样的思考。我们一顿 <code>Jump</code> 我们又看见了一个熟悉的身影。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Flux&lt;T&gt; <span class="title function_">publishOn</span><span class="params">(Scheduler scheduler, <span class="type">boolean</span> delayError, <span class="type">int</span> prefetch, <span class="type">int</span> lowTide)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> Callable) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> Fuseable.ScalarCallable) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Fuseable.ScalarCallable&lt;T&gt; s = (Fuseable.ScalarCallable&lt;T&gt;) <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> onAssembly(<span class="keyword">new</span> <span class="title class_">FluxSubscribeOnValue</span>&lt;&gt;(s.call(), scheduler)); ➊</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//leave FluxSubscribeOnCallable defer exception call</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Callable&lt;T&gt; c = (Callable&lt;T&gt;)<span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">return</span> onAssembly(<span class="keyword">new</span> <span class="title class_">FluxSubscribeOnCallable</span>&lt;&gt;(c, scheduler)); ➋</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> onAssembly(<span class="keyword">new</span> <span class="title class_">FluxPublishOn</span>&lt;&gt;(<span class="built_in">this</span>, scheduler, delayError, prefetch, lowTide, Queues.get(prefetch))); ➌</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暂且不管其他的部分，我们发现核心的依然是 构建了一个新的包裹 <code>Subscribe</code>，我们去看看最为简单的 <code>FluxPublishOn</code>，这里仅仅是 <code>New</code> 出一个新的对象，至于正在的运行时，在这里是无从得知的。但是我们去看看它的定义发现一个有钱的函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(CoreSubscriber&lt;? <span class="built_in">super</span> T&gt; actual)</span> &#123;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> Objects.requireNonNull(scheduler.createWorker(),</span><br><span class="line">					<span class="string">&quot;The scheduler returned a null worker&quot;</span>);</span><br><span class="line">    <span class="comment">//阉割</span></span><br><span class="line">    <span class="keyword">if</span> (actual <span class="keyword">instanceof</span> ConditionalSubscriber) &#123;</span><br><span class="line">        ConditionalSubscriber&lt;? <span class="built_in">super</span> T&gt; cs = (ConditionalSubscriber&lt;? <span class="built_in">super</span> T&gt;) actual;</span><br><span class="line">        source.subscribe(<span class="keyword">new</span> <span class="title class_">PublishOnConditionalSubscriber</span>&lt;&gt;(cs,</span><br><span class="line">                scheduler,</span><br><span class="line">                worker,</span><br><span class="line">                delayError,</span><br><span class="line">                prefetch,</span><br><span class="line">                lowTide,</span><br><span class="line">                queueSupplier));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    source.subscribe(<span class="keyword">new</span> <span class="title class_">PublishOnSubscriber</span>&lt;&gt;(actual,</span><br><span class="line">            scheduler,</span><br><span class="line">            worker,</span><br><span class="line">            delayError,</span><br><span class="line">            prefetch,</span><br><span class="line">            lowTide,</span><br><span class="line">            queueSupplier));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现在 <code>subscribe()</code> 函数中，我们在构建一个新的 <code>PublishOnSubscriber</code> 对象时候，我们将 <code>worker</code> 传入其中，我们又将 <code>actual</code> 上一层的 <code>Subscriber</code> 传入，在这里可以推测出，我们又将 <code>Subscriber</code> 包装了。</p>
<p>而我们已经知道了事件的触发处是 <code>request()</code>，和传递元素处是 <code>onNext()</code> 那线程切换自然也在这两处地方。我们找到源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reactor.core.publisher.FluxPublishOn.PublishOnSubscriber#request</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Operators.validate(n)) &#123;</span><br><span class="line">        Operators.addCap(REQUESTED, <span class="built_in">this</span>, n);</span><br><span class="line">        <span class="comment">//WIP also guards during request and onError is possible</span></span><br><span class="line">        trySchedule(<span class="built_in">this</span>, <span class="literal">null</span>, <span class="literal">null</span>); ➊</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reactor.core.publisher.FluxPublishOn.PublishOnSubscriber#onNext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(T t)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (!queue.offer(t)) &#123;  ➋ </span><br><span class="line">            error = Operators.onOperatorError(s, Exceptions.failWithOverflow(Exceptions.BACKPRESSURE_ERROR_QUEUE_FULL), t,</span><br><span class="line">                    actual.currentContext());</span><br><span class="line">            done = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    trySchedule(<span class="built_in">this</span>, <span class="literal">null</span>, t); ➌</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊➌ 处出现的 trySchedule() 也就是切换线程的核心。<br>
➋ 处有个值得注意的地方，我们将当前的接受的到的元素放置到了一个队列之中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">trySchedule</span><span class="params">(<span class="meta">@Nullable</span> Subscription subscription,</span></span><br><span class="line"><span class="params">				<span class="meta">@Nullable</span> Throwable suppressed,</span></span><br><span class="line"><span class="params">				<span class="meta">@Nullable</span> Object dataSignal)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        worker.schedule(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;</span><br><span class="line">       <span class="comment">//略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切换的代码并不复杂，在当前的对象放到另外一个 <code>Worker</code> 中运行，而我们知道，从另外一个线程运行代码是在 <code>Runnable</code> 的 <code>run</code> 函数中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reactor.core.publisher.FluxPublishOn.PublishOnSubscriber#run</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (outputFused) &#123;</span><br><span class="line">        runBackfused();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sourceMode == Fuseable.SYNC) &#123;</span><br><span class="line">        runSync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        runAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看查看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">runSync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ConditionalSubscriber&lt;? <span class="built_in">super</span> T&gt; a = actual;</span><br><span class="line">    <span class="keyword">final</span> Queue&lt;T&gt; q = queue;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> produced;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> requested;</span><br><span class="line">        <span class="keyword">while</span> (e != r) &#123;</span><br><span class="line">            T v;</span><br><span class="line">            <span class="keyword">try</span> &#123; v = q.poll(); ➊ &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123; <span class="comment">/* skip */</span>&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123; doComplete(a); <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a.tryOnNext(v)) &#123; ➋</span><br><span class="line">                e++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty()) &#123;</span><br><span class="line">            doComplete(a);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 在切换线程之前，我们将我们需要处理的元素存储在我们的 <code>Queue</code>队列之中，在这里取出来<br>
➋ 将我们的数据交付给真实操作的 <code>Subscriber</code></p>
<h3 id="短小结"><a class="header-anchor" href="#短小结">¶</a>短小结</h3>
<p>看到这里的时候，我们已经知道了 <code>publishOn</code> 的工作原理，和 <code>Operator</code> 是类型的，只是在 <code>OnNext()</code> 的函数嵌入线程处理的代码，为什么 <code>publishOn</code> 仅对后续的操作有效，我们也可以看出来，因为 <code>publishOn</code> 的原理如下图。</p>
<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: publishOn原理时序图',
	 'Source->FluxPublishOn: 1. onNext 将输入元素置于 Queue',
	 'FluxPublishOn->FluxPublishOn: 2.trySchedule 切换线程',
	 'FluxPublishOn->FluxPublishOn: 3. run 取出 Queue 继续处理',
     'FluxPublishOn->Subscriber: 4. 后续Subscriber处理'
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>
<p>用图表示的话是这样的：<br>
<img src="https://s1.ax1x.com/2018/06/29/PFp8f0.png" alt="pic"></p>
<p>所以我们知道了，<code>publishOn</code> 并不会关心之前的操作是在哪里进行的，到它这里的时候，会切换一次线程即可。</p>
<h3 id="subscribeOn-原理"><a class="header-anchor" href="#subscribeOn-原理">¶</a>subscribeOn 原理</h3>
<p>因为从上文的描述中，我们得知了 <code>subscribeOn</code> 修改的是 <code>Source</code> 的行为，在几个关键的函数中，大概率就是只有 <code>subscribe()</code> 阶段可以修改这个，果不其然。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(CoreSubscriber&lt;? <span class="built_in">super</span> T&gt; actual)</span> &#123;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> Objects.requireNonNull(scheduler.createWorker(), <span class="string">&quot;The scheduler returned a null Function&quot;</span>);</span><br><span class="line">    SubscribeOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> <span class="title class_">SubscribeOnSubscriber</span>&lt;&gt;(source,</span><br><span class="line">            actual, worker, requestOnSeparateThread);</span><br><span class="line">    </span><br><span class="line">    actual.onSubscribe(parent); ➊</span><br><span class="line">    <span class="keyword">try</span> &#123; worker.schedule(parent); ➋ &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">catch</span> (RejectedExecutionException ree) &#123; <span class="comment">/* skip */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ➊ 处，构建了一个新的 <code>Subscriber</code> 叫 <code>SubscribeOn</code>，将 <code>actual</code> 包裹成一个新的对象 ，然后在 ➋ 处进行了 线程的切换。而它的 <code>Run</code> 也很简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    THREAD.lazySet(<span class="built_in">this</span>, Thread.currentThread());</span><br><span class="line">    source.subscribe(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看出来，<code>subscribeOn</code> 相对来说更为简单，我们 创建一个新的 <code>Subscriber</code> 将 <code>源Subscriber</code> 关联起来，然后切换线程，之后就是正常的运行机制。</p>
<div style="width:100%; overflow-y:scroll;" id="diagram2"></div>
<script>
	var data2 =
	['Title: subscribeOn原理时序图',
	 'Source->FluxSubscribeOn: 1. subscribe 构建一个 SubscribeOnSubscriber，关联源 Subscriber',
	 'FluxSubscribeOn->FluxSubscribeOn: 2.schedule 切换线程',
	 'FluxSubscribeOn->Source: 3. subscribe 继续远逻辑处理',
    ].join('\n');
  	var diagram2 = Diagram.parse(data2);
  	diagram2.drawSVG("diagram2", {theme: 'simple', scale: 0.5});
</script>
<p>用图表示的话是这样的：<br>
<img src="https://s1.ax1x.com/2018/06/29/PFCrQK.png" alt="pic"></p>
<h3 id="谜题"><a class="header-anchor" href="#谜题">¶</a>谜题</h3>
<p>如果我们写出形如下面的代码，那结果应该如何。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(to length) at [&quot;</span> + Thread.currentThread() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribeOn(Schedulers.newSingle(<span class="string">&quot;source1&quot;</span>))</span><br><span class="line">    .subscribeOn(Schedulers.newSingle(<span class="string">&quot;source2&quot;</span>))</span><br><span class="line">    .subscribeOn(Schedulers.newSingle(<span class="string">&quot;source3&quot;</span>))</span><br><span class="line">    .subscribeOn(Schedulers.newSingle(<span class="string">&quot;source4&quot;</span>))</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>答案是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(to length) at [Thread[source1-4,5,main]]</span><br></pre></td></tr></table></figure>
<p>我们发现下面的 <code>.subscribeOn()</code> 根本无效，让我们会议一下，<code>Subscriber</code> 的包装是 逆序的。 包装的顺序是 <code>源Subscriber</code> <code>Subscriber-Source-1</code> <code>Subscriber-Source-2</code> <code>Subscriber-Source-3</code> <code>Subscriber-Source-4</code> 那我们在 <code>Subscriber-Source-4</code> 阶段进行了线程切换，之后到了 <code>Subscriber-Source-3</code> 又进行了一次切换 所以只有最后一次 <code>Subscriber-Source-1</code> 最终影响我们的 <code>Source</code> 事件所在的线程。</p>
<p><img src="https://s1.ax1x.com/2018/06/29/PFChWt.png" alt="pic"></p>
<h2 id="大总结"><a class="header-anchor" href="#大总结">¶</a>大总结</h2>
<p>我们最后总结一下</p>
<ol>
<li>在声明阶段，我们像 <code>俄罗斯套娃</code> 一样，创建一个嵌套一个的 <code>Publisher</code></li>
<li>在 <code>subscribe()</code> 调用的时候，我们从最外围的  <code>Publisher</code> 根据包裹的 <code>Operator</code> 创建各种 <code>Subscriber</code></li>
<li><code>Subscriber</code> 通过 <code>onSubscribe()</code> 使得他们像一个链条一样关联起来，并和 最外围的 <code>Publisher</code> 组合成一个 <code>Subscription</code></li>
<li>在最底层的 <code>Subscriber</code> 调用 <code>onSubscribe</code> 去调用 <code>Subscription</code> 的 <code>request(n);</code> 函数开始操作</li>
<li>元素就像水管中的水一样挨个 经过  <code>Subscriber</code> 的 <code>onNext()</code>，直至我们最终消费的 <code>Subscriber</code></li>
</ol>
<h2 id="参考文档"><a class="header-anchor" href="#参考文档">¶</a>参考文档</h2>
<ul>
<li><a href="http://projectreactor.io/docs/core/release/reference/#intro-reactive">Reactor 3 Reference</a></li>
<li><a href="https://htmlpreview.github.io/">Reactor 3 参考文档</a></li>
<li><a href="http://projectreactor.mydoc.io/?t=44474">Reactor 指南中文版</a></li>
<li><a href="https://community.oracle.com/docs/DOC-1006738">Reactive Programming with JDK 9 Flow API</a></li>
<li><a href="https://blog.piasy.com/AdvancedRxJava/2017/03/19/comparison-of-reactive-streams-part-1/">Reactive Stream 各实现的对比（一）</a></li>
<li><a href="http://www.codenuclear.com/observer-design-pattern-in-java/">observer-design-pattern-in-java</a></li>
</ul>
<h2 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h2>
<p><img src="https://s1.ax1x.com/2018/06/27/PP7x54.png" alt="BigPic"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
        <category>projectreactor</category>
      </categories>
  </entry>
  <entry>
    <title>How Dubbo Envoy Filter Works (For Envoy)</title>
    <url>/2021/05/26/networking/envoy/how-dubbo-filter-works/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210606174353.png" alt=""></p>
<p>今天就让我们一起来品一品，<code>Envoy</code> 中的 <code>Dubbo</code> 协议是如何实现的，基于 <code>1.18</code> 分支</p>
<span id="more"></span>


<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<h2 id="Intro"><a class="header-anchor" href="#Intro">¶</a>Intro</h2>
<p><code>Dubbo Filter</code> 位于 <code>/*/extensions/filters/network/dubbo_proxy</code> 中，首先让我们先瞧一瞧，这个 <code>Filter</code> 是如何使用的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">listeners:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span></span><br><span class="line">      <span class="attr">socket_address:</span></span><br><span class="line">        <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        <span class="attr">port_value:</span> <span class="number">20881</span></span><br><span class="line">    <span class="attr">filter_chains:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.dubbo_proxy</span></span><br><span class="line">            <span class="attr">typed_config:</span></span><br><span class="line">            <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.dubbo_proxy.v3.DubboProxy</span></span><br><span class="line">            <span class="attr">stat_prefix:</span> <span class="string">dubbo_incomming_stats</span></span><br><span class="line">            <span class="attr">protocol_type:</span> <span class="string">Dubbo</span></span><br><span class="line">            <span class="attr">serialization_type:</span> <span class="string">Hessian2</span></span><br><span class="line">            <span class="attr">route_config:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">local_route</span></span><br><span class="line">                <span class="attr">interface:</span> <span class="string">org.apache.dubbo.demo.DemoService</span></span><br><span class="line">                <span class="attr">routes:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">                    <span class="attr">method:</span></span><br><span class="line">                    <span class="attr">name:</span></span><br><span class="line">                        <span class="attr">exact:</span> <span class="string">sayHello</span></span><br><span class="line">                <span class="attr">route:</span></span><br><span class="line">                    <span class="attr">cluster:</span> <span class="string">user_service_dubbo_server</span></span><br><span class="line">            <span class="attr">dubbo_filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.dubbo.testFilter</span></span><br><span class="line">                <span class="attr">typed_config:</span></span><br><span class="line">                <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/google.protobuf.Struct</span></span><br><span class="line">                <span class="attr">value:</span></span><br><span class="line">                    <span class="attr">name:</span> <span class="string">test_service</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.dubbo.router</span></span><br></pre></td></tr></table></figure>
<p>可见 <code>dubbo</code> 的插件是以 <code>filter</code> 的形式，通过 <code>LDS</code> 协议进行分发。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        dubbo proxy 目录
    </div>
    <div class='spoiler-content'>
        <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">├── BUILD</span><br><span class="line">├── active_message.cc</span><br><span class="line">├── active_message.h</span><br><span class="line">├── app_exception.cc</span><br><span class="line">├── app_exception.h</span><br><span class="line">├── config.cc</span><br><span class="line">├── config.h</span><br><span class="line">├── conn_manager.cc</span><br><span class="line">├── conn_manager.h</span><br><span class="line">├── decoder.cc</span><br><span class="line">├── decoder.h</span><br><span class="line">├── decoder_event_handler.h</span><br><span class="line">├── dubbo_hessian2_serializer_impl.cc</span><br><span class="line">├── dubbo_hessian2_serializer_impl.h</span><br><span class="line">├── dubbo_protocol_impl.cc</span><br><span class="line">├── dubbo_protocol_impl.h</span><br><span class="line">├── filters</span><br><span class="line">│   ├── BUILD</span><br><span class="line">│   ├── factory_base.h</span><br><span class="line">│   ├── filter.h</span><br><span class="line">│   ├── filter_config.h</span><br><span class="line">│   └── well_known_names.h</span><br><span class="line">├── heartbeat_response.cc</span><br><span class="line">├── heartbeat_response.h</span><br><span class="line">├── hessian_utils.cc</span><br><span class="line">├── hessian_utils.h</span><br><span class="line">├── message.h</span><br><span class="line">├── message_impl.cc</span><br><span class="line">├── message_impl.h</span><br><span class="line">├── metadata.h</span><br><span class="line">├── protocol.h</span><br><span class="line">├── protocol_constants.h</span><br><span class="line">├── router</span><br><span class="line">│   ├── BUILD</span><br><span class="line">│   ├── config.cc</span><br><span class="line">│   ├── config.h</span><br><span class="line">│   ├── route.h</span><br><span class="line">│   ├── route_matcher.cc</span><br><span class="line">│   ├── route_matcher.h</span><br><span class="line">│   ├── router.h</span><br><span class="line">│   ├── router_impl.cc</span><br><span class="line">│   └── router_impl.h</span><br><span class="line">├── serializer.h</span><br><span class="line">└── stats.h</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="插件加载"><a class="header-anchor" href="#插件加载">¶</a>插件加载</h2>
<p>在 <a href="http://blog.yanick.site/2020/04/21/networking/around-envoy/#Envoy-Extend">Envoy Extend</a> 中也聊过这部分内容，简而言之就是在 <code>ListenerImpl</code> 中，初始化 <code>FilterChain</code> 的时候是可以基于注册机制完成的</p>
<figure class="highlight cpp"><figcaption><span>ListenerImpl::createNetworkFilterChain</span><a href="https://github.com/envoyproxy/envoy/blob/874fb03dbc662edcba5f64082c2996a2378ae7f6/source/server/listener_impl.cc#L671">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListenerImpl::createNetworkFilterChain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Network::Connection&amp; connection,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;Network::FilterFactoryCb&gt;&amp; filter_factories)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Configuration::FilterChainUtility::<span class="built_in">buildFilterChain</span>(connection, filter_factories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从机制上，我们需要注册 <code>factory</code> 到 <code>envoy</code> 的上下文中，因此在 <code>dubbo_proxy/config.cc</code> 进行了注册</p>
<figure class="highlight cpp"><figcaption><span>REGISTER_FACTORY</span><a href="https://github.com/envoyproxy/envoy/blob/main/source/extensions/filters/network/dubbo_proxy/config.cc#L35">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">REGISTER_FACTORY</span>(DubboProxyFilterConfigFactory, Server::Configuration::NamedNetworkFilterConfigFactory);</span><br></pre></td></tr></table></figure>
<h2 id="插件初始化"><a class="header-anchor" href="#插件初始化">¶</a>插件初始化</h2>
<p>注册到 <code>Envoy</code> 之后，在系统启动的时候，系统就会回调我们构建我们的 <code>Factory</code>，继而又由 <code>Factory</code> 构建出我们的 <code>Filter</code> 而这部分的逻辑处于</p>
<figure class="highlight cpp"><figcaption><span>createFilterFactoryFromProtoTyped</span><a href="https://github.com/envoyproxy/envoy/blob/main/source/extensions/filters/network/dubbo_proxy/config.cc#L21">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Network::FilterFactoryCb <span class="title">DubboProxyFilterConfigFactory::createFilterFactoryFromProtoTyped</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> envoy::extensions::filters::network::dubbo_proxy::v3::DubboProxy&amp; proto_config,</span></span></span><br><span class="line"><span class="params"><span class="function">    Server::Configuration::FactoryContext&amp; context)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;Config&gt; <span class="title">filter_config</span><span class="params">(std::make_shared&lt;ConfigImpl&gt;(proto_config, context))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [filter_config, &amp;context](Network::FilterManager&amp; filter_manager) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    filter_manager.<span class="built_in">addReadFilter</span>(std::<span class="built_in">make_shared</span>&lt;ConnectionManager&gt;(</span><br><span class="line">        *filter_config, context.<span class="built_in">api</span>().<span class="built_in">randomGenerator</span>(), context.<span class="built_in">dispatcher</span>().<span class="built_in">timeSource</span>())); <span class="comment">// 当构建 filter_manager 回调完成 Filter 的构建</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们构建完成系统之后，就来到了如何处理数据量的地方了。我们从上文中已经知道，我们在 <code>filter_manager</code> 中构建了 <code>ReadFilter</code> 为我们的 <code>dubbo</code> 协议, 而这个 <code>ReadFilter</code> 实际上就是 <code>ConnectionManager</code>。</p>
<div>
    <label class="author-mark-label">小声比比</label>
    <p class="author-mark">ConnectionManager 的组件名真的有点大，这里的 `ConnectionManager` 和系统内置的并不是相同的(看名字很容易搞错)。</p>
</div>
<figure class="highlight cpp"><figcaption><span>conn_manager.h</span><a href="https://github.com/envoyproxy/envoy/blob/main/source/extensions/filters/network/dubbo_proxy/conn_manager.h">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionManager</span> : <span class="keyword">public</span> Network::ReadFilter,</span><br><span class="line">                          <span class="keyword">public</span> Network::ConnectionCallbacks,</span><br><span class="line">                          <span class="keyword">public</span> RequestDecoderCallbacks,</span><br><span class="line">                          Logger::Loggable&lt;Logger::Id::dubbo&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> ConfigProtocolType = envoy::extensions::filters::network::dubbo_proxy::v3::ProtocolType;</span><br><span class="line">  <span class="keyword">using</span> ConfigSerializationType =</span><br><span class="line">      envoy::extensions::filters::network::dubbo_proxy::v3::SerializationType;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ConnectionManager</span>(Config&amp; config, Random::RandomGenerator&amp; random_generator,</span><br><span class="line">                    TimeSource&amp; time_system);</span><br><span class="line">  ~<span class="built_in">ConnectionManager</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Network::ReadFilter</span></span><br><span class="line">  <span class="function">Network::FilterStatus <span class="title">onData</span><span class="params">(Buffer::Instance&amp; data, <span class="type">bool</span> end_stream)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">Network::FilterStatus <span class="title">onNewConnection</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">initializeReadFilterCallbacks</span><span class="params">(Network::ReadFilterCallbacks&amp;)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// RequestDecoderCallbacks</span></span><br><span class="line">  <span class="function">StreamHandler&amp; <span class="title">newStream</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This function is for testing only.</span></span><br><span class="line">  <span class="function">std::list&lt;ActiveMessagePtr&gt;&amp; <span class="title">getActiveMessagesForTest</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> active_message_list_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace DubboProxy</span></span><br><span class="line">&#125; <span class="comment">// namespace NetworkFilters</span></span><br><span class="line">&#125; <span class="comment">// namespace Extensions</span></span><br><span class="line">&#125; <span class="comment">// namespace Envoy</span></span><br></pre></td></tr></table></figure>
<p>从函数签名上，我们即可知道，这个 <code>ConnectionManager</code> 是 <code>ConnectionCallbacks</code> &amp; <code>ReadFilter</code> &amp; <code>RequestDecoderCallbacks</code> 三合一了。</p>
<p>此时系统很清晰的可以了解到是这么工作的</p>
<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title:  Dubbo Filter Init',
   'FilterManager->FilterManager: 0. new filter chain',
	 'FilterManager->DubboProxyFilterConfigFactory: 1. new dubbo read filter(Dubbo ConnectionManager)',
	 'FilterManager->FilterManager: 2. append Dubbo ConnectionManager',
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>
<h2 id="全局抽象"><a class="header-anchor" href="#全局抽象">¶</a>全局抽象</h2>
<p>对于 <code>Dubbo Proxy</code> 来说，代码中抽象一些比较重要的概念</p>
<ul>
<li><code>ConnectionManager</code>: 请求逻辑的主入口</li>
<li><code>Decoder</code>: 数据体反序列的实现，分 <code>ResponseDecoder</code> 和 <code>RequestDecoder</code></li>
<li><code>Protocol</code>: Dubbo 协议的实现部分（仅解析 Dubbo 自定义的 Header 部分）</li>
<li><code>ActiveMessage</code>: 一次 <code>Dubbo</code> 请求所对应的上下文，将其他的抽象串联起来</li>
<li><code>Router</code>: 路由转发匹配</li>
<li><code>FilterChain</code>: Dubbo 内部依然提供了额外构建的的 <code>Filter Chain</code></li>
</ul>
<h2 id="数据处理-TOP-HALF"><a class="header-anchor" href="#数据处理-TOP-HALF">¶</a>数据处理 [TOP HALF]</h2>
<h3 id="读数据处理"><a class="header-anchor" href="#读数据处理">¶</a>读数据处理</h3>
<p>读数据很明显从 <code>onData</code> 作为入口。</p>
<figure class="highlight cpp"><figcaption><span>onData</span><a href="https://github.com/envoyproxy/envoy/blob/main/source/extensions/filters/network/dubbo_proxy/conn_manager.cc#L27">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Network::FilterStatus <span class="title">ConnectionManager::onData</span><span class="params">(Buffer::Instance&amp; data, <span class="type">bool</span> end_stream)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ENVOY_LOG</span>(trace, <span class="string">&quot;dubbo: read &#123;&#125; bytes&quot;</span>, data.<span class="built_in">length</span>());</span><br><span class="line">  request_buffer_.<span class="built_in">move</span>(data);</span><br><span class="line">  <span class="built_in">dispatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (end_stream) &#123;</span><br><span class="line">    <span class="comment">// 暂时先忽略 end bottom </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Network::FilterStatus::StopIteration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于数据获取到第一时间就直接进行了 <code>dispatch()</code></p>
<figure class="highlight cpp"><figcaption><span>dispatch</span><a href="https://github.com/envoyproxy/envoy/blob/main/source/extensions/filters/network/dubbo_proxy/conn_manager.cc#L108">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionManager::dispatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">bool</span> underflow = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!underflow) &#123; <span class="comment">// 等待数据足够完成序列化</span></span><br><span class="line">      decoder_-&gt;<span class="built_in">onData</span>(request_buffer_, underflow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> EnvoyException&amp; ex) &#123;</span><br><span class="line">    <span class="built_in">ENVOY_CONN_LOG</span>(error, <span class="string">&quot;dubbo error: &#123;&#125;&quot;</span>, read_callbacks_-&gt;<span class="built_in">connection</span>(), ex.<span class="built_in">what</span>());</span><br><span class="line">    read_callbacks_-&gt;<span class="built_in">connection</span>().<span class="built_in">close</span>(Network::ConnectionCloseType::NoFlush);</span><br><span class="line">    stats_.request_decoding_error_.<span class="built_in">inc</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">resetAllMessages</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们先经过内部的 <code>decoder_</code> 进行序列化。</p>
<figure class="highlight cpp"><figcaption><span>onData</span><a href="https://github.com/envoyproxy/envoy/blob/main/source/extensions/filters/network/dubbo_proxy/decoder.cc#L93">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">FilterStatus <span class="title">DecoderBase::onData</span><span class="params">(Buffer::Instance&amp; data, <span class="type">bool</span>&amp; buffer_underflow)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ENVOY_LOG</span>(debug, <span class="string">&quot;dubbo decoder: &#123;&#125; bytes available&quot;</span>, data.<span class="built_in">length</span>());</span><br><span class="line">  buffer_underflow = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!decode_started_) &#123;</span><br><span class="line">    <span class="built_in">start</span>(); <span class="comment">// 状态机尚未初始化，现在开始</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ASSERT</span>(state_machine_ != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ENVOY_LOG</span>(debug, <span class="string">&quot;dubbo decoder: protocol &#123;&#125;, state &#123;&#125;, &#123;&#125; bytes available&quot;</span>, protocol_.<span class="built_in">name</span>(),</span><br><span class="line">            ProtocolStateNameValues::<span class="built_in">name</span>(state_machine_-&gt;<span class="built_in">currentState</span>()), data.<span class="built_in">length</span>());</span><br><span class="line"></span><br><span class="line">  ProtocolState rv = state_machine_-&gt;<span class="built_in">run</span>(data); <span class="comment">// 开始处理数据，这里涉及到不同的序列化协议，继续深入</span></span><br><span class="line">  <span class="keyword">switch</span> (rv) &#123;</span><br><span class="line">  <span class="keyword">case</span> ProtocolState::WaitForData: <span class="comment">// 如果需要更多数据，直接 Return 等待</span></span><br><span class="line">    <span class="built_in">ENVOY_LOG</span>(debug, <span class="string">&quot;dubbo decoder: wait for data&quot;</span>);</span><br><span class="line">    buffer_underflow = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> FilterStatus::Continue;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 其他就是结束，也就是收集完了，下面就要重置状态机</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ASSERT</span>(rv == ProtocolState::Done);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">complete</span>();</span><br><span class="line">  buffer_underflow = (data.<span class="built_in">length</span>() == <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">ENVOY_LOG</span>(debug, <span class="string">&quot;dubbo decoder: data length &#123;&#125;&quot;</span>, data.<span class="built_in">length</span>());</span><br><span class="line">  <span class="keyword">return</span> FilterStatus::Continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>dubbo</code> 抽象了一个 <code>状态机</code> 来解决问题，大致上也就是需要等待所有的数据收集到之后我们继续向下处理，因此当我们将数据收集完整之后，我们继续处理。</p>
<div style="width:100%; overflow-y:scroll;" id="diagram2"></div>
<script>
	var data =
	['Title:  Dubbo Filter Read',
   'ConnectionManager->ConnectionManager: 0. onData() 接收到数据',
	 'ConnectionManager->Decoder: 1. 序列化的数据 & 处理',
	 'Decoder->ConnectionManager: 1.1 结束 返回 ProtocolState::Done',
   'Decoder->ConnectionManager: 1.2 等待更多 返回 ProtocolState::WaitForData, 修改 buffer_underflow -> true',
   'Decoder->ConnectionManager: 1.3 异常 返回  ProtocolState::WaitForData',
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram2", {theme: 'simple', scale: 0.5});
</script>
<h3 id="序列化处理"><a class="header-anchor" href="#序列化处理">¶</a>序列化处理</h3>
<p>继续深入系列化的部分</p>
<figure class="highlight cpp"><figcaption><span>decode</span><a href="https://github.com/envoyproxy/envoy/blob/release/v1.18/source/extensions/filters/network/dubbo_proxy/decoder.cc#L71">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">ProtocolState <span class="title">DecoderStateMachine::run</span><span class="params">(Buffer::Instance&amp; buffer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (state_ != ProtocolState::Done) &#123;</span><br><span class="line">    DecoderStatus s = <span class="built_in">handleState</span>(buffer);</span><br><span class="line">    <span class="keyword">if</span> (s.next_state_ == ProtocolState::WaitForData) &#123;</span><br><span class="line">      <span class="keyword">return</span> ProtocolState::WaitForData;</span><br><span class="line">    &#125;</span><br><span class="line">    state_ = s.next_state_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DecoderStateMachine::DecoderStatus <span class="title">DecoderStateMachine::handleState</span><span class="params">(Buffer::Instance&amp; buffer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (state_) &#123;</span><br><span class="line">  <span class="keyword">case</span> ProtocolState::OnDecodeStreamHeader:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">onDecodeStreamHeader</span>(buffer);</span><br><span class="line">  <span class="keyword">case</span> ProtocolState::OnDecodeStreamData:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">onDecodeStreamData</span>(buffer);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    NOT_REACHED_GCOVR_EXCL_LINE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于接收到的数据，我们进行处理，对于 <code>Stream</code> 类型的数据，分为了 <code>Header</code> 和 <code>Data</code> 部分的处理，大致上是一样的，我们去 Header 的逻辑中一窥究竟。对于大部分的协议而言，<code>Header</code> 都是我们的元数据部分，包含了 <code>Len</code> <code>Type</code> 之类的字段，一般都是先处理 <code>Header</code></p>
<figure class="highlight cpp"><figcaption><span>onDecodeStreamHeader</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">DecoderStateMachine::DecoderStatus</span></span><br><span class="line"><span class="function"><span class="title">DecoderStateMachine::onDecodeStreamHeader</span><span class="params">(Buffer::Instance&amp; buffer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> metadata = std::<span class="built_in">make_shared</span>&lt;MessageMetadata&gt;();</span><br><span class="line">  <span class="keyword">auto</span> ret = protocol_.<span class="built_in">decodeHeader</span>(buffer, metadata); <span class="comment">// 使用 protocal 进行解析</span></span><br><span class="line">  <span class="keyword">if</span> (!ret.second) &#123; <span class="comment">// 当数据不足的时候，返回等待，因为 Header 本身还没传完。这里用了 Pair 返回</span></span><br><span class="line">    <span class="built_in">ENVOY_LOG</span>(debug, <span class="string">&quot;dubbo decoder: need more data for &#123;&#125; protocol&quot;</span>, protocol_.<span class="built_in">name</span>());</span><br><span class="line">    <span class="keyword">return</span> &#123;ProtocolState::WaitForData&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> context = ret.first;</span><br><span class="line">  <span class="keyword">if</span> (metadata-&gt;<span class="built_in">messageType</span>() == MessageType::HeartbeatRequest || metadata-&gt;<span class="built_in">messageType</span>() == MessageType::HeartbeatResponse) &#123;</span><br><span class="line">    <span class="comment">// 心跳处理，Skip</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将此 Stream 委托给另外一个对象处理，而这里就是</span></span><br><span class="line">  active_stream_ = delegate_.<span class="built_in">newStream</span>(metadata, context);</span><br><span class="line">  context-&gt;<span class="built_in">originMessage</span>().<span class="built_in">move</span>(buffer, context-&gt;<span class="built_in">headerSize</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当我们处理完成 Header 部分，给上游回复一个 OnDecodeStreamData，也就是下一次来的数据，就是我们的 Body 部分</span></span><br><span class="line">  <span class="keyword">return</span> &#123;ProtocolState::OnDecodeStreamData&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而委托者是谁，就是我们解答此代码逻辑的核心，我们在 <code>decoder.h</code> 中会发现 <code>delegate_</code> 的原型是一个 <code>Decoder</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ActiveStream* <span class="title">newStream</span><span class="params">(MessageMetadataSharedPtr metadata, ContextSharedPtr context)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  stream_ = std::<span class="built_in">make_unique</span>&lt;ActiveStream&gt;(callbacks_.<span class="built_in">newStream</span>(), metadata, context); </span><br><span class="line">  <span class="keyword">return</span> stream_.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见最为重要的是 <code>callbacks_</code> 如何 <code>newStream()</code> 的，这部分的逻辑在</p>
<figure class="highlight cpp"><figcaption><span>ConnectionManager.newSteam()</span><a href="https://github.com/envoyproxy/envoy/blob/release%2Fv1.18/source/extensions/filters/network/dubbo_proxy/conn_manager.cc#L81">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">StreamHandler&amp; <span class="title">ConnectionManager::newStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ActiveMessagePtr <span class="title">new_message</span><span class="params">(std::make_unique&lt;ActiveMessage&gt;(*<span class="keyword">this</span>))</span></span>;</span><br><span class="line">  <span class="comment">// 构建一个 FilterChain</span></span><br><span class="line">  new_message-&gt;<span class="built_in">createFilterChain</span>();</span><br><span class="line">  <span class="comment">// 将任务 Append 既有的任务列表中, 然后返回</span></span><br><span class="line">  LinkedList::<span class="built_in">moveIntoList</span>(std::<span class="built_in">move</span>(new_message), active_message_list_);</span><br><span class="line">  <span class="keyword">return</span> **active_message_list_.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div>
    <label class="author-mark-label">小声比比</label>
    <p class="author-mark">走到这里，我们又看见了我们熟悉的 FilterChain，我们可以把整个系统看作一个大 FilterChain，而在 Dubbo Proxy 包含了一个子 FilterChain</p>
</div>
<p>而当我们继续处理 <code>Body</code> 部分的时候</p>
<figure class="highlight cpp"><figcaption><span>onDecodeStreamData</span><a href="https://github.com/envoyproxy/envoy/blob/release%2Fv1.18/source/extensions/filters/network/dubbo_proxy/decoder.cc#L43">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">DecoderStateMachine::DecoderStatus</span></span><br><span class="line"><span class="function"><span class="title">DecoderStateMachine::onDecodeStreamData</span><span class="params">(Buffer::Instance&amp; buffer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!protocol_.<span class="built_in">decodeData</span>(buffer, active_stream_-&gt;context_, active_stream_-&gt;metadata_)) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;ProtocolState::WaitForData&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  active_stream_-&gt;context_-&gt;<span class="built_in">originMessage</span>().<span class="built_in">move</span>(buffer, active_stream_-&gt;context_-&gt;<span class="built_in">bodySize</span>());</span><br><span class="line">  active_stream_-&gt;<span class="built_in">onStreamDecoded</span>(); <span class="comment">//经过转换直接跳转到 ActiveMessage::onStreamDecoded 中</span></span><br><span class="line">  active_stream_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;ProtocolState::Done&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ActiveMessage::onStreamDecoded</span><span class="params">(MessageMetadataSharedPtr metadata, ContextSharedPtr ctx)</span> </span>&#123;</span><br><span class="line">  metadata_ = metadata;</span><br><span class="line">  context_ = ctx;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义进入 filter 进行 Message Decoded 的工作，把这个对象放到了 ActiveMessage 上下文中</span></span><br><span class="line">  filter_action_ = [metadata, ctx](DubboFilters::DecoderFilter* filter) -&gt; FilterStatus &#123;</span><br><span class="line">    <span class="keyword">return</span> filter-&gt;<span class="built_in">onMessageDecoded</span>(metadata, ctx);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后去执行这个 filter</span></span><br><span class="line">  <span class="keyword">auto</span> status = <span class="built_in">applyDecoderFilters</span>(<span class="literal">nullptr</span>, FilterIterationStartState::CanStartFromCurrent);</span><br><span class="line">  <span class="keyword">if</span> (status == FilterStatus::StopIteration) &#123;</span><br><span class="line">    pending_stream_decoded_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">finalizeRequest</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="width:100%; overflow-y:scroll;" id="diagram3"></div>
<script>
	var data =
	['Title: ActiveMessage',
   'DecoderStateMachine->ConnectionManager: 0. newStream() 在处理 Header 部分时候，newStream() 创建一个 ActiveMessage',
	 'DecoderStateMachine->ActiveMessage: 1. onStreamDecoded() 继续处理 Body 部分的时候，使用之前的 ActiveMessage 来处理',
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram3", {theme: 'simple', scale: 0.5});
</script>
<figure class="highlight cpp"><figcaption><span>applyDecoderFilters</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">FilterStatus <span class="title">ActiveMessage::applyDecoderFilters</span><span class="params">(ActiveMessageDecoderFilter* filter,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                FilterIterationStartState state)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!local_response_sent_) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> entry = <span class="built_in">commonDecodePrefix</span>(filter, state); entry != decoder_filters_.<span class="built_in">end</span>(); entry++) &#123;</span><br><span class="line">      <span class="type">const</span> FilterStatus status = <span class="built_in">filter_action_</span>((*entry)-&gt;<span class="built_in">handler</span>().<span class="built_in">get</span>());</span><br><span class="line">      <span class="keyword">if</span> (local_response_sent_) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (status != FilterStatus::Continue) &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  filter_action_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> FilterStatus::Continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然进入的逻辑就是一个比较正常的 <code>filter chain</code> 了，走过这些漫长曲折的道路，我们来到了，真正的逻辑部分。也就是这些 <code>filter</code> 是什么,不过这里显然是配置化的，在 <code>example</code> 也如此，因此在此处我们不做深入，逻辑和之前的 <code>filterChain</code> 类似。</p>
<h3 id="Dubbo-Filter-Route"><a class="header-anchor" href="#Dubbo-Filter-Route">¶</a>Dubbo Filter Route</h3>
<p>我们在上面 <code> return filter-&gt;onMessageDecoded(metadata, ctx);</code> 中，当我们完成了所有的 MessageDcoded 就会进入如下逻辑，显然进入了我们所能见的 <code>route</code> 阶段。</p>
<figure class="highlight cpp"><figcaption><span>onMessageDecoded</span><a href="https://github.com/envoyproxy/envoy/blob/release%2Fv1.18/source/extensions/filters/network/dubbo_proxy/router/router_impl.cc#L26">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">FilterStatus <span class="title">Router::onMessageDecoded</span><span class="params">(MessageMetadataSharedPtr metadata, ContextSharedPtr ctx)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ASSERT</span>(metadata-&gt;<span class="built_in">hasInvocationInfo</span>());</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; invocation = metadata-&gt;<span class="built_in">invocationInfo</span>();</span><br><span class="line"></span><br><span class="line">  route_ = callbacks_-&gt;<span class="built_in">route</span>();</span><br><span class="line">  <span class="keyword">if</span> (!route_) &#123;</span><br><span class="line">    <span class="comment">// 没有 route 直接 Stop</span></span><br><span class="line">    <span class="keyword">return</span> FilterStatus::StopIteration;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  route_entry_ = route_-&gt;<span class="built_in">routeEntry</span>();</span><br><span class="line"></span><br><span class="line">  Upstream::ThreadLocalCluster* cluster = cluster_manager_.<span class="built_in">getThreadLocalCluster</span>(route_entry_-&gt;<span class="built_in">clusterName</span>());</span><br><span class="line">  <span class="keyword">if</span> (!cluster) &#123;</span><br><span class="line">    <span class="comment">// 没找到 cluster 就返回</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster_ = cluster-&gt;<span class="built_in">info</span>();</span><br><span class="line"></span><br><span class="line">  Tcp::ConnectionPool::Instance* conn_pool =</span><br><span class="line">      cluster-&gt;<span class="built_in">tcpConnPool</span>(Upstream::ResourcePriority::Default, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>* invocation_impl = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> RpcInvocationImpl*&gt;(&amp;invocation);</span><br><span class="line">  <span class="keyword">if</span> (invocation_impl-&gt;<span class="built_in">hasAttachment</span>() &amp;&amp; invocation_impl-&gt;<span class="built_in">attachment</span>().<span class="built_in">attachmentUpdated</span>()) &#123;</span><br><span class="line">   <span class="comment">// 附件上传</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//直接将请求体放置于 upstream_request_buffer_ 中，并不做任何修改</span></span><br><span class="line">    upstream_request_buffer_.<span class="built_in">move</span>(ctx-&gt;<span class="built_in">originMessage</span>(), ctx-&gt;<span class="built_in">messageSize</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  upstream_request_ = std::<span class="built_in">make_unique</span>&lt;UpstreamRequest&gt;(</span><br><span class="line">      *<span class="keyword">this</span>, *conn_pool, metadata, callbacks_-&gt;<span class="built_in">serializationType</span>(), callbacks_-&gt;<span class="built_in">protocolType</span>());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开始传输数据</span></span><br><span class="line">  <span class="keyword">return</span> upstream_request_-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转发的本体逻辑并不复杂，主要的还是在 <code>route</code> 部分，我们来看看。</p>
<h3 id="Route"><a class="header-anchor" href="#Route">¶</a>Route</h3>
<figure class="highlight cpp"><figcaption><span>matches</span><a href="https://github.com/envoyproxy/envoy/blob/release%2Fv1.18/source/extensions/filters/network/dubbo_proxy/router/route_matcher.cc#L86">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">RouteConstSharedPtr <span class="title">MethodRouteEntryImpl::matches</span><span class="params">(<span class="type">const</span> MessageMetadata&amp; metadata, <span class="type">uint64_t</span> random_value)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> invocation = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> RpcInvocationImpl*&gt;(&amp;metadata.<span class="built_in">invocationInfo</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 invocation 的 Header 进行匹配</span></span><br><span class="line">  <span class="keyword">if</span> (!RouteEntryImplBase::<span class="built_in">headersMatch</span>(*invocation)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据 Method 进行匹配</span></span><br><span class="line">  <span class="keyword">if</span> (!method_name_.<span class="built_in">match</span>(invocation-&gt;<span class="built_in">methodName</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据参数匹配 </span></span><br><span class="line">  <span class="keyword">if</span> (parameter_route_) &#123;</span><br><span class="line">    <span class="keyword">return</span> parameter_route_-&gt;<span class="built_in">matches</span>(metadata, random_value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 随机选择</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">clusterEntry</span>(random_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路由部分就是标准的一个从上往下执行的过程。</p>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>
<p>当我们完成了上半部分的逻辑之后，我们会得到这么一个全局的视角</p>
<div style="width:100%; overflow-y:scroll;" id="diagram4"></div>
<script>
	var data =
	['Title:  Dubbo Filter 上半部分',
   'FilterChainManage->DubboFiterFactory: 0. newReadFilter 创建 ConnectionManager',
	 'FilterChainManage->ConnectionManager: 1. 调用 ConnectionManager 进行处理',
	 'ConnectionManager->Decoder: 2. onData() 进行逻辑处理',
   'Decoder->ConnectionManager: 3. newStream() 创建 ActiveMessage 进行此链接处理',
   'Decoder->ActiveMessage: 4. onDecodeStreamData() 完成 Header 部分协议解析，进入 Body 逻辑处理',
   'ActiveMessage->ActiveMessage: 5. applyDecoderFilters() 对数据包进行 Filter ',
   'ActiveMessage->Route: 6. route() 进行路由',
   'Route->UpstreamRequest: 7. start() 进行转发'
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram4", {theme: 'simple', scale: 0.5});
</script>
<h2 id="数据处理-BOTTOM-HALF"><a class="header-anchor" href="#数据处理-BOTTOM-HALF">¶</a>数据处理 [BOTTOM HALF]</h2>
<h3 id="写入回调"><a class="header-anchor" href="#写入回调">¶</a>写入回调</h3>
<p>显然当我们 <code>start</code> 写入之后，当服务端回复了我们的请求，我们需要知道在哪里处理，而这一切在构建的时候就已经确定了。</p>
<figure class="highlight cpp"><figcaption><span>start</span></figcaption><table><tr><td class="code"><pre><span class="line">FilterStatus Router::UpstreamRequest::<span class="built_in">start</span>() &#123;</span><br><span class="line">  Tcp::ConnectionPool::Cancellable* handle = conn_pool_.<span class="built_in">newConnection</span>(*<span class="keyword">this</span>); <span class="comment">// 这里的this也就是 callback</span></span><br><span class="line">  <span class="comment">// ConnectionPool::Cancellable* newConnection(Tcp::ConnectionPool::Callbacks&amp; callbacks)</span></span><br><span class="line">  <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">    conn_pool_handle_ = handle;</span><br><span class="line">    <span class="keyword">return</span> FilterStatus::StopIteration;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FilterStatus::Continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，完成请求之后的回调是进入</p>
<figure class="highlight cpp"><figcaption><span>onPoolReady</span><a href="https://github.com/envoyproxy/envoy/blob/release%2Fv1.18/source/extensions/filters/network/dubbo_proxy/router/router_impl.cc#L261">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> Router::UpstreamRequest::<span class="built_in">onPoolReady</span>(Tcp::ConnectionPool::ConnectionDataPtr&amp;&amp; conn_data,</span><br><span class="line">                                          Upstream::HostDescriptionConstSharedPtr host) &#123;</span><br><span class="line">  <span class="built_in">onUpstreamHostSelected</span>(host);</span><br><span class="line">  conn_data_ = std::<span class="built_in">move</span>(conn_data);</span><br><span class="line">  conn_data_-&gt;<span class="built_in">addUpstreamCallbacks</span>(parent_);</span><br><span class="line">  <span class="built_in">onRequestStart</span>(continue_decoding);</span><br><span class="line">  <span class="built_in">encodeData</span>(parent_.upstream_request_buffer_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终和 Envoy 的契约跳入此函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::onUpstreamData</span><span class="params">(Buffer::Instance&amp; data, <span class="type">bool</span> end_stream)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 处理返回</span></span><br><span class="line">  <span class="keyword">if</span> (!upstream_request_-&gt;response_started_) &#123;</span><br><span class="line">    callbacks_-&gt;<span class="built_in">startUpstreamResponse</span>();</span><br><span class="line">    upstream_request_-&gt;response_started_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用回调的 upstreamData，而这里的 callbacks 其实就是 ActiveMessageDecoderFilter</span></span><br><span class="line">  DubboFilters::UpstreamResponseStatus status = callbacks_-&gt;<span class="built_in">upstreamData</span>(data);</span><br><span class="line">  <span class="keyword">if</span> (status == DubboFilters::UpstreamResponseStatus::Complete) &#123;</span><br><span class="line">    <span class="built_in">ENVOY_STREAM_LOG</span>(debug, <span class="string">&quot;dubbo router: response complete&quot;</span>, *callbacks_);</span><br><span class="line">    upstream_request_-&gt;<span class="built_in">onResponseComplete</span>();</span><br><span class="line">    <span class="built_in">cleanup</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == DubboFilters::UpstreamResponseStatus::Reset) &#123;</span><br><span class="line">    <span class="built_in">ENVOY_STREAM_LOG</span>(debug, <span class="string">&quot;dubbo router: upstream reset&quot;</span>, *callbacks_);</span><br><span class="line">    upstream_request_-&gt;<span class="built_in">resetStream</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DubboFilters::UpstreamResponseStatus</span></span><br><span class="line"><span class="function"><span class="title">ActiveMessageDecoderFilter::upstreamData</span><span class="params">(Buffer::Instance&amp; buffer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> parent_.<span class="built_in">upstreamData</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parent_ -&gt; ActiveMessage</span></span><br><span class="line">ActiveResponseDecoder::<span class="built_in">ActiveResponseDecoder</span>(ActiveMessage&amp; parent, DubboFilterStats&amp; stats, Network::Connection&amp; connection ProtocolPtr&amp;&amp; protocol)</span><br></pre></td></tr></table></figure>
<h3 id="写入"><a class="header-anchor" href="#写入">¶</a>写入</h3>
<p>从上面就看到我直接回跳到 <code>ActiveMessage</code> 中 <code>upstreamData</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DubboFilters::UpstreamResponseStatus <span class="title">ActiveMessage::upstreamData</span><span class="params">(Buffer::Instance&amp; buffer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> status = response_decoder_-&gt;<span class="built_in">onData</span>(buffer);</span><br><span class="line">    <span class="keyword">if</span> (status == DubboFilters::UpstreamResponseStatus::Complete) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">requestId</span>() != response_decoder_-&gt;<span class="built_in">requestId</span>()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="built_in">EnvoyException</span>(fmt::format(<span class="string">&quot;dubbo response: request ID is not equal, &#123;&#125;:&#123;&#125;&quot;</span>, <span class="built_in">requestId</span>(), response_decoder_-&gt;<span class="built_in">requestId</span>()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Completed upstream response.</span></span><br><span class="line">      parent_.<span class="built_in">deferredMessage</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == DubboFilters::UpstreamResponseStatus::Retry) &#123;</span><br><span class="line">      response_decoder_.<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// response_decoder_ = std::make_unique&lt;ActiveResponseDecoder&gt;(*this, parent_.stats(), parent_.connection(), std::move(protocol));</span></span><br></pre></td></tr></table></figure>
<p>而当我们抵达到 <code>onData</code> 的时候，调用了本体上的 <code>decoder</code> 的逻辑，这里对于数据的解析使用了统一的逻辑。</p>
<figure class="highlight cpp"><figcaption><span>onData</span><a href="https://github.com/envoyproxy/envoy/blob/release%2Fv1.18/source/extensions/filters/network/dubbo_proxy/active_message.cc#L22">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">DubboFilters::UpstreamResponseStatus <span class="title">ActiveResponseDecoder::onData</span><span class="params">(Buffer::Instance&amp; data)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> underflow = <span class="literal">false</span>;</span><br><span class="line">  decoder_-&gt;<span class="built_in">onData</span>(data, underflow);</span><br><span class="line">  <span class="built_in">ASSERT</span>(complete_ || underflow);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response_status_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完成一切"><a class="header-anchor" href="#完成一切">¶</a>完成一切</h3>
<p>当我们完成协议数据等待的完成，就再次进入我们熟悉的 <code>onStreamDecoded</code> 部分</p>
<figure class="highlight cpp"><figcaption><span>ActiveResponseDecoder::onStreamDecoded</span><a href="https://github.com/envoyproxy/envoy/blob/release%2Fv1.18/source/extensions/filters/network/dubbo_proxy/active_message.cc#L32">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ActiveResponseDecoder::onStreamDecoded</span><span class="params">(MessageMetadataSharedPtr metadata, ContextSharedPtr ctx)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  metadata_ = metadata;</span><br><span class="line">  <span class="comment">//同样的 Filter Chain 逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">applyMessageEncodedFilters</span>(metadata, ctx) != FilterStatus::Continue) &#123;</span><br><span class="line">    response_status_ = DubboFilters::UpstreamResponseStatus::Complete;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在这里我们完成了所有的写入操作</span></span><br><span class="line">  response_connection_.<span class="built_in">write</span>(ctx-&gt;<span class="built_in">originMessage</span>(), <span class="literal">false</span>);</span><br><span class="line">  complete_ = <span class="literal">true</span>;</span><br><span class="line">  response_status_ = DubboFilters::UpstreamResponseStatus::Complete;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ENVOY_LOG</span>(debug, <span class="string">&quot;dubbo response: complete processing of upstream response messages, id is &#123;&#125;&quot;</span>, metadata-&gt;<span class="built_in">requestId</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们完成这一切的时候，需要把 <code>ActiveMessage</code> 释放掉即可。</p>
<h3 id="总结-v2"><a class="header-anchor" href="#总结-v2">¶</a>总结</h3>
<p>当我们完成了下半部分的逻辑之后，我们又会得到这么一个全局的视角</p>
<div style="width:100%; overflow-y:scroll;" id="diagram5"></div>
<script>
	var data =
	['Title:  Dubbo Filter 下半部分',
   'UpstreamRequest->ActiveMessageDecoderFilter: 0. upstreamData() UpdateRequest接收到的响应数据进入 ActiveMessageDecoderFilter',
	 'ActiveMessageDecoderFilter->ActiveMessageDecoderFilter: 1. onData() 直接进入自身的 ondata() 中',
	 'ActiveMessageDecoderFilter->Decoder: 2. onData() 进行逻辑处理',
   'Decoder->ActiveMessageDecoderFilter: 3. onStreamDecoded() 完成 Header 部分协议解析，进入逻辑处理',
   'ActiveMessageDecoderFilter->Connection: 4. write() 回写数据包'
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram5", {theme: 'simple', scale: 0.5});
</script>
<h2 id="最终"><a class="header-anchor" href="#最终">¶</a>最终</h2>
<p>当我们将一切源码串起来的时候，我们就可知的，项目的逻辑是</p>
<div style="width:100%; overflow-y:scroll;" id="diagram6"></div>
<script>
	var data =
	['Title:  Dubbo Filter Works',
   'EnvoyFilterManager->ConnectionManager: 0. Envoy 构建 Dubbo ConnectionManager 并调用之',
	 'ConnectionManager->Decoder: 1. onData() 进入Decoder 完成序列化，处理包括等待异常',
	 'Decoder->ActiveMessage: 2. onStreamDecoded() 完成 Dubbo 协议的元数据解析，之后进入路由',
   'ActiveMessage->Route: 3. route() 完成路由之后进入转发',
   'Route->UpstreamRequest: 4. 完成路由之后进入转发 ',
   'ConnectionManager->ConnectionManager: 4. TOP Half 逻辑完成',
   'UpstreamRequest->ActiveMessageDecoderFilter: 5. 完成请求回调 ActiveMessageDecoderFilter',
   'ActiveMessageDecoderFilter->ResponseDecoder: 6. 等待完成序列化，回调之' ,
   'ResponseDecoder->ActiveMessageDecoderFilter: 7. onStreamDecoded() 完成序列化，准备回复客户端',
   'ActiveMessageDecoderFilter->Connection: 8.write() 回写数据',
   'Connection->ActiveMessageDecoderFilter: 9. Complete() 完成, 回收 ActiveMessage ',
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram6", {theme: 'simple', scale: 0.5});
</script>
<h3 id="我们能用-Rust-实现这一切吗？"><a class="header-anchor" href="#我们能用-Rust-实现这一切吗？">¶</a>我们能用 Rust 实现这一切吗？</h3>
<p>答案是显然的，因为对于整个 <code>dubbo filter</code> 来说，最为核心的部分就是要把自己看做一个 <code>network filter</code>，而在 <code>envoy</code> 中，也作为 <code>wasm</code> 的 <code>abi</code> 暴露出来了。</p>
<figure class="highlight rust"><figcaption><span>NetworkFilter</span><a href="https://github.com/tetratelabs/envoy-wasm-rust-sdk/blob/master/envoy-sdk/src/extension/filter/network/mod.rs">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> envoy::extension::&#123;NetworkFilter, <span class="type">Result</span>&#125;;</span><br><span class="line"><span class="keyword">use</span> envoy::extension::filter::network::FilterStatus;</span><br><span class="line"><span class="keyword">use</span> envoy::host::log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyNetworkFilter</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">NetworkFilter</span> <span class="keyword">for</span> <span class="title class_">MyNetworkFilter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">on_new_connection</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;FilterStatus&gt; &#123;</span><br><span class="line">        log::info!(<span class="string">&quot;a new connection has been established&quot;</span>);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(FilterStatus::Continue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在整个过程中，<code>dubbo proxy</code> 需要获得 <code>cluster</code> 的信息和获得连接池。</p>
<p>获得 <code>cluster</code> 信息可以通过 <a href="https://github.com/tetratelabs/envoy-wasm-rust-sdk/blob/master/envoy-sdk/src/host/stream_info/mod.rs">stream_info</a> 接口获得。不过向下游发送 <code>TCP</code> 请求，在 <a href="https://github.com/proxy-wasm/proxy-wasm-rust-sdk/blob/master/src/hostcalls.rs">hostcalls</a> 并未可见。因此我们无法实现此功能。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>dubbo</category>
        <category>envoy</category>
      </categories>
      <tags>
        <tag>envoy</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>How Higress Works</title>
    <url>/2022/11/07/networking/higress/higress/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2022/202211071002609.png" alt=""></p>
<p>在 <a href="https://mp.weixin.qq.com/s/vUkA4SeMVtG-genfP2b0ww">阿里巴巴开源下一代云原生网关Higress：基于Envoy，支持Nginx Ingress零成本快速迁移</a>中，介绍了阿里开源的云原生网关。<br>
我们今天就来探索下，这个项目是做了什么，他又是怎么工作的。</p>
<span id="more"></span>
<h2 id="Intro"><a class="header-anchor" href="#Intro">¶</a>Intro</h2>
<p>对于一个全新的系统，我们首先从架构上切入是一个比较的好的选择。</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2022/202211071007261.png" alt=""></p>
<p>从架构图上，我们可以发现，整体还是分成了</p>
<ul>
<li><code>控制面</code>: istio + Higress Controller</li>
<li><code>数据面</code>: Higress Data Plane</li>
</ul>
<p>从图上我们就可以猜测出，<code>数据面</code> 是基于 <code>Envoy</code> + 一些自定义的插件来构成的。而<code>控制面</code> 看起来并不是很直观。<br>
从上图可以看出 <code>istio</code> 和 <code>Envoy</code> 通讯，而 <code>higress</code> 不直接和 <code>Envoy</code> 通讯，因此，我们可以大胆的猜测 <code>Higress</code> 作为 <code>istio</code> 的 <code>MCP</code> 远端数据源提供服务给 <code>istio</code>。那么基于这的假设我们来看看它是如何工作的。</p>
<h2 id="How-it-works"><a class="header-anchor" href="#How-it-works">¶</a>How it works</h2>
<h3 id="初始化环境"><a class="header-anchor" href="#初始化环境">¶</a>初始化环境</h3>
<p><code>直接看代码是不明智的</code>，一般来说我们先从一个项目的 <code>Statup</code> 开始，对一个项目有自己的观感才是比较好的选择。那我们先按照社区的文档初始化这个项目</p>
<ol>
<li>安装 istio</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create ns istio-system</span><br><span class="line">helm install istio -n istio-system oci://higress-registry.cn-hangzhou.cr.aliyuncs.com/charts/istio</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要 helm 较高版本的，如果运行出现  failed to download “oci://higress-registry.cn-hangzhou.cr.aliyuncs.com/charts/istio” (hint: running <code>helm repo update</code> may help)，更新helm即可。</p>
</blockquote>
<ol start="2">
<li>安装 higess</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create ns higress-system</span><br><span class="line">helm install higress -n higress-system oci://higress-registry.cn-hangzhou.cr.aliyuncs.com/charts/higress </span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建 Ingress 配置</li>
</ol>
<p>假设在 default 命名空间下已经部署了一个 <code>demo service</code>，服务端口为 80 ，则创建下面这个 K8s Ingress</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">simple-example</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">demo.bar.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/demo</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span>  </span><br></pre></td></tr></table></figure>
<p>最终环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get pod -A</span><br><span class="line">NAMESPACE        NAME                                 READY   STATUS    RESTARTS   AGE</span><br><span class="line">default          echo-web-89668cbcc-7jsx7             1/1     Running   0          82s</span><br><span class="line">default          echo-web-89668cbcc-zxjsl             1/1     Running   0          82s</span><br><span class="line">higress-system   higress-controller-857bc7484-znslv   1/1     Running   0          2m54s</span><br><span class="line">higress-system   higress-gateway-74cb5978cc-fw28r     1/1     Running   0          2m54s</span><br><span class="line">istio-system     istiod-5bf74cd79b-9gzm9              1/1     Running   0          6m59s</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>执行访问</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">&quot;<span class="subst">$(k get svc -n higress-system higress-gateway -o jsonpath=&#x27;&#123;.status.loadBalancer.ingress[0].ip&#125;&#x27;)</span>&quot;</span>/demo -H <span class="string">&#x27;host: demo.bar.com&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;host&quot;</span>:&#123;<span class="string">&quot;hostname&quot;</span>:<span class="string">&quot;demo.bar.com&quot;</span>,<span class="string">&quot;ip&quot;</span>:<span class="string">&quot;::ffff:172.30.52.234&quot;</span>,<span class="string">&quot;ips&quot;</span>:[]&#125;,<span class="string">&quot;http&quot;</span>:&#123;<span class="string">&quot;method&quot;</span>:<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;baseUrl&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;originalUrl&quot;</span>:<span class="string">&quot;/demo&quot;</span>,<span class="string">&quot;protocol&quot;</span>:<span class="string">&quot;http&quot;</span>&#125;,<span class="string">&quot;request&quot;</span>:&#123;<span class="string">&quot;params&quot;</span>:&#123;<span class="string">&quot;0&quot;</span>:<span class="string">&quot;/demo&quot;</span>&#125;,<span class="string">&quot;query&quot;</span>:&#123;&#125;,<span class="string">&quot;cookies&quot;</span>:&#123;&#125;,<span class="string">&quot;body&quot;</span>:&#123;&#125;,<span class="string">&quot;headers&quot;</span>:&#123;<span class="string">&quot;host&quot;</span>:<span class="string">&quot;demo.bar.com&quot;</span>,<span class="string">&quot;user-agent&quot;</span>:<span class="string">&quot;curl/7.79.1&quot;</span>,<span class="string">&quot;accept&quot;</span>:<span class="string">&quot;*/*&quot;</span>,<span class="string">&quot;DETAILS_SERVICE_PORT&quot;</span>:<span class="string">&quot;9080&quot;</span>,<span class="string">&quot;HELLOWORLD_SERVICE_PORT_HTTP&quot;</span>:<span class="string">&quot;5000&quot;</span>,<span class="string">&quot;KUBERNETES_PORT_443_TCP_PORT&quot;</span>:<span class="string">&quot;443&quot;</span>,<span class="string">&quot;KUBERNETES_PORT_443_TCP&quot;</span>:<span class="string">&quot;tcp://172.31.160.1:443&quot;</span>,<span class="string">&quot;HOME&quot;</span>:<span class="string">&quot;/root&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从日志验证"><a class="header-anchor" href="#从日志验证">¶</a>从日志验证</h3>
<p>首先第一步，我们可以从启动日志中去看出一些端倪，这是一个比较好的习惯。</p>
<p>从 istiod 日志中我们就可以获得如同我们猜想的日志信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl logs -n istio-system istiod-5bf74cd79b-9gzm9</span><br><span class="line"></span><br><span class="line">nc: getaddrinfo <span class="keyword">for</span> host <span class="string">&quot;higress-controller.higress-system&quot;</span> port 15051: Name or service not known</span><br><span class="line">testing higress controller is ready to connect...</span><br><span class="line">nc: getaddrinfo <span class="keyword">for</span> host <span class="string">&quot;higress-controller.higress-system&quot;</span> port 15051: Name or service not known</span><br><span class="line">testing higress controller is ready to connect...</span><br><span class="line">nc: getaddrinfo <span class="keyword">for</span> host <span class="string">&quot;higress-controller.higress-system&quot;</span> port 15051: Name or service not known</span><br><span class="line">testing higress controller is ready to connect...</span><br><span class="line">2022-11-07T02:22:11.924444Z	info	FLAG: --caCertFile=<span class="string">&quot;&quot;</span></span><br><span class="line">2022-11-07T02:22:11.924484Z	info	FLAG: --clusterAliases=<span class="string">&quot;[]&quot;</span></span><br><span class="line">2022-11-07T02:22:11.938185Z	info	klog	Config not found: /var/run/secrets/remote/config</span><br><span class="line">2022-11-07T02:22:11.939130Z	info	initializing mesh configuration ./etc/istio/config/mesh</span><br><span class="line">2022-11-07T02:22:11.939963Z	warn	Using <span class="built_in">local</span> mesh config file ./etc/istio/config/mesh, <span class="keyword">in</span> cluster configs ignored</span><br><span class="line">2022-11-07T02:22:11.940311Z	info	mesh configuration: &#123;</span><br><span class="line">    <span class="string">&quot;proxyListenPort&quot;</span>: 15001,</span><br><span class="line">    <span class="string">&quot;connectTimeout&quot;</span>: <span class="string">&quot;10s&quot;</span>,</span><br><span class="line">    <span class="string">&quot;protocolDetectionTimeout&quot;</span>: <span class="string">&quot;0.100s&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ingressClass&quot;</span>: <span class="string">&quot;istio&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ingressService&quot;</span>: <span class="string">&quot;istio-ingressgateway&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ingressControllerMode&quot;</span>: <span class="string">&quot;STRICT&quot;</span>,</span><br><span class="line">    <span class="string">&quot;enableTracing&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;accessLogFile&quot;</span>: <span class="string">&quot;/dev/stdout&quot;</span>,</span><br><span class="line">    <span class="string">&quot;accessLogFormat&quot;</span>: <span class="string">&quot;&#123;\&quot;authority\&quot;:\&quot;%REQ(:AUTHORITY)%\&quot;,\&quot;bytes_received\&quot;:\&quot;%BYTES_RECEIVED%\&quot;,\&quot;bytes_sent\&quot;:\&quot;%BYTES_SENT%\&quot;,\&quot;downstream_local_address\&quot;:\&quot;%DOWNSTREAM_LOCAL_ADDRESS%\&quot;,\&quot;downstream_remote_address\&quot;:\&quot;%DOWNSTREAM_REMOTE_ADDRESS%\&quot;,\&quot;duration\&quot;:\&quot;%DURATION%\&quot;,\&quot;istio_policy_status\&quot;:\&quot;%DYNAMIC_METADATA(istio.mixer:status)%\&quot;,\&quot;method\&quot;:\&quot;%REQ(:METHOD)%\&quot;,\&quot;path\&quot;:\&quot;%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\&quot;,\&quot;protocol\&quot;:\&quot;%PROTOCOL%\&quot;,\&quot;request_id\&quot;:\&quot;%REQ(X-REQUEST-ID)%\&quot;,\&quot;requested_server_name\&quot;:\&quot;%REQUESTED_SERVER_NAME%\&quot;,\&quot;response_code\&quot;:\&quot;%RESPONSE_CODE%\&quot;,\&quot;response_flags\&quot;:\&quot;%RESPONSE_FLAGS%\&quot;,\&quot;route_name\&quot;:\&quot;%ROUTE_NAME%\&quot;,\&quot;start_time\&quot;:\&quot;%START_TIME%\&quot;,\&quot;trace_id\&quot;:\&quot;%REQ(X-B3-TRACEID)%\&quot;,\&quot;upstream_cluster\&quot;:\&quot;%UPSTREAM_CLUSTER%\&quot;,\&quot;upstream_host\&quot;:\&quot;%UPSTREAM_HOST%\&quot;,\&quot;upstream_local_address\&quot;:\&quot;%UPSTREAM_LOCAL_ADDRESS%\&quot;,\&quot;upstream_service_time\&quot;:\&quot;%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%\&quot;,\&quot;upstream_transport_failure_reason\&quot;:\&quot;%UPSTREAM_TRANSPORT_FAILURE_REASON%\&quot;,\&quot;user_agent\&quot;:\&quot;%REQ(USER-AGENT)%\&quot;,\&quot;x_forwarded_for\&quot;:\&quot;%REQ(X-FORWARDED-FOR)%\&quot;&#125;\n&quot;</span>,</span><br><span class="line">    <span class="string">&quot;defaultConfig&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;configPath&quot;</span>: <span class="string">&quot;./etc/istio/proxy&quot;</span>,</span><br><span class="line">        <span class="string">&quot;binaryPath&quot;</span>: <span class="string">&quot;/usr/local/bin/envoy&quot;</span>,</span><br><span class="line">        <span class="string">&quot;serviceCluster&quot;</span>: <span class="string">&quot;istio-proxy&quot;</span>,</span><br><span class="line">        <span class="string">&quot;drainDuration&quot;</span>: <span class="string">&quot;45s&quot;</span>,</span><br><span class="line">        <span class="string">&quot;parentShutdownDuration&quot;</span>: <span class="string">&quot;60s&quot;</span>,</span><br><span class="line">        <span class="string">&quot;discoveryAddress&quot;</span>: <span class="string">&quot;istiod.istio-system.svc:15012&quot;</span>,</span><br><span class="line">        <span class="string">&quot;proxyAdminPort&quot;</span>: 15000,</span><br><span class="line">        <span class="string">&quot;controlPlaneAuthPolicy&quot;</span>: <span class="string">&quot;MUTUAL_TLS&quot;</span>,</span><br><span class="line">        <span class="string">&quot;statNameLength&quot;</span>: 189,</span><br><span class="line">        <span class="string">&quot;concurrency&quot;</span>: 2,</span><br><span class="line">        <span class="string">&quot;tracing&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;zipkin&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;address&quot;</span>: <span class="string">&quot;zipkin.istio-system:9411&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;statusPort&quot;</span>: 15020,</span><br><span class="line">        <span class="string">&quot;terminationDrainDuration&quot;</span>: <span class="string">&quot;5s&quot;</span>,</span><br><span class="line">        <span class="string">&quot;proxyStatsMatcher&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;inclusionRegexps&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;.*&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;outboundTrafficPolicy&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;mode&quot;</span>: <span class="string">&quot;ALLOW_ANY&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;configSources&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;address&quot;</span>: <span class="string">&quot;k8s://&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;address&quot;</span>: <span class="string">&quot;xds://higress-controller.higress-system:15051&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;enableAutoMtls&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;trustDomain&quot;</span>: <span class="string">&quot;cluster.local&quot;</span>,</span><br><span class="line">    <span class="string">&quot;trustDomainAliases&quot;</span>: [</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;defaultServiceExportTo&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;*&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;defaultVirtualServiceExportTo&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;*&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;defaultDestinationRuleExportTo&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;*&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;rootNamespace&quot;</span>: <span class="string">&quot;istio-system&quot;</span>,</span><br><span class="line">    <span class="string">&quot;localityLbSetting&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;enabled&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">2022-11-07T02:22:11.940338Z	info	version: 1.12-dev-e9de7ac36deb19dcc4738a397ef3dc03579aa336-Modified</span><br><span class="line">2022-11-07T02:22:11.993517Z	info	Adding Kubernetes registry adapter</span><br><span class="line">2022-11-07T02:22:11.993539Z	info	handling remote clusters <span class="keyword">in</span> *controller.Multicluster</span><br><span class="line">2022-11-07T02:22:11.993557Z	info	initializing Istiod DNS certificates host: istiod.istio-system.svc, custom host:</span><br><span class="line">2022-11-07T02:22:11.993606Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> core/v1alpha1/MeshConfig cnt=0 nonce=51897ff3-8583-4965-ada3-0c58b6e63867</span><br><span class="line">2022-11-07T02:22:11.993672Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> extensions.istio.io/v1alpha1/WasmPlugin cnt=0 nonce=807490a6-10ec-4977-b21b-3ceca4eda34c</span><br><span class="line">2022-11-07T02:22:11.993703Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> networking.istio.io/v1alpha3/DestinationRule cnt=0 nonce=ab806b12-17e7-42da-9ab2-46ce16fdb362</span><br><span class="line">2022-11-07T02:22:11.993718Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> networking.istio.io/v1alpha3/EnvoyFilter cnt=0 nonce=c7ff2b1d-5a33-4c2e-aeac-d37cb1f4a1ec</span><br><span class="line">2022-11-07T02:22:11.993731Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> networking.istio.io/v1alpha3/Gateway cnt=0 nonce=f485bfb3-4bd9-4ff0-b069-99cdcd3849d0</span><br><span class="line">2022-11-07T02:22:11.993744Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> networking.istio.io/v1alpha3/ServiceEntry cnt=0 nonce=be689b82-6def-4979-9d40-538821e24328</span><br><span class="line">2022-11-07T02:22:11.993760Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> networking.istio.io/v1alpha3/ServiceSubscriptionList cnt=0 nonce=49ec0b57-a6e1-46ab-9ee0-99e5dfd1c758</span><br><span class="line">2022-11-07T02:22:11.993773Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> networking.istio.io/v1alpha3/Sidecar cnt=0 nonce=5756d43f-c8e5-44aa-bf55-38dd54911646</span><br><span class="line">2022-11-07T02:22:11.993785Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> networking.istio.io/v1alpha3/VirtualService cnt=0 nonce=ba88c77d-d062-4d5e-a61c-e2c98f5a4068</span><br><span class="line">2022-11-07T02:22:11.993806Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> networking.istio.io/v1alpha3/WorkloadEntry cnt=0 nonce=e6453814-dfff-474f-bf8d-85b190764a36</span><br><span class="line">2022-11-07T02:22:11.993824Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> networking.istio.io/v1alpha3/WorkloadGroup cnt=0 nonce=c8b12853-306d-443d-89de-141a02c6f525</span><br><span class="line">2022-11-07T02:22:11.993840Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> security.istio.io/v1beta1/AuthorizationPolicy cnt=0 nonce=b7de10db-dc94-4b15-8e02-e79173664372</span><br><span class="line">2022-11-07T02:22:11.993861Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> security.istio.io/v1beta1/PeerAuthentication cnt=0 nonce=273eca9d-b148-4b85-bf09-3b2bd7585353</span><br><span class="line">2022-11-07T02:22:11.993879Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> security.istio.io/v1beta1/RequestAuthentication cnt=0 nonce=d8b6b803-58f3-4467-a176-db911ab829f8</span><br><span class="line">2022-11-07T02:22:11.993908Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> telemetry.istio.io/v1alpha1/Telemetry cnt=0 nonce=5d222fc3-f44a-4a5a-a8d8-38464ec9da90</span><br></pre></td></tr></table></figure>
<p>从日志中，我们就可以比较明确的得到我们之前的判断了。</p>
<ol>
<li><code>getaddrinfo for host &quot;higress-controller.higress-system&quot; port 15051: Name or service not known testing higress controller is ready to connect...</code> 在启动之前会等待 higress-controller 的启动（应该是魔改版的 istio chart)</li>
<li>在配置源中多了一个上游的 MCP XDS 服务</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xds://higress-controller.higress-system:15051&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>higress 会向服务器推送 istio 的配置项</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2022-11-07T02:22:11.993861Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> security.istio.io/v1beta1/PeerAuthentication cnt=0 nonce=273eca9d-b148-4b85-bf09-3b2bd7585353</span><br><span class="line">2022-11-07T02:22:11.993879Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> security.istio.io/v1beta1/RequestAuthentication cnt=0 nonce=d8b6b803-58f3-4467-a176-db911ab829f8</span><br><span class="line">2022-11-07T02:22:11.993908Z	info	adsc	Received higress-controller.higress-system:15051 <span class="built_in">type</span> telemetry.istio.io/v1alpha1/Telemetry cnt=0 nonce=5d222fc3-f44a-4a5a-a8d8-38464ec9da90</span><br></pre></td></tr></table></figure>
<h3 id="从配置项认证"><a class="header-anchor" href="#从配置项认证">¶</a>从配置项认证</h3>
<p>当我们已经有了明确的认知的时候，我们再来看 <code>Envoy</code> 的配置项</p>
<p>首先生成了一个 <code>80</code> 的 Listener</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0_80&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;active_state&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version_info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2022-11-07T02:41:43Z/8&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;listener&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type.googleapis.com/envoy.config.listener.v3.Listener&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0_80&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;socket_address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;port_value&quot;</span><span class="punctuation">:</span> <span class="number">80</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filter_chains&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;envoy.filters.network.http_connection_manager&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;typed_config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;stat_prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;outbound_0.0.0.0_80&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;rds&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;config_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;ads&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        </span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;initial_fetch_timeout&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0s&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;resource_api_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;V3&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;route_config_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http.80&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>然后生成了 <code>Router</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version_info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2022-11-07T02:41:43Z/9&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;route_config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type.googleapis.com/envoy.config.route.v3.RouteConfiguration&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http.80&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;virtual_hosts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;demo.bar.com:80&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;domains&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;demo.bar.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;demo.bar.com:*&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;routes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;case_sensitive&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;safe_regex&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;google_re2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    </span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;regex&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/demo((\\/).*)?&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;route&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cluster&quot;</span><span class="punctuation">:</span> <span class="string">&quot;outbound|80||echo-web.default.svc.cluster.local&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0s&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;retry_policy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;retry_on&quot;</span><span class="punctuation">:</span> <span class="string">&quot;connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;num_retries&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;retry_host_predicate&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;envoy.retry_host_predicates.previous_hosts&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;host_selection_retry_max_attempts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;retriable_status_codes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="number">503</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;retriable_request_headers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;:method&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;invert_match&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;string_match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;safe_regex&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;google_re2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            </span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;regex&quot;</span><span class="punctuation">:</span> <span class="string">&quot;POST|PATCH|LOCK&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;max_grpc_timeout&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0s&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;filter_metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;istio&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/apis/networking.istio.io/v1alpha3/namespaces/higress-system/virtual-service/default-simple-example-demo-bar-com&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;decorator&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;operation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo-web.default.svc.cluster.local:80/demo((\\/).*)?&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default-simple-example-34da3948&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;validate_clusters&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>这么看起来也挺明显的。并且因为 <code>Higress Gateway</code> 连接的地址是 <code>istiod</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl logs -n higress-system higress-gateway-74cb5978cc-2sv8k</span><br><span class="line"></span><br><span class="line">defaultConfig:</span><br><span class="line">  discoveryAddress: istiod.istio-system.svc:15012</span><br></pre></td></tr></table></figure>
<p>那和我们猜测的架构一致。</p>
<h3 id="阅读代码"><a class="header-anchor" href="#阅读代码">¶</a>阅读代码</h3>
<p>最后我们来看看代码里面，做了些什么，从项目的结构上，我们就知道他分为 数据面和 控制面，数据面对 <code>Envoy</code> 做了一些扩展，这部分都在 <a href="https://github.dev/alibaba/higress/blob/08e8a57bb8b4da33cd8d9a4b986b741773fa1f0e/plugins/wasm-cpp/extensions">extensions</a> 中。这部分的逻辑就不做展开了。</p>
<p>重点还是看看控制面的逻辑。这部分的代码都在 <a href="https://github.dev/alibaba/higress/blob/08e8a57bb8b4da33cd8d9a4b986b741773fa1f0e/ingress"><code>ingress</code></a> 之中。</p>
<h4 id="控制面启动-XDS"><a class="header-anchor" href="#控制面启动-XDS">¶</a>控制面启动 XDS</h4>
<p>对于任何的 <code>Operator</code> 组件来说，我们第一步需要关心的是它关注什么资源的变化，这里在下面的代码中，我们可以看出来，<code>Ingress Controller</code> 关注下面的几个配置类型。</p>
<figure class="highlight go"><figcaption><span>initRegistryEventHandlers</span><a href="https://github.com/alibaba/higress/blob/08e8a57bb8b4da33cd8d9a4b986b741773fa1f0e/cmd/higress/bootstrap/server.go#L172-L202">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> IngressIR = collection.NewSchemasBuilder().</span><br><span class="line">	MustAdd(collections.IstioExtensionsV1Alpha1Wasmplugins).</span><br><span class="line">	MustAdd(collections.IstioNetworkingV1Alpha3Destinationrules).</span><br><span class="line">	MustAdd(collections.IstioNetworkingV1Alpha3Envoyfilters).</span><br><span class="line">	MustAdd(collections.IstioNetworkingV1Alpha3Gateways).</span><br><span class="line">	MustAdd(collections.IstioNetworkingV1Alpha3Serviceentries).</span><br><span class="line">	MustAdd(collections.IstioNetworkingV1Alpha3Virtualservices).</span><br><span class="line">	Build()</span><br><span class="line"></span><br><span class="line"><span class="comment">// initRegistryEventHandlers sets up event handlers for config updates</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> initRegistryEventHandlers() <span class="type">error</span> &#123;</span><br><span class="line">	log.Info(<span class="string">&quot;initializing registry event handlers&quot;</span>)</span><br><span class="line">	configHandler := <span class="function"><span class="keyword">func</span><span class="params">(prev config.Config, curr config.Config, event model.Event)</span></span> &#123;</span><br><span class="line">		<span class="comment">// For update events, trigger push only if spec has changed.</span></span><br><span class="line">		pushReq := &amp;model.PushRequest&#123;</span><br><span class="line">			Full: <span class="literal">true</span>,</span><br><span class="line">			ConfigsUpdated: <span class="keyword">map</span>[model.ConfigKey]<span class="keyword">struct</span>&#123;&#125;&#123;&#123;</span><br><span class="line">				Kind:      curr.GroupVersionKind,</span><br><span class="line">				Name:      curr.Name,</span><br><span class="line">				Namespace: curr.Namespace,</span><br><span class="line">			&#125;: &#123;&#125;&#125;,</span><br><span class="line">			Reason: []model.TriggerReason&#123;model.ConfigUpdate&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		s.xdsServer.ConfigUpdate(pushReq)</span><br><span class="line">	&#125;</span><br><span class="line">	schemas := IngressIR.All()</span><br><span class="line">	<span class="keyword">for</span> _, schema := <span class="keyword">range</span> schemas &#123;</span><br><span class="line">		s.configController.RegisterEventHandler(schema.Resource().GroupVersionKind(), configHandler)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这些资源的处理在</p>
<figure class="highlight go"><figcaption><span>RegisterEventHandler</span><a href="https://github.dev/alibaba/higress/blob/08e8a57bb8b4da33cd8d9a4b986b741773fa1f0e/ingress/config/ingress_config.go#L102-L126">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *IngressConfig)</span></span> RegisterEventHandler(kind config.GroupVersionKind, f model.EventHandler) &#123;</span><br><span class="line">	IngressLog.Infof(<span class="string">&quot;register resource %v&quot;</span>, kind)</span><br><span class="line">	<span class="keyword">if</span> kind != gvk.VirtualService &amp;&amp; kind != gvk.Gateway &amp;&amp;</span><br><span class="line">		kind != gvk.DestinationRule &amp;&amp; kind != gvk.EnvoyFilter &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> kind &#123;</span><br><span class="line">	<span class="keyword">case</span> gvk.VirtualService:</span><br><span class="line">		m.virtualServiceHandlers = <span class="built_in">append</span>(m.virtualServiceHandlers, f)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> gvk.Gateway:</span><br><span class="line">		m.gatewayHandlers = <span class="built_in">append</span>(m.gatewayHandlers, f)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> gvk.DestinationRule:</span><br><span class="line">		m.destinationRuleHandlers = <span class="built_in">append</span>(m.destinationRuleHandlers, f)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> gvk.EnvoyFilter:</span><br><span class="line">		m.envoyFilterHandlers = <span class="built_in">append</span>(m.envoyFilterHandlers, f)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, remoteIngressController := <span class="keyword">range</span> m.remoteIngressControllers &#123;</span><br><span class="line">		remoteIngressController.RegisterEventHandler(kind, f)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而执行逻辑就是把这个 <code>handlers</code> 挨个执行一遍</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> c.gatewayHandlers &#123;</span><br><span class="line">    f(config.Config&#123;Meta: gatewaymetadata&#125;, config.Config&#123;Meta: gatewaymetadata&#125;, event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上，也只是通知下 istiod，Push 一个事件给 istiod，等 istiod 来拉取。</p>
</blockquote>
<p>这是这个 Xds 的逻辑，我们来看看 <code>higress</code> 到底做了什么。</p>
<h4 id="Controller"><a class="header-anchor" href="#Controller">¶</a>Controller</h4>
<p>在 <code>Controller</code> 的 <code>onEvent</code> 事件中，我们发现也就是关注了 <code>Ingress</code> 这个 <code>CR</code> 资源，然后把所有的 <code>Handlers</code> 执行了一遍。</p>
<figure class="highlight go"><figcaption><span>onEvent</span><a href="https://github.dev/alibaba/higress/blob/08e8a57bb8b4da33cd8d9a4b986b741773fa1f0e/ingress/kube/ingress/controller.go#L175-L254">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span></span> onEvent(namespacedName types.NamespacedName) <span class="type">error</span> &#123;</span><br><span class="line">	event := model.EventUpdate</span><br><span class="line">	ing, err := c.ingressLister.Ingresses(namespacedName.Namespace).Get(namespacedName.Name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> kerrors.IsNotFound(err) &#123;</span><br><span class="line">			event = model.EventDelete</span><br><span class="line">			c.mutex.Lock()</span><br><span class="line">			ing = c.ingresses[namespacedName.String()]</span><br><span class="line">			<span class="built_in">delete</span>(c.ingresses, namespacedName.String())</span><br><span class="line">			c.mutex.Unlock()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ingress deleted, and it is not processed before</span></span><br><span class="line">	<span class="keyword">if</span> ing == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we should check need process only when event is not delete,</span></span><br><span class="line">	<span class="comment">// if it is delete event, and previously processed, we need to process too.</span></span><br><span class="line">	<span class="keyword">if</span> event != model.EventDelete &#123;</span><br><span class="line">		shouldProcess, err := c.shouldProcessIngressUpdate(ing)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !shouldProcess &#123;</span><br><span class="line">			IngressLog.Infof(<span class="string">&quot;no need process, ingress %s&quot;</span>, namespacedName)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	drmetadata := config.Meta&#123;</span><br><span class="line">		Name:             ing.Name + <span class="string">&quot;-&quot;</span> + <span class="string">&quot;destinationrule&quot;</span>,</span><br><span class="line">		Namespace:        ing.Namespace,</span><br><span class="line">		GroupVersionKind: gvk.DestinationRule,</span><br><span class="line">		<span class="comment">// Set this label so that we do not compare configs and just push.</span></span><br><span class="line">		Labels: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;constants.AlwaysPushLabel: <span class="string">&quot;true&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	vsmetadata := config.Meta&#123;</span><br><span class="line">		Name:             ing.Name + <span class="string">&quot;-&quot;</span> + <span class="string">&quot;virtualservice&quot;</span>,</span><br><span class="line">		Namespace:        ing.Namespace,</span><br><span class="line">		GroupVersionKind: gvk.VirtualService,</span><br><span class="line">		<span class="comment">// Set this label so that we do not compare configs and just push.</span></span><br><span class="line">		Labels: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;constants.AlwaysPushLabel: <span class="string">&quot;true&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	efmetadata := config.Meta&#123;</span><br><span class="line">		Name:             ing.Name + <span class="string">&quot;-&quot;</span> + <span class="string">&quot;envoyfilter&quot;</span>,</span><br><span class="line">		Namespace:        ing.Namespace,</span><br><span class="line">		GroupVersionKind: gvk.EnvoyFilter,</span><br><span class="line">		<span class="comment">// Set this label so that we do not compare configs and just push.</span></span><br><span class="line">		Labels: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;constants.AlwaysPushLabel: <span class="string">&quot;true&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	gatewaymetadata := config.Meta&#123;</span><br><span class="line">		Name:             ing.Name + <span class="string">&quot;-&quot;</span> + <span class="string">&quot;gateway&quot;</span>,</span><br><span class="line">		Namespace:        ing.Namespace,</span><br><span class="line">		GroupVersionKind: gvk.Gateway,</span><br><span class="line">		<span class="comment">// Set this label so that we do not compare configs and just push.</span></span><br><span class="line">		Labels: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;constants.AlwaysPushLabel: <span class="string">&quot;true&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> c.destinationRuleHandlers &#123;</span><br><span class="line">		f(config.Config&#123;Meta: drmetadata&#125;, config.Config&#123;Meta: drmetadata&#125;, event)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> c.virtualServiceHandlers &#123;</span><br><span class="line">		f(config.Config&#123;Meta: vsmetadata&#125;, config.Config&#123;Meta: vsmetadata&#125;, event)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> c.envoyFilterHandlers &#123;</span><br><span class="line">		f(config.Config&#123;Meta: efmetadata&#125;, config.Config&#123;Meta: efmetadata&#125;, event)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> c.gatewayHandlers &#123;</span><br><span class="line">		f(config.Config&#123;Meta: gatewaymetadata&#125;, config.Config&#123;Meta: gatewaymetadata&#125;, event)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前的大部分代码逻辑都在 <a href="https://github.com/alibaba/higress/tree/08e8a57bb8b4da33cd8d9a4b986b741773fa1f0e/ingress/kube/annotations"><code>annotations</code></a> 里面，也就是当前支持的各个功能</p>
<figure class="highlight go"><figcaption><span>NewAnnotationHandlerManager</span><a href="https://github.com/alibaba/higress/blob/08e8a57bb8b4da33cd8d9a4b986b741773fa1f0e/ingress/kube/annotations/annotations.go#L140-L180">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAnnotationHandlerManager</span><span class="params">()</span></span> AnnotationHandler &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;AnnotationHandlerManager&#123;</span><br><span class="line">		parsers: []Parser&#123;</span><br><span class="line">			canary&#123;&#125;,</span><br><span class="line">			cors&#123;&#125;,</span><br><span class="line">			downstreamTLS&#123;&#125;,</span><br><span class="line">			redirect&#123;&#125;,</span><br><span class="line">			rewrite&#123;&#125;,</span><br><span class="line">			upstreamTLS&#123;&#125;,</span><br><span class="line">			ipAccessControl&#123;&#125;,</span><br><span class="line">			headerControl&#123;&#125;,</span><br><span class="line">			timeout&#123;&#125;,</span><br><span class="line">			retry&#123;&#125;,</span><br><span class="line">			loadBalance&#123;&#125;,</span><br><span class="line">			localRateLimit&#123;&#125;,</span><br><span class="line">			fallback&#123;&#125;,</span><br><span class="line">			auth&#123;&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		gatewayHandlers: []GatewayHandler&#123;</span><br><span class="line">			downstreamTLS&#123;&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		virtualServiceHandlers: []VirtualServiceHandler&#123;</span><br><span class="line">			ipAccessControl&#123;&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		routeHandlers: []RouteHandler&#123;</span><br><span class="line">			cors&#123;&#125;,</span><br><span class="line">			redirect&#123;&#125;,</span><br><span class="line">			rewrite&#123;&#125;,</span><br><span class="line">			ipAccessControl&#123;&#125;,</span><br><span class="line">			headerControl&#123;&#125;,</span><br><span class="line">			timeout&#123;&#125;,</span><br><span class="line">			retry&#123;&#125;,</span><br><span class="line">			localRateLimit&#123;&#125;,</span><br><span class="line">			fallback&#123;&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		trafficPolicyHandlers: []TrafficPolicyHandler&#123;</span><br><span class="line">			upstreamTLS&#123;&#125;,</span><br><span class="line">			loadBalance&#123;&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里以 <code>cors</code> 为例子。</p>
<figure class="highlight go"><figcaption><span>Parse</span><a href="https://github.com/alibaba/higress/blob/08e8a57bb8b4da33cd8d9a4b986b741773fa1f0e/ingress/kube/annotations/cors.go#L61-L116">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cors)</span></span> Parse(annotations Annotations, config *Ingress, _ *GlobalContext) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 判断了anontations 中是否需要配置 cors</span></span><br><span class="line">	<span class="keyword">if</span> !needCorsConfig(annotations) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cors enable</span></span><br><span class="line">	enable, _ := annotations.ParseBoolASAP(enableCors)</span><br><span class="line">	<span class="keyword">if</span> !enable &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成一个 CORS 的配置</span></span><br><span class="line">	corsConfig := &amp;CorsConfig&#123;</span><br><span class="line">		Enabled:          enable,</span><br><span class="line">		AllowOrigin:      []<span class="type">string</span>&#123;defaultAllowOrigin&#125;,</span><br><span class="line">		AllowMethods:     splitStringWithSpaceTrim(defaultAllowMethods),</span><br><span class="line">		AllowHeaders:     splitStringWithSpaceTrim(defaultAllowHeaders),</span><br><span class="line">		AllowCredentials: defaultAllowCredentials,</span><br><span class="line">		MaxAge:           defaultMaxAge,</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终 Append 到配置中去，再下面就是各种配置</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		config.Cors = corsConfig</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allow origin</span></span><br><span class="line">	<span class="keyword">if</span> origin, err := annotations.ParseStringASAP(allowOrigin); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		corsConfig.AllowOrigin = splitStringWithSpaceTrim(origin)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allow methods</span></span><br><span class="line">	<span class="keyword">if</span> methods, err := annotations.ParseStringASAP(allowMethods); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		corsConfig.AllowMethods = splitStringWithSpaceTrim(methods)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allow headers</span></span><br><span class="line">	<span class="keyword">if</span> headers, err := annotations.ParseStringASAP(allowHeaders); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		corsConfig.AllowHeaders = splitStringWithSpaceTrim(headers)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// expose headers</span></span><br><span class="line">	<span class="keyword">if</span> exposeHeaders, err := annotations.ParseStringASAP(exposeHeaders); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		corsConfig.ExposeHeaders = splitStringWithSpaceTrim(exposeHeaders)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allow credentials</span></span><br><span class="line">	<span class="keyword">if</span> allowCredentials, err := annotations.ParseBoolASAP(allowCredentials); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		corsConfig.AllowCredentials = allowCredentials</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// max age</span></span><br><span class="line">	<span class="keyword">if</span> age, err := annotations.ParseIntASAP(maxAge); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		corsConfig.MaxAge = age</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理逻辑衔接"><a class="header-anchor" href="#处理逻辑衔接">¶</a>处理逻辑衔接</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *IngressConfig)</span></span> List(typ config.GroupVersionKind, namespace <span class="type">string</span>) ([]config.Config, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> typ != gvk.Gateway &amp;&amp;</span><br><span class="line">		typ != gvk.VirtualService &amp;&amp;</span><br><span class="line">		typ != gvk.DestinationRule &amp;&amp;</span><br><span class="line">		typ != gvk.EnvoyFilter &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, common.ErrUnsupportedOp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Currently, only support list all namespaces gateways or virtualservices.</span></span><br><span class="line">	<span class="keyword">if</span> namespace != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		IngressLog.Warnf(<span class="string">&quot;ingress store only support type %s of all namespace.&quot;</span>, typ)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, common.ErrUnsupportedOp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> typ == gvk.EnvoyFilter &#123;</span><br><span class="line">		m.mutex.RLock()</span><br><span class="line">		<span class="keyword">defer</span> m.mutex.RUnlock()</span><br><span class="line">		IngressLog.Infof(<span class="string">&quot;resource type %s, configs number %d&quot;</span>, typ, <span class="built_in">len</span>(m.cachedEnvoyFilters))</span><br><span class="line">		<span class="keyword">return</span> m.cachedEnvoyFilters, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> configs []config.Config</span><br><span class="line">	m.mutex.RLock()</span><br><span class="line">	<span class="keyword">for</span> _, ingressController := <span class="keyword">range</span> m.remoteIngressControllers &#123;</span><br><span class="line">		configs = <span class="built_in">append</span>(configs, ingressController.List()...)</span><br><span class="line">	&#125;</span><br><span class="line">	m.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line">	common.SortIngressByCreationTime(configs)</span><br><span class="line">	wrapperConfigs := m.createWrapperConfigs(configs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 istiod 的 List 请求的内容就返回对应的数据</span></span><br><span class="line">	IngressLog.Infof(<span class="string">&quot;resource type %s, configs number %d&quot;</span>, typ, <span class="built_in">len</span>(wrapperConfigs))</span><br><span class="line">	<span class="keyword">switch</span> typ &#123;</span><br><span class="line">	<span class="keyword">case</span> gvk.Gateway:</span><br><span class="line">		<span class="keyword">return</span> m.convertGateways(wrapperConfigs), <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> gvk.VirtualService:</span><br><span class="line">		<span class="keyword">return</span> m.convertVirtualService(wrapperConfigs), <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> gvk.DestinationRule:</span><br><span class="line">		<span class="keyword">return</span> m.convertDestinationRule(wrapperConfigs), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里其实我们把整个流程梳理下</p>


<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: Higress',
	 'Kube->Higress: 1. cr udate',
	 'Higress->Istiod: 2. notify xds update',
     'Istiod->Higress: 3. List Resource by Type',
     'Higress->Istiod: 4. Process & Retrun',
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>
<p>到这里我们发现其实整个 Higress 的逻辑当前还是比较的简单的，就是处理一些 <code>annotations</code> 中的信息，转为 <code>istio</code> 的数据。</p>
<h2 id="开发环境搭建"><a class="header-anchor" href="#开发环境搭建">¶</a>开发环境搭建</h2>
<p>社区Readme 少了这部分，也就是初始化 <code>submodules</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make prebuild</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>网络编程</category>
        <category>API</category>
        <category>Gateway</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>Gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 1 &amp; 2</title>
    <url>/2020/10/08/networking/http/http/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/10/08/t8J6C.png" alt="t8J6C.png"></p>
<p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，我们今天就来深度剖析这个古老的协议。</p>
<span id="more"></span>
<h2 id="HTTP-1"><a class="header-anchor" href="#HTTP-1">¶</a>HTTP 1</h2>
<h3 id="协议"><a class="header-anchor" href="#协议">¶</a>协议</h3>
<p><code>HTTP</code> 协议的构建很简单，协议分为了 <code>Request</code> 和 <code>Response</code> 部分。</p>
<blockquote>
<p>HTTP-message   = Request | Response     ; HTTP/1.1 messages</p>
</blockquote>
<p>无论是 <code>Request</code> 或者是 <code>Response</code> 所使用的的格式也是一致的，遵守 <a href="https://tools.ietf.org/html/rfc822"><code>rfc822</code></a> 格式，如下所示</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">generic-message = start-line</span><br><span class="line">                    *(message-header CRLF)</span><br><span class="line">                    CRLF</span><br><span class="line">                    [ message-body ]</span><br><span class="line">start-line      = Request-Line | Status-Line</span><br></pre></td></tr></table></figure>
<p>值得注意的是，<code>HTTP</code> 是一个文本协议，是可以非常方便的打印出来的。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">GET /ocsp-devid01/ME4wTKADAgEAMEUwQzBBMAkGBSsOAwIaBQAEFDOB0e%2FbaLCFIU0u76%2BMSmlkPCpsBBRXF%2B2iz9x8mKEQ4Py%2Bhy0s8uMXVAIIF5cOVThOvII%3D HTTP/1.1</span><br><span class="line">Host: ocsp.apple.com</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en-us</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">User-Agent: com.apple.trustd/2.0</span><br></pre></td></tr></table></figure>
<p>对于 <code>HTTP</code> 协议的解析就等同于解析文本，没有什么复杂可言。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">http_hex_data</span> = hex::<span class="title function_ invoke__">decode</span>(<span class="string">&quot;474554202f6f6373702d646576696430312f4d453477544b4144416745414d455577517a42424d416b474253734f417749614251414546444f42306525324662614c43464955307537362532424d536d6c6b50437073424252584625324232697a3978386d4b45513450792532426879307338754d58564149494635634f5654684f76494925334420485454502f312e310d0a486f73743a206f6373702e6170706c652e636f6d0d0a4163636570743a202a2f2a0d0a4163636570742d4c616e67756167653a20656e2d75730d0a436f6e6e656374696f6e3a206b6565702d616c6976650d0a4163636570742d456e636f64696e673a20677a69702c206465666c6174650d0a557365722d4167656e743a20636f6d2e6170706c652e7472757374642f322e300d0a0d0a&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">http_data</span> = <span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(http_hex_data.<span class="title function_ invoke__">unwrap</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">lines</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = http_data.<span class="title function_ invoke__">lines</span>()</span><br><span class="line">    .<span class="title function_ invoke__">filter</span>(|it| it.<span class="title function_ invoke__">len</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">request_line</span> = lines[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">request_line_values</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; =  request_line.<span class="title function_ invoke__">split_whitespace</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得第一行的 method 即可</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">method</span> = request_line_values[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h3 id="通信"><a class="header-anchor" href="#通信">¶</a>通信</h3>
<p>协议部分不是很复杂，但是 <code>HTTP</code> 通信却有一些很大的弊端。我们先看下常见的 <code>HTTP</code> 通讯</p>
<p><img src="https://s3.jpg.cm/2020/10/09/tXynw.png" alt="tXynw.png"></p>
<p>一来一回就构成了，我们的 <code>HTTP</code> 通讯的全部。在 <code>HTTP 1.0</code> 的时候，当我们完成一次通讯的时候，我就会 <code>Close</code> 底层的 <code>TCP</code> 协议。但是我们知道开通一个 <code>TCP</code> 连接是至少需要 <code>3RTT</code>+ <code>1RTT</code> 的 HTTP 发送，因此成本是很高的。因此在 <code>HTTP 1.1</code> 里面提出一些改进计划。</p>
<h3 id="特性"><a class="header-anchor" href="#特性">¶</a>特性</h3>
<h4 id="持久连接"><a class="header-anchor" href="#持久连接">¶</a>持久连接</h4>
<p>即是不声明 <code>Connection: keep-alive</code>，<code>HTTP 1.1</code> 也不会关闭底层的 <code>TCP</code> 连接，客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送 <code>Connection: close</code>，明确要求服务器关闭TCP连接。</p>
<h4 id="管道机制"><a class="header-anchor" href="#管道机制">¶</a>管道机制</h4>
<p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p>
<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p>
<p>为了达成 <code>pipeling</code> 的机能，我们需要分区响应的数据，所以在 <code>Reponse line</code> 中的 <code>Context-Length</code> 是必须设置的，并且只有幂等方法（即GET、HEAD、PUT和DELETE）才可以使用管道功能。不过值得注意的，大部分的浏览器并没有启用这个功能。</p>
<p><img src="https://s3.jpg.cm/2020/10/09/tX9t8.png" alt="tX9t8.png"></p>
<h4 id="分块传输编码"><a class="header-anchor" href="#分块传输编码">¶</a>分块传输编码</h4>
<p>使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p>
<p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用&quot;流模式&quot;（stream）取代&quot;缓存模式&quot;（buffer）。</p>
<p>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用&quot;分块传输编码&quot;（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。</p>
<hr>
<p>虽然 <code>1.1</code> 改进了很多，但是我们还是发现了，所有的请求都是要按顺序处理的，就算是在管道化之后，当第一个请求未完成的时候我们也不能返回，导致了 <code>Head-of-line blocking</code> 头部阻塞。如果很不幸的第一个请求特别慢，导致我们只能等待。</p>
<h2 id="HTTP-2"><a class="header-anchor" href="#HTTP-2">¶</a>HTTP 2</h2>
<p>因为现代网络的发展，大量的数据需要被处理，显然 <code>HTTP 1.1</code> 已经有点跟不上时代了，<a href="https://tools.ietf.org/html/rfc7540">HTTP 2</a> 他来了。</p>
<h3 id="协议-v2"><a class="header-anchor" href="#协议-v2">¶</a>协议</h3>
<p><code>HTTP 2</code> 基于 <code>Frame</code> 进行通讯。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+-----------------------------------------------+</span><br><span class="line">|                 Length (24)                   |</span><br><span class="line">+---------------+---------------+---------------+</span><br><span class="line">|   Type (8)    |   Flags (8)   |</span><br><span class="line">+-+-------------+---------------+-------------------------------+</span><br><span class="line">|R|                 Stream Identifier (31)                      |</span><br><span class="line">+=+=============================================================+</span><br><span class="line">|                   Frame Payload (0...)                      ...</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">                    Figure 1: Frame Layout</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Length</code>: 载荷的长度, 无符号24位整型. 对于发送值大于2^14 (长度大于16384字节)的载荷, 只有在接收方设置SETTINGS_MAX_FRAME_SIZE为更大的值时才被允许</li>
<li><code>Type</code>: 8位的值表示帧类型, 决定了帧的格式和语义. 协议实现上必须忽略任何未知类型的帧.</li>
<li><code>Flags</code>: 为Type保留的bool标识, 大小是8位. 对确定的帧类型赋予特定的语义, 否则发送时必须忽略(设置为0x0).</li>
<li><code>R</code>: 1位的保留字段, 尚未定义语义. 发送和接收必须忽略(0x0).</li>
<li><code>Stream Identifier</code>: 31位无符号整型的流标示符. 其中0x0作为保留值, 表示与连接相关的frames作为一个整体而不是一个单独的流.</li>
</ul>
<h4 id="Frames"><a class="header-anchor" href="#Frames">¶</a>Frames</h4>
<p><code>HTTP2</code> 有不同的 <code>Frame</code> 类型。比较常见的就是 <code>Header</code> 和 <code>Data</code></p>
<figure class="highlight text"><figcaption><span>header</span></figcaption><table><tr><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|Pad Length? (8)|</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|E|                 Stream Dependency? (31)                     |</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|  Weight? (8)  |</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|                   Header Block Fragment (*)                 ...</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                           Padding (*)                       ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>因为 <code>Header</code> 常常被使用，<code>Http2</code> 针对 <code>Header Frame</code> 还有一个单独的 <a href="https://httpwg.org/specs/rfc7541.html">HPACK: Header Compression for HTTP/2</a> ，就是针对 <code>Header</code> 数据进行数据压缩，因为 <code>Header</code> 的发送是一个阻塞的事件，尽快的快递数据才是我们需要的。</p>
<p><img src="https://s3.jpg.cm/2020/10/09/tcgSR.png" alt="tcgSR.png"></p>
<figure class="highlight text"><figcaption><span>data</span></figcaption><table><tr><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|Pad Length? (8)|</span><br><span class="line">+---------------+-----------------------------------------------+</span><br><span class="line">|                            Data (*)                         ...</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                           Padding (*)                       ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>除了这些之外还要 <code>PRIORITY</code> <code>RST_STREAM</code> <code>SETTINGS</code> <code>PUSH_PROMISE</code> <code>PING</code> <code>GOAWAY</code> <code>WINDOW_UPDATE</code> <code>CONTINUATION</code>，对于实现框架的同学们来说看起来要吃不少的苦了。</p>
<h3 id="通信-v2"><a class="header-anchor" href="#通信-v2">¶</a>通信</h3>
<h4 id="多路复用"><a class="header-anchor" href="#多路复用">¶</a>多路复用</h4>
<p>因为 <code>HTTP 2</code> 是多路复用的，有点类似于 <code>TCP</code> 的协议，因此对于一次完整的请求我们定义为 <code>Steam 流</code> ，那显然涉及到 <code>State</code> 的切换。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">                         +--------+</span><br><span class="line">                 send PP |        | recv PP</span><br><span class="line">                ,--------|  idle  |--------.</span><br><span class="line">               /         |        |         \</span><br><span class="line">              v          +--------+          v</span><br><span class="line">       +----------+          |           +----------+</span><br><span class="line">       |          |          | send H /  |          |</span><br><span class="line">,------| reserved |          | recv H    | reserved |------.</span><br><span class="line">|      | (local)  |          |           | (remote) |      |</span><br><span class="line">|      +----------+          v           +----------+      |</span><br><span class="line">|          |             +--------+             |          |</span><br><span class="line">|          |     recv ES |        | send ES     |          |</span><br><span class="line">|   send H |     ,-------|  open  |-------.     | recv H   |</span><br><span class="line">|          |    /        |        |        \    |          |</span><br><span class="line">|          v   v         +--------+         v   v          |</span><br><span class="line">|      +----------+          |           +----------+      |</span><br><span class="line">|      |   half   |          |           |   half   |      |</span><br><span class="line">|      |  closed  |          | send R /  |  closed  |      |</span><br><span class="line">|      | (remote) |          | recv R    | (local)  |      |</span><br><span class="line">|      +----------+          |           +----------+      |</span><br><span class="line">|           |                |                 |           |</span><br><span class="line">|           | send ES /      |       recv ES / |           |</span><br><span class="line">|           | send R /       v        send R / |           |</span><br><span class="line">|           | recv R     +--------+   recv R   |           |</span><br><span class="line">| send R /  `-----------&gt;|        |&lt;-----------&#x27;  send R / |</span><br><span class="line">| recv R                 | closed |               recv R   |</span><br><span class="line">`-----------------------&gt;|        |&lt;----------------------&#x27;</span><br><span class="line">                         +--------+</span><br><span class="line"></span><br><span class="line">   send:   endpoint sends this frame</span><br><span class="line">   recv:   endpoint receives this frame</span><br><span class="line"></span><br><span class="line">   H:  HEADERS frame (with implied CONTINUATIONs)</span><br><span class="line">   PP: PUSH_PROMISE frame (with implied CONTINUATIONs)</span><br><span class="line">   ES: END_STREAM flag</span><br><span class="line">   R:  RST_STREAM frame</span><br><span class="line"></span><br><span class="line">                   Figure 2: Stream States</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.jpg.cm/2020/10/09/tcuo2.png" alt="tcuo2.png"></p>
<p><code>Steam</code> 的状态变化依靠的是 <code>Frame</code> 数据不同进行驱动的。比如从 <code>idle</code> 状态切换到 <code>open</code> 状态，就需要通过发送/接受 <code>Headers Frame</code>，除了 <code>Stream</code> <code>Frame</code> 还一个 <code>Message</code> 的概念，这个对应到 <code>1.1</code> 的 <code>Request/Reponse</code>。</p>
<h4 id="流控"><a class="header-anchor" href="#流控">¶</a>流控</h4>
<p>在看 <code>Header Frame</code> 定义的时候，我们发现有一个字段叫 <code>Stream Dependency</code>，看上去很像是什么依赖关系，其实不是，这个字段是用来标记 <code>优先级</code> 而不是 <code>从属关系</code>。因为我们在 <code>HTTP2</code>中实际上仍是通过一个 <code>TCP</code> 连接进行数据传输。</p>
<p><img src="https://s3.jpg.cm/2020/10/09/tcJVL.png" alt="tcJVL.png"></p>
<p>面临 <code>拥堵</code> 问题，因此增加了一个 <code>拥塞控制</code> 在 <code>HTTP2</code> 协议之中，因为通过 <code>Stream Dependency</code> 我们可以构建出一个层级树</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  A                 A</span><br><span class="line"> / \      ==&gt;      /|\</span><br><span class="line">B   C             B D C</span><br></pre></td></tr></table></figure>
<p>并且在 <code>H</code> 帧中，还包含一个 <code>Weight</code> 字段，可用来标记权重，所有的从属流会分配到一个介于[1, 256]之间的整数, 表示权重，依赖于相同上级的流应该依据其权重比例分配资源. 因此, 如果权重为4的流B和权重为12的流C都依赖于流A, 并且A上不会有任何动作, 那么B会分得1/4的资源, C分得3/4的资源。</p>
<h4 id="服务器推送"><a class="header-anchor" href="#服务器推送">¶</a>服务器推送</h4>
<p><img src="https://s3.jpg.cm/2020/10/09/tcNyU.png" alt="tcNyU.png"></p>
<p>HTTP/2 脱离了严格的请求-响应语义，支持一对多和服务器启动的推送工作流，在浏览器内外开辟了一个新的交互可能性世界。这是一个有利的特性，对于我们如何看待该协议，以及在何处和如何使用它，都将产生重要的长期影响。[看起来是抢了 Websocket 的生意]</p>
<h4 id="交换数据"><a class="header-anchor" href="#交换数据">¶</a>交换数据</h4>
<p>客户端发起一次 <code>HTTP</code> 请求(<code>H</code>帧)就会生成一个 <code>Stream</code>，服务端响应使用相同的 <code>Stream</code>进行响应。</p>
<div>
    <label class="author-mark-label">小声比比</label>
    <p class="author-mark">会不会创建相同的Stream ID呢？协议也考虑到了，客户端创建的ID是奇数，服务器端创建的ID是偶数，就不会重复了。</p>
</div>
<p>响应的时候可以选择返回 <code>H</code> 或者直接返回 <code>D</code> 都是可以的 <a href="https://tools.ietf.org/html/rfc7540#page-52">文档</a>，最后 <code>Frame</code> 需要包含 <code>END_STREAM</code> 标记，这样我们就可以关闭这个 <code>Stream</code> 了。</p>
<h3 id="实现"><a class="header-anchor" href="#实现">¶</a>实现</h3>
<p>从协议上，我们可以发现其实整个 <code>HTTP 2</code> 的协议实现，抛开 <code>流控</code> 部分，其他的还是比较好实现的。我们来看看 <code>Netty</code> 的实现重点。</p>
<p>第一步显然是读取到 <code>H</code> 帧之后的操作，从入口处开始阅读：</p>
<figure class="highlight java"><figcaption><span>readFrame</span><a href="https://github.com/netty/netty/blob/4.1/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java#L139">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFrame</span><span class="params">(ChannelHandlerContext ctx, ByteBuf input, Http2FrameListener listener)</span> <span class="keyword">throws</span> Http2Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 如果还没有读取到 Header部分，这里不是 Header Frame，是说我们的 HTTP2 协议的头部</span></span><br><span class="line">            <span class="keyword">if</span> (readingHeaders) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理 Header 头部，比如 FLAGS，STREAM ID, FRAME TYPE 等</span></span><br><span class="line">                processHeaderState(input);</span><br><span class="line">                <span class="keyword">if</span> (readingHeaders) &#123;</span><br><span class="line">                    <span class="comment">// Wait until the entire header has arrived.</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理数据体</span></span><br><span class="line">            processPayloadState(ctx, input, listener);</span><br><span class="line">            <span class="keyword">if</span> (!readingHeaders) &#123;</span><br><span class="line">                <span class="comment">// Wait until the entire payload has arrived.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (input.isReadable());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们下来要看如果我们的 <code>FRAME TYPE</code> 是 <code>HEADER</code> 的应该怎么处理，我们知道应该创建一个 <code>STREAM</code> 才是，我们继续来看代码</p>
<figure class="highlight java"><figcaption><span>onDataRead</span><a href="https://github.com/netty/netty/blob/4.1/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java#L231">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onHeadersRead</span><span class="params">(ChannelHandlerContext ctx, <span class="type">int</span> streamId, Http2Headers headers, <span class="type">int</span> streamDependency,</span></span><br><span class="line"><span class="params">                <span class="type">short</span> weight, <span class="type">boolean</span> exclusive, <span class="type">int</span> padding, <span class="type">boolean</span> endOfStream)</span> <span class="keyword">throws</span> Http2Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 ID 获得 Stream，这里其实不销毁(实际上非协议)，可以复用这个对象</span></span><br><span class="line">    <span class="type">Http2Stream</span> <span class="variable">stream</span> <span class="operator">=</span> connection.stream(streamId);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">allowHalfClosedRemote</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 没有就创建</span></span><br><span class="line">    <span class="keyword">if</span> (stream == <span class="literal">null</span> &amp;&amp; !connection.streamMayHaveExisted(streamId)) &#123;</span><br><span class="line">        stream = connection.remote().createStream(streamId, endOfStream);</span><br><span class="line">        <span class="comment">// Allow the state to be HALF_CLOSE_REMOTE if we&#x27;re creating it in that state.</span></span><br><span class="line">        allowHalfClosedRemote = stream.state() == HALF_CLOSED_REMOTE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, <span class="string">&quot;HEADERS&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个 <code>connection.stream(streamId);</code> 实际上创建的对象是由 <code>DefaultHttp2Connection</code> 创建的 <code>DefaultStream</code>，创建完成之后需要执行激活。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DefaultStream <span class="title function_">createStream</span><span class="params">(<span class="type">int</span> streamId, <span class="type">boolean</span> halfClosed)</span> <span class="keyword">throws</span> Http2Exception &#123;</span><br><span class="line">    <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> activeState(streamId, IDLE, isLocal(), halfClosed);</span><br><span class="line">    <span class="type">DefaultStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultStream</span>(streamId, state);</span><br><span class="line">    stream.activate();</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>激活的逻辑比较简单，直接将 <code>Stream</code> 放置于 <code>Connection</code> 内置的一个 <code>LinkedHashSet</code> 的 <code>Streams</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ActiveStreams</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Listener&gt; listeners;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Event&gt; pendingEvents = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Event&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Http2Stream&gt; streams = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;Http2Stream&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pendingIterations;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ActiveStreams</span><span class="params">(List&lt;Listener&gt; listeners)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.listeners = listeners;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">activate</span><span class="params">(<span class="keyword">final</span> DefaultStream stream)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (allowModifications()) &#123;</span><br><span class="line">            addToActiveStreams(stream);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pendingEvents.add(<span class="keyword">new</span> <span class="title class_">Event</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">                    addToActiveStreams(stream);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此对于读取的部分，我们就更可以信手拈来了。</p>
<figure class="highlight java"><figcaption><span>onDataRead</span><a href="https://github.com/netty/netty/blob/4.1/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java#L231">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onDataRead</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="type">int</span> streamId, ByteBuf data, <span class="type">int</span> padding,</span></span><br><span class="line"><span class="params">                        <span class="type">boolean</span> endOfStream)</span> <span class="keyword">throws</span> Http2Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 ID 获得 Stream</span></span><br><span class="line">    <span class="type">Http2Stream</span> <span class="variable">stream</span> <span class="operator">=</span> connection.stream(streamId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流程控制辅助类</span></span><br><span class="line">    <span class="type">Http2LocalFlowController</span> <span class="variable">flowController</span> <span class="operator">=</span> flowController();</span><br><span class="line">    <span class="type">int</span> <span class="variable">bytesToReturn</span> <span class="operator">=</span> data.readableBytes() + padding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先判断状态是不是能够接受数据的状态</span></span><br><span class="line">    <span class="type">Http2Exception</span> <span class="variable">error</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (stream.state()) &#123;</span><br><span class="line">        <span class="keyword">case</span> OPEN:</span><br><span class="line">        <span class="keyword">case</span> HALF_CLOSED_LOCAL:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HALF_CLOSED_REMOTE:</span><br><span class="line">        <span class="keyword">case</span> CLOSED:</span><br><span class="line">            error = streamError(stream.id(), STREAM_CLOSED, <span class="string">&quot;Stream %d in unexpected state: %s&quot;</span>,</span><br><span class="line">                stream.id(), stream.state());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            error = streamError(stream.id(), PROTOCOL_ERROR,</span><br><span class="line">                <span class="string">&quot;Stream %d in unexpected state: %s&quot;</span>, stream.id(), stream.state());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理是不是流程控制帧，就是上面的 H ES PP 等</span></span><br><span class="line">        flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 应该被消费的数据长度</span></span><br><span class="line">        unconsumedBytes = unconsumedBytes(stream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用消费者进行数据读取</span></span><br><span class="line">        bytesToReturn = listener.onDataRead(ctx, streamId, data, padding, endOfStream);</span><br><span class="line">        <span class="keyword">return</span> bytesToReturn;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol – HTTP/1.1</a></li>
<li><a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Connection_management_in_HTTP_1.x">Connection management in HTTP/1.x</a></li>
<li><a href="https://hpbn.co/http2/">HTTP/2</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>networking</category>
        <category>http</category>
      </categories>
      <tags>
        <tag>networking</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>How Istio works&amp;#58 translate</title>
    <url>/2021/08/27/networking/istio/How-Istio-works-translate/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210830103734.png" alt=""></p>
<p>众所周知，Istio 有一个很核心的功能是将Kube的资源对象翻译成Envoy的Xds协议。因此对于这部分来说，Istio 涉及到大致上三个部分</p>
<ul>
<li>Kube 资源的监听</li>
<li>Istio 内部如何存储这些数据</li>
<li>如何转为Xds协议</li>
</ul>
<span id="more"></span>
<h2 id="Kube-资源的监听"><a class="header-anchor" href="#Kube-资源的监听">¶</a>Kube 资源的监听</h2>
<p>Istio 有个单独的路径 <code>pilot/pkg/serviceregistry</code> 用来处理，早期的时候还有不同的资源，现在只保留了 kube 的实现。</p>
<p>在 <code>pilot/pkg/serviceregistry/kube/controller</code>  的路径中，我们可以发现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── controller.go</span><br><span class="line">├── discoverycontrollers.go</span><br><span class="line">├── endpoint_builder.go</span><br><span class="line">├── endpointcontroller.go</span><br><span class="line">├── endpoints.go</span><br><span class="line">├── endpointslice.go</span><br><span class="line">├── fake.go</span><br><span class="line">├── filter</span><br><span class="line">│   ├── discoverynamespaces.go</span><br><span class="line">│   └── informer.go</span><br><span class="line">├── leak_test.go</span><br><span class="line">├── multicluster.go</span><br><span class="line">├── namespacecontroller.go</span><br><span class="line">├── network.go</span><br><span class="line">├── pod.go</span><br><span class="line">├── pod_test.go</span><br><span class="line">├── serviceexportcache.go</span><br><span class="line">├── serviceexportcontroller.go</span><br><span class="line">├── sync.go</span><br><span class="line">├── util.go</span><br></pre></td></tr></table></figure>
<p>而我们所有的对象都会存储于 <code>Controller</code> 这个对象中。</p>
<p>在这个对象中，我们可以发现其中存储了最终获取到的所有资源，这个 <code>Controller</code> 对象对应了一个集群，而多个集群我们后文再提及。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">	opts Options</span><br><span class="line"></span><br><span class="line">	client kubelib.Client</span><br><span class="line"></span><br><span class="line">	queue queue.Instance</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Endpoint 的 Controller</span></span><br><span class="line">	endpoints kubeEndpointsController</span><br><span class="line"></span><br><span class="line">	<span class="comment">// serviceExport Cache &amp; Pod Cache</span></span><br><span class="line">	exports serviceExportCache</span><br><span class="line">	pods    *PodCache</span><br><span class="line"></span><br><span class="line">	serviceHandlers  []<span class="function"><span class="keyword">func</span><span class="params">(*model.Service, model.Event)</span></span></span><br><span class="line">	workloadHandlers []<span class="function"><span class="keyword">func</span><span class="params">(*model.WorkloadInstance, model.Event)</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这下面都是一些内部的数据结构，比如外部服务，Workload 等等</span></span><br><span class="line">	<span class="comment">// servicesMap stores hostname ==&gt; service, it is used to reduce convertService calls.</span></span><br><span class="line">	servicesMap <span class="keyword">map</span>[host.Name]*model.Service</span><br><span class="line">	<span class="comment">// nodeSelectorsForServices stores hostname =&gt; label selectors that can be used to</span></span><br><span class="line">	<span class="comment">// refine the set of node port IPs for a service.</span></span><br><span class="line">	nodeSelectorsForServices <span class="keyword">map</span>[host.Name]labels.Instance</span><br><span class="line">	<span class="comment">// map of node name and its address+labels - this is the only thing we need from nodes</span></span><br><span class="line">	<span class="comment">// for vm to k8s or cross cluster. When node port services select specific nodes by labels,</span></span><br><span class="line">	<span class="comment">// we run through the label selectors here to pick only ones that we need.</span></span><br><span class="line">	<span class="comment">// Only nodes with ExternalIP addresses are included in this map !</span></span><br><span class="line">	nodeInfoMap <span class="keyword">map</span>[<span class="type">string</span>]kubernetesNode</span><br><span class="line">	<span class="comment">// externalNameSvcInstanceMap stores hostname ==&gt; instance, is used to store instances for ExternalName k8s services</span></span><br><span class="line">	externalNameSvcInstanceMap <span class="keyword">map</span>[host.Name][]*model.ServiceInstance</span><br><span class="line">	<span class="comment">// workload instances from workload entries  - map of ip -&gt; workload instance</span></span><br><span class="line">	workloadInstancesByIP <span class="keyword">map</span>[<span class="type">string</span>]*model.WorkloadInstance</span><br><span class="line">	<span class="comment">// Stores a map of workload instance name/namespace to address</span></span><br><span class="line">	workloadInstancesIPsByName <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">	<span class="comment">// tracks which services on which ports should act as a gateway for networkForRegistry</span></span><br><span class="line">	registryServiceNameGateways <span class="keyword">map</span>[host.Name]<span class="type">uint32</span></span><br><span class="line">	<span class="comment">// gateways for each network, indexed by the service that runs them so we clean them up later</span></span><br><span class="line">	networkGateways <span class="keyword">map</span>[host.Name]<span class="keyword">map</span>[network.ID]gatewaySet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在随之的构造函数中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(kubeClient kubelib.Client, options Options)</span></span> *Controller &#123;</span><br><span class="line">	c.serviceInformer = filter.NewFilteredSharedIndexInformer(c.opts.DiscoveryNamespacesFilter.Filter, kubeClient.KubeInformer().Core().V1().Services().Informer())</span><br><span class="line">	c.serviceLister = listerv1.NewServiceLister(c.serviceInformer.GetIndexer())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过 Informer 的通知来处理 Service 对象</span></span><br><span class="line">	c.registerHandlers(c.serviceInformer, <span class="string">&quot;Services&quot;</span>, c.onServiceEvent, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过 Informer 的通知来处理 Endpoints 对象</span></span><br><span class="line">	endpointsInformer := filter.NewFilteredSharedIndexInformer(</span><br><span class="line">			c.opts.DiscoveryNamespacesFilter.Filter,</span><br><span class="line">			kubeClient.KubeInformer().Core().V1().Endpoints().Informer(),</span><br><span class="line">		)</span><br><span class="line">	c.endpoints = newEndpointsController(c, endpointsInformer)</span><br><span class="line">	<span class="comment">// 下面都是类似的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们会发现，对于资源的变化，<code>istio</code> 对于简单的资源，通过 Informer 通过 Event 回调就完成了资源的变更，相对复杂的就是直接单独提了一个 <code>controller</code>.</p>
<div>
	<label class="author-mark-label">小声比比</label>
	<p class="author-mark">这里感觉就是不太一致，如果是 Java body 肯定会统一抽象了。</p>
</div>
<h3 id="Discoverycontrollers"><a class="header-anchor" href="#Discoverycontrollers">¶</a>Discoverycontrollers</h3>
<p>对于 <code>discoverycontrollers</code> 系统入口是 <code>initDiscoveryNamespaceHandlers</code> 在这里我们会初始化那些需要被关注的 <code>Namespace</code>，默认情况下是所有，如果需要特殊指定，我们可以在 istio 的 CM 中配置。</p>
<p>当确认这个 <code>namesapce</code> 使我们需要处理的时候会触发如下函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> handleSelectedNamespace(endpointMode EndpointMode, ns <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> errs *multierror.Error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获得所有的服务</span></span><br><span class="line">	services, err := c.serviceLister.Services(ns).List(labels.Everything())</span><br><span class="line">	<span class="comment">// 触发服务增加的事件回调</span></span><br><span class="line">	<span class="keyword">for</span> _, svc := <span class="keyword">range</span> services &#123;</span><br><span class="line">		errs = multierror.Append(errs, c.onServiceEvent(svc, model.EventAdd))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获得所有的 Pod</span></span><br><span class="line">	pods, err := listerv1.NewPodLister(c.pods.informer.GetIndexer()).Pods(ns).List(labels.Everything())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Errorf(<span class="string">&quot;error listing pods: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  触发Pod增加的事件回调</span></span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		errs = multierror.Append(errs, c.pods.onEvent(pod, model.EventAdd))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下同忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 NS 的变更，我们会立即触发较多的的资源的变化，对 <code>Service</code> <code>Pod</code> <code>Endpoint</code> 都会一次性的出发变化。</p>
<div>
	<label class="author-mark-label">小声比比</label>
	<p class="author-mark">其他的都类似不做一一解释。</p>
</div>
<p>在此之上，<code>istio</code> 做了一个 <code>Multicluster</code> 的抽象，把单个 <code>Controller</code> 都提取到一起了。这部分我们就不再关注，我们至今知道了，所有的 Kube 原生资源都会在这个 <code>Controller</code> 中被关注到。但是我们还有 <code>VirtualService</code> 这样的配置呢? 而这部分逻辑我们需要回到我们的 <code>Poilt Server</code> 中</p>
<h3 id="ConfigStoreCache"><a class="header-anchor" href="#ConfigStoreCache">¶</a>ConfigStoreCache</h3>
<figure class="highlight go"><figcaption><span>Server</span><a href="https://github.com/istio/istio/blob/master/pilot/pkg/bootstrap/server.go#L111">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	XDSServer *xds.DiscoveryServer</span><br><span class="line"></span><br><span class="line">	configController  model.ConfigStoreCache</span><br><span class="line">	ConfigStores      []model.ConfigStoreCache</span><br><span class="line">	serviceEntryStore *serviceentry.ServiceEntryStore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>istio</code> 的配置，都在 <code>ConfigStoreCache</code> 中储存着呢。让我们到初始化的地方。</p>
<figure class="highlight go"><figcaption><span>init</span><a href="https://github.com/istio/istio/blob/master/pilot/pkg/bootstrap/configcontroller.go#L193">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> initConfigSources(args *PilotArgs) (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, configSource := <span class="keyword">range</span> s.environment.Mesh().ConfigSources &#123;</span><br><span class="line">		srcAddress, err := url.Parse(configSource.Address)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid config URL %s %v&quot;</span>, configSource.Address, err)</span><br><span class="line">		&#125;</span><br><span class="line">		scheme := ConfigSourceAddressScheme(srcAddress.Scheme)</span><br><span class="line">		<span class="keyword">switch</span> scheme &#123;</span><br><span class="line">		<span class="comment">// 略</span></span><br><span class="line">		<span class="keyword">case</span> Kubernetes:</span><br><span class="line">			<span class="keyword">if</span> srcAddress.Path == <span class="string">&quot;&quot;</span> || srcAddress.Path == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">				err2 := s.initK8SConfigStore(args)</span><br><span class="line">				<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Warn(<span class="string">&quot;Error loading k8s &quot;</span>, err2)</span><br><span class="line">					<span class="keyword">return</span> err2</span><br><span class="line">				&#125;</span><br><span class="line">				log.Warn(<span class="string">&quot;Started K8S config&quot;</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				log.Warnf(<span class="string">&quot;Not implemented, ignore: %v&quot;</span>, configSource.Address)</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> handle k8s:// scheme for remote cluster. Use same mechanism as service registry,</span></span><br><span class="line">				<span class="comment">// using the cluster name as key to match a secret.</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			log.Warnf(<span class="string">&quot;Ignoring unsupported config source: %v&quot;</span>, configSource.Address)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们默认会走到 <code>case Kubernetes</code> 这里其实有个设计上的缺陷，我们这里只能配置一个 <code>Kubernetes</code> 并不能使用多个 <code>Kubernetes</code> 作为数据源。在初始化的最下面，依然有一个聚合函数</p>
<figure class="highlight go"><figcaption><span>aggregateConfigController</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrap the config controller with a cache.</span></span><br><span class="line">aggregateConfigController, err := configaggregate.MakeCache(s.ConfigStores)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">s.configController = aggregateConfigController</span><br></pre></td></tr></table></figure>
<p>显然我们只需要关注 <code>aggregateConfigController</code></p>
<p>到这里我们已经找到了所有的如何读取数据的地方，那我们的数据又存储在什么地方呢？我们来到了 <code>controller</code> 的定义处</p>
<figure class="highlight go"><figcaption><span>pilot/pkg/config/aggregate/config.go:184</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cr *storeCache)</span></span> RegisterEventHandler(kind config.GroupVersionKind, handler model.EventHandler) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, cache := <span class="keyword">range</span> cr.caches &#123;</span><br><span class="line">		<span class="keyword">if</span> _, exists := cache.Schemas().FindByGroupVersionKind(kind); exists &#123;</span><br><span class="line">			cache.RegisterEventHandler(kind, handler)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在就绪的 <code>aggregateConfigController</code> 中，我们为不同的 <code>Schemams</code> 注册不同的回调函数。而这个回调函数的创建位置。</p>
<figure class="highlight go"><figcaption><span>createCacheHandler</span><a href="https://github.com/istio/istio/blob/master/pilot/pkg/config/kube/crdclient/client.go#L463">github</a></figcaption><table><tr><td class="code"><pre><span class="line">cl.kinds[s.Resource().GroupVersionKind()] = createCacheHandler(cl, s, i)</span><br><span class="line"></span><br><span class="line">i.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			incrementEvent(kind, <span class="string">&quot;add&quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> !cl.beginSync.Load() &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			cl.queue.Push(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> h.onEvent(<span class="literal">nil</span>, obj, model.EventAdd)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// 略</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>我们对于不同的 <code>CRD</code> 对象，我们注册了不同的 <code>Callback</code> 函数，而所有的一切都指向了 <code>onEvent</code> 函数</p>
<figure class="highlight go"><figcaption><span>onEvent</span><a href="https://github.com/istio/istio/blob/master/pilot/pkg/config/kube/crdclient/cache_handler.go#L43">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *cacheHandler)</span></span> onEvent(old <span class="keyword">interface</span>&#123;&#125;, curr <span class="keyword">interface</span>&#123;&#125;, event model.Event) <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里将所有的CRD对象转为istio内置的 Config 对象</span></span><br><span class="line">	currConfig := *TranslateObject(currItem, h.schema.Resource().GroupVersionKind(), h.client.domainSuffix)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// TODO we may consider passing a pointer to handlers instead of the value. While spec is a pointer, the meta will be copied</span></span><br><span class="line">	<span class="comment">// 而我们在这里真的去处理</span></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> h.client.handlers[h.schema.Resource().GroupVersionKind()] &#123;</span><br><span class="line">		f(oldConfig, currConfig, event)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那这个 <code>f</code> 是什么呢？笔者找了半天，<code>go</code> 的确这点不太好，最终发现其实很简单</p>
<figure class="highlight go"><figcaption><span>configHandler</span><a href="https://github.com/istio/istio/blob/master/pilot/pkg/bootstrap/server.go#L887">github</a></figcaption><table><tr><td class="code"><pre><span class="line">configHandler := <span class="function"><span class="keyword">func</span><span class="params">(_ config.Config, curr config.Config, event model.Event)</span></span> &#123;</span><br><span class="line">	pushReq := &amp;model.PushRequest&#123;</span><br><span class="line">		Full: <span class="literal">true</span>,</span><br><span class="line">		ConfigsUpdated: <span class="keyword">map</span>[model.ConfigKey]<span class="keyword">struct</span>&#123;&#125;&#123;&#123;</span><br><span class="line">			Kind:      curr.GroupVersionKind,</span><br><span class="line">			Name:      curr.Name,</span><br><span class="line">			Namespace: curr.Namespace,</span><br><span class="line">		&#125;: &#123;&#125;&#125;,</span><br><span class="line">		Reason: []model.TriggerReason&#123;model.ConfigUpdate&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	s.XDSServer.ConfigUpdate(pushReq)</span><br><span class="line">	<span class="keyword">if</span> event != model.EventDelete &#123;</span><br><span class="line">		s.statusReporter.AddInProgressResource(curr)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		s.statusReporter.DeleteInProgressResource(curr)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div>
	<label class="author-mark-label">小声比比</label>
	<p class="author-mark">所有的 Istio CRD 的变更，都会导致 Xds 发生 FullPush，尽量的减少 CRD 的变更。</p>
</div>
<p>其实看到这里，我们发现，至今我们都没有发现这些资源，istio 是如何储存的，而在这里，已经慢慢的揭开面纱。</p>
<figure class="highlight go"><figcaption><span>ConfigUpdate</span><a href="https://github.com/istio/istio/blob/master/pilot/pkg/xds/discovery.go#L368">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span></span> ConfigUpdate(req *model.PushRequest) &#123;</span><br><span class="line">	inboundConfigUpdates.Increment()</span><br><span class="line">	s.InboundUpdates.Inc()</span><br><span class="line">	s.pushChannel &lt;- req</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们大部分的行为变化，都会导致发生 <code>ConfigUpdate</code>，而我们是通过一个独立的 <code>pushChannel</code> 向我们的 <code>xds server</code> 发送信息（也是poliot自身）。现在再回到我们的 <code>endpointController</code> 中，我们可以发现</p>
<figure class="highlight go"><figcaption><span>updateEDS</span><a href="https://github.com/istio/istio/blob/master/pilot/pkg/serviceregistry/kube/controller/endpointcontroller.go#L62">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateEDS</span><span class="params">(c *Controller, epc kubeEndpointsController, ep <span class="keyword">interface</span>&#123;&#125;, event model.Event)</span></span> &#123;</span><br><span class="line">	host, svcName, ns := epc.getServiceInfo(ep)</span><br><span class="line">	log.Debugf(<span class="string">&quot;Handle EDS endpoint %s in namespace %s&quot;</span>, svcName, ns)</span><br><span class="line">	<span class="keyword">var</span> endpoints []*model.IstioEndpoint</span><br><span class="line">	<span class="keyword">if</span> event == model.EventDelete &#123;</span><br><span class="line">		endpoints = epc.forgetEndpoint(ep)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		endpoints = epc.buildIstioEndpoints(ep, host)</span><br><span class="line">	&#125;</span><br><span class="line">	c.opts.XDSUpdater.EDSUpdate(<span class="type">string</span>(c.Cluster()), <span class="type">string</span>(host), ns, endpoints)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>呼之欲出，我们所有的资源变化都会导致 <code>Xds Server</code> 产生变化。</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/istio-translate-1.png" alt=""></p>
<p>因此我们来到了下一个问题</p>
<h2 id="Istio-如何储存资源"><a class="header-anchor" href="#Istio-如何储存资源">¶</a>Istio 如何储存资源</h2>
<p>在消费 <code>push event</code> 的地方，我们经常轻易的发现，这一切处理函数在</p>
<figure class="highlight go"><figcaption><span>push</span><a href="https://github.com/istio/istio/blob/master/pilot/pkg/xds/discovery.go#L316">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span></span> Push(req *model.PushRequest) &#123;</span><br><span class="line">	<span class="keyword">if</span> !req.Full &#123;</span><br><span class="line">		req.Push = s.globalPushContext()</span><br><span class="line">		s.dropCacheForRequest(req)</span><br><span class="line">		s.AdsPushAll(versionInfo(), req)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	oldPushContext := s.globalPushContext()</span><br><span class="line">	<span class="keyword">if</span> oldPushContext != <span class="literal">nil</span> &#123;</span><br><span class="line">		oldPushContext.OnConfigChange()</span><br><span class="line">	&#125;</span><br><span class="line">	t0 := time.Now()</span><br><span class="line"></span><br><span class="line">	versionLocal := time.Now().Format(time.RFC3339) + <span class="string">&quot;/&quot;</span> + strconv.FormatUint(versionNum.Inc(), <span class="number">10</span>)</span><br><span class="line">	push, err := s.initPushContext(req, oldPushContext, versionLocal)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	initContextTime := time.Since(t0)</span><br><span class="line">	log.Debugf(<span class="string">&quot;InitContext %v for push took %s&quot;</span>, versionLocal, initContextTime)</span><br><span class="line">	pushContextInitTime.Record(initContextTime.Seconds())</span><br><span class="line"></span><br><span class="line">	versionMutex.Lock()</span><br><span class="line">	version = versionLocal</span><br><span class="line">	versionMutex.Unlock()</span><br><span class="line"></span><br><span class="line">	req.Push = push</span><br><span class="line">	s.AdsPushAll(versionLocal, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以轻易的猜测出，推送的数据显然是是这个 initPushContext 函数所提供。再需要细微的一小步，我们就可以发现构建数据</p>
<figure class="highlight go"><figcaption><span>createNewContext</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PushContext)</span></span> createNewContext(env *Environment) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := ps.initServiceRegistry(env); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := ps.initKubernetesGateways(env); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := ps.initVirtualServices(env); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 下略</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我们从 <code>PushContext</code> 定义可见。</p>
<figure class="highlight go"><figcaption><span>PushContext</span><a href="https://github.com/istio/istio/blob/master/pilot/pkg/model/push_context.go#L147">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PushContext <span class="keyword">struct</span> &#123;</span><br><span class="line">	proxyStatusMutex sync.RWMutex</span><br><span class="line">	<span class="comment">// ProxyStatus is keyed by the error code, and holds a map keyed</span></span><br><span class="line">	<span class="comment">// by the ID.</span></span><br><span class="line">	ProxyStatus <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]ProxyPushStatus</span><br><span class="line">	exportToDefaults exportToDefaults</span><br><span class="line">	<span class="comment">// ServiceIndex is the index of services by various fields.</span></span><br><span class="line">	ServiceIndex serviceIndex</span><br><span class="line">	<span class="comment">// vs 配置</span></span><br><span class="line">	virtualServiceIndex virtualServiceIndex</span><br><span class="line">	<span class="comment">// dt 配置</span></span><br><span class="line">	destinationRuleIndex destinationRuleIndex</span><br><span class="line">	<span class="comment">// gateway配置</span></span><br><span class="line">	gatewayIndex gatewayIndex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里就可以发现，其实我们现在所有的对象都转化为了 <code>istio</code> 内置在 <code>pushContext</code> 中的数据结构。</p>
<p>//TODO 转化逻辑</p>
<h2 id="重要对象关系"><a class="header-anchor" href="#重要对象关系">¶</a>重要对象关系</h2>
<p>在我们探索最后一部分逻辑的时候，我们了解下有几个重要重要对象的关系</p>
<ul>
<li>DiscoveryServer:  我们的 xDS 服务器，也就是 Poliot Discovery 组件</li>
<li>Proxy: 一个 xDS 连接</li>
<li>PushRequest: 推送请求</li>
<li>PushContext: 推送上下文对象，对于 DiscoveryServer 存储一个 全局的 <code>globalPushContext</code></li>
</ul>
<p>因此在这里我们我们就可以梳理清楚这几者的关系。</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/istio.png" alt=""></p>
<h2 id="如何转为Xds协议"><a class="header-anchor" href="#如何转为Xds协议">¶</a>如何转为Xds协议</h2>
<p>来到了我们的最后一个需要解答的地方，我们这些 <code>PushContext</code> 的内容又是如何转化为 <code>xDS</code> 协议的呢？</p>
<p>对于所有的资源转化，<code>istio</code> 抽象了一个独立的  <code>Interface</code> 进行出来。</p>
<figure class="highlight go"><figcaption><span>XdsResourceGenerator</span><a href="https://github.com/istio/istio/blob/master/pilot/pkg/model/context.go#L213">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> XdsResourceGenerator <span class="keyword">interface</span> &#123;</span><br><span class="line">	Generate(proxy *Proxy, push *PushContext, w *WatchedResource, updates *PushRequest) (Resources, XdsLogDetails, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210828102630.png" alt=""></p>
<p>我们可以发现不同类型的转换。对于 <code>xDS</code> 协议本身的实现，可以参考 <a href="2021/07/01/xDS/">xDS 协议的实现</a></p>
<p>从这里我们梳理下调用的时序关系</p>


<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>

<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: 下发全流程',
	 '资源变动->DiscoveryServer: 1. 资源变动产生的 ConfigUpdate',
	 'DiscoveryServer->DiscoveryServer: 2. 触发 Push 函数',
	 'DiscoveryServer->DiscoveryServer: 3. initPushContext 创建 PushContext 对象',
	 'DiscoveryServer->PushQueue: 4. startPush 将需要更新的 PushRequest 压入队列',
	 'PushQueue->PushQueue: 5. 后台循环处理发送时间'
	].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>


<p>当我们有一个全局概念之后，我们就可以来看看具体的 <code>LDS</code> 是如何实现的。</p>
<h3 id="LDS"><a class="header-anchor" href="#LDS">¶</a>LDS</h3>
<p>我们的开胃菜先从 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/xds_api#v3-grpc-streaming-endpoints"><code>LDS</code></a> 开始看起来。</p>
<figure class="highlight go"><figcaption><span>Generate</span><a href="https://github.com/istio/istio/blob/master/pilot/pkg/xds/lds.go">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l LdsGenerator)</span></span> Generate(proxy *model.Proxy, push *model.PushContext, w *model.WatchedResource, req *model.PushRequest) (model.Resources, model.XdsLogDetails, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> !ldsNeedsPush(req) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, model.DefaultXdsLogDetails, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	listeners := l.Server.ConfigGenerator.BuildListeners(proxy, push)</span><br><span class="line">	resources := model.Resources&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> listeners &#123;</span><br><span class="line">		resources = <span class="built_in">append</span>(resources, &amp;discovery.Resource&#123;</span><br><span class="line">			Name:     c.Name,</span><br><span class="line">			Resource: util.MessageToAny(c),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resources, model.DefaultXdsLogDetails, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>LDS</code> 的生成逻辑，会分为 <code>Sidecar</code> 和 <code>Router</code> 两部分，我们取 <code>Sidecar</code> 处逻辑，在</p>
<figure class="highlight go"><figcaption><span>buildSidecarInboundListeners</span><a href="https://github.com/istio/istio/blob/master/pilot/pkg/networking/core/v1alpha3/listener.go#L131">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(configgen *ConfigGeneratorImpl)</span></span> buildSidecarInboundListeners(node *model.Proxy,push *model.PushContext) []*listener.Listener &#123;</span><br><span class="line">	<span class="keyword">var</span> listeners []*listener.Listener</span><br><span class="line">	listenerMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*inboundListenerEntry)</span><br><span class="line"></span><br><span class="line">	sidecarScope := node.SidecarScope</span><br><span class="line">	noneMode := node.GetInterceptionMode() == model.InterceptionNone</span><br><span class="line">	<span class="keyword">if</span> !sidecarScope.HasIngressListener() &#123;</span><br><span class="line">		<span class="comment">// 先构建所有的 Service 实例对应的地址 Listener，而这个 instances，从而来，我们下文介绍</span></span><br><span class="line">		<span class="keyword">for</span> _, instance := <span class="keyword">range</span> node.ServiceInstances &#123;</span><br><span class="line">			endpoint := instance.Endpoint</span><br><span class="line">			wildcard, _ := getActualWildcardAndLocalHost(node)</span><br><span class="line">			bind := wildcard</span><br><span class="line">			port := *instance.ServicePort</span><br><span class="line">			port.Port = <span class="type">int</span>(endpoint.EndpointPort)</span><br><span class="line">			listenerOpts := buildListenerOpts&#123;</span><br><span class="line">				push:       push,</span><br><span class="line">				proxy:      node,</span><br><span class="line">				bind:       bind,</span><br><span class="line">				port:       &amp;port,</span><br><span class="line">				bindToPort: <span class="literal">false</span>,</span><br><span class="line">				protocol:   istionetworking.ModelProtocolToListenerProtocol(instance.ServicePort.Protocol, core.TrafficDirection_INBOUND),</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pluginParams := &amp;plugin.InputParams&#123;</span><br><span class="line">				Node:            node,</span><br><span class="line">				ServiceInstance: instance,</span><br><span class="line">				Push:            push,</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> l := configgen.buildSidecarInboundListenerForPortOrUDS(listenerOpts, pluginParams, listenerMap); l != <span class="literal">nil</span> &#123;</span><br><span class="line">				listeners = <span class="built_in">append</span>(listeners, l)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> listeners</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> listeners</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个 <code>Instances</code> 列表是从我们 <code>Poliot Xds</code> 上下文中构建而来。</p>
<figure class="highlight go"><figcaption><span>SetServiceInstances</span><a href="https://github.com/istio/istio/blob/master/pilot/pkg/model/context.go#L810">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *Proxy)</span></span> SetServiceInstances(serviceDiscovery ServiceDiscovery) &#123;</span><br><span class="line">	<span class="comment">// 我们根据当前 xDs Context 上下文中的 serviceDiscovery 构建这个 Instance 列表</span></span><br><span class="line">	instances := serviceDiscovery.GetProxyServiceInstances(node)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Keep service instances in order of creation/hostname.</span></span><br><span class="line">	sort.SliceStable(instances, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="comment">// ....</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	node.ServiceInstances = instances</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EDS"><a class="header-anchor" href="#EDS">¶</a>EDS</h3>
<p>除了 <code>LDS</code> 之外，还有一些会走捷径的资源更新，比如我们只是 <code>Pod Ip</code> 的变更不会导致其他资源更新，我们只需要更新我们的 <code>eds</code> 就可以。</p>
<figure class="highlight go"><figcaption><span>processEndpointEvent</span><a href="https://github.com/istio/istio/blob/master/pilot/pkg/serviceregistry/kube/controller/endpointcontroller.go#L62">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processEndpointEvent</span><span class="params">(c *Controller, epc kubeEndpointsController, name <span class="type">string</span>, namespace <span class="type">string</span>, event model.Event, ep <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	updateEDS(c, epc, ep, event)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们可以更快速抵达更新路径上</p>
<figure class="highlight go"><figcaption><span>EDSUpdate</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span></span> EDSUpdate(clusterID, serviceName <span class="type">string</span>, namespace <span class="type">string</span>,</span><br><span class="line">	istioEndpoints []*model.IstioEndpoint) &#123;</span><br><span class="line">	inboundEDSUpdates.Increment()</span><br><span class="line">	<span class="comment">// Update the endpoint shards</span></span><br><span class="line">	fp := s.edsCacheUpdate(clusterID, serviceName, namespace, istioEndpoints)</span><br><span class="line">	<span class="comment">// Trigger a push</span></span><br><span class="line">	s.ConfigUpdate(&amp;model.PushRequest&#123;</span><br><span class="line">		Full: fp,</span><br><span class="line">		ConfigsUpdated: <span class="keyword">map</span>[model.ConfigKey]<span class="keyword">struct</span>&#123;&#125;&#123;&#123;</span><br><span class="line">			Kind:      gvk.ServiceEntry,</span><br><span class="line">			Name:      serviceName,</span><br><span class="line">			Namespace: namespace,</span><br><span class="line">		&#125;: &#123;&#125;&#125;,</span><br><span class="line">		Reason: []model.TriggerReason&#123;model.EndpointUpdate&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是值得注意，因为一些其他原因的也会导致，我们仅仅更新 <code>eds</code> 是不够的也需要全量的更新。</p>
<h2 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h2>
<p>对于当前版本的 <code>istio</code> 我们还需要一些额外的工作，比如自动注册的 <code>workload entry</code>，我们没有在本文中解释，寄希望大家能够把握住，系统的主要脉络以分析系统的构成。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>istio</category>
      </categories>
      <tags>
        <tag>istio</tag>
      </tags>
  </entry>
  <entry>
    <title>How Merbridge Works</title>
    <url>/2023/05/17/networking/istio/how-merbridge-works/</url>
    <content><![CDATA[<p>在 <a href="https://mp.weixin.qq.com/s/Ht1HuLxQ2RngrVD92TBl4Q">服务网格加速器 Merbridge 正式进入 CNCF 沙箱</a> 中提及使用 Cillum 来提速 Istio，我们来瞧瞧这个原理是如何的。</p>
<div>
    <label class="author-mark-label">注意</label>
    <p class="author-mark">本文基于 0.8.1 版本</p>
</div>
<span id="more"></span>
<h2 id="Istio-iptable-流量路径"><a class="header-anchor" href="#Istio-iptable-流量路径">¶</a>Istio iptable 流量路径</h2>
<p>在传统的 Istio 流量路径中，outbound 流量由 APP 出来被 iptables 劫持，然后通过内核转发给 Envoy，Envoy 再出去。Inbound 类似，因此实际上数据包在内核中倒腾了好几次</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2023/202305171028862.png" alt=""></p>
<h2 id="优化手段"><a class="header-anchor" href="#优化手段">¶</a>优化手段</h2>
<p>既然是 ebpf 的手段，那肯定是 <a href="https://arthurchiao.art/blog/socket-acceleration-with-ebpf-zh/">[译] 利用 ebpf sockmap/redirection 提升 socket 性能（2020）</a><br>
目标是绕过内核的 <code>TCP/IP</code> 协议栈</p>
<h2 id="How-Merbridge-Works"><a class="header-anchor" href="#How-Merbridge-Works">¶</a>How Merbridge Works</h2>
<p><code>iptables</code> 本身使用 <code>DNAT</code> 功能做流量转发<br>
这里主要有两个要点：</p>
<ol>
<li>修改连接发起时的目的地址，让流量能够发送到新的接口；</li>
<li>让 Envoy 能识别原始的目的地址，以能够识别流量。</li>
</ol>
<p>想要用 <code>eBPF</code> 模拟 <code>iptables</code> 的能力，就需要使用 <code>eBPF</code> 实现类似 <code>iptables</code> <code>DNAT</code> 的能力。</p>
<ol>
<li>使用 eBPF 的 connect 程序修改 user_ip 和 user_port 实现。</li>
<li>需要用到 ORIGINAL_DST 的概念，这在 Linux 内核中是 netfilter 模块专属的。</li>
</ol>
<blockquote>
<p>其原理为：应用程序在收到连接之后调用 get_sockopts 函数，获取 ORIGINAL_DST。如果经过了 iptables 的 DNAT，那么 iptables 就会给当前的 socket 设置 ORIGINAL_DST 这个值，并把原有的 IP + 端口写入这个值，应用程序就可以根据连接拿到原有的目的地址。</p>
</blockquote>
<blockquote>
<p>PS: 值得注意的 eBPF 运行在内核态，因此不能想象其运行在 cgroup 的限制的虚拟空间中</p>
</blockquote>
<h3 id="Outbound-流量"><a class="header-anchor" href="#Outbound-流量">¶</a>Outbound 流量</h3>
<h4 id="早期版本"><a class="header-anchor" href="#早期版本">¶</a>早期版本</h4>
<p>在早期的版本中，采用了一个比较巧妙的方式来做</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2023/202305171045615.png" alt=""></p>
<ol>
<li>在应用向外发起连接时，connect 程序会将目标地址修改为 127.x.y.z:15001，并用 cookie_original_dst 保存原始目的地址。</li>
<li>在 sockops 程序中，将当前 sock 和四元组保存在 sock_pair_map 中。同时，将四元组信息和对应的原始目的地址写入 pair_original_dst 中 (之所以不用 cookie，是因为 get_sockopt 函数无法获取当前 cookie)。</li>
<li>Envoy 收到连接之后会调用 getsockopt 获取当前连接的目的地址，get_sockopt 函数会根据四元组信息从 pair_original_dst 取出原始目的地址并返回，由此完全建立连接。</li>
<li>在发送数据阶段，redir 程序会根据四元组信息，从 sock_pair_map 中读取 sock，然后通过 bpf_msg_redirect_hash 进行直接转发，加速请求。</li>
</ol>
<p>其中，之所以在 connect 时，修改目的地址为 127.x.y.z 而不是 127.0.0.1，是因为在不同的 Pod 中，可能产生冲突的四元组，使用此方式即可巧妙地避开冲突 (每个 Pod 间的目的 IP 不同，不会出现冲突的情况)。</p>
<p><a href="https://github.com/merbridge/merbridge/blob/cc805614079c74dfc87dae9cc3b935ed63a0b176/bpf/mb_connect.c#L180-L191">source code</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__u64 uid = bpf_get_current_uid_gid() &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">__u32 dst_ip = ctx-&gt;user_ip4;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 outip 就是一个自增变量，来区分在同一个宿主机上不同命名空间内的来自相同 localhost 的请求</span></span><br><span class="line">ctx-&gt;user_ip4 = bpf_htonl(<span class="number">0x7f800000</span> | (outip++));</span><br><span class="line"><span class="keyword">if</span> (outip &gt;&gt; <span class="number">20</span>) &#123;</span><br><span class="line">    outip = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ctx-&gt;user_port = bpf_htons(OUT_REDIRECT_PORT);</span><br></pre></td></tr></table></figure>
<h4 id="当前版本-0-7-2"><a class="header-anchor" href="#当前版本-0-7-2">¶</a>当前版本 (&gt;0.7.2)</h4>
<p>当前版本采用了 CNI 模式，较为复杂，但是会更加全面。</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2023/202305171100535.png" alt=""></p>
<p>大部分 CNI 就是在节点上运行一个 <code>daemonsets</code> 的 <code>POD</code> 基于 <code>Network NS</code> 做一些工作，这里也一样，当我们安装完成 <code>merbridge</code>，我们就能看到对应的节点 POD，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get pod -n istio-system</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">istio-ingressgateway-676d4bf8b7-24257   1/1     Running   0          57d</span><br><span class="line">istiod-5fb4fb7f6b-5pzbs                 1/1     Running   0          57d</span><br><span class="line">merbridge-c4jj9                         1/1     Running   0          14h</span><br><span class="line">merbridge-jldmx                         1/1     Running   0          14h</span><br><span class="line">merbridge-x65x6                         1/1     Running   0          14h</span><br></pre></td></tr></table></figure>
<p>当然还有 CLI 命令，代码在<a href="https://github.com/merbridge/merbridge/blob/3db9b4462a0d4e61791a57dcbe5728607eb35e3d/internal/cni-server/cni-plugin.go#L63-L111">这里</a></p>
<p>启动逻辑在 <a href="https://github.com/merbridge/merbridge/blob/554cf33d429fad8b29252ae0776fb8fec8d7aecc/controller/pod.go#L40-L71">RunLocalPodController</a> 这里不做展开，<br>
这里主要的工作就是维护当前 <code>NODE</code> 节点上的 <code>POD IP</code> 列表。</p>
<p>下面就一个新增 POD 的流程来看看。</p>
<h5 id="POD-初始化"><a class="header-anchor" href="#POD-初始化">¶</a>POD 初始化</h5>
<ol>
<li>节点上的 membrige 会更新本Node节点的 IP 清单</li>
</ol>
<figure class="highlight go"><figcaption><span>新建 POD</span><a href="https://github.com/merbridge/merbridge/blob/554cf33d429fad8b29252ae0776fb8fec8d7aecc/controller/pod.go#L106-L139">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addFunc</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	pod, ok := obj.(*v1.Pod)</span><br><span class="line">	log.Debugf(<span class="string">&quot;got pod updated %s/%s&quot;</span>, pod.Namespace, pod.Name)</span><br><span class="line"></span><br><span class="line">	_ip, _ := linux.IP2Linux(pod.Status.PodIP)</span><br><span class="line">	log.Infof(<span class="string">&quot;update local_pod_ips with ip: %s&quot;</span>, pod.Status.PodIP)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 ebpf 中的 localIPMAP 对象</span></span><br><span class="line">	err := ebpfs.GetLocalIPMap().Update(_ip, &amp;p, ebpf.UpdateAny)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Errorf(<span class="string">&quot;update local_pod_ips %s error: %v&quot;</span>, pod.Status.PodIP, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>bpftool</code> 工具很方便可以查看到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bpftool map show</span><br><span class="line">29: lru_hash  name cookie_original  flags 0x0</span><br><span class="line">        key 8B  value 24B  max_entries 65535  memlock 2097152B</span><br><span class="line">30: <span class="built_in">hash</span>  name local_pod_ips  flags 0x0</span><br><span class="line">        key 16B  value 484B  max_entries 1024  memlock 516096B</span><br><span class="line">31: lru_hash  name process_ip  flags 0x0</span><br><span class="line">        key 4B  value 4B  max_entries 1024  memlock 8192B</span><br><span class="line">32: lru_hash  name cgroup_info_map  flags 0x0</span><br><span class="line">        key 8B  value 32B  max_entries 1024  memlock 40960B</span><br><span class="line">33: <span class="built_in">hash</span>  name mark_pod_ips_ma  flags 0x0</span><br><span class="line">        key 4B  value 16B  max_entries 65535  memlock 1572864B</span><br><span class="line">37: array  name mb_conne.data  flags 0x0</span><br><span class="line">        key 4B  value 4B  max_entries 1  memlock 4096B</span><br><span class="line">        btf_id 135</span><br><span class="line">38: lru_hash  name pair_original_d  flags 0x0</span><br><span class="line">        key 36B  value 24B  max_entries 65535  memlock 4194304B</span><br><span class="line">39: sockhash  name sock_pair_map  flags 0x0</span><br><span class="line">        key 36B  value 4B  max_entries 65535  memlock 2621440B</span><br><span class="line">70: <span class="built_in">hash</span>  name calico_failsafe  flags 0x1</span><br><span class="line">        key 4B  value 1B  max_entries 65535  memlock 524288B</span><br></pre></td></tr></table></figure>
<ol>
<li>CNI 会将当前 POD IP 植入命令空间</li>
</ol>
<figure class="highlight go"><figcaption><span>CNI-CMDADD</span><a href="https://github.com/merbridge/merbridge/blob/3db9b4462a0d4e61791a57dcbe5728607eb35e3d/internal/cni-server/cni-plugin.go#L208-L241">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> listenConfig(addr net.Addr, netns <span class="type">string</span>) net.ListenConfig &#123;</span><br><span class="line">	<span class="keyword">return</span> net.ListenConfig&#123;</span><br><span class="line">		Control: <span class="function"><span class="keyword">func</span><span class="params">(network, address <span class="type">string</span>, conn syscall.RawConn)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> operr <span class="type">error</span></span><br><span class="line">			<span class="keyword">if</span> err := conn.Control(<span class="function"><span class="keyword">func</span><span class="params">(fd <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">                <span class="comment">// 创建一个 mark_pod_ips_map 在 epbf 中</span></span><br><span class="line">				m, err := ebpf.LoadPinnedMap(path.Join(s.bpfMountPath, <span class="string">&quot;mark_pod_ips_map&quot;</span>), &amp;ebpf.LoadPinOptions&#123;&#125;)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					operr = err</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">var</span> ip unsafe.Pointer</span><br><span class="line">				<span class="keyword">switch</span> v := addr.(<span class="keyword">type</span>) &#123; <span class="comment">// todo instead of hash</span></span><br><span class="line">				<span class="keyword">case</span> *net.IPNet: <span class="comment">// nolint: typecheck</span></span><br><span class="line">					ip, err = linux.IP2Linux(v.IP.String())</span><br><span class="line">				<span class="keyword">case</span> *net.IPAddr: <span class="comment">// nolint: typecheck</span></span><br><span class="line">					ip, err = linux.IP2Linux(v.String())</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					operr = err</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				key := getMarkKeyOfNetns(netns)</span><br><span class="line">                <span class="comment">// 将 IP 更换新到其中</span></span><br><span class="line">				operr = m.Update(key, ip, ebpf.UpdateAny)</span><br><span class="line">				<span class="keyword">if</span> operr != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				operr = syscall.SetsockoptInt(<span class="type">int</span>(fd), unix.SOL_SOCKET, ns.SoMark, <span class="type">int</span>(key))</span><br><span class="line">			&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> operr</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Outbound-处理"><a class="header-anchor" href="#Outbound-处理">¶</a>Outbound 处理</h5>
<h6 id="Connect-阶段"><a class="header-anchor" href="#Connect-阶段">¶</a>Connect 阶段</h6>
<ol>
<li>在应用向外发起连接时，connect 程序会先去读取下 cgroup_info，在 <code>CNI</code> 模式中，会获取当前的 <code>POD IP</code>，<a href="https://github.com/merbridge/merbridge/blob/f88730f95eb808d25f181473c75f2c4748b943b1/bpf/headers/cgroup.h#L47-L71">源码地址</a></li>
<li>通过 cookie 保存 cookie_original_dst 信息，这个在后续 Envoy 中的 get_sockopt 函数需要使用到。</li>
<li>然后将 bpf_bind 把  ctx 和这个 cgroup 内的 socket 绑定，后续可以获取 ctx 在后续的执行</li>
</ol>
<figure class="highlight c"><figcaption><span>tcp4connect</span><a href="https://github.com/merbridge/merbridge/blob/cc805614079c74dfc87dae9cc3b935ed63a0b176/bpf/mb_connect.c#L61-L86">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">tcp_connect4</span><span class="params">(<span class="keyword">struct</span> bpf_sock_addr *ctx)</span></span><br><span class="line">&#123;   </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_info</span> <span class="title">cg_info</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!get_current_cgroup_info(ctx, &amp;cg_info)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    __u32 curr_pod_ip;</span><br><span class="line">    __u32 _curr_pod_ip[<span class="number">4</span>];</span><br><span class="line">    set_ipv6(_curr_pod_ip, cg_info.cgroup_ip);</span><br><span class="line">    curr_pod_ip = get_ipv4(_curr_pod_ip);</span><br><span class="line"></span><br><span class="line">    __u64 uid = bpf_get_current_uid_gid() &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    __u32 dst_ip = ctx-&gt;user_ip4;</span><br><span class="line">    <span class="keyword">if</span> (uid != SIDECAR_USER_ID) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((dst_ip &amp; <span class="number">0xff</span>) == <span class="number">0x7f</span>) &#123;</span><br><span class="line">            <span class="comment">// app call local, bypass.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        __u64 cookie = bpf_get_socket_cookie_addr(ctx);</span><br><span class="line">        <span class="comment">// app call others</span></span><br><span class="line">        debugf(<span class="string">&quot;call from user container: cookie: %d, ip: %pI4, port: %d&quot;</span>,</span><br><span class="line">               cookie, &amp;dst_ip, bpf_htons(ctx-&gt;user_port));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we need redirect it to envoy.</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> <span class="title">origin</span>;</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;origin, <span class="number">0</span>, <span class="keyword">sizeof</span>(origin));</span><br><span class="line">        set_ipv4(origin.ip, dst_ip);</span><br><span class="line">        origin.port = ctx-&gt;user_port;</span><br><span class="line">        origin.flags = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bpf_map_update_elem(&amp;cookie_original_dst, &amp;cookie, &amp;origin,</span><br><span class="line">                                BPF_ANY)) &#123;</span><br><span class="line">            printk(<span class="string">&quot;write cookie_original_dst failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr_pod_ip) &#123;</span><br><span class="line">            <span class="comment">// 一些检查 SKIP </span></span><br><span class="line">            <span class="comment">// 把这个 ctx 和 socket 绑定</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span> =</span> &#123;</span><br><span class="line">                .sin_addr =</span><br><span class="line">                    &#123;</span><br><span class="line">                        .s_addr = curr_pod_ip,</span><br><span class="line">                    &#125;,</span><br><span class="line">                .sin_port = <span class="number">0</span>,</span><br><span class="line">                .sin_family = <span class="number">2</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (bpf_bind(ctx, &amp;addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in))) &#123;</span><br><span class="line">                debugf(<span class="string">&quot;bind %pI4 error&quot;</span>, &amp;curr_pod_ip);</span><br><span class="line">            &#125;</span><br><span class="line">            ctx-&gt;user_ip4 = localhost;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 旧版本兼容</span></span><br><span class="line">            ctx-&gt;user_ip4 = bpf_htonl(<span class="number">0x7f800000</span> | (outip++));</span><br><span class="line">            <span class="keyword">if</span> (outip &gt;&gt; <span class="number">20</span>) &#123;</span><br><span class="line">                outip = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx-&gt;user_port = bpf_htons(OUT_REDIRECT_PORT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// outbound 流量</span></span><br><span class="line">        <span class="comment">// from envoy to others</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做完这些的时候，我们已经完成了第一部分：修改连接发起时的目的地址，让流量能够发送到新的接口。</p>
<h6 id="SetOps-GetOps-阶段"><a class="header-anchor" href="#SetOps-GetOps-阶段">¶</a>SetOps/GetOps 阶段</h6>
<ol>
<li>在请求建立成功的时候，会将这个对象保存起来，这里刚好用到我们上面的 <code>cookie</code> 中储存的值。</li>
</ol>
<figure class="highlight c"><figcaption><span>sockops_ipv4</span><a href="https://github.com/merbridge/merbridge/blob/7fd1fddb7e3f64f125dafb9bb75059ed5341408d/bpf/mb_sockops.c#L23-L70">github</a></figcaption><table><tr><td class="code"><pre><span class="line">__section(<span class="string">&quot;sockops&quot;</span>) <span class="type">int</span> <span class="title function_">mb_sockops</span><span class="params">(<span class="keyword">struct</span> bpf_sock_ops *skops)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (skops-&gt;op) &#123;</span><br><span class="line">    <span class="keyword">case</span> BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB:</span><br><span class="line">    <span class="keyword">case</span> BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB:</span><br><span class="line">        <span class="keyword">switch</span> (skops-&gt;family) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_IPV4</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="comment">// AF_INET, we don&#x27;t include socket.h, because it may</span></span><br><span class="line">            <span class="comment">// cause an import error.</span></span><br><span class="line">            <span class="keyword">return</span> sockops_ipv4(skops);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">sockops_ipv4</span><span class="params">(<span class="keyword">struct</span> bpf_sock_ops *skops)</span></span><br><span class="line">&#123;</span><br><span class="line">    __u64 cookie = bpf_get_socket_cookie_ops(skops);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pair</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    set_ipv4(p.sip, skops-&gt;local_ip4);</span><br><span class="line">    p.sport = bpf_htons(skops-&gt;local_port);</span><br><span class="line">    set_ipv4(p.dip, skops-&gt;remote_ip4);</span><br><span class="line">    p.dport = skops-&gt;remote_port &gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> *<span class="title">dst</span> =</span></span><br><span class="line">        bpf_map_lookup_elem(&amp;cookie_original_dst, &amp;cookie);</span><br><span class="line">    <span class="keyword">if</span> (dst) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> <span class="title">dd</span> =</span> *dst;</span><br><span class="line">        <span class="comment">// 在 Istio 中，Envoy 用的方式是使用当前 PodIP 加服务端口。经过上述入口流量处理后，我们会发现由于 PodIP 也存在于 local_pod_ips 中，那么这个请求会被转发到 PodIP + 15006 端口，这显然是不行的，会造成无限递归。</span></span><br><span class="line">        <span class="comment">// 即在 Envoy 尝试建立连接时，还是会走重定向到 15006 端口，但是在 sockops 阶段会判断源 IP 和目的地址 IP 是否一致。如果一致，代表发送了错误的请求，那么我们会在 sockops 丢弃这个连接，并将当前的 ProcessID 和 </span></span><br><span class="line">        <span class="comment">// IP 地址信息写入 process_ip 这个 map，让 eBPF 支持进程与 IP 的对应关系。当下次发送请求时，直接从 process_ip 表检查目的地址是否与当前 IP 地址一致。</span></span><br><span class="line">        <span class="keyword">if</span> (!(dd.flags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            __u32 pid = dd.pid;</span><br><span class="line">            <span class="comment">// process ip not detected</span></span><br><span class="line">            <span class="keyword">if</span> (skops-&gt;local_ip4 == envoy_ip ||</span><br><span class="line">                skops-&gt;local_ip4 == skops-&gt;remote_ip4) &#123;</span><br><span class="line">                <span class="comment">// envoy to local</span></span><br><span class="line">                __u32 ip = skops-&gt;remote_ip4;</span><br><span class="line">                debugf(<span class="string">&quot;detected process %d&#x27;s ip is %pI4&quot;</span>, pid, &amp;ip);</span><br><span class="line">                bpf_map_update_elem(&amp;process_ip, &amp;pid, &amp;ip, BPF_ANY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// envoy to envoy</span></span><br><span class="line">                __u32 ip = skops-&gt;local_ip4;</span><br><span class="line">                bpf_map_update_elem(&amp;process_ip, &amp;pid, &amp;ip, BPF_ANY);</span><br><span class="line">                debugf(<span class="string">&quot;detected process %d&#x27;s ip is %pI4&quot;</span>, pid, &amp;ip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// get_sockopts can read pid and cookie,</span></span><br><span class="line">        <span class="comment">// we should write a new map named pair_original_dst</span></span><br><span class="line">        bpf_map_update_elem(&amp;pair_original_dst, &amp;p, &amp;dd, BPF_ANY);</span><br><span class="line">        bpf_sock_hash_update(skops, &amp;sock_pair_map, &amp;p, BPF_NOEXIST);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skops-&gt;local_port == OUT_REDIRECT_PORT ||</span><br><span class="line">               skops-&gt;local_port == IN_REDIRECT_PORT ||</span><br><span class="line">               skops-&gt;remote_ip4 == envoy_ip) &#123;</span><br><span class="line">        bpf_sock_hash_update(skops, &amp;sock_pair_map, &amp;p, BPF_NOEXIST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>读取这部分比较简单在 <code>mb_get_sockopt</code> 返回相对应的即可</li>
</ol>
<figure class="highlight c"><figcaption><span>mb_get_sockopt</span><a href="https://github.com/merbridge/merbridge/blob/7fd1fddb7e3f64f125dafb9bb75059ed5341408d/bpf/mb_get_sockopts.c#L24-L66">github</a></figcaption><table><tr><td class="code"><pre><span class="line">__section(<span class="string">&quot;cgroup/getsockopt&quot;</span>) <span class="type">int</span> <span class="title function_">mb_get_sockopt</span><span class="params">(<span class="keyword">struct</span> bpf_sockopt *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// envoy will call getsockopt with SO_ORIGINAL_DST, we should rewrite it to</span></span><br><span class="line">    <span class="comment">// return original dst info.</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;optname != SO_ORIGINAL_DST) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pair</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    p.dport = bpf_htons(ctx-&gt;sk-&gt;src_port);</span><br><span class="line">    p.sport = ctx-&gt;sk-&gt;dst_port;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> *<span class="title">origin</span>;</span></span><br><span class="line">    <span class="keyword">switch</span> (ctx-&gt;sk-&gt;family) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_IPV4</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// ipv4</span></span><br><span class="line">        set_ipv4(p.dip, ctx-&gt;sk-&gt;src_ip4);</span><br><span class="line">        set_ipv4(p.sip, ctx-&gt;sk-&gt;dst_ip4);</span><br><span class="line">        origin = bpf_map_lookup_elem(&amp;pair_original_dst, &amp;p);</span><br><span class="line">        <span class="keyword">if</span> (origin) &#123;</span><br><span class="line">            <span class="comment">// rewrite original_dst</span></span><br><span class="line">            ctx-&gt;optlen = (__s32)<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">void</span> *)((<span class="keyword">struct</span> sockaddr_in *)ctx-&gt;optval + <span class="number">1</span>) &gt;</span><br><span class="line">                ctx-&gt;optval_end) &#123;</span><br><span class="line">                printk(<span class="string">&quot;optname: %d: invalid getsockopt optval&quot;</span>, ctx-&gt;optname);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ctx-&gt;retval = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span> =</span> &#123;</span><br><span class="line">                .sin_family = ctx-&gt;sk-&gt;family,</span><br><span class="line">                .sin_addr.s_addr = get_ipv4(origin-&gt;ip),</span><br><span class="line">                .sin_port = origin-&gt;port,</span><br><span class="line">            &#125;;</span><br><span class="line">            *(<span class="keyword">struct</span> sockaddr_in *)ctx-&gt;optval = sa;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Redirect-阶段"><a class="header-anchor" href="#Redirect-阶段">¶</a>Redirect 阶段</h6>
<p>通过标准的 socketmap 就好了，修改地址即可完成重定向</p>
<figure class="highlight c"><figcaption><span>sk_msg</span><a href="https://github.com/merbridge/merbridge/blob/7fd1fddb7e3f64f125dafb9bb75059ed5341408d/bpf/mb_redir.c#L21-L49">github</a></figcaption><table><tr><td class="code"><pre><span class="line">__section(<span class="string">&quot;sk_msg&quot;</span>) <span class="type">int</span> <span class="title function_">mb_msg_redir</span><span class="params">(<span class="keyword">struct</span> sk_msg_md *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pair</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    p.dport = bpf_htons(msg-&gt;local_port);</span><br><span class="line">    p.sport = msg-&gt;remote_port &gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;family) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_IPV4</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// ipv4</span></span><br><span class="line">        set_ipv4(p.dip, msg-&gt;local_ip4);</span><br><span class="line">        set_ipv4(p.sip, msg-&gt;remote_ip4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> ret = bpf_msg_redirect_hash(msg, &amp;sock_pair_map, &amp;p, BPF_F_INGRESS);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        debugf(<span class="string">&quot;redirect %d bytes with eBPF successfully&quot;</span>, msg-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Inbound-流量"><a class="header-anchor" href="#Inbound-流量">¶</a>Inbound 流量</h3>
<p>和 <code>Outbound</code> 类似，不做多阐述，可以参考<a href="https://blog.daocloud.io/7949.html">官博</a></p>
<h3 id="同节点加速"><a class="header-anchor" href="#同节点加速">¶</a>同节点加速</h3>
<p>同集群加速的大部分逻辑也在之前 <code>Connect</code> 中，<a href="https://github.com/merbridge/merbridge/blob/cc805614079c74dfc87dae9cc3b935ed63a0b176/bpf/mb_connect.c#L193-L276">源码</a></p>
<ol>
<li>因为在宿主机上有 CNI POD，来维护当前 Node POD IPS，并且维护在 <code>local_pod_ips</code> 中</li>
<li>根据 <code>dst_ip</code> 查询 <code>local_pod_ips</code> 是否包含，不包含直接 ret，走外部流量路径</li>
<li>如果有的话，经过一些检查，将转发端口修改 <code>IN_REDIRECT_PORT</code> （inbound端口）即可（没有这个端口的话，就不是 sidecar 的目标地址，使用用户的端口即可）</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from envoy to others</span></span><br><span class="line">__u32 _dst_ip[<span class="number">4</span>];</span><br><span class="line">set_ipv4(_dst_ip, dst_ip);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pod_config</span> *<span class="title">pod</span> =</span> bpf_map_lookup_elem(&amp;local_pod_ips, _dst_ip);</span><br><span class="line"><span class="keyword">if</span> (!pod) &#123;</span><br><span class="line">    <span class="comment">// dst ip is not in this node, bypass</span></span><br><span class="line">    debugf(<span class="string">&quot;dest ip: %pI4 not in this node, bypass&quot;</span>, &amp;dst_ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (curr_pod_ip) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curr_pod_ip != dst_ip) &#123;</span><br><span class="line">        <span class="comment">// call other pod, need redirect port.</span></span><br><span class="line">        <span class="type">int</span> exclude = <span class="number">0</span>;</span><br><span class="line">        IS_EXCLUDE_PORT(pod-&gt;exclude_in_ports, ctx-&gt;user_port,</span><br><span class="line">                        &amp;exclude);</span><br><span class="line">        <span class="keyword">if</span> (exclude) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;ignored dest port by exclude_in_ports, ip: %pI4, &quot;</span></span><br><span class="line">                   <span class="string">&quot;port: %d&quot;</span>,</span><br><span class="line">                   &amp;dst_ip, bpf_htons(ctx-&gt;user_port));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> include = <span class="number">0</span>;</span><br><span class="line">        IS_INCLUDE_PORT(pod-&gt;include_in_ports, ctx-&gt;user_port,</span><br><span class="line">                        &amp;include);</span><br><span class="line">        <span class="keyword">if</span> (!include) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;ignored dest port by include_in_ports, ip: %pI4, &quot;</span></span><br><span class="line">                   <span class="string">&quot;port: %d&quot;</span>,</span><br><span class="line">                   &amp;dst_ip, bpf_htons(ctx-&gt;user_port));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx-&gt;user_port = bpf_htons(IN_REDIRECT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    origin.flags |= <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 兼容老模式</span></span><br><span class="line">&#125;</span><br><span class="line">__u64 cookie = bpf_get_socket_cookie_addr(ctx);</span><br><span class="line">debugf(<span class="string">&quot;call from sidecar container: cookie: %d, ip: %pI4, port: %d&quot;</span>,</span><br><span class="line">       cookie, &amp;dst_ip, bpf_htons(ctx-&gt;user_port));</span><br><span class="line"><span class="keyword">if</span> (bpf_map_update_elem(&amp;cookie_original_dst, &amp;cookie, &amp;origin,</span><br><span class="line">                        BPF_NOEXIST)) &#123;</span><br><span class="line">    printk(<span class="string">&quot;update cookie origin failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最终效果"><a class="header-anchor" href="#最终效果">¶</a>最终效果</h3>
<h4 id="IPtables-模型"><a class="header-anchor" href="#IPtables-模型">¶</a>IPtables 模型</h4>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2023/202305171140364.png" alt=""></p>
<h4 id="eBPF-模式-跨集群"><a class="header-anchor" href="#eBPF-模式-跨集群">¶</a>eBPF 模式(跨集群)</h4>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2023/202305171141222.png" alt=""></p>
<h4 id="eBPF-模式-同集群"><a class="header-anchor" href="#eBPF-模式-同集群">¶</a>eBPF 模式(同集群)</h4>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2023/202305171141016.png" alt=""></p>
<h2 id="Next"><a class="header-anchor" href="#Next">¶</a>Next</h2>
<p>基于 eBPF 的扩展性，社区也在积极的探索新的功能，比如 TC (流量控制)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = netns.Do(<span class="function"><span class="keyword">func</span><span class="params">(_ ns.NetNS)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// listen on 39807</span></span><br><span class="line">    <span class="keyword">if</span> err := s.buildListener(netns.Path()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// attach tc to the device</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args.IfName) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.attachTC(netns.Path(), args.IfName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// interface not specified, should not happen?</span></span><br><span class="line">    ifaces, _ := net.Interfaces()</span><br><span class="line">    <span class="keyword">for</span> _, iface := <span class="keyword">range</span> ifaces &#123;</span><br><span class="line">        <span class="keyword">if</span> (iface.Flags&amp;net.FlagLoopback) == <span class="number">0</span> &amp;&amp; (iface.Flags&amp;net.FlagUp) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s.attachTC(netns.Path(), iface.Name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;device not found for %s&quot;</span>, args.Netns)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="http://blog.daocloud.io/7949.html">使用一行代码：开启eBPF，代替iptables，加速Istio</a></li>
<li><a href="https://arthurchiao.art/blog/socket-acceleration-with-ebpf-zh/">[译] 利用 ebpf sockmap/redirection 提升 socket 性能（2020）</a></li>
<li><a href="https://www.techtarget.com/searchitoperations/tip/Explore-network-plugins-for-Kubernetes-CNI-explained">https://www.techtarget.com/searchitoperations/tip/Explore-network-plugins-for-Kubernetes-CNI-explained</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>istio</category>
        <category>merbridge</category>
      </categories>
      <tags>
        <tag>istio</tag>
        <tag>merbridge</tag>
      </tags>
  </entry>
  <entry>
    <title>Isito の Pilot 组件</title>
    <url>/2020/10/28/networking/istio/isito-pilot/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/10/29/Nhq9u.png" alt="Nhq9u.png"></p>
<blockquote>
<p>本文基于 istio: release-1.7</p>
</blockquote>
<span id="more"></span>
<h2 id="Pre"><a class="header-anchor" href="#Pre">¶</a>Pre</h2>
<p><img src="https://s3.jpg.cm/2020/10/28/NzdPt.png" alt="NzdPt.png"></p>
<p>对于 <code>istio</code> 架构来说，包含了较多的组件其中包含了 <code>Pilot</code> <code>Citadel</code> <code>Galley</code> 等组件，全部置于一个单一的 <code>isitod</code> 镜像中，我们今天就来看看最重要的 <code>Poilot</code> 组件。</p>
<blockquote>
<p>Individual Istio components like <em><strong>service discovery (Pilot)</strong></em>, configuration (Galley), certificate generation (Citadel) and extensibility (Mixer)</p>
</blockquote>
<h2 id="Pliot"><a class="header-anchor" href="#Pliot">¶</a>Pliot</h2>
<p>对于 <code>Poliot</code> 来说，我们其实有两个，第一个是 <code>Poilot Discovery</code> 作为控制面组件，另外一个是 <code>Poilot Agent</code> 在数据面对于 <code>Envoy</code> 进行配置的组件。</p>
<p><img src="https://s3.jpg.cm/2020/10/29/NhRkz.png" alt="NhRkz.png"></p>
<hr>
<p>对于 <code>Pilot</code> 来说，做的事情也很简单</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201118183737.png" alt=""></p>
<p>将 <code>istio crd</code> 的配置信息和 <code>kube</code> 的各种服务信息进行整合，然后通过 <code>xds</code> 推送给 <code>Envoy</code></p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201118183803.png" alt=""></p>
<h3 id="Discovery-Server"><a class="header-anchor" href="#Discovery-Server">¶</a>Discovery Server</h3>
<p>函数的入口处为 <code>pilot/pkg/bootstrap/server.go:Start</code> 我们实际上会启动两个不同的 <code>Server</code></p>
<ul>
<li><code>grpcServer</code>: 负责和 Galley CDS CA 通讯</li>
<li><code>httpServer</code>: 处理 readiness 的请求</li>
</ul>
<p><code>pilot-discovery</code> 扮演服务注册中心、<code>istio</code> 控制平面到 <code>Envoy</code> 之间的桥梁作用。<code>Pilot-Discovery</code> 的主要功能包括：</p>
<ul>
<li>监控服务注册中心（如Kubernetes）的服务注册情况。在Kubernetes环境下，会监控service、endpoint、pod、node等资源信息。</li>
<li>监控istio控制面信息变化，在Kubernetes环境下，会监控包括RouteRule、VirtualService、Gateway、EgressRule、ServiceEntry等以Kubernetes CRD形式存在的istio控制面配置信息。</li>
<li>将上述两类信息合并组合为Envoy可以理解的（即遵循Envoy data plane api的）配置信息，并将这些信息以gRPC协议提供给Envoy</li>
</ul>
<p><img src="https://s3.jpg.cm/2020/10/29/NhnQG.png" alt="NhnQG.png"></p>
<h3 id="Service-Registry"><a class="header-anchor" href="#Service-Registry">¶</a>Service Registry</h3>
<p><code>Poilot</code> 为了支持多种基础设施，因此抽象了一个对象叫 <code>serviceregistry</code>，我们从源码中可以发现至少支持了 <code>consul</code> <code>kube</code> <code>mcp</code> <code>mock</code> <code>memory</code>  这几类基础设施。</p>
<p>在作为常见的 <code>Kube</code> 的支持中，我们在这里 <code>pilot/pkg/serviceregistry/kube/register.go:RegisterEndpoint</code> 注册我们的 <code>Kube</code> 控制节点，我们知道当使用 <code>CRD</code> 的时候，对于 <code>CRD</code> 功能的翻译需要 <code>CRD Controller</code> 进行实现，因此我们的实现点在于 <code>pilot/pkg/serviceregistry/kube/controller/controller.go:NewController</code></p>
<p>在 <code>NewController</code> 之中，我们注册大量的对于 <code>Kube</code> 资源处理的回调函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于 Endpoints 的处理</span></span><br><span class="line">c.endpoints = newEndpointsController(c, kubeClient.KubeInformer().Core().V1().Endpoints())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 Nodes 的处理</span></span><br><span class="line">registerHandlers(c.nodeInformer, c.queue, <span class="string">&quot;Nodes&quot;</span>, c.onNodeEvent, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 Pod 的处理</span></span><br><span class="line">registerHandlers(c.pods.informer, c.queue, <span class="string">&quot;Pods&quot;</span>, c.pods.onEvent, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Controller"><a class="header-anchor" href="#Controller">¶</a>Controller</h3>
<h4 id="CRD-Resource-Controller"><a class="header-anchor" href="#CRD-Resource-Controller">¶</a>CRD Resource Controller</h4>
<p>在 <code>Kube</code> 的 <code>Service Registry</code> 模式下，支持多种自定义资源来操作我们的 <code>isito</code></p>
<ul>
<li>Virtualservice：用于定义路由规则，如根据来源或 Header 制定规则，或在不同服务版本之间分拆流量。</li>
<li>DestinationRule：定义目的服务的配置策略以及可路由子集。策略包括断路器、负载均衡以及 TLS 等。</li>
<li>ServiceEntry：可以使用ServiceEntry向Istio中加入附加的服务条目，以使网格内可以向istio 服务网格之外的服务发出请求。</li>
<li>Gateway：为网格配置网关，以允许一个服务可以被网格外部访问。</li>
<li>EnvoyFilter：可以为Envoy配置过滤器。由于Envoy已经支持Lua过滤器，因此可以通过EnvoyFilter启用Lua过滤器，动态改变Envoy的过滤链行为。我之前一直在考虑如何才能动态扩展Envoy的能力，EnvoyFilter提供了很灵活的扩展性。</li>
<li>Sidecar：缺省情况下，Pilot将会把和Envoy Sidecar所在namespace的所有services的相关配置，包括inbound和outbound listenter, cluster, route等，都下发给Enovy。使用Sidecar可以对Pilot向Envoy Sidcar下发的配置进行更细粒度的调整，例如只向其下发该Sidecar 所在服务需要访问的那些外部服务的相关outbound配置。</li>
</ul>
<blockquote>
<p>这一部分代码都在 <code>pilot/pkg/config/kube</code> 中</p>
</blockquote>
<h4 id="Kube-Resource-Controller"><a class="header-anchor" href="#Kube-Resource-Controller">¶</a>Kube Resource Controller</h4>
<p>显然我们需要监听 <code>Pods</code> <code>Services</code> <code>Namespaces</code> 等信息</p>
<blockquote>
<p>这一部分代码都在 <code>pilot/pkg/serviceregistry/kube/controller/</code> 中</p>
</blockquote>
<h3 id="Push-Context"><a class="header-anchor" href="#Push-Context">¶</a>Push Context</h3>
<p>上述的处理的 <code>callback</code> 大多数都会转至 <code>push_context.go</code> 中进行处理 <code>PushContext</code> 会记录我们操作的更新状态等信息。</p>
<h3 id="Xds-Updater"><a class="header-anchor" href="#Xds-Updater">¶</a>Xds Updater</h3>
<p>而对于所有的状态更新，都是通过 <code>XDSUpdater</code> 进行更新。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">	client kubernetes.Interface</span><br><span class="line"></span><br><span class="line">	nodeInformer cache.SharedIndexInformer</span><br><span class="line">	nodeLister   listerv1.NodeLister</span><br><span class="line"></span><br><span class="line">	pods *PodCache</span><br><span class="line"></span><br><span class="line">	metrics         model.Metrics</span><br><span class="line">    networksWatcher mesh.NetworksWatcher</span><br><span class="line">    <span class="comment">// 通过 XDSUpdater 和下游进行通讯</span></span><br><span class="line">	xdsUpdater      model.XDSUpdater</span><br><span class="line">	domainSuffix    <span class="type">string</span></span><br><span class="line">	clusterID       <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子，当我们的 <code>Pod</code> 的 <code>IP</code> 进行更新的时候，我们会触发</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *PodCache)</span></span> proxyUpdates(ip <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> pc.c != <span class="literal">nil</span> &amp;&amp; pc.c.xdsUpdater != <span class="literal">nil</span> &#123;</span><br><span class="line">		pc.c.xdsUpdater.ProxyUpdate(pc.c.clusterID, ip)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以发现直接调用了 <code>xdsUpdater.ProxyUpdate</code></p>
<figure class="highlight go"><figcaption><span>xdsUpdater.ProxyUpdate</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span></span> ProxyUpdate(clusterID, ip <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> connection *Connection</span><br><span class="line">    </span><br><span class="line">	s.pushQueue.Enqueue(connection, &amp;model.PushRequest&#123;</span><br><span class="line">		Full:   <span class="literal">true</span>,</span><br><span class="line">		Push:   s.globalPushContext(),</span><br><span class="line">		Start:  time.Now(),</span><br><span class="line">		Reason: []model.TriggerReason&#123;model.ProxyUpdate&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将这一次的变化 <code>Push</code> 到我们的 <code>PushQueue</code> 中。</p>
<p>而最终的消费者在一层层的调用中我们可以定位至 <code>pilot/pkg/xds/ads.go:pushConnection</code> 中，具体逻辑不做展开。</p>
<h3 id="Multicluster"><a class="header-anchor" href="#Multicluster">¶</a>Multicluster</h3>
<p>多集群的设计相对简单，我们只需要将本来的逻辑隔离 +1 配置即可。比如在 <code>AddMemberCluster</code> 我们只需要将 <code>kube client</code> 和 <code>cluster id</code> 传入，我们就可以在第二个集群中创建我们的对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Multicluster)</span></span> AddMemberCluster(clients kubelib.Client, clusterID <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// stopCh to stop controller created here when cluster removed.</span></span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> remoteKubeController kubeController</span><br><span class="line">	remoteKubeController.stopCh = stopCh</span><br><span class="line">	m.m.Lock()</span><br><span class="line">	remoteKubeController.Controller = kubectl</span><br><span class="line">	m.serviceController.AddRegistry(kubectl)</span><br><span class="line"></span><br><span class="line">	m.remoteKubeControllers[clusterID] = &amp;remoteKubeController</span><br><span class="line">	m.m.Unlock()</span><br><span class="line"></span><br><span class="line">	_ = kubectl.AppendServiceHandler(<span class="function"><span class="keyword">func</span><span class="params">(svc *model.Service, ev model.Event)</span></span> &#123; m.updateHandler(svc) &#125;)</span><br><span class="line"></span><br><span class="line">	clients.RunAndWait(stopCh)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Poliot-流程分析"><a class="header-anchor" href="#Poliot-流程分析">¶</a>Poliot 流程分析</h2>
<p>上面看了一堆实现，我们还是看下 <code>Bootstrap</code> 的流程，入口处于 <code>pilot/cmd/pilot-discovery/main.go</code> 中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">discoveryServer, err := bootstrap.NewServer(serverArgs)</span><br></pre></td></tr></table></figure>
<h3 id="Server-Def"><a class="header-anchor" href="#Server-Def">¶</a>Server Def</h3>
<p>我们往往从 <code>Server</code> 的定义中就可以看出那些重量级的实现。</p>
<figure class="highlight go"><figcaption><span>pilot/pkg/bootstrap/server.go:Server</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 包含的 xds 服务</span></span><br><span class="line">	EnvoyXdsServer *xds.DiscoveryServer</span><br><span class="line">	<span class="comment">// 包含了 kube 的一些资源的监控</span></span><br><span class="line">	environment *model.Environment</span><br><span class="line">	<span class="comment">// 多集群的配置</span></span><br><span class="line">	multicluster   *kubecontroller.Multicluster</span><br><span class="line">	<span class="comment">// istio 配置 Controller</span></span><br><span class="line">	configController  model.ConfigStoreCache</span><br><span class="line">	<span class="comment">// istio 配置缓存</span></span><br><span class="line">	ConfigStores      []model.ConfigStoreCache</span><br><span class="line">	<span class="comment">// service entry 配置存储</span></span><br><span class="line">	serviceEntryStore *serviceentry.ServiceEntryStore</span><br><span class="line">	<span class="comment">// 监听文件的变化</span></span><br><span class="line">	fileWatcher filewatcher.FileWatcher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保留了一些重点，我们可以看出来那两部分数据来源就是在 <code>configController</code> 和 <code>environment</code> 中</p>
<h3 id="Bootstrap"><a class="header-anchor" href="#Bootstrap">¶</a>Bootstrap</h3>
<p>在 <code>NewServer</code> 中一开始就申明了最重要的对象 <code>model.Environment</code></p>
<figure class="highlight go"><figcaption><span>NewServer</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(args *PilotArgs)</span></span> (*Server, <span class="type">error</span>) &#123;</span><br><span class="line">	e := &amp;model.Environment&#123;</span><br><span class="line">		ServiceDiscovery: aggregate.NewController(),</span><br><span class="line">		PushContext:      model.NewPushContext(),</span><br><span class="line">		DomainSuffix:     args.RegistryOptions.KubeOptions.DomainSuffix,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s := &amp;Server&#123;</span><br><span class="line">		clusterID:       getClusterID(args),</span><br><span class="line">		environment:     e,</span><br><span class="line">		EnvoyXdsServer:  xds.NewDiscoveryServer(e, args.Plugins),</span><br><span class="line">		fileWatcher:     filewatcher.NewWatcher(),</span><br><span class="line">		httpMux:         http.NewServeMux(),</span><br><span class="line">		readinessProbes: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]readinessProbe),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>model.Environment</code> 里面有三个对象，都很重要：</p>
<ul>
<li><code>ServiceDiscovery</code>: 代表了对于此 <code>Kube</code> 集群的所有 <code>Controller</code></li>
<li><code>PushContext</code>: 包含了当前系统的 <code>Metris</code> 指标的信息，推送给 <code>prom</code></li>
<li><code>DomainSuffix</code>: 此集群的域名后缀</li>
</ul>
<p><code>Server</code> 中包含了除此之外的一些辅助能力，比如 <code>fileWatcher</code> 来观察配置文件的变化，<code>EnvoyXdsServer</code> 向 <code>Sidecar</code> 下发数据等</p>
<p>紧挨着比较重要的代码就是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := s.initControllers(args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们初始化所有的对 <code>CRD</code> 的控制对象。</p>
<p>然后就是一大票的对象初始化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">wh, err := s.initSidecarInjector(args)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;error initializing sidecar injector: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := s.initConfigValidation(args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;error initializing config validator: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Used for readiness, monitoring and debug handlers.</span></span><br><span class="line"><span class="keyword">if</span> err := s.initIstiodAdminServer(args, wh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;error initializing debug server: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This should be called only after controllers are initialized.</span></span><br><span class="line"><span class="keyword">if</span> err := s.initRegistryEventHandlers(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;error initializing handlers: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := s.initDiscoveryService(args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;error initializing discovery service: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Run"><a class="header-anchor" href="#Run">¶</a>Run</h3>
<p>在我们初始化完成之后，在 <code>main</code> 函数中，我们开始执行我们真实的逻辑</p>
<figure class="highlight go"><figcaption><span>pilot/pkg/bootstrap/server.go:Start</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Start(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	log.Infof(<span class="string">&quot;Staring Istiod Server with primary cluster %s&quot;</span>, s.clusterID)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动所有的组件</span></span><br><span class="line">	<span class="keyword">for</span> _, fn := <span class="keyword">range</span> s.startFuncs &#123;</span><br><span class="line">		<span class="keyword">if</span> err := fn(stop); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// grpcServer is shared by Galley, CA, XDS - must Serve at the end, but before &#x27;wait&#x27;</span></span><br><span class="line">	<span class="comment">// 启动 GRPC 服务，这个是被多个组件共享的，CA XDS Galley 等</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		log.Infof(<span class="string">&quot;starting gRPC discovery service at %s&quot;</span>, s.GRPCListener.Addr())</span><br><span class="line">		<span class="keyword">if</span> err := s.grpcServer.Serve(s.GRPCListener); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Warna(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// At this point we are ready - start Http Listener so that it can respond to readiness events.</span></span><br><span class="line">	<span class="comment">// 启动 HTTP 服务，处理 readiness</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		log.Infof(<span class="string">&quot;starting Http service at %s&quot;</span>, s.HTTPListener.Addr())</span><br><span class="line">		<span class="keyword">if</span> err := s.httpServer.Serve(s.HTTPListener); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Warna(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>s.startFuncs</code> 中储存着我们所有的 <code>start func</code> 这里我们启动我们所有的需要在启动的组件。比如在 <code>XDS</code> 服务的启动函数是定义在如下</p>
<figure class="highlight go"><figcaption><span>pilot/pkg/bootstrap/server.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> initDiscoveryService(args *PilotArgs) <span class="type">error</span> &#123;</span><br><span class="line">	log.Infof(<span class="string">&quot;starting discovery service&quot;</span>)</span><br><span class="line">	<span class="comment">// Implement EnvoyXdsServer grace shutdown</span></span><br><span class="line">	s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		s.EnvoyXdsServer.Start(stop)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此对于我们后需要，我们要查看各种实现都需要通过不同组件的 <code>Start</code> 来辨别。</p>
<h4 id="监控变化"><a class="header-anchor" href="#监控变化">¶</a>监控变化</h4>
<p>启动的流程不算复杂，我们尝试分析一个常规的场景。</p>
<p><img src="https://s3.jpg.cm/2020/11/13/YA6lD.png" alt="YA6lD.png"></p>
<p>我们监听一个 <code>POD</code> 被删除之后，我们 <code>XDS</code> 应该可以获得监听的变化。</p>
<p>根据 <code>Isito</code> 系统的构成，显然我们可以知道的应该会涉及到 <code>Controller</code> 监听到变化之后的 <code>Action</code>，而这个 <code>Action</code> 应该就是如何将数据下发到 <code>Sidecar</code> 中。</p>
<h5 id="Controller-v2"><a class="header-anchor" href="#Controller-v2">¶</a>Controller</h5>
<p>在 <code>Init</code> 的抽函数中，我们很容易就发现了 <code>PodController</code> 的位置</p>
<figure class="highlight go"><figcaption><span>pilot/pkg/serviceregistry/kube/controller/controller.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(kubeClient kubelib.Client, options Options)</span></span> *Controller &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	c.serviceInformer = kubeClient.KubeInformer().Core().V1().Services().Informer()</span><br><span class="line">	c.serviceLister = kubeClient.KubeInformer().Core().V1().Services().Lister()</span><br><span class="line">	registerHandlers(c.serviceInformer, c.queue, <span class="string">&quot;Services&quot;</span>, c.onServiceEvent, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	c.nodeInformer = kubeClient.KubeInformer().Core().V1().Nodes().Informer()</span><br><span class="line">	c.nodeLister = kubeClient.KubeInformer().Core().V1().Nodes().Lister()</span><br><span class="line">	registerHandlers(c.nodeInformer, c.queue, <span class="string">&quot;Nodes&quot;</span>, c.onNodeEvent, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	c.pods = newPodCache(c, kubeClient.KubeInformer().Core().V1().Pods(), <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		item, exists, err := c.endpoints.getInformer().GetStore().GetByKey(key)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Debugf(<span class="string">&quot;Endpoint %v lookup failed with error %v, skipping stale endpoint&quot;</span>, key, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !exists &#123;</span><br><span class="line">			log.Debugf(<span class="string">&quot;Endpoint %v not found, skipping stale endpoint&quot;</span>, key)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.queue.Push(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> c.endpoints.onEvent(item, model.EventUpdate)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	registerHandlers(c.pods.informer, c.queue, <span class="string">&quot;Pods&quot;</span>, c.pods.onEvent, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构建 <code>newPodCache</code> 时候，显然我们第一次还是需要将所有的 <code>POD</code> 先取出来，然后之后处理我们的回调函数来处理，我们的重心还是来处理 <code>registerHandlers</code> 的事件。</p>
<p>在 <code>registerHandlers</code> 函数中，我们可以看到数据的变化对于系统影响</p>
<figure class="highlight go"><figcaption><span>registerHandlers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerHandlers</span><span class="params">(informer cache.SharedIndexInformer, q queue.Instance, otype <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	handler <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;, model.Event)</span></span> <span class="type">error</span>, filter FilterOutFunc) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为 informer 增加 Callback</span></span><br><span class="line">	informer.AddEventHandler(</span><br><span class="line">		cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">			AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">				<span class="comment">//...</span></span><br><span class="line">			&#125;,</span><br><span class="line">			UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">				<span class="comment">//...</span></span><br><span class="line">			&#125;,</span><br><span class="line">			DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">				incrementEvent(otype, <span class="string">&quot;delete&quot;</span>) <span class="comment">// BreakPoint</span></span><br><span class="line">				q.Push(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> handler(obj, model.EventDelete)</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们就将 <code>informer</code> 的数据转化成 <code>istio</code> 的数据结构，然后 <code>push</code> 到 <code>Quene</code></p>
<p><img src="https://s3.jpg.cm/2020/11/13/YAfy5.png" alt="YAfy5.png"></p>
<p>为了验证我们的想法，我们直接在 <code>incrementEvent(otype, &quot;delete&quot;)</code> 加上我们的 <code>BreakPoint</code></p>
<figure class="highlight bash"><figcaption><span>delete a pod</span></figcaption><table><tr><td class="code"><pre><span class="line">kubectl delete pod tcp-echo-v1-7dd5c5dcfb-mxs77</span><br></pre></td></tr></table></figure>
<p>然后果然在我们这里看到 <code>BreakPoint</code> 的对象元数据。</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20201113161439.png" alt=""></p>
<p>在 <code>Queue</code> 的数据如何被消费，实则是一个定时的 <code>Task</code>，如下声明</p>
<figure class="highlight go"><figcaption><span>pkg/queue/instance.go:Run</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queueImpl)</span></span> Run(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		q.cond.L.Lock() <span class="comment">// 上锁</span></span><br><span class="line">		<span class="keyword">for</span> !q.closing &amp;&amp; <span class="built_in">len</span>(q.tasks) == <span class="number">0</span> &#123; <span class="comment">// 没有任务继续 Wait</span></span><br><span class="line">			q.cond.Wait()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> task Task</span><br><span class="line">		task, q.tasks = q.tasks[<span class="number">0</span>], q.tasks[<span class="number">1</span>:] <span class="comment">// 获得需要运行的 Task</span></span><br><span class="line">		q.cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := task(); err != <span class="literal">nil</span> &#123; <span class="comment">// 执行操作</span></span><br><span class="line">			log.Infof(<span class="string">&quot;Work item handle failed (%v), retry after delay %v&quot;</span>, err, q.delay)</span><br><span class="line">			time.AfterFunc(q.delay, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 如果错误就延迟执行</span></span><br><span class="line">				q.Push(task)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.jpg.cm/2020/11/13/YAayp.png" alt="YAayp.png"></p>
<p>而我们真实的 <code>Handler</code> 实则是传递进来的，因此真正的代码是在 <code>PodCache.onEvent</code> 中</p>
<figure class="highlight go"><figcaption><span>pilot/pkg/serviceregistry/kube/controller/pod.go:onEvent</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *PodCache)</span></span> onEvent(curr <span class="keyword">interface</span>&#123;&#125;, ev model.Event) <span class="type">error</span> &#123;</span><br><span class="line">	pc.Lock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ip) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		key := kube.KeyFunc(pod.Name, pod.Namespace)</span><br><span class="line">		<span class="keyword">switch</span> ev &#123;</span><br><span class="line">		<span class="keyword">case</span> model.EventAdd:</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">		<span class="keyword">case</span> model.EventUpdate:</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">		<span class="keyword">case</span> model.EventDelete:</span><br><span class="line">			<span class="comment">// delete only if this pod was in the cache</span></span><br><span class="line">			<span class="comment">// 我们根据 IP 删除一个 POD 从缓存中</span></span><br><span class="line">			<span class="keyword">if</span> pc.podsByIP[ip] == key &#123;</span><br><span class="line">				pc.deleteIP(ip)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// fire instance handles for workload</span></span><br><span class="line">		<span class="comment">// 我们修改了 POD，我们显然需要更新 Envoy 的 Endpoint，这里因为我们不维护 Pod 的 IP，还是通过 workloadHandlers 来处理</span></span><br><span class="line">		<span class="keyword">for</span> _, handler := <span class="keyword">range</span> pc.c.workloadHandlers &#123;</span><br><span class="line">			ep := NewEndpointBuilder(pc.c, pod).buildIstioEndpoint(ip, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">			handler(&amp;model.WorkloadInstance&#123;</span><br><span class="line">				Name:      pod.Name,</span><br><span class="line">				Namespace: pod.Namespace,</span><br><span class="line">				Endpoint:  ep,</span><br><span class="line">				PortMap:   getPortMap(pod),</span><br><span class="line">			&#125;, ev)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>NewEndpointBuilder(pc.c, pod).buildIstioEndpoint(ip, 0, &quot;&quot;)</code> 中我们将其翻译成 <code>Endpoint</code>，而这个 <code>Endpoint</code> 是需要下发到 <code>Sidecar</code> 中的，那处理的逻辑肯定又在 <code>handler</code> 中的。一路小跳到</p>
<figure class="highlight go"><figcaption><span>pilot/pkg/serviceregistry/serviceentry/servicediscovery.go:WorkloadInstanceHandler</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceEntryStore)</span></span> WorkloadInstanceHandler(si *model.WorkloadInstance, event model.Event) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据 Kind Name Namespace 生成唯一的 Key</span></span><br><span class="line">	key := configKey&#123;</span><br><span class="line">		kind:      workloadInstanceConfigType,</span><br><span class="line">		name:      si.Name,</span><br><span class="line">		namespace: si.Namespace,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> event &#123;</span><br><span class="line">	<span class="keyword">case</span> model.EventDelete:</span><br><span class="line">		<span class="comment">// ... 处理 Delete </span></span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// add or update</span></span><br><span class="line">		<span class="comment">// ... 忽略了 Update 的逻辑</span></span><br><span class="line">		<span class="comment">// 这里我们将信息储存到 ServiceEntryStore 中</span></span><br><span class="line">		s.workloadInstancesByIP[si.Endpoint.Address] = si</span><br><span class="line">		s.workloadInstancesIPsByName[k] = si.Endpoint.Address</span><br><span class="line">	&#125;</span><br><span class="line">	entries := s.seWithSelectorByNamespace[si.Namespace]</span><br><span class="line">	instances := []*model.ServiceInstance&#123;&#125;</span><br><span class="line">	instancesDeleted := []*model.ServiceInstance&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这里处理 entries，也就是 ServicesWithEntry，这里需要处理其实是动态的流量均衡</span></span><br><span class="line">	<span class="keyword">for</span> _, se := <span class="keyword">range</span> entries &#123;</span><br><span class="line">		workloadLabels := labels.Collection&#123;si.Endpoint.Labels&#125;</span><br><span class="line">		instance := convertWorkloadInstanceToServiceInstance(si.Endpoint, se.services, se.entry)</span><br><span class="line">		instances = <span class="built_in">append</span>(instances, instance...)</span><br><span class="line">		<span class="keyword">if</span> addressToDelete != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="comment">// ... Delete</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> event != model.EventDelete &#123;</span><br><span class="line">		s.updateExistingInstances(key, instances)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		s.deleteExistingInstances(key, instances)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// eds 更新</span></span><br><span class="line">	s.edsUpdate(instances)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实看到这里，我们发现了我们在 <code>ServiceEntryStore</code> 中维护了系统对于 <code>ServiceEntry</code> 的状态维护。</p>
<p>那如果我们删除了 <code>Service</code> 呢？那显然在 <code>endpointController</code> 找我们想要的对象</p>
<figure class="highlight go"><figcaption><span>pilot/pkg/serviceregistry/kube/controller/endpointcontroller.go:processEndpointEvent</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processEndpointEvent</span><span class="params">(c *Controller, epc kubeEndpointsController, name <span class="type">string</span>, namespace <span class="type">string</span>, event model.Event, ep <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 在这里我们就直接需要更新 XDS 协议中的 EDS</span></span><br><span class="line">	updateEDS(c, epc, ep, event)</span><br><span class="line">	<span class="keyword">if</span> features.EnableHeadlessService &#123;</span><br><span class="line">		<span class="comment">//....</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 <code>updateEDS</code> 中去更新 <code>XDS</code> 的相关信息。而最终我们回去调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_ = c.xdsUpdater.EDSUpdate(c.clusterID, <span class="type">string</span>(host), ns, endpoints)</span><br></pre></td></tr></table></figure>
<p>来完成我的 <code>XDS</code> 的更新。</p>
<h5 id="CRD-Controller"><a class="header-anchor" href="#CRD-Controller">¶</a>CRD Controller</h5>
<p>对于 <code>CRD</code> 资源的定义和操作都置于 <code>pilot/pkg/config/kube/crdclient</code> 中，在 <code>kube client</code> 做了一层缓冲来处理</p>
<figure class="highlight go"><figcaption><span>cacheHandler</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> cacheHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	client   *Client <span class="comment">// CRD Client</span></span><br><span class="line">	handlers []<span class="function"><span class="keyword">func</span><span class="params">(model.Config, model.Config, model.Event)</span></span>  <span class="comment">// 处理不同配置的 Handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在触发了 <code>CRD</code> 变化的时候会回调 <code>onEvent</code> 函数</p>
<figure class="highlight go"><figcaption><span>onEvent</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *cacheHandler)</span></span> onEvent(old <span class="keyword">interface</span>&#123;&#125;, curr <span class="keyword">interface</span>&#123;&#125;, event model.Event) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">//... 略部分代码</span></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> h.handlers &#123;</span><br><span class="line">		f(oldConfig, currConfig, event)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Updater"><a class="header-anchor" href="#Updater">¶</a>Updater</h3>
<p>更新 <code>XDS</code> 也不是一件很简单的事情，我们需要区分，什么时候时候可以增量更新，而什么时候只需要更新一部分。</p>
<h4 id="EDSUpdate"><a class="header-anchor" href="#EDSUpdate">¶</a>EDSUpdate</h4>
<p>如果仅仅是比如 <code>services</code> 的资源产生了变化，我们就可以直接更新 <code>eds</code>，比如在上文中，我们删除另一个 <code>services</code> 就会触发 <code>EDSUpdate</code> 函数</p>
<figure class="highlight go"><figcaption><span>EDSUpdate</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span></span> EDSUpdate(clusterID, serviceName <span class="type">string</span>, namespace <span class="type">string</span>,</span><br><span class="line">	istioEndpoints []*model.IstioEndpoint) <span class="type">error</span> &#123;</span><br><span class="line">	inboundEDSUpdates.Increment()</span><br><span class="line">	<span class="comment">// FullPush 来决定是否完全的更新</span></span><br><span class="line">	fp := s.edsUpdate(clusterID, serviceName, namespace, istioEndpoints)</span><br><span class="line">	s.ConfigUpdate(&amp;model.PushRequest&#123;</span><br><span class="line">		Full: fp,</span><br><span class="line">		ConfigsUpdated: <span class="keyword">map</span>[model.ConfigKey]<span class="keyword">struct</span>&#123;&#125;&#123;&#123;</span><br><span class="line">			Kind:      gvk.ServiceEntry,</span><br><span class="line">			Name:      serviceName,</span><br><span class="line">			Namespace: namespace,</span><br><span class="line">		&#125;: &#123;&#125;&#125;,</span><br><span class="line">		Reason: []model.TriggerReason&#123;model.EndpointUpdate&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后生成了一个 <code>PushRequst</code> 在 <code>ConfigUpdate</code> 中，我们将请求至于  <code>PushChannel</code> 之中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">unc (s *DiscoveryServer) ConfigUpdate(req *model.PushRequest) &#123;</span><br><span class="line">	s.pushChannel &lt;- req</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>Push</code> 的消费逻辑在</p>
<figure class="highlight go"><figcaption><span>DiscoveryServer:Push</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span></span> Push(req *model.PushRequest) &#123;</span><br><span class="line">	<span class="keyword">if</span> !req.Full &#123;</span><br><span class="line">		req.Push = s.globalPushContext()</span><br><span class="line">		<span class="keyword">go</span> s.AdsPushAll(versionInfo(), req)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新版本号</span></span><br><span class="line">	versionLocal := time.Now().Format(time.RFC3339) + <span class="string">&quot;/&quot;</span> + strconv.FormatUint(versionNum.Load(), <span class="number">10</span>)</span><br><span class="line">	versionNum.Inc()</span><br><span class="line">	initContextTime := time.Since(t0)</span><br><span class="line">	adsLog.Debugf(<span class="string">&quot;InitContext %v for push took %s&quot;</span>, versionLocal, initContextTime)</span><br><span class="line"></span><br><span class="line">	versionMutex.Lock()</span><br><span class="line">	version = versionLocal</span><br><span class="line">	versionMutex.Unlock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 推送请求</span></span><br><span class="line">	req.Push = push</span><br><span class="line">	<span class="keyword">go</span> s.AdsPushAll(versionLocal, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.jpg.cm/2020/11/13/YcDIQ.png" alt="YcDIQ.png"></p>
<h4 id="More-Update"><a class="header-anchor" href="#More-Update">¶</a>More Update</h4>
<p>如果我们修改我们的 <code>CRD</code> 定义，就往往会导致更多的配置需要更新，这时候就会触发一些其他的更新。</p>
<p>在 <code>pilot/pkg/xds/</code> 中有大量对于其他 <code>PUSH</code> 的实现，就不做展开。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>对于 <code>Pilot</code> 的功能还是非常的简单，就是监听各种 <code>Kube Resource</code> 然后向 <code>XDS</code> 进行数据更新。不过值得注意的，单纯的依靠 <code>Poilot</code> 是完成不了 <code>istio</code> 的功能的， <code>Pilot</code> 更多只是维护了一组 <code>Endpoints</code>，而访问的一些其他信息都是在 <code>Galley</code> 中进行配置的。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://www.servicemesher.com/blog/201910-pilot-code-deep-dive/">Istio Pilot代码深度解析</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>isito</category>
      </categories>
      <tags>
        <tag>isito</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现 TCP 协议 [WIP]</title>
    <url>/2020/09/30/networking/tcp-ip/build-tcp/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/10/01/J4UJh.png" alt="J4UJh.png"></p>
<p>学不会 <code>TCP</code> ? 没关系，让我们就自己造一个。</p>
<span id="more"></span>
<h2 id="环境搭建"><a class="header-anchor" href="#环境搭建">¶</a>环境搭建</h2>
<p>本文专注于 <code>TCP</code> 层的协议实现，因此对于 <code>网卡驱动</code> <code>OS</code> 都不在本文的实现范围内，因此我们基于现已有<code>pnet</code> 进行开发。</p>
<figure class="highlight rust"><figcaption><span>main</span><a href="https://github.com/yanickxia/rust-tcp-tutorial/blob/init/src/main.rs">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得第一个函数参数 -&gt; 网卡名称</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">interface_name</span> = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">interface_names_match</span> =</span><br><span class="line">        |iface: &amp;NetworkInterface| iface.name == interface_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">interfaces</span> = datalink::<span class="title function_ invoke__">interfaces</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照网卡名称获得网卡</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">interface</span> = interfaces.<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(interface_names_match)</span><br><span class="line">        .<span class="title function_ invoke__">next</span>()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个发送和接受 channel</span></span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> tx, <span class="keyword">mut</span> rx) = <span class="keyword">match</span> datalink::<span class="title function_ invoke__">channel</span>(&amp;interface, <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>()) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Ethernet</span>(tx, rx)) =&gt; (tx, rx),</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Unhandled channel type&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;An error occurred when creating the datalink channel: &#123;&#125;&quot;</span>, e)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// 处理下次抵达的数据包</span></span><br><span class="line">        <span class="keyword">match</span> rx.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(packet) =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">packet</span> = EthernetPacket::<span class="title function_ invoke__">new</span>(packet).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Got packet &#123;:?&#125;&quot;</span>, packet);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">                <span class="comment">// If an error occurs, we can handle it here</span></span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;An error occurred while reading: &#123;&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是我们最初的模板环境的，<a href="https://github.com/yanickxia/rust-tcp-tutorial/tree/init">源码下载</a></p>
<p>我们运行可得结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo run -- lo0</span><br><span class="line">Got packet EthernetPacket &#123; destination : 00:00:00:00:00:00, <span class="built_in">source</span> : 00:00:00:00:00:00, ethertype : EtherType(0),  &#125;</span><br><span class="line">Got packet EthernetPacket &#123; destination : 00:00:00:00:00:00, <span class="built_in">source</span> : 00:00:00:00:00:00, ethertype : EtherType(0),  &#125;</span><br><span class="line">Got packet EthernetPacket &#123; destination : 00:00:00:00:00:00, <span class="built_in">source</span> : 00:00:00:00:00:00, ethertype : EtherType(0),  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="IP-协议"><a class="header-anchor" href="#IP-协议">¶</a>IP 协议</h2>
<p><a href="https://tools.ietf.org/html/rfc791"><code>Internet Protocol</code></a> 协议为上层协议提供了寻址的能力， <code>ip</code> 协议通过协议头部分的 <code>IP Address</code> 进行不同目标地址的区分，因为我们直接从 <code>二层</code> 上进行本次探索，因此对于 <code>IP Route</code> 的部分已经被 <code>OS</code> 完成，我们直接解析协议即可。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+------+ +-----+ +-----+     +-----+</span><br><span class="line">|Telnet| | FTP | | TFTP| ... | ... |</span><br><span class="line">+------+ +-----+ +-----+     +-----+</span><br><span class="line">    |   |         |           |</span><br><span class="line">    +-----+     +-----+     +-----+</span><br><span class="line">    | TCP |     | UDP | ... | ... |</span><br><span class="line">    +-----+     +-----+     +-----+</span><br><span class="line">        |           |           |</span><br><span class="line">    +--------------------------+----+</span><br><span class="line">    |    Internet Protocol &amp; ICMP   |</span><br><span class="line">    +--------------------------+----+</span><br><span class="line">                    |</span><br><span class="line">    +---------------------------+</span><br><span class="line">    |   Local Network Protocol  |</span><br><span class="line">    +---------------------------+</span><br></pre></td></tr></table></figure>
<p><code>IP</code> 协议的构成如下</p>
<figure class="highlight text"><figcaption><span>Internet Header Format hhttps://tools.ietf.org/html/rfc791#page-11 doc</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         Identification        |Flags|      Fragment Offset    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       Source Address                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Destination Address                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>让我们开始 <code>coding</code> 吧，我们先来定义下数据结构。比 <code>u8</code> 还小的数据体我们都用 <code>u8</code> 描述。</p>
<h3 id="定义格式"><a class="header-anchor" href="#定义格式">¶</a>定义格式</h3>
<figure class="highlight rust"><figcaption><span>def</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">IPv4Header</span> &#123;</span><br><span class="line">    <span class="comment">// internet header field, 4bit</span></span><br><span class="line">    <span class="keyword">pub</span> version: <span class="type">u8</span>,</span><br><span class="line">    <span class="comment">// internet header field Internet Header Length, 4bit</span></span><br><span class="line">    <span class="keyword">pub</span> ihl: <span class="type">u8</span>,</span><br><span class="line">    <span class="comment">// Type of Service, 8bit</span></span><br><span class="line">    <span class="keyword">pub</span> toc: <span class="type">u8</span>,</span><br><span class="line">    <span class="comment">// total length, 16bit</span></span><br><span class="line">    <span class="keyword">pub</span> len: <span class="type">u16</span>,</span><br><span class="line">    <span class="comment">// Identification, 16bit</span></span><br><span class="line">    <span class="keyword">pub</span> identification: <span class="type">u16</span>,</span><br><span class="line">    <span class="comment">// flag, 3bit</span></span><br><span class="line">    <span class="keyword">pub</span> flags: <span class="type">u8</span>,</span><br><span class="line">    <span class="comment">// Fragment offset, 13 bit</span></span><br><span class="line">    <span class="keyword">pub</span> offset: <span class="type">u16</span>,</span><br><span class="line">    <span class="comment">// ttl, 8bit</span></span><br><span class="line">    <span class="keyword">pub</span> ttl: <span class="type">u8</span>,</span><br><span class="line">    <span class="comment">// Protocol, 8bit</span></span><br><span class="line">    <span class="keyword">pub</span> protocol: <span class="type">u8</span>,</span><br><span class="line">    <span class="comment">// checksum</span></span><br><span class="line">    <span class="keyword">pub</span> checksum: <span class="type">u16</span>,</span><br><span class="line">    <span class="comment">// Source Address</span></span><br><span class="line">    <span class="keyword">pub</span> source_address: <span class="type">u32</span>,</span><br><span class="line">    <span class="comment">// Destination Address</span></span><br><span class="line">    <span class="keyword">pub</span> destination_address: <span class="type">u32</span>,</span><br><span class="line">    <span class="comment">// Options</span></span><br><span class="line">    <span class="keyword">pub</span> options_len: <span class="type">u8</span>,</span><br><span class="line">    <span class="comment">// Options 部分最长 40 字节</span></span><br><span class="line">    <span class="keyword">pub</span> options_buffer: [<span class="type">u8</span>; <span class="number">40</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">IPv4</span> &#123;</span><br><span class="line">    <span class="comment">// header</span></span><br><span class="line">    <span class="keyword">pub</span> header: IPv4Header,</span><br><span class="line">    <span class="comment">// Data, 这里可以用 &#x27;a &amp;[u8] 减少拷贝，因为这是教程，图方便就先不管这些了</span></span><br><span class="line">    <span class="keyword">pub</span> data: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义完成我们的 <code>IP</code> 协议格式之后，增加一个对于 <code>Check TCP IP</code> 的函数，并为之增加单元测试。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_tcp_ip</span>(packet: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> packet.<span class="title function_ invoke__">len</span>() &lt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">version</span> = packet[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">protocol</span> = packet[<span class="number">9</span>];</span><br><span class="line">    <span class="comment">// 检测首位是否为 4 ，然后协议为 TCP 的协议号</span></span><br><span class="line">    <span class="keyword">return</span> version == <span class="number">4</span> &amp;&amp; protocol == <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">test_is_tcp_ip</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hex_data</span> = hex::<span class="title function_ invoke__">decode</span>(<span class="string">&quot;45000034000040004006f023c0a80d1f783504a4df98e67dd861552917e0b7ae801007fff3ac00000101080a016dfbad36f9392c&quot;</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">is_tcp_ip</span>(hex_data.<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_slice</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="协议解析"><a class="header-anchor" href="#协议解析">¶</a>协议解析</h3>
<p>这部分其实没有什么花头，按照规则解析即可。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">IPv4</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(packet: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> IPv4 &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = BigEndian::<span class="title function_ invoke__">read_u16</span>(&amp;packet[<span class="number">2</span>..]); <span class="comment">// 总长</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ihl</span> = packet[<span class="number">0</span>] &lt;&lt; <span class="number">4</span> &gt;&gt; <span class="number">4</span>; <span class="comment">// 头部长</span></span><br><span class="line">        <span class="keyword">return</span> IPv4 &#123;</span><br><span class="line">            header: IPv4Header &#123;</span><br><span class="line">                version: packet[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>,</span><br><span class="line">                ihl,</span><br><span class="line">                toc: packet[<span class="number">1</span>],</span><br><span class="line">                len,</span><br><span class="line">                identification: BigEndian::<span class="title function_ invoke__">read_u16</span>(&amp;packet[<span class="number">4</span>..]),</span><br><span class="line">                flags: packet[<span class="number">6</span>] &gt;&gt; <span class="number">5</span>,</span><br><span class="line">                offset: BigEndian::<span class="title function_ invoke__">read_u16</span>(&amp;packet[<span class="number">6</span>..]) &lt;&lt; <span class="number">3</span> &gt;&gt; <span class="number">3</span>,</span><br><span class="line">                ttl: packet[<span class="number">8</span>],</span><br><span class="line">                protocol: packet[<span class="number">9</span>],</span><br><span class="line">                checksum: BigEndian::<span class="title function_ invoke__">read_u16</span>(&amp;packet[<span class="number">10</span>..]),</span><br><span class="line">                source_address: BigEndian::<span class="title function_ invoke__">read_u32</span>(&amp;packet[<span class="number">12</span>..]),</span><br><span class="line">                destination_address: BigEndian::<span class="title function_ invoke__">read_u32</span>(&amp;packet[<span class="number">16</span>..]),</span><br><span class="line">                options_len: <span class="number">0</span>, <span class="comment">// options 部分没有解析</span></span><br><span class="line">                options_buffer: <span class="built_in">vec!</span>[],</span><br><span class="line">            &#125;,</span><br><span class="line">            data: <span class="type">Vec</span>::<span class="title function_ invoke__">from</span>(&amp;packet[(ihl <span class="keyword">as</span> <span class="type">usize</span>) * <span class="number">4</span>..len <span class="keyword">as</span> <span class="type">usize</span>]), <span class="comment">// data区域</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="看看效果"><a class="header-anchor" href="#看看效果">¶</a>看看效果</h3>
<p>修改我们的 <code>main</code> 函数，打印出更可读的部分内容</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> packet.<span class="title function_ invoke__">len</span>() &gt; payload_offset &amp;&amp; ip::IPv4::<span class="title function_ invoke__">is_tcp_ip</span>(&amp;packet[payload_offset..]) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ipv4_packet</span> = ip::IPv4::<span class="title function_ invoke__">new</span>(&amp;packet[payload_offset..]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got Tcp Ip Package From &#123;&#125; To &#123;&#125; Len &#123;&#125;&quot;</span>,</span><br><span class="line">                ipv4_packet.header.<span class="title function_ invoke__">source</span>(),</span><br><span class="line">                ipv4_packet.header.<span class="title function_ invoke__">destination</span>(),</span><br><span class="line">                ipv4_packet.header.len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Got Tcp Ip Package From 127.0.0.1 To 127.0.0.1 Len 64</span><br><span class="line">Got Tcp Ip Package From 127.0.0.1 To 127.0.0.1 Len 40</span><br><span class="line">Got Tcp Ip Package From 127.0.0.1 To 127.0.0.1 Len 100</span><br><span class="line">Got Tcp Ip Package From 127.0.0.1 To 127.0.0.1 Len 52</span><br><span class="line">Got Tcp Ip Package From 127.0.0.1 To 127.0.0.1 Len 100</span><br></pre></td></tr></table></figure>
<p>为了快速的跑完主线，对于 <code>Options</code> 和 <code>分片</code> 部分的逻辑暂时也没有涉及，因此对于 <code>TCP</code> 有自己的 <code>MMS</code> 的协商部分，一般不会使用到 <code>IP</code> 的分片逻辑。下一步我们就正式的进入我们的 <code>TCP</code> 代码部分吧。</p>
<h2 id="TCP-协议"><a class="header-anchor" href="#TCP-协议">¶</a>TCP 协议</h2>
<p>传输控制协议（<code>Transmission Control Protocol</code>）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的<a href="https://tools.ietf.org/html/rfc793"><code>RFC 793</code></a>定义。</p>
<h3 id="数据格式定义"><a class="header-anchor" href="#数据格式定义">¶</a>数据格式定义</h3>
<p>和 <code>IP</code> 类似</p>
<figure class="highlight text"><figcaption><span>TCP Header Format</span><a href="https://tools.ietf.org/html/rfc793#page-15">link</a></figcaption><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>我们先来定义数据结构先</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TCPHeader</span> &#123;</span><br><span class="line">    <span class="comment">// source port, 16 bit, index 0-1</span></span><br><span class="line">    <span class="keyword">pub</span> source_port: <span class="type">u16</span>,</span><br><span class="line">    <span class="comment">// Destination port, 16 bit, index 2-3</span></span><br><span class="line">    <span class="keyword">pub</span> destination_port: <span class="type">u16</span>,</span><br><span class="line">    <span class="comment">// Sequence Number , 32 bit, index 4 - 7</span></span><br><span class="line">    <span class="keyword">pub</span> sequence_number: <span class="type">u32</span>,</span><br><span class="line">    <span class="comment">// Acknowledgment Number, 32 bit, index 8 - 11</span></span><br><span class="line">    <span class="keyword">pub</span> acknowledgment_number: <span class="type">u32</span>,</span><br><span class="line">    <span class="comment">// Data offset, 4 bit, index 12</span></span><br><span class="line">    <span class="keyword">pub</span> offset: <span class="type">u8</span>,</span><br><span class="line">    <span class="comment">// reserved, 6bit, index 13</span></span><br><span class="line">    <span class="keyword">pub</span> reserved: <span class="type">u8</span>,</span><br><span class="line">    <span class="comment">// flags, 6bit, index 14</span></span><br><span class="line">    <span class="keyword">pub</span> flags: <span class="type">u8</span>,</span><br><span class="line">    <span class="comment">// windows, 16bit, index 15</span></span><br><span class="line">    <span class="keyword">pub</span> windows: <span class="type">u16</span>,</span><br><span class="line">    <span class="comment">// checksum, 16bit, index 17</span></span><br><span class="line">    <span class="keyword">pub</span> checksum: <span class="type">u16</span>,</span><br><span class="line">    <span class="comment">// Urgent Pointer, 16 bit, index 21</span></span><br><span class="line">    <span class="keyword">pub</span> urgent_pointer: <span class="type">u16</span>,</span><br><span class="line">    <span class="comment">// Options len</span></span><br><span class="line">    <span class="comment">// Options data</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TCP</span> &#123;</span><br><span class="line">    <span class="comment">// tcp header</span></span><br><span class="line">    <span class="keyword">pub</span> header: TCPHeader,</span><br><span class="line">    <span class="comment">// tcp data</span></span><br><span class="line">    <span class="keyword">pub</span> data: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解析数据"><a class="header-anchor" href="#解析数据">¶</a>解析数据</h3>
<p>相同的味道和套路，再来一遍</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">TCP</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(packet: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> TCP &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">offset</span> = packet[<span class="number">12</span>] &gt;&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> TCP &#123;</span><br><span class="line">            header: TCPHeader &#123;</span><br><span class="line">                source_port: BigEndian::<span class="title function_ invoke__">read_u16</span>(packet),</span><br><span class="line">                destination_port: BigEndian::<span class="title function_ invoke__">read_u16</span>(&amp;packet[<span class="number">2</span>..]),</span><br><span class="line">                sequence_number: BigEndian::<span class="title function_ invoke__">read_u32</span>(&amp;packet[<span class="number">4</span>..]),</span><br><span class="line">                acknowledgment_number: BigEndian::<span class="title function_ invoke__">read_u32</span>(&amp;packet[<span class="number">8</span>..]),</span><br><span class="line">                offset,</span><br><span class="line">                reserved: (BigEndian::<span class="title function_ invoke__">read_u16</span>(&amp;packet[<span class="number">12</span>..]) &lt;&lt; <span class="number">4</span> &gt;&gt; <span class="number">10</span>) <span class="keyword">as</span> <span class="type">u8</span>,</span><br><span class="line">                flags: packet[<span class="number">13</span>] &lt;&lt; <span class="number">2</span> &gt;&gt; <span class="number">2</span>,</span><br><span class="line">                windows: BigEndian::<span class="title function_ invoke__">read_u16</span>(&amp;packet[<span class="number">14</span>..]),</span><br><span class="line">                checksum: BigEndian::<span class="title function_ invoke__">read_u16</span>(&amp;packet[<span class="number">17</span>..]),</span><br><span class="line">                urgent_pointer: BigEndian::<span class="title function_ invoke__">read_u16</span>(&amp;packet[<span class="number">21</span>..]),</span><br><span class="line">            &#125;,</span><br><span class="line">            data: <span class="type">Vec</span>::<span class="title function_ invoke__">from</span>(&amp;packet[(offset <span class="keyword">as</span> <span class="type">usize</span>) * <span class="number">4</span>..]),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记得补充单元测试</p>
<figure class="highlight rust"><figcaption><span>unit test</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">test_parse_tcp</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hex_data</span> = hex::<span class="title function_ invoke__">decode</span>(<span class="string">&quot;e67ddf9817e0b77ed8615529801801f52b2300000101080a36f9392c016de81f263cdb224dcc9a4b4c2191ecb4c43c0a3daeb61233ee4af155a60c9dcac70fcebe0fca8964908c1c5f5073c50b0522eb&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tcp</span> = TCP::<span class="title function_ invoke__">new</span>(hex_data.<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_slice</span>());</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">59005</span>, tcp.header.source_port);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">57240</span>, tcp.header.destination_port);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">400603006</span>, tcp.header.sequence_number);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3630257449</span>, tcp.header.acknowledgment_number);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">501</span>, tcp.header.windows);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(tcp.header.<span class="title function_ invoke__">is_psh</span>());</span><br><span class="line">    <span class="built_in">assert!</span>(tcp.header.<span class="title function_ invoke__">is_ack</span>());</span><br><span class="line">    <span class="built_in">assert!</span>(!tcp.header.<span class="title function_ invoke__">is_fin</span>());</span><br><span class="line">    <span class="built_in">assert!</span>(!tcp.header.<span class="title function_ invoke__">is_rst</span>());</span><br><span class="line">    <span class="built_in">assert!</span>(!tcp.header.<span class="title function_ invoke__">is_syn</span>());</span><br><span class="line">    <span class="built_in">assert!</span>(!tcp.header.<span class="title function_ invoke__">is_urg</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = hex::<span class="title function_ invoke__">decode</span>(<span class="string">&quot;263cdb224dcc9a4b4c2191ecb4c43c0a3daeb61233ee4af155a60c9dcac70fcebe0fca8964908c1c5f5073c50b0522eb&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(data.<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">as_slice</span>(), tcp.data.<span class="title function_ invoke__">as_slice</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="增加Flag辅助函数"><a class="header-anchor" href="#增加Flag辅助函数">¶</a>增加Flag辅助函数</h3>
<p>我们知道 <code>TCP</code> 大部分的时候，我们都需要判断 <code>Flags</code> 的标记，一共 <code>6</code> 种，我们处理一下。</p>
<figure class="highlight rust"><figcaption><span>tcpheader flags</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">TCPHeader</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_urg</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.flags &amp; <span class="number">0b100000</span> != <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_ack</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.flags &amp; <span class="number">0b010000</span> != <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_psh</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.flags &amp; <span class="number">0b001000</span> != <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_rst</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.flags &amp; <span class="number">0b000100</span> != <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_syn</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.flags &amp; <span class="number">0b000010</span> != <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_fin</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.flags &amp; <span class="number">0b000001</span> != <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/yanickxia/rust-tcp-tutorial/tree/parse-tcp">源码地址</a></p>
<p>在来看看效果</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> packet.<span class="title function_ invoke__">len</span>() &gt; payload_offset &amp;&amp; ip::IPv4::<span class="title function_ invoke__">is_tcp_ip</span>(&amp;packet[payload_offset..]) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ipv4_packet</span> = ip::IPv4::<span class="title function_ invoke__">new</span>(&amp;packet[payload_offset..]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tcp_packet</span> = tcp::TCP::<span class="title function_ invoke__">new</span>(ipv4_packet.data.<span class="title function_ invoke__">as_slice</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got Tcp Ip Package From &#123;&#125;:&#123;&#125; To &#123;&#125;:&#123;&#125; Data Len &#123;&#125;&quot;</span>,</span><br><span class="line">                ipv4_packet.header.<span class="title function_ invoke__">source</span>(),</span><br><span class="line">                tcp_packet.header.source_port,</span><br><span class="line">                ipv4_packet.header.<span class="title function_ invoke__">destination</span>(),</span><br><span class="line">                tcp_packet.header.destination_port,</span><br><span class="line">                tcp_packet.data.<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Got Tcp Ip Package From 127.0.0.1:1080 To 127.0.0.1:64533 Data Len 48</span><br><span class="line">Got Tcp Ip Package From 127.0.0.1:1080 To 127.0.0.1:64588 Data Len 47</span><br><span class="line">Got Tcp Ip Package From 127.0.0.1:64533 To 127.0.0.1:1080 Data Len 0</span><br><span class="line">Got Tcp Ip Package From 127.0.0.1:64588 To 127.0.0.1:1080 Data Len 0</span><br><span class="line">Got Tcp Ip Package From 127.0.0.1:64531 To 127.0.0.1:64532 Data Len 48</span><br></pre></td></tr></table></figure>
<h2 id="TCP-状态储存"><a class="header-anchor" href="#TCP-状态储存">¶</a>TCP 状态储存</h2>
<p>我们知道 <code>TCP/IP</code> 协议来说，我们通过 <strong>(来源IP，来源端口，目的IP，目标端口)</strong> 这四组数据可以组成一个唯一的<code>ID</code>，我们使用这个<code>ID</code>作为我们储存的<code>KEY</code>来储存我们的数据。</p>
<p>我们用一种比较简单的 <code>u128</code> 来表示我们的这个 <code>ID</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0                       31                      63                         95                  127</span><br><span class="line">+-----------------------------------------------------------------------------------------------+</span><br><span class="line">   source address              source port           destination address       destination port</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><figcaption><span>计算ID</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">unique</span>: <span class="type">u128</span> = (packet.header.source_address <span class="keyword">as</span> <span class="type">u128</span>) &lt;&lt; <span class="number">96</span>;</span><br><span class="line">unique = unique &amp; ((tcp_packet.header.source_port <span class="keyword">as</span> <span class="type">u128</span>) &lt;&lt; <span class="number">64</span>);</span><br><span class="line">unique = unique &amp; ((packet.header.destination_address <span class="keyword">as</span> <span class="type">u128</span>) &lt;&lt; <span class="number">32</span>);</span><br><span class="line">unique = unique &amp; tcp_packet.header.destination_port <span class="keyword">as</span> <span class="type">u128</span>;</span><br></pre></td></tr></table></figure>
<p>之后我们简单的使用一个 <code>map</code> 来储存我们的数据。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> HASHMAP: HashMap&lt;<span class="type">u128</span>, TCPCurState&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        m</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TCP-状态转移"><a class="header-anchor" href="#TCP-状态转移">¶</a>TCP 状态转移</h2>
<h3 id="Map"><a class="header-anchor" href="#Map">¶</a>Map</h3>
<p>先上一份<a href="https://users.cs.northwestern.edu/~agupta/cs340/project2/TCPIP_State_Transition_Diagram.pdf">PDF</a></p>
<p><img src="https://s3.jpg.cm/2020/10/03/JyPES.png" alt="JyPES.png"></p>
<h3 id="三次握手"><a class="header-anchor" href="#三次握手">¶</a>三次握手</h3>
<p>我们来实现左线关于 <code>Server</code> 端的 <code>TCP</code> 状态转移，不过因为我们并没有实现 <code>Socket</code>，因此数据进入系统的第一步应该是通过 <code>Listening Port</code> 决定是否需要丢弃 <code>Packet</code>，因此我们使用一个常量来模拟 <code>Listening Port</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> LISTENING_PORT: <span class="type">u16</span> = <span class="number">10023</span>;</span><br></pre></td></tr></table></figure>
<p>那我们先来处理我们第一步需要处理的状态转换: <code>LISTEN</code> -&gt; <code>SYN_RCVD</code>，这是我们建立 <code>TCP</code> 连接的第一步，从图上看我们知道，服务器接收到 <code>syn</code> 报文然后响应 <code>syn,ack</code> 报文即可。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">    TCP A                                                TCP B</span><br><span class="line"></span><br><span class="line">1.  CLOSED                                               LISTEN</span><br><span class="line"></span><br><span class="line">2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED</span><br><span class="line"></span><br><span class="line">3.  ESTABLISHED &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED</span><br><span class="line"></span><br><span class="line">4.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;       --&gt; ESTABLISHED</span><br><span class="line"></span><br><span class="line">5.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; --&gt; ESTABLISHED</span><br><span class="line"></span><br><span class="line">        Basic 3-Way Handshake for Connection Synchronization</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=bzja9fQWzdA">Implementing TCP in Rust</a></li>
<li><a href="https://tools.ietf.org/html/rfc791">rfc791: INTERNET PROTOCOL</a></li>
<li><a href="https://tools.ietf.org/html/rfc793#page-15">rfc793: Transmission Control Protocol</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>network</category>
        <category>tcp</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>Zuul2源码分析</title>
    <url>/2018/06/22/java/microservice/gateway/zuul2/</url>
    <content><![CDATA[<h1>Zuul2</h1>
<p>Zuul2的难产，终于在 2018.4.13 上架了中心仓库，也代表着Zuul正式加入Netty全家桶的怀抱，关于 Zuul2 有一篇宏观性的博文有兴趣的可以阅读 <a href="https://medium.com/netflix-techblog/zuul-2-the-netflix-journey-to-asynchronous-non-blocking-systems-45947377fb5c">Zuul 2 : The Netflix Journey to Asynchronous, Non-Blocking Systems</a> 此篇博客。</p>
<span id="more"></span>
<p>简而言之，Zuul2也就是从传统的 BIO 切换到了 NIO 模式。<br>
<img src="https://s1.ax1x.com/2018/06/22/PSzIQs.png" alt="bio-thread"><br>
传统的BIO模型基于Thread的方式</p>
<p><img src="https://s1.ax1x.com/2018/06/22/PSzHe0.png" alt="nio-thread"><br>
NIO模型基于Reactor模型</p>
<h2 id="Zuul2-架构"><a class="header-anchor" href="#Zuul2-架构">¶</a>Zuul2 架构</h2>
<p>从上帝视角来开，Zuul2是一个在 <code>Netty</code> 上运行一系列Filter的服务，执行完成PreFilter (inbound filters)之后将请求通过 <code>Netty Client</code> 转发出去，然后将请求的结果通过一系列PostFilter (outbound filters) 返回，如下图所示。<br>
<img src="https://s1.ax1x.com/2018/06/22/PpSZSH.png" alt="Architectural-over"></p>
<p>正如之前的 <code>ZuulFilter</code> 分为了 <code>Pre</code>,<code>Post</code>,<code>Route</code>,<code>Error</code>，Zuul2的Filter分为三种类型</p>
<ul>
<li>Inbound Filters: 在路由之前执行</li>
<li>Endpoint Filters: 路由操作</li>
<li>Outbound Filters: 得到相应数据之后执行</li>
</ul>
<p>我们用官方的Demo进行分析 <a href="https://github.com/Netflix/zuul/tree/2.1/zuul-sample">zuul-sample</a>，诸位看官自行下载导入。</p>
<h2 id="ServerStartup"><a class="header-anchor" href="#ServerStartup">¶</a>ServerStartup</h2>
<p>在Demo的启动中，我们发现启动的入口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ConfigurationManager.loadCascadedPropertiesFromResources(<span class="string">&quot;application&quot;</span>); ➊</span><br><span class="line">    <span class="type">Injector</span> <span class="variable">injector</span> <span class="operator">=</span> InjectorBuilder.fromModule(<span class="keyword">new</span> <span class="title class_">ZuulSampleModule</span>()).createInjector(); ➋</span><br><span class="line">    <span class="type">BaseServerStartup</span> <span class="variable">serverStartup</span> <span class="operator">=</span> injector.getInstance(BaseServerStartup.class);</span><br><span class="line">    server = serverStartup.server(); </span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">startupDuration</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">    System.out.println(<span class="string">&quot;Zuul Sample: finished startup. Duration = &quot;</span> + startupDuration + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    server.start(<span class="literal">true</span>); ➌</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 获得系统的一些配置参数<br>
➋ Demo中使用的是Google的Guice进行依赖注入的，这个就展开了有兴趣的可以自行去搜索<br>
➌ 启动一个Zuul2服务</p>
<p>我们从这个 <code>start()</code> 作为我们的突破口，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">boolean</span> sync)</span>&#123;</span><br><span class="line">    serverGroup = <span class="keyword">new</span> <span class="title class_">ServerGroup</span>(<span class="string">&quot;Salamander&quot;</span>, eventLoopConfig.acceptorCount(),   eventLoopConfig.eventLoopCount(), eventLoopGroupMetrics); ➊</span><br><span class="line">    serverGroup.initializeTransport();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;ChannelFuture&gt; allBindFutures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// Setup each of the channel initializers on requested ports.</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, ChannelInitializer&gt; entry : portsToChannelInitializers.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            allBindFutures.add(setupServerBootstrap(entry.getKey(), entry.getValue())); ➋</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Once all server bootstraps are successfully initialized, then bind to each port.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 构建一个新的 <code>ServerGroup</code><br>
➋ <code>setupServerBootstrap()</code> 初始化一个 <code>ServerBootstrap</code>，根据之前Netty的分析，我们知道Netty需要使用 <code>ServerBootstrap</code> 进行 端口绑定，那这里是不是就是那个东西。<br>
我们继续深入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">setupServerBootstrap</span><span class="params">(<span class="type">int</span> port, ChannelInitializer channelInitializer)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().group(</span><br><span class="line">            serverGroup.clientToProxyBossPool,</span><br><span class="line">            serverGroup.clientToProxyWorkerPool); ➊</span><br><span class="line"></span><br><span class="line">    serverBootstrap.childHandler(channelInitializer); ➋</span><br><span class="line">    serverBootstrap.validate();</span><br><span class="line"></span><br><span class="line">    LOG.info(<span class="string">&quot;Binding to port: &quot;</span> + port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flag status as UP just before binding to the port.</span></span><br><span class="line">    serverStatusManager.localStatus(InstanceInfo.InstanceStatus.UP); ➌</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind and start to accept incoming connections.</span></span><br><span class="line">    <span class="keyword">return</span> serverBootstrap.bind(port).sync();  ➍</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ➊ 构建了一个 <code>ServerBootstrap</code> 这个正是Netty的启动类<br>
➋ 正如Netty的启动中的处理数据的 <code>Handler</code> 那这里应该也就是Zuul处理的核心所在<br>
➌ 一个我们的老朋友，和Eureka集成时改变服务器状态<br>
➍ 绑定 <code>ServerNioSockertChannel</code> 不再多做分析</p>
<h2 id="1-3-休息"><a class="header-anchor" href="#1-3-休息">¶</a>1/3 休息</h2>
<p>我们已经发现了Zuul2是如何启动一个Netty服务的，我们解决了图中红框部分的原理，那我们接下来去了解最为重要的这些Filter是如何工作的，我们上启动中已经发现一个很重要的对象 <code>channelInitializer</code> 我们知道在Netty中，是将一系列的 <code>Handler</code> 聚合在一起并使用 <code>Pipeline</code> 执行（参考<a href="http://blog.yannxia.top/2018/06/20/java/netty/netty-3-pipeline/">Netty源码分析-(3)-ChannelPipeline</a>）我们可以猜测 zuul 的做法是类型，我们从这个 <code>channelInitializer</code> 入手去研究。</p>
<h2 id="ZuulServerChannelInitializer"><a class="header-anchor" href="#ZuulServerChannelInitializer">¶</a>ZuulServerChannelInitializer</h2>
<p>我们轻而易举的可以发现 <code>ChannelInitializer</code> 其实是  <code>ZuulServerChannelInitializer</code> 对象。在initChannel中我们发现了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">    storeChannel(ch);</span><br><span class="line">    addTimeoutHandlers(pipeline);</span><br><span class="line">    addPassportHandler(pipeline);</span><br><span class="line">    addTcpRelatedHandlers(pipeline);</span><br><span class="line">    addHttp1Handlers(pipeline);</span><br><span class="line">    addHttpRelatedHandlers(pipeline);</span><br><span class="line">    addZuulHandlers(pipeline); ➊</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在➊前面的都比较简单都是一些标准的 <code>Handler</code> 大家可以自己阅读，最为重要是 <code>addZuulHandlers(pipeline);</code> 这个函数，我们继续深入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addZuulHandlers</span><span class="params">(<span class="keyword">final</span> ChannelPipeline pipeline)</span>&#123;</span><br><span class="line">    pipeline.addLast(<span class="string">&quot;logger&quot;</span>, nettyLogger);</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ClientRequestReceiver</span>(sessionContextDecorator));</span><br><span class="line">    pipeline.addLast(passportLoggingHandler);</span><br><span class="line">    addZuulFilterChainHandler(pipeline); ➋</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ClientResponseWriter</span>(requestCompleteHandler, registry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的都很容易看出来，是日志，Session之类的Handler，最为重要的是 ➋ 处增加 ZuulFilter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addZuulFilterChainHandler</span><span class="params">(<span class="keyword">final</span> ChannelPipeline pipeline)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ZuulFilter&lt;HttpResponseMessage, HttpResponseMessage&gt;[] responseFilters = getFilters(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">OutboundPassportStampingFilter</span>(FILTERS_OUTBOUND_START),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">OutboundPassportStampingFilter</span>(FILTERS_OUTBOUND_END)); ➊</span><br><span class="line"></span><br><span class="line">    <span class="comment">// response filter chain</span></span><br><span class="line">    <span class="keyword">final</span> ZuulFilterChainRunner&lt;HttpResponseMessage&gt; responseFilterChain = getFilterChainRunner(responseFilters,</span><br><span class="line">            filterUsageNotifier); ➋</span><br><span class="line"></span><br><span class="line">    <span class="comment">// endpoint | response filter chain</span></span><br><span class="line">    <span class="keyword">final</span> FilterRunner&lt;HttpRequestMessage, HttpResponseMessage&gt; endPoint = getEndpointRunner(responseFilterChain,</span><br><span class="line">            filterUsageNotifier, filterLoader); ➌</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ZuulFilter&lt;HttpRequestMessage, HttpRequestMessage&gt;[] requestFilters = getFilters(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InboundPassportStampingFilter</span>(FILTERS_INBOUND_START),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InboundPassportStampingFilter</span>(FILTERS_INBOUND_END));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// request filter chain | end point | response filter chain</span></span><br><span class="line">    <span class="keyword">final</span> ZuulFilterChainRunner&lt;HttpRequestMessage&gt; requestFilterChain = getFilterChainRunner(requestFilters,</span><br><span class="line">            filterUsageNotifier, endPoint);</span><br><span class="line"></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ZuulFilterChainHandler</span>(requestFilterChain, responseFilterChain));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 ➊ 深入可以看到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ZuulMessage</span>&gt; ZuulFilter&lt;T, T&gt; [] getFilters(<span class="keyword">final</span> ZuulFilter start, <span class="keyword">final</span> ZuulFilter stop) &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;ZuulFilter&gt; zuulFilters = filterLoader.getFiltersByType(start.filterType());</span><br><span class="line">    <span class="keyword">final</span> ZuulFilter[] filters = <span class="keyword">new</span> <span class="title class_">ZuulFilter</span>[zuulFilters.size() + <span class="number">2</span>];</span><br><span class="line">    filters[<span class="number">0</span>] = start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i &lt; filters.length &amp;&amp; j &lt; zuulFilters.size(); i++,j++) &#123;</span><br><span class="line">        filters[i] = zuulFilters.get(j);</span><br><span class="line">    &#125;</span><br><span class="line">    filters[filters.length -<span class="number">1</span>] = stop;</span><br><span class="line">    <span class="keyword">return</span> filters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里返回了一个 <code>ZuulFilter</code> 的数组，开始分别是 <code>start</code> 和 <code>stop</code> 对应的刚好是 <code>OutboundPassportStampingFilter</code>。</p>
<p>然我们继续回到 <code>addZuulFilterChainHandler()</code> 函数上来，我们发现有三段相似的代码正好对应着获得了 <code>InBound</code><br>
<code>OutBond</code> <code>EndPoint</code> 这三种Filter，在代码我们可以看出顺序是</p>
<ol>
<li><code>requestFilters</code> 和 <code>endPointFilters</code> 合并成 <code>requestFilterChain</code></li>
<li><code>responseFilters</code> 构建成 <code>responseFilterChain</code></li>
<li><code>requestFilterChain</code> 和 <code>responseFilterChain</code> 组合成 <code>ZuulFilterChainHandler</code></li>
<li>将 <code>ZuulFilterChainHandler</code> 添加至 <code>pipeline</code> 中</li>
</ol>
<p>那这里我们还有一个疑问，这些Filter是从何而来的？这个答案隐藏在<br>
<code>com.netflix.zuul.FilterLoader#getFiltersByType</code> 中，通过简单的跟踪我们可以得到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Collection&lt;ZuulFilter&gt; <span class="title function_">getAllFilters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.filters.values(); ➊</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里 ➊ 获得所有的Fiter，而这里的Filter看起来是通过 <code>Put</code>进来的，通过一个简单的断点，我们就可以发现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.netflix.zuul.FilterFileManager#init</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;    </span><br><span class="line">    filterLoader.putFiltersForClasses(config.getClassNames()); ➊</span><br><span class="line">    manageFiles();</span><br><span class="line">    startPoller();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 我们通过类的全称限定类名获得的这个Fitler，这个配置是在我们的配置文件中配置的。</p>
<h2 id="2-3-休息"><a class="header-anchor" href="#2-3-休息">¶</a>2/3 休息</h2>
<p>文至中场，我们已经明白了Zuul2如何将自己的 <code>ZuulFilter</code> 变换成 <code>Netty Handler</code> 并添加到 <code>Netty Pipeline</code> 之中的，那我们还剩下一个问题，这个 <code>ZuulFilter</code> 是如何运作的。但是我们在上段中，我们已经发现了最后是一个 <code>ZuulFilterChainHandler</code> 通过名称我们可以推测出，这是一个 <code>Chain 链</code>，我们继续往下探索吧。</p>
<h2 id="ZuulFilterChainHandler"><a class="header-anchor" href="#ZuulFilterChainHandler">¶</a>ZuulFilterChainHandler</h2>
<p>我们知道，最终注册到 <code>Netty Pipeline</code> 上的最终肯定是 <code>Handler</code>, 我们只需要从 Netty 的 <code>channelRead()</code> 函数作为突破口去阅读。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequestMessage) &#123; ➊</span><br><span class="line">        zuulRequest = (HttpRequestMessage)msg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Replace NETTY_SERVER_CHANNEL_HANDLER_CONTEXT in SessionContext</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">SessionContext</span> <span class="variable">zuulCtx</span> <span class="operator">=</span> zuulRequest.getContext();</span><br><span class="line">        zuulCtx.put(NETTY_SERVER_CHANNEL_HANDLER_CONTEXT, ctx);</span><br><span class="line">        zuulCtx.put(ZUUL_FILTER_CHAIN, requestFilterChain);</span><br><span class="line"></span><br><span class="line">        requestFilterChain.filter(zuulRequest); ➋</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((msg <span class="keyword">instanceof</span> HttpContent)&amp;&amp;(zuulRequest != <span class="literal">null</span>)) &#123;  ➌</span><br><span class="line">        requestFilterChain.filter(zuulRequest, (HttpContent) msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG.debug(<span class="string">&quot;Received unrecognized message type. &quot;</span> + msg.getClass().getName());</span><br><span class="line">        ReferenceCountUtil.release(msg); ➍</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 这段逻辑处理 已经被转化为 <code>HttpRequestMessage</code> 类型的消息<br>
➋ 实际上的 filter 处理逻辑<br>
➌ 处理还没被转化为 <code>HttpRequestMessage</code> 类型的消息<br>
➍ 无法处理抛出异常，释放MSG</p>
<p>而这里的 <code>requestFilterChain</code> 就是之前我们传入进去的 <code>ZuulFilterChainRunner</code> 我们看看这 <code>filter()</code> 函数做了什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.netflix.zuul.netty.filter.ZuulFilterChainRunner#runFilters </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runFilters</span><span class="params">(<span class="keyword">final</span> T mesg, <span class="keyword">final</span> AtomicInteger runningFilterIdx)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">inMesg</span> <span class="operator">=</span> mesg;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(mesg, <span class="string">&quot;Input message&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> runningFilterIdx.get(); ➊</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; filters.length) &#123;</span><br><span class="line">            <span class="keyword">final</span> ZuulFilter&lt;T, T&gt; filter = filters[i]; ➋</span><br><span class="line">            filterName = filter.filterName();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">T</span> <span class="variable">outMesg</span> <span class="operator">=</span> filter(filter, inMesg); ➌</span><br><span class="line">            <span class="keyword">if</span> (outMesg == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">//either async filter or waiting for the message body to be buffered</span></span><br><span class="line">            &#125;</span><br><span class="line">            inMesg = outMesg;</span><br><span class="line">            i = runningFilterIdx.incrementAndGet(); ➍</span><br><span class="line">        &#125;</span><br><span class="line">        invokeNextStage(inMesg); ➎</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 获得当前运行的Filter的下标值<br>
➋ 获得对应的 <code>ZuulFilter</code><br>
➌ 调用 <code>ZuulFilter</code> 进行处理<br>
➍ 将下标志值 +1，继续循环体<br>
➎ 执行下个阶段，这里对应着我们自己再构建 <code>new InboundPassportStampingFilter(FILTERS_INBOUND_END)</code></p>
<p>通过这段代码，我们知道了 <code>Zuul2</code> 的Chain是由 <code>ChainRunner</code>运行，和Netty的Head tail的链方式大相径庭。<br>
在 <code>BaseZuulFilterRunner</code> 中的 <code>filter()</code> 函数也相当有趣。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.netflix.zuul.netty.filter.BaseZuulFilterRunner#filter </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> O <span class="title function_">filter</span><span class="params">(<span class="keyword">final</span> ZuulFilter&lt;I, O&gt; filter, <span class="keyword">final</span> I inMesg)</span> &#123;</span><br><span class="line">  filter.incrementConcurrency();</span><br><span class="line">    resumer = <span class="keyword">new</span> <span class="title class_">FilterChainResumer</span>(inMesg, filter, snapshot, startTime); ➊</span><br><span class="line">    filter.applyAsync(inMesg) ➋</span><br><span class="line">        .observeOn(Schedulers.from(getChannelHandlerContext(inMesg).executor()))  ➌</span><br><span class="line">        .doOnUnsubscribe(resumer::decrementConcurrency)</span><br><span class="line">        .subscribe(resumer);  ➍</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">//wait for the async filter to finish</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 临时存储起来这个Filter待异步完成回调<br>
➋ 具体的执行处<br>
➌ 获取当前的所在的 <code>EventExecutor</code> 并在这个线程上观察<br>
➍ 将数据在 resumer 中消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(O outMesg)</span> &#123;  ➊</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        recordFilterCompletion(SUCCESS, filter, startTime, inMesg, snapshot);</span><br><span class="line">        <span class="keyword">if</span> (outMesg == <span class="literal">null</span>) &#123;</span><br><span class="line">            outMesg = filter.getDefaultOutput(inMesg);</span><br><span class="line">        &#125;</span><br><span class="line">        resumeInBindingContext(outMesg, filter.filterName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 处获得我们的结果并将其恢复到我们保管的 <code>filter</code>。</p>
<p>剩余关于 <code>ReponseFilter</code> 的运行机制是类似的，诸位看官自行分析下。</p>
<h2 id="终场休息"><a class="header-anchor" href="#终场休息">¶</a>终场休息</h2>
<p>通过上面的一系列分析，我们已经知道的，Zuul的 <code>调用链模型</code>，<code>PreFilters</code>的运行机制，整个Zuul2的运行机制在我们的面前一览无遗。整体的Zuul代码是相当的明了的，代码的分层也很好，但是还有一朵乌云在我们的头顶之上，那就是在那张途中的 <code>Netty Client</code> 我们并没有发现其踪迹，但是我们知道只有在 <code>End</code> 阶段，我们才会对外进行访问，在官网的Wiki中，我们也可以获得</p>
<blockquote>
<p>Zuul does not use Ribbon for making outgoing connections and instead uses its own connection pool, using a Netty client. Zuul creates a connection pool per host, per event loop. It does this in order to reduce context switching between threads and to ensure sanity for both the inbound event loops and outbound event loops. The result is that the entire request is run on the same thread, regardless of which event loop is running it.</p>
</blockquote>
<p>我们从 <code>Wiki</code> 中可以得知，Netty不再默认使用 Ribbon 而是默认使用 <code>Netty</code> 作为一个 <code>Client</code>.</p>
<h2 id="ProxyEndpoint"><a class="header-anchor" href="#ProxyEndpoint">¶</a>ProxyEndpoint</h2>
<p>这个类的对象及其的复杂，我们从filter的核心逻辑 <code>apply</code>看起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> HttpResponseMessage <span class="title function_">apply</span><span class="params">(<span class="keyword">final</span> HttpRequestMessage input)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        origin.getProxyTiming(zuulRequest).start();</span><br><span class="line">        origin.onRequestExecutionStart(zuulRequest, <span class="number">1</span>);</span><br><span class="line">        proxyRequestToOrigin(); ➊</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 将请求转发至远端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">proxyRequestToOrigin</span><span class="params">()</span> &#123;</span><br><span class="line">    Promise&lt;PooledConnection&gt; promise = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        promise = origin.connectToOrigin(zuulRequest, channelCtx.channel().eventLoop(), attemptNum, passport, chosenServer); ➊</span><br><span class="line"></span><br><span class="line">        currentRequestAttempt = origin.newRequestAttempt(chosenServer.get(), context, attemptNum); </span><br><span class="line">        <span class="keyword">if</span> (promise.isDone()) &#123;</span><br><span class="line">            operationComplete(promise); ➋</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            promise.addListener(<span class="built_in">this</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 处将请求包装，连接到远端地址，获得 Promise<br>
➋ 结束的 Promise 处理，在 <code>operationComplete()</code> 中包含了成功的执行代码，至于 <code>connectToOrigin</code> Zuul 包装了 Netty的Client。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeClientRequestToOrigin</span><span class="params">(<span class="keyword">final</span> PooledConnection conn)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">ch</span> <span class="operator">=</span> conn.getChannel(); ➊</span><br><span class="line"></span><br><span class="line">    ch.write(zuulRequest);   ➋</span><br><span class="line">    writeBufferedBodyContent(zuulRequest, ch);</span><br><span class="line">    ch.flush(); ➌</span><br><span class="line">    <span class="comment">//Get ready to read origin&#x27;s response</span></span><br><span class="line">    ch.read(); ➍</span><br><span class="line"></span><br><span class="line">    originConn = conn;</span><br><span class="line">    channelCtx.read(); ➎</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➊ 获得建立的连接<br>
➋ 写入Zuul的请求，也就是用户的请求<br>
➌ 将消息Flush出去<br>
➍ 在这里读取响应的数据，也就是触发 <code>OutBoundHandler</code> 的处理时间</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>Zuul整体逻辑，我们通过博文可以分析而出。</p>
<ol>
<li>ZuulFilter 分为 <code>Inbound</code>, <code>Outbound</code>, <code>EndPoint</code></li>
<li><code>Inbound</code>, <code>Outbound</code>, <code>EndPoint</code> 包裹成 <code>ChainRunner</code></li>
<li><code>ChainRunner</code> 组合成一个 <code>ZuulFilterChainHandler</code>，而 <code>ZuulFilterChainHandler</code> 是Netty的 一个Handler</li>
<li><code>ZuulFilterChainHandler</code> 会组装到 Netty 的 <code>Pipeline</code> 中，剩下来就是Netty的流程了</li>
</ol>
<h2 id="参考知识"><a class="header-anchor" href="#参考知识">¶</a>参考知识</h2>
<ul>
<li><a href="https://gank.io/post/560e15be2dca930e00da1083">给 Android 开发者的 RxJava 详解</a></li>
<li><a href="https://segmentfault.com/a/1190000004856071">谜之RxJava （三）update 2 —— subscribeOn 和 observeOn 的区别</a></li>
<li><a href="https://github.com/Netflix/zuul/wiki">Zuul-Wiki</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
        <category>微服务</category>
        <category>网关</category>
      </categories>
  </entry>
  <entry>
    <title>Rust Ztunnel 源码分析</title>
    <url>/2023/03/07/networking/istio/ambient-mesh/ztunnel/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2023/202303071736740.png" alt=""></p>
<p>推荐在阅读前，先阅读下<a href="https://istio.io/latest/blog/2023/rust-based-ztunnel/">Introducing Rust-Based Ztunnel for Istio Ambient Service Mesh</a></p>
<span id="more"></span>
<h2 id="Goal"><a class="header-anchor" href="#Goal">¶</a>Goal</h2>
<p>阅读一个开源项目，我们首先要知道它的主要解决的问题是什么，Ztuunel 是一个 L4 的代理服务器，主要解决了 mtls 的问题，正如名字所描述 zero trust tunnel，因此我们需要关注这个项目有两个部分</p>
<ul>
<li>L4 的流量是如何区分和扭转的</li>
<li>mtls 是如何工作的</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2023/202303061459764.png" alt=""></p>
<h2 id="前置知识"><a class="header-anchor" href="#前置知识">¶</a>前置知识</h2>
<ul>
<li>Ztunnel 基于 Tokio(Network库) 和 Hyper(Http库)
<ul>
<li>Tokio 实现了 await async 的编程模型，是无栈的，参考 <a href="https://tokio.rs/tokio/tutorial/async">https://tokio.rs/tokio/tutorial/async</a></li>
</ul>
</li>
</ul>
<h2 id="构建基础"><a class="header-anchor" href="#构建基础">¶</a>构建基础</h2>
<ul>
<li>因为用了 BoringSSL ，当前只支持 Linux</li>
<li>在阅读代码之前记得运行 <code>cargo run build.rs</code> 生成 proto 相关的对象</li>
</ul>
<h2 id="代码架构"><a class="header-anchor" href="#代码架构">¶</a>代码架构</h2>
<p>Ztunnel 大概分成了几个部分</p>
<ul>
<li>Admin: 管理模块，和 Envoy Admin 类似</li>
<li>Stats: 指标模块</li>
<li>Workload Manager: 负载管理模块</li>
<li>Proxy: 代理模块【核心模块】
<ul>
<li>inbound: 入流量处理模式</li>
<li>outbound: 出流量处理模块</li>
<li>socks5: 代理模块</li>
</ul>
</li>
</ul>
<p>整体代码的入口在 <a href="https://github.com/istio/ztunnel/blob/f9672662a0448067ce19d1908907b6f4db8016e0/src/app.rs#L30-L131">build_with_cert</a> 这里就可以看到整个项目的全貌</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">build_with_cert</span>(</span><br><span class="line">    config: config::Config,</span><br><span class="line">    cert_manager: <span class="keyword">impl</span> <span class="title class_">CertificateProvider</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> anyhow::<span class="type">Result</span>&lt;Bound&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">registry</span> = Registry::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">metrics</span> = Arc::<span class="title function_ invoke__">new</span>(Metrics::<span class="title function_ invoke__">from</span>(&amp;<span class="keyword">mut</span> registry));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">certificate_manager</span>: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> CertificateProvider&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(cert_manager);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">shutdown</span> = signal::Shutdown::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="comment">// Setup a drain channel. drain_tx is used to trigger a drain, which will complete</span></span><br><span class="line">    <span class="comment">// once all drain_rx handlers are dropped.</span></span><br><span class="line">    <span class="comment">// Any component which wants time to gracefully exit should take in a drain_rx clone, await drain_rx.signaled(), then cleanup.</span></span><br><span class="line">    <span class="comment">// Note: there is still a hard timeout if the draining takes too long</span></span><br><span class="line">    <span class="keyword">let</span> (drain_tx, drain_rx) = drain::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ready</span> = readiness::Ready::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">proxy_task</span> = ready.<span class="title function_ invoke__">register_task</span>(<span class="string">&quot;proxy listeners&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">workload_manager</span> = workload::WorkloadManager::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        config.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        metrics.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        ready.<span class="title function_ invoke__">register_task</span>(<span class="string">&quot;workload manager&quot;</span>),</span><br><span class="line">        certificate_manager.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    )</span><br><span class="line">    .<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">admin_server</span> = admin::Service::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        config.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        workload_manager.<span class="title function_ invoke__">workloads</span>(),</span><br><span class="line">        shutdown.<span class="title function_ invoke__">trigger</span>(),</span><br><span class="line">        drain_rx.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    )</span><br><span class="line">    .<span class="title function_ invoke__">context</span>(<span class="string">&quot;admin server starts&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stats_server</span> = stats::Service::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        config.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        registry,</span><br><span class="line">        shutdown.<span class="title function_ invoke__">trigger</span>(),</span><br><span class="line">        drain_rx.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    )</span><br><span class="line">    .<span class="title function_ invoke__">context</span>(<span class="string">&quot;stats server starts&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">readiness_server</span> =</span><br><span class="line">        readiness::Service::<span class="title function_ invoke__">new</span>(config.<span class="title function_ invoke__">clone</span>(), ready, shutdown.<span class="title function_ invoke__">trigger</span>(), drain_rx.<span class="title function_ invoke__">clone</span>())</span><br><span class="line">            .<span class="title function_ invoke__">context</span>(<span class="string">&quot;readiness server starts&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">readiness_address</span> = readiness_server.<span class="title function_ invoke__">address</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">admin_address</span> = admin_server.<span class="title function_ invoke__">address</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stats_address</span> = stats_server.<span class="title function_ invoke__">address</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">proxy</span> = proxy::Proxy::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        config.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        workload_manager.<span class="title function_ invoke__">workloads</span>(),</span><br><span class="line">        certificate_manager.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        metrics.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        drain_rx.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    )</span><br><span class="line">    .<span class="keyword">await</span>?;</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(proxy_task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spawn all tasks that should run in the main thread</span></span><br><span class="line">    admin_server.<span class="title function_ invoke__">spawn</span>();</span><br><span class="line">    stats_server.<span class="title function_ invoke__">spawn</span>();</span><br><span class="line">    tokio::<span class="title function_ invoke__">spawn</span>(</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = workload_manager.<span class="title function_ invoke__">run</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">                error!(<span class="string">&quot;workload manager: &#123;&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="title function_ invoke__">in_current_span</span>(),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">proxy_addresses</span> = proxy.<span class="title function_ invoke__">addresses</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">span</span> = tracing::span::Span::<span class="title function_ invoke__">current</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_span</span> = span.<span class="title function_ invoke__">enter</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">runtime</span> = tokio::runtime::Builder::<span class="title function_ invoke__">new_multi_thread</span>()</span><br><span class="line">            .<span class="title function_ invoke__">worker_threads</span>(config.num_worker_threads)</span><br><span class="line">            .<span class="title function_ invoke__">thread_name_fn</span>(|| &#123;</span><br><span class="line">                <span class="keyword">static</span> ATOMIC_ID: AtomicUsize = AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">id</span> = ATOMIC_ID.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::SeqCst);</span><br><span class="line">                <span class="built_in">format!</span>(<span class="string">&quot;ztunnel-proxy-&#123;id&#125;&quot;</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">            .<span class="title function_ invoke__">enable_all</span>()</span><br><span class="line">            .<span class="title function_ invoke__">build</span>()</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        runtime.<span class="title function_ invoke__">block_on</span>(</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">                readiness_server.<span class="title function_ invoke__">spawn</span>();</span><br><span class="line">                proxy.<span class="title function_ invoke__">run</span>().<span class="title function_ invoke__">in_current_span</span>().<span class="keyword">await</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            .<span class="title function_ invoke__">in_current_span</span>(),</span><br><span class="line">        );</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(Bound &#123;</span><br><span class="line">        drain_tx,</span><br><span class="line">        config,</span><br><span class="line">        shutdown,</span><br><span class="line">        readiness_address,</span><br><span class="line">        admin_address,</span><br><span class="line">        stats_address,</span><br><span class="line">        proxy_addresses,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Proxy-模块"><a class="header-anchor" href="#Proxy-模块">¶</a>Proxy 模块</h2>
<p>我们先来看看 Proxy 模块，代码并不多在 <a href="https://github.com/istio/ztunnel/tree/f9672662a0448067ce19d1908907b6f4db8016e0/src/proxy">https://github.com/istio/ztunnel/tree/f9672662a0448067ce19d1908907b6f4db8016e0/src/proxy</a> 中，只有几个文件。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── inbound.rs</span><br><span class="line">├── inbound_passthrough.rs</span><br><span class="line">├── outbound.rs</span><br><span class="line">├── socks5.rs</span><br><span class="line">└── util.rs</span><br></pre></td></tr></table></figure>
<p>Proxy 承担了整个系统的数据扭转部分的逻辑，非常的重要，基于 Tokio 和 Hyper，非常简单的就实现了整体逻辑。</p>
<h3 id="Outbound-模块"><a class="header-anchor" href="#Outbound-模块">¶</a>Outbound 模块</h3>
<p><a href="https://github.com/istio/ztunnel/blob/f9672662a0448067ce19d1908907b6f4db8016e0/src/proxy/outbound.rs#L65-L98">Outbound::new</a>是一个非常简单的函数，也就是启动一个 Socket 来 Accept 请求，并且通过一个 <code>loop</code> 来不断的建立新链接。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">run</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">accept</span> = <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="comment">// Asynchronously wait for an inbound socket.</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">socket</span> = <span class="keyword">self</span>.listener.<span class="title function_ invoke__">accept</span>().<span class="keyword">await</span>;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">start_outbound_instant</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">            <span class="keyword">match</span> socket &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>((stream, _remote)) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">oc</span> = OutboundConnection &#123;</span><br><span class="line">                        pi: <span class="keyword">self</span>.pi.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                        id: TraceParent::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">span</span> = info_span!(<span class="string">&quot;outbound&quot;</span>, id=%oc.id);</span><br><span class="line">                    tokio::<span class="title function_ invoke__">spawn</span>(</span><br><span class="line">                        (<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> <span class="variable">res</span> = oc.<span class="title function_ invoke__">proxy</span>(stream).<span class="keyword">await</span>;</span><br><span class="line">                            <span class="keyword">match</span> res &#123;</span><br><span class="line">                                <span class="title function_ invoke__">Ok</span>(_) =&gt; info!(dur=?start_outbound_instant.<span class="title function_ invoke__">elapsed</span>(), <span class="string">&quot;complete&quot;</span>),</span><br><span class="line">                                <span class="title function_ invoke__">Err</span>(e) =&gt; warn!(dur=?start_outbound_instant.<span class="title function_ invoke__">elapsed</span>(), err=%e, <span class="string">&quot;failed&quot;</span>)</span><br><span class="line">                            &#125;;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .<span class="title function_ invoke__">instrument</span>(span),</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">                    error!(<span class="string">&quot;Failed TCP handshake &#123;&#125;&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.<span class="title function_ invoke__">in_current_span</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主体的逻辑在 <code>OutboundConnection</code> 中 <code> let res = oc.proxy(stream).await;</code> 也就是主体逻辑。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">proxy</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, stream: TcpStream) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">peer</span> = socket::<span class="title function_ invoke__">to_canonical</span>(stream.<span class="title function_ invoke__">peer_addr</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;must receive peer addr&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">orig_dst_addr</span> = socket::<span class="title function_ invoke__">orig_dst_addr_or_default</span>(&amp;stream);</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">proxy_to</span>(stream, peer.<span class="title function_ invoke__">ip</span>(), orig_dst_addr, <span class="literal">false</span>).<span class="keyword">await</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就来到我们正菜部分，<a href="https://github.com/istio/ztunnel/blob/f9672662a0448067ce19d1908907b6f4db8016e0/src/proxy/outbound.rs#L123-L314"><code>proxy_to</code></a> 就是所有的逻辑了。这部分比较多，拆分解释</p>
<p>根据 IP 来构建转发请求，这里需要的 Source(remote_addr) 和 Dest(orig_dst_addr) 两个地址，这里就可能进入三种状态</p>
<ol>
<li>passthrought: 找不到 dest</li>
<li>上下游都找到是走 mtls
<ol>
<li>有 waypoint 就去 waypoint</li>
<li>没有就去另外一个节点的 ztunnel</li>
</ol>
</li>
<li>error</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">req</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">build_request</span>(remote_addr, orig_dst_addr).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">build_request</span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        downstream: IpAddr,</span><br><span class="line">        target: SocketAddr,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Request, Error&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据 IP 来判断 source_workload ，找不到就走 Err 了</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">source_workload</span> = <span class="keyword">match</span> <span class="keyword">self</span>.pi.workloads.<span class="title function_ invoke__">fetch_workload</span>(&amp;downstream).<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(wl) =&gt; wl,</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">UnknownSource</span>(downstream)),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">us</span> = <span class="keyword">self</span>.pi.workloads.<span class="title function_ invoke__">find_upstream</span>(target, <span class="keyword">self</span>.pi.hbone_port).<span class="keyword">await</span>;</span><br><span class="line">     <span class="comment">// 找不到 dest， passthrought 掉这个请求</span></span><br><span class="line">    <span class="keyword">if</span> us.<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(Request &#123;</span><br><span class="line">            protocol: Protocol::TCP,</span><br><span class="line">            request_type: RequestType::Passthrough,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">us</span> = us.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// 这里如果找到 waypoint 走 waypoint</span></span><br><span class="line">    <span class="keyword">if</span> !us.workload.waypoint_addresses.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">waypoint_address</span> = us.workload.<span class="title function_ invoke__">choose_waypoint_address</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(Request &#123;</span><br><span class="line">            <span class="comment">// Always use HBONE here</span></span><br><span class="line">            protocol: Protocol::HBONE,</span><br><span class="line">            source: source_workload,</span><br><span class="line">            request_type: RequestType::ToServerWaypoint,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> us.workload.gateway_address.<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">NoGatewayAddress</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(us.workload.<span class="title function_ invoke__">clone</span>())));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有个优化路径，如果访问的对方和本地在同一个 NODE 上直接走 local，这里skip了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有目标地址的 waypoint 就走正常的 ztunnel 路径</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(Request &#123;</span><br><span class="line">        protocol: us.workload.protocol,</span><br><span class="line">        source: source_workload,</span><br><span class="line">        destination: SocketAddr::<span class="title function_ invoke__">from</span>((us.workload.workload_ip, us.port)),</span><br><span class="line">        destination_workload: <span class="title function_ invoke__">Some</span>(us.workload.<span class="title function_ invoke__">clone</span>()),</span><br><span class="line">        expected_identity: <span class="title function_ invoke__">Some</span>(us.workload.<span class="title function_ invoke__">identity</span>()),</span><br><span class="line">        gateway: us</span><br><span class="line">            .workload</span><br><span class="line">            .gateway_address</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;gateway address confirmed&quot;</span>),</span><br><span class="line">        direction: Direction::Outbound,</span><br><span class="line">        request_type: RequestType::Direct,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当完成了这一步的时候，我们已经构建好了目标请求。让我们回到 <code>proxy_to</code>，之后，我们需要通过协议来判断我们应该走哪个分支， TCP 是非常的简单的，我们重点看看另外一个路径上的 HBONE</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> req.protocol &#123;</span><br><span class="line">        Protocol::HBONE =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Protocol::TCP =&gt; &#123;</span><br><span class="line">            <span class="comment">// 创建一个 TCP 链接</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">local</span> = <span class="keyword">if</span> <span class="keyword">self</span>.pi.cfg.enable_original_source.<span class="title function_ invoke__">unwrap_or_default</span>() &#123;</span><br><span class="line">                super::<span class="title function_ invoke__">get_original_src_from_stream</span>(&amp;stream)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="literal">None</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">outbound</span> = super::<span class="title function_ invoke__">freebind_connect</span>(local, req.gateway).<span class="keyword">await</span>?;</span><br><span class="line">            <span class="comment">// 直接 proxy 数据就好了</span></span><br><span class="line">            proxy::<span class="title function_ invoke__">relay</span>(</span><br><span class="line">                &amp;<span class="keyword">mut</span> stream,</span><br><span class="line">                &amp;<span class="keyword">mut</span> outbound,</span><br><span class="line">                &amp;<span class="keyword">self</span>.pi.metrics,</span><br><span class="line">                transferred_bytes,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.solo.io/blog/understanding-istio-ambient-ztunnel-and-secure-overlay/">HBONE</a> 是一个代理协议，工作在 HTTP 那一层。我们看看这里如何处理的。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">builder</span> = hyper::client::conn::Builder::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="comment">// 构建一个 Builder，主要调整了一些 HTTP 的参数</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">builder</span> = builder</span><br><span class="line">    .<span class="title function_ invoke__">http2_only</span>(<span class="literal">true</span>)</span><br><span class="line">    .<span class="title function_ invoke__">http2_initial_stream_window_size</span>(<span class="keyword">self</span>.pi.cfg.window_size)</span><br><span class="line">    .<span class="title function_ invoke__">http2_max_frame_size</span>(<span class="keyword">self</span>.pi.cfg.frame_size)</span><br><span class="line">    .<span class="title function_ invoke__">http2_initial_connection_window_size</span>(<span class="keyword">self</span>.pi.cfg.connection_window_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = http_types::proxies::Forwarded::<span class="title function_ invoke__">new</span>();</span><br><span class="line">f.<span class="title function_ invoke__">add_for</span>(remote_addr.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 HBONE 的 Request，就是一个 Connect 请求</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">request</span> = hyper::Request::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">    .<span class="title function_ invoke__">uri</span>(&amp;req.destination.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    .<span class="title function_ invoke__">method</span>(hyper::Method::CONNECT)</span><br><span class="line">    .<span class="title function_ invoke__">version</span>(hyper::Version::HTTP_2)</span><br><span class="line">    .<span class="title function_ invoke__">header</span>(BAGGAGE_HEADER, <span class="title function_ invoke__">baggage</span>(&amp;req))</span><br><span class="line">    .<span class="title function_ invoke__">header</span>(FORWARDED, f.<span class="title function_ invoke__">value</span>().<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">    .<span class="title function_ invoke__">header</span>(TRACEPARENT_HEADER, <span class="keyword">self</span>.id.<span class="title function_ invoke__">header</span>())</span><br><span class="line">    .<span class="title function_ invoke__">body</span>(hyper::Body::<span class="title function_ invoke__">empty</span>())</span><br><span class="line">    .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">local</span> = <span class="keyword">self</span>.pi.cfg.enable_original_source.<span class="title function_ invoke__">unwrap_or_default</span>().<span class="title function_ invoke__">then_some</span>(remote_addr);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">id</span> = &amp;req.source.<span class="title function_ invoke__">identity</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里构建 TLS 的证书管理</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">cert</span> = <span class="keyword">self</span>.pi.cert_manager.<span class="title function_ invoke__">fetch_certificate</span>(id).<span class="keyword">await</span>?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">connector</span> = cert</span><br><span class="line">    .<span class="title function_ invoke__">connector</span>(req.expected_identity.<span class="title function_ invoke__">as_ref</span>())?</span><br><span class="line">    .<span class="title function_ invoke__">configure</span>()</span><br><span class="line">    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;configure&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的 TCP 连接</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">tcp_stream</span> = super::<span class="title function_ invoke__">freebind_connect</span>(local, req.gateway).<span class="keyword">await</span>?;</span><br><span class="line">tcp_stream.<span class="title function_ invoke__">set_nodelay</span>(<span class="literal">true</span>)?;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的 TLS 连接（over TCP），然后去握手</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">tls_stream</span> = <span class="title function_ invoke__">connect_tls</span>(connector, tcp_stream).<span class="keyword">await</span>?;</span><br><span class="line"><span class="keyword">let</span> (<span class="keyword">mut</span> request_sender, connection) = builder</span><br><span class="line">    .<span class="title function_ invoke__">handshake</span>(tls_stream)</span><br><span class="line">    .<span class="keyword">await</span></span><br><span class="line">    .<span class="title function_ invoke__">map_err</span>(Error::HttpHandshake)?;</span><br><span class="line"><span class="comment">// spawn a task to poll the connection and drive the HTTP state</span></span><br><span class="line">tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = connection.<span class="keyword">await</span> &#123;</span><br><span class="line">        error!(<span class="string">&quot;Error in HBONE connection handshake: &#123;:?&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 HTTP Req</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">response</span> = request_sender.<span class="title function_ invoke__">send_request</span>(request).<span class="keyword">await</span>?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">code</span> = response.<span class="title function_ invoke__">status</span>();</span><br><span class="line"><span class="keyword">if</span> code != <span class="number">200</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">HttpStatus</span>(code));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等到 upgraded 成功</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">upgraded</span> = hyper::upgrade::<span class="title function_ invoke__">on</span>(response).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动传输任务</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">res</span> = super::<span class="title function_ invoke__">copy_hbone</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> upgraded,</span><br><span class="line">    &amp;<span class="keyword">mut</span> stream,</span><br><span class="line">    &amp;<span class="keyword">self</span>.pi.metrics,</span><br><span class="line">    transferred_bytes,</span><br><span class="line">)</span><br><span class="line">.<span class="title function_ invoke__">instrument</span>(trace_span!(<span class="string">&quot;hbone client&quot;</span>))</span><br><span class="line">.<span class="keyword">await</span>;</span><br><span class="line">res</span><br></pre></td></tr></table></figure>
<p>不过注意，这里还没有真的去传输数据，只是将传输的准备做好，逻辑在 copy_hbone 内，在 copy_hbone 调用的时候，我们已经建立好 HBONE 所需要的 HTTP 链接了。所有有<a href="https://github.com/istio/ztunnel/blob/f9672662a0448067ce19d1908907b6f4db8016e0/src/proxy.rs#L166-L203">如下代码</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">copy_hbone</span>(</span><br><span class="line">    upgraded: &amp;<span class="keyword">mut</span> hyper::upgrade::Upgraded,</span><br><span class="line">    stream: &amp;<span class="keyword">mut</span> TcpStream,</span><br><span class="line">    metrics: <span class="keyword">impl</span> <span class="title class_">AsRef</span>&lt;Metrics&gt;,</span><br><span class="line">    transferred_bytes: traffic::BytesTransferred&lt;<span class="symbol">&#x27;_</span>&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">use</span> tokio::io::AsyncWriteExt;</span><br><span class="line">    <span class="comment">// 把输出端的 HTTP 拆分成 read 和 write 2个方向</span></span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> ri, <span class="keyword">mut</span> wi) = tokio::io::<span class="title function_ invoke__">split</span>(upgraded);</span><br><span class="line">    <span class="comment">// 把输入端的 TCP 拆分成 read 和 write 2个方向</span></span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> ro, <span class="keyword">mut</span> wo) = stream.<span class="title function_ invoke__">split</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> sent, <span class="keyword">mut</span> received): (<span class="type">u64</span>, <span class="type">u64</span>) = (<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来回传递就好了</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client_to_server</span> = <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ri</span> = tokio::io::BufReader::<span class="title function_ invoke__">with_capacity</span>(HBONE_BUFFER_SIZE, &amp;<span class="keyword">mut</span> ri);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">wo</span> = tokio::io::BufWriter::<span class="title function_ invoke__">with_capacity</span>(HBONE_BUFFER_SIZE, &amp;<span class="keyword">mut</span> wo);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = tokio::io::<span class="title function_ invoke__">copy</span>(&amp;<span class="keyword">mut</span> ri, &amp;<span class="keyword">mut</span> wo).<span class="keyword">await</span>;</span><br><span class="line">        trace!(?res, <span class="string">&quot;hbone -&gt; tcp&quot;</span>);</span><br><span class="line">        received = res?;</span><br><span class="line">        wo.<span class="title function_ invoke__">shutdown</span>().<span class="keyword">await</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">server_to_client</span> = <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ro</span> = tokio::io::BufReader::<span class="title function_ invoke__">with_capacity</span>(HBONE_BUFFER_SIZE, &amp;<span class="keyword">mut</span> ro);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">wi</span> = tokio::io::BufWriter::<span class="title function_ invoke__">with_capacity</span>(HBONE_BUFFER_SIZE, &amp;<span class="keyword">mut</span> wi);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = tokio::io::<span class="title function_ invoke__">copy</span>(&amp;<span class="keyword">mut</span> ro, &amp;<span class="keyword">mut</span> wi).<span class="keyword">await</span>;</span><br><span class="line">        trace!(?res, <span class="string">&quot;tcp -&gt; hbone&quot;</span>);</span><br><span class="line">        sent = res?;</span><br><span class="line">        wi.<span class="title function_ invoke__">shutdown</span>().<span class="keyword">await</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把任务压入执行器里面</span></span><br><span class="line">    tokio::try_join!(client_to_server, server_to_client)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Inbound-模块"><a class="header-anchor" href="#Inbound-模块">¶</a>Inbound 模块</h3>
<p>有了 outbound 的经验，看 Inbound 就相对的简单很多。因为 Inbound 接受的只有 HBONE，先在创建 Inbound 的时候需要一个 HTTP Server，这就是主要的初始化部分</p>
<h4 id="初始化"><a class="header-anchor" href="#初始化">¶</a>初始化</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">acceptor</span> = InboundCertProvider &#123;</span><br><span class="line">    workloads: <span class="keyword">self</span>.workloads.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    cert_manager: <span class="keyword">self</span>.cert_manager.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 TLS 的 stream</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">tls_stream</span> = crate::hyper_util::<span class="title function_ invoke__">tls_server</span>(acceptor, <span class="keyword">self</span>.listener);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于上诉的再去构建一个 Hyper 的 HTTP 服务</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">incoming</span> = hyper::server::accept::<span class="title function_ invoke__">from_stream</span>(tls_stream);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">server</span> = Server::<span class="title function_ invoke__">builder</span>(incoming)</span><br><span class="line">    .<span class="title function_ invoke__">http2_only</span>(<span class="literal">true</span>)</span><br><span class="line">    .<span class="title function_ invoke__">http2_initial_stream_window_size</span>(<span class="keyword">self</span>.cfg.window_size)</span><br><span class="line">    .<span class="title function_ invoke__">http2_initial_connection_window_size</span>(<span class="keyword">self</span>.cfg.connection_window_size)</span><br><span class="line">    .<span class="title function_ invoke__">http2_max_frame_size</span>(<span class="keyword">self</span>.cfg.frame_size)</span><br><span class="line">    .<span class="title function_ invoke__">serve</span>(service)</span><br><span class="line">    .<span class="title function_ invoke__">with_graceful_shutdown</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="comment">// Wait until the drain is signaled</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shutdown</span> = <span class="keyword">self</span>.drain.<span class="title function_ invoke__">signaled</span>().<span class="keyword">await</span>;</span><br><span class="line">        <span class="comment">// Once `shutdown` is dropped, we are declaring the drain is complete. Hyper will start draining</span></span><br><span class="line">        <span class="comment">// once with_graceful_shutdown function exists, so we need to exit the function but later</span></span><br><span class="line">        <span class="comment">// drop `shutdown`.</span></span><br><span class="line">        <span class="keyword">if</span> tx.<span class="title function_ invoke__">send</span>(shutdown).<span class="title function_ invoke__">is_err</span>() &#123;</span><br><span class="line">            error!(<span class="string">&quot;HBONE receiver dropped&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        info!(<span class="string">&quot;starting drain of inbound connections&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="建立链接"><a class="header-anchor" href="#建立链接">¶</a>建立链接</h4>
<p>显然 <code>serve</code> 逻辑就是在下面的 <a href="https://github.com/istio/ztunnel/blob/f9672662a0448067ce19d1908907b6f4db8016e0/src/proxy/inbound.rs#L241-L353"><code>serve_connect</code></a>，用来处理建立的新链接，这里只需要处理 Connect 请求即可，其他 404 就可以了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> req.<span class="title function_ invoke__">method</span>() &#123;</span><br><span class="line">    &amp;Method::CONNECT =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Return the 404 Not Found for other routes.</span></span><br><span class="line">    method =&gt; &#123;</span><br><span class="line">        info!(<span class="string">&quot;Sending 404, got &#123;method&#125;&quot;</span>);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Response::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">            .<span class="title function_ invoke__">status</span>(hyper::StatusCode::NOT_FOUND)</span><br><span class="line">            .<span class="title function_ invoke__">body</span>(Body::<span class="title function_ invoke__">empty</span>())</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Outbound 里面我们已经知道，这里期望返回 200 就好了，而在 Inbound 里面也就是检查下 mTLS 即可和 RBAC 权限即可</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// Orig has 15008, swap with the real port</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">conn</span> = rbac::Connection &#123; dst: addr, ..conn &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">Some</span>(upstream) = workloads.<span class="title function_ invoke__">fetch_workload</span>(&amp;addr.<span class="title function_ invoke__">ip</span>()).<span class="keyword">await</span> <span class="keyword">else</span> &#123;</span><br><span class="line">    info!(%conn, <span class="string">&quot;unknown destination&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(Response::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">        .<span class="title function_ invoke__">status</span>(StatusCode::NOT_FOUND)</span><br><span class="line">        .<span class="title function_ invoke__">body</span>(Body::<span class="title function_ invoke__">empty</span>())</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;;</span><br><span class="line">!workloads.<span class="title function_ invoke__">assert_rbac</span>(&amp;conn).<span class="keyword">await</span> &#123;</span><br><span class="line">    info!(%conn, <span class="string">&quot;RBAC rejected&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(Response::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">        .<span class="title function_ invoke__">status</span>(StatusCode::UNAUTHORIZED)</span><br><span class="line">        .<span class="title function_ invoke__">body</span>(Body::<span class="title function_ invoke__">empty</span>())</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过在这里需要注意有两种请求，</p>
<ol>
<li>
<p>zTunnel &lt;–&gt; zTunnel<br>
<img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2023/202303071350215.png" alt=""></p>
</li>
<li>
<p>zTunnel &lt;–&gt; Waypoint<br>
<img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2023/202303071352265.png" alt=""></p>
</li>
</ol>
<p>因此在处理上也略有不同</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// waypoint 请求是不检查</span></span><br><span class="line"><span class="keyword">if</span> from_waypoint &#123;</span><br><span class="line">    debug!(<span class="string">&quot;request from waypoint, skipping policy&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !workloads.<span class="title function_ invoke__">assert_rbac</span>(&amp;conn).<span class="keyword">await</span> &#123;</span><br><span class="line">    info!(%conn, <span class="string">&quot;RBAC rejected&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(Response::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">        .<span class="title function_ invoke__">status</span>(StatusCode::UNAUTHORIZED)</span><br><span class="line">        .<span class="title function_ invoke__">body</span>(Body::<span class="title function_ invoke__">empty</span>())</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// waypoint 可信，从 Header 里面拿 Forward Header 作为来源 IP</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">source_ip</span> = <span class="keyword">if</span> from_waypoint &#123;</span><br><span class="line">    super::<span class="title function_ invoke__">get_original_src_from_fwded</span>(&amp;req).<span class="title function_ invoke__">unwrap_or</span>(conn.src_ip)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    conn.src_ip</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充来源即可 </span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">source</span> = workloads.<span class="title function_ invoke__">fetch_workload</span>(&amp;source_ip).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 紧接着就是处理 Inbound 的请求即可</span></span><br><span class="line"><span class="keyword">Self</span>::<span class="title function_ invoke__">handle_inbound</span>(</span><br><span class="line">    <span class="title function_ invoke__">Hbone</span>(req),</span><br><span class="line">    enable_original_source.<span class="title function_ invoke__">then_some</span>(source_ip),</span><br><span class="line">    addr,</span><br><span class="line">    metrics,</span><br><span class="line">    connection_metrics,</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="处理请求"><a class="header-anchor" href="#处理请求">¶</a>处理请求</h4>
<p>处理请求就和 Outbound 非常的接近了，读写即可。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stream</span> = stream;</span><br><span class="line">stream.<span class="title function_ invoke__">set_nodelay</span>(<span class="literal">true</span>)?;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Runtime 里面去执行下面的 CodeBlock 任务</span></span><br><span class="line">tokio::task::<span class="title function_ invoke__">spawn</span>(</span><br><span class="line">    (<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_connection_close</span> = metrics</span><br><span class="line">            .increment_defer::&lt;_, traffic::ConnectionClose&gt;(&amp;connection_metrics);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_extra_conn_close</span> = extra_connection_metrics</span><br><span class="line">            .<span class="title function_ invoke__">as_ref</span>()</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|co| metrics.increment_defer::&lt;_, traffic::ConnectionClose&gt;(co));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">transferred_bytes</span> =</span><br><span class="line">            traffic::BytesTransferred::<span class="title function_ invoke__">from</span>(&amp;connection_metrics);</span><br><span class="line">        <span class="keyword">match</span> request_type &#123;</span><br><span class="line">            <span class="comment">// 预留了没用到</span></span><br><span class="line">            <span class="title function_ invoke__">DirectPath</span>(<span class="keyword">mut</span> incoming) =&gt; &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Hbone 读取 Body 就可以了，和之前 copy_hbone 一样的逻辑</span></span><br><span class="line">            <span class="title function_ invoke__">Hbone</span>(req) =&gt; <span class="keyword">match</span> hyper::upgrade::<span class="title function_ invoke__">on</span>(req).<span class="keyword">await</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="keyword">mut</span> upgraded) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = super::<span class="title function_ invoke__">copy_hbone</span>(</span><br><span class="line">                        &amp;<span class="keyword">mut</span> upgraded,</span><br><span class="line">                        &amp;<span class="keyword">mut</span> stream,</span><br><span class="line">                        &amp;metrics,</span><br><span class="line">                        transferred_bytes,</span><br><span class="line">                    )</span><br><span class="line">                    .<span class="title function_ invoke__">instrument</span>(trace_span!(<span class="string">&quot;hbone server&quot;</span>))</span><br><span class="line">                    .<span class="keyword">await</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        error!(dur=?start.<span class="title function_ invoke__">elapsed</span>(), <span class="string">&quot;hbone server copy: &#123;&#125;&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">                    <span class="comment">// Not sure if this can even happen</span></span><br><span class="line">                    error!(dur=?start.<span class="title function_ invoke__">elapsed</span>(), <span class="string">&quot;No upgrade &#123;e&#125;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_ invoke__">in_current_span</span>(),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="Socks5-模块"><a class="header-anchor" href="#Socks5-模块">¶</a>Socks5 模块</h3>
<p>在 15080 上监听了一个 socks5 模块，但是没有找到具体的用途，先 SKIP 了</p>
<h2 id="Workload-Manger-模块"><a class="header-anchor" href="#Workload-Manger-模块">¶</a>Workload Manger 模块</h2>
<p>我们在 Inbound 和 Outbound 里面都发现了除了扭转 TCP 的请求数据，还需要处理就是身份信息了，在上述代码里面，我们已经看到这么<a href="https://github.com/istio/ztunnel/blob/f9672662a0448067ce19d1908907b6f4db8016e0/src/workload.rs#L238-L242">一个对象</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WorkloadManager</span> &#123;</span><br><span class="line">    workloads: WorkloadInformation,</span><br><span class="line">    xds_client: <span class="type">Option</span>&lt;AdsClient&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(serde::Serialize, Debug, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WorkloadInformation</span> &#123;</span><br><span class="line">    <span class="meta">#[serde(flatten)]</span></span><br><span class="line">    <span class="keyword">pub</span> info: Arc&lt;Mutex&lt;WorkloadStore&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// demand, if present, is used to request on-demand updates for workloads.</span></span><br><span class="line">    <span class="meta">#[serde(skip_serializing)]</span></span><br><span class="line">    <span class="keyword">pub</span> demand: <span class="type">Option</span>&lt;Demander&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(serde::Serialize, Default, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WorkloadStore</span> &#123;</span><br><span class="line">    workloads: HashMap&lt;IpAddr, Workload&gt;,</span><br><span class="line">    <span class="comment">/// workload_to_vip maintains a mapping of workload IP to VIP. This is used only to handle removals.</span></span><br><span class="line">    workload_to_vip: HashMap&lt;IpAddr, HashSet&lt;(SocketAddr, <span class="type">u16</span>)&gt;&gt;,</span><br><span class="line">    <span class="comment">/// vips maintains a mapping of socket address with service port to workload ip and socket address</span></span><br><span class="line">    <span class="comment">/// with target ports in hashset.</span></span><br><span class="line">    vips: HashMap&lt;SocketAddr, HashSet&lt;(IpAddr, <span class="type">u16</span>)&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// policies maintains a mapping of ns/name to policy.</span></span><br><span class="line">    policies: HashMap&lt;<span class="type">String</span>, rbac::Authorization&gt;,</span><br><span class="line">    <span class="comment">// policies_by_namespace maintains a mapping of namespace (or &quot;&quot; for global) to policy names</span></span><br><span class="line">    policies_by_namespace: HashMap&lt;<span class="type">String</span>, HashSet&lt;<span class="type">String</span>&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[serde(skip_serializing, default)]</span></span><br><span class="line">    cert_tx: <span class="type">Option</span>&lt;mpsc::Sender&lt;Identity&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// needed to determine whether or not to prefetch certs</span></span><br><span class="line">    local_node: <span class="type">Option</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的对象众多，大概的关系是</p>
<ul>
<li>WorkloadManager: 作为最外层对象
<ul>
<li>WorkloadInformation: 对外提供的可用Shadow副本</li>
<li>AdsClient: 更新通讯的主要对象</li>
</ul>
</li>
</ul>
<p>而这个 AdsClient 的构建逻辑是</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">xds::Config::<span class="title function_ invoke__">new</span>(config.<span class="title function_ invoke__">clone</span>()) <span class="comment">// 默认配置</span></span><br><span class="line">   .<span class="title function_ invoke__">with_workload_handler</span>(xds_workloads) <span class="comment">// WorkloadStore 实例</span></span><br><span class="line">   .<span class="title function_ invoke__">with_authorization_handler</span>(xds_rbac) <span class="comment">// WorkloadStore 别名副本</span></span><br><span class="line">   .<span class="title function_ invoke__">watch</span>(xds::WORKLOAD_TYPE.<span class="title function_ invoke__">into</span>())</span><br><span class="line">   .<span class="title function_ invoke__">watch</span>(xds::AUTHORIZATION_TYPE.<span class="title function_ invoke__">into</span>())</span><br><span class="line">   .<span class="title function_ invoke__">build</span>(metrics, awaiting_ready.<span class="title function_ invoke__">subtask</span>(<span class="string">&quot;ads client&quot;</span>)),</span><br></pre></td></tr></table></figure>
<p>看到 <code>Arc&lt;Mutex&lt;WorkloadStore&gt;&gt;</code> 的时候，显然我们就知道这个对象显然是会被异步线程更新了。这部分也很<a href="https://github.com/istio/ztunnel/blob/f9672662a0448067ce19d1908907b6f4db8016e0/src/xds/client.rs#L575-L607">容易被找到</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">decode_and_handle</span>&lt;</span><br><span class="line">    T: prost::Message + <span class="built_in">Default</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>(&amp;AdsClient) <span class="punctuation">-&gt;</span> &amp;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Handler&lt;T&gt;&gt;,</span><br><span class="line">&gt;(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    f: F,</span><br><span class="line">    response: DeltaDiscoveryResponse,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Vec</span>&lt;RejectedConfig&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">type_url</span> = response.type_url.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">removes</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">handle_removes</span>(&amp;response);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">updates</span>: <span class="type">Vec</span>&lt;XdsUpdate&lt;T&gt;&gt; = response</span><br><span class="line">        .resources</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|r| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">key</span> = ResourceKey &#123;</span><br><span class="line">                name: r.name.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                type_url: type_url.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">notify_on_demand</span>(&amp;key);</span><br><span class="line">            <span class="keyword">self</span>.known_resources</span><br><span class="line">                .<span class="title function_ invoke__">entry</span>(key.type_url)</span><br><span class="line">                .<span class="title function_ invoke__">or_default</span>()</span><br><span class="line">                .<span class="title function_ invoke__">insert</span>(key.name);</span><br><span class="line">            r</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|raw| decode_proto::&lt;T&gt;(raw).<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(XdsUpdate::Update)</span><br><span class="line">        .<span class="title function_ invoke__">chain</span>(removes.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">map</span>(XdsUpdate::Remove))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handler</span> = <span class="title function_ invoke__">f</span>(<span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">    handler.<span class="title function_ invoke__">handle</span>(updates)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里进行处理，通过一系列的回调，对 WorkloadStore 进行了更新操作</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">xds</span>::Handler&lt;XdsWorkload&gt; <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;Mutex&lt;WorkloadStore&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">handle</span>(&amp;<span class="keyword">self</span>, updates: <span class="type">Vec</span>&lt;XdsUpdate&lt;XdsWorkload&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Vec</span>&lt;RejectedConfig&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">wli</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = |res: XdsUpdate&lt;XdsWorkload&gt;| &#123;</span><br><span class="line">            <span class="keyword">match</span> res &#123;</span><br><span class="line">                XdsUpdate::<span class="title function_ invoke__">Update</span>(w) =&gt; wli.<span class="title function_ invoke__">insert_xds_workload</span>(w.resource)?,</span><br><span class="line">                XdsUpdate::<span class="title function_ invoke__">Remove</span>(name) =&gt; &#123;</span><br><span class="line">                    info!(<span class="string">&quot;handling delete &#123;&#125;&quot;</span>, name);</span><br><span class="line">                    wli.<span class="title function_ invoke__">remove</span>(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125;;</span><br><span class="line">        xds::<span class="title function_ invoke__">handle_single_resource</span>(updates, handle)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 XDS 通讯就不做展开，这里大致上也是一个标准的 Request / Repsone 模式。</p>
<h2 id="XDS-模块"><a class="header-anchor" href="#XDS-模块">¶</a>XDS 模块</h2>
<p>在刚刚的 workload 里面我们是看到一部分和 XDS 相关的内容，这里我们展开看看 <a href="https://github.com/istio/ztunnel/blob/f9672662a0448067ce19d1908907b6f4db8016e0/src/xds/client.rs#L172-L187">AdsClient</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">AdsClient</span> &#123;</span><br><span class="line">    config: Config,</span><br><span class="line">    <span class="comment">/// Stores all known workload resources. Map from type_url to name</span></span><br><span class="line">    known_resources: HashMap&lt;<span class="type">String</span>, HashSet&lt;<span class="type">String</span>&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// pending stores a list of all resources that are pending and XDS push</span></span><br><span class="line">    pending: HashMap&lt;ResourceKey, oneshot::Sender&lt;()&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    demand: mpsc::Receiver&lt;(oneshot::Sender&lt;()&gt;, ResourceKey)&gt;,</span><br><span class="line">    demand_tx: mpsc::Sender&lt;(oneshot::Sender&lt;()&gt;, ResourceKey)&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) metrics: Arc&lt;Metrics&gt;,</span><br><span class="line">    block_ready: <span class="type">Option</span>&lt;readiness::BlockReady&gt;,</span><br><span class="line"></span><br><span class="line">    connection_id: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ADSClient 是一个Background程序来加载数据</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">run_loop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, backoff: Duration) <span class="punctuation">-&gt;</span> Duration &#123;</span><br><span class="line">    <span class="keyword">const</span> MAX_BACKOFF: Duration = Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">run_internal</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="comment">// 抛开无关的异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">run_internal</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里直接打开一个连接去连接 XDS 服务器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">address</span> = <span class="keyword">self</span>.config.address.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">svc</span> = tls::<span class="title function_ invoke__">grpc_connector</span>(address, <span class="keyword">self</span>.config.root_cert.<span class="title function_ invoke__">clone</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">client</span> =</span><br><span class="line">        AggregatedDiscoveryServiceClient::<span class="title function_ invoke__">with_interceptor</span>(svc, <span class="keyword">self</span>.config.auth.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    <span class="keyword">let</span> (discovery_req_tx, <span class="keyword">mut</span> discovery_req_rx) = mpsc::channel::&lt;DeltaDiscoveryRequest&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//  这里需要先构建一个 初始化请求，注意这里是一个 vec ，多个</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">initial_requests</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">construct_initial_requests</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里用 async stream 的 marco 来完成一个 类似 vec&lt;Req&gt; 的效果，参考 [Rust Async: async-stream](https://zhuanlan.zhihu.com/p/266269521)</span></span><br><span class="line">    <span class="comment">// 这里还是很 hack 的，返回了一个 unstopped 的 stream，开头是 initial_requests，后面的从 discovery_req_rx 里接受</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">outbound</span> = async_stream::stream! &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">initial</span> <span class="keyword">in</span> initial_requests &#123;</span><br><span class="line">            info!(resources=initial.initial_resource_versions.<span class="title function_ invoke__">len</span>(), type_url=initial.type_url, <span class="string">&quot;sending initial request&quot;</span>);</span><br><span class="line">            <span class="keyword">yield</span> initial;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(message) = discovery_req_rx.<span class="title function_ invoke__">recv</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">            debug!(type_url=message.type_url, <span class="string">&quot;sending request&quot;</span>);</span><br><span class="line">            <span class="keyword">yield</span> message</span><br><span class="line">        &#125;</span><br><span class="line">        warn!(<span class="string">&quot;outbound stream complete&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">response_stream</span> = client</span><br><span class="line">        .<span class="title function_ invoke__">delta_aggregated_resources</span>(tonic::Request::<span class="title function_ invoke__">new</span>(outbound))</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">        .<span class="title function_ invoke__">map_err</span>(Error::Connection)?</span><br><span class="line">        .<span class="title function_ invoke__">into_inner</span>();</span><br><span class="line">    debug!(<span class="string">&quot;connected established&quot;</span>);</span><br><span class="line"></span><br><span class="line">    info!(<span class="string">&quot;Stream established&quot;</span>);</span><br><span class="line">    <span class="comment">// Create a oneshot channel to be notified as soon as we ACK the first XDS response</span></span><br><span class="line">    <span class="comment">// 这里开了另外一个 channel，主要是处理当第一个请求 ack 的时候，让系统进入 Ready 状态</span></span><br><span class="line">    <span class="keyword">let</span> (tx, initial_xds_rx) = oneshot::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">initial_xds_tx</span> = <span class="title function_ invoke__">Some</span>(tx);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ready</span> = mem::<span class="title function_ invoke__">take</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.block_ready);</span><br><span class="line">    tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> initial_xds_rx.<span class="keyword">await</span> &#123;</span><br><span class="line">            <span class="comment">// 这里的 DROP 魔改了默认实现，在 [readiness.rs](https://github.com/istio/ztunnel/blob/f9672662a0448067ce19d1908907b6f4db8016e0/src/readiness.rs#L57-L77)</span></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">drop</span>(ready),</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; &#123;</span><br><span class="line">                debug!(<span class="string">&quot;sender was dropped before initial xds sync event was received&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">            _demand_event = <span class="keyword">self</span>.demand.<span class="title function_ invoke__">recv</span>() =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.<span class="title function_ invoke__">handle_demand_event</span>(_demand_event, &amp;discovery_req_tx).<span class="keyword">await</span>?;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 主体逻辑在这里，根据上面的 stream 里面 send 的部分，接收到 response 来挨个处理</span></span><br><span class="line">            msg = response_stream.<span class="title function_ invoke__">message</span>() =&gt; &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> If we have responses of different types (e.g. RBAC), we&#x27;ll want to wait for</span></span><br><span class="line">                <span class="comment">// each type to receive a response before marking ready</span></span><br><span class="line">                <span class="comment">// 处理函数是 handle_stream_event</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">XdsSignal</span>::Ack = <span class="keyword">self</span>.<span class="title function_ invoke__">handle_stream_event</span>(msg?, &amp;discovery_req_tx).<span class="keyword">await</span>? &#123;</span><br><span class="line">                    <span class="comment">// 这里巧妙的利用了 initial_xds_tx 做一次通知，来ready整个系统</span></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">val</span> = mem::<span class="title function_ invoke__">take</span>(&amp;<span class="keyword">mut</span> initial_xds_tx);</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(tx) = val &#123;</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(err) = tx.<span class="title function_ invoke__">send</span>(()) &#123;</span><br><span class="line">                            warn!(<span class="string">&quot;initial xds sync signal send failed: &#123;:?&#125;&quot;</span>, err)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面只是发送部分，具体的处理逻辑，我们继续往下探索，<a href="https://github.com/istio/ztunnel/blob/f9672662a0448067ce19d1908907b6f4db8016e0/src/xds/client.rs#L464-L525">handle_stream_event</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">handle_stream_event</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    stream_event: <span class="type">Option</span>&lt;DeltaDiscoveryResponse&gt;,</span><br><span class="line">    send: &amp;mpsc::Sender&lt;DeltaDiscoveryRequest&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;XdsSignal, Error&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// Due to lack of dynamic typing in Rust we have some code duplication here. In the future this could be a macro,</span></span><br><span class="line">    <span class="comment">// but for now its easier to just have a bit of duplication.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handler_response</span>: <span class="type">Result</span>&lt;(), <span class="type">Vec</span>&lt;RejectedConfig&gt;&gt; = <span class="keyword">match</span> type_url.<span class="title function_ invoke__">as_str</span>() &#123;</span><br><span class="line">        xds::WORKLOAD_TYPE =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.decode_and_handle::&lt;Workload, _&gt;(|a| &amp;a.config.workload_handler, response)</span><br><span class="line">        &#125;</span><br><span class="line">        xds::AUTHORIZATION_TYPE =&gt; <span class="keyword">self</span>.decode_and_handle::&lt;Authorization, _&gt;(</span><br><span class="line">            |a| &amp;a.config.authorization_handler,</span><br><span class="line">            response,</span><br><span class="line">        ),</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            error!(<span class="string">&quot;unknown type&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (response_type, error) = <span class="keyword">match</span> handler_response &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(rejects) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">error</span> = rejects</span><br><span class="line">                .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">                .<span class="title function_ invoke__">map</span>(|reject| reject.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">                .collect::&lt;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt;()</span><br><span class="line">                .<span class="title function_ invoke__">join</span>(<span class="string">&quot;; &quot;</span>);</span><br><span class="line">            (XdsSignal::Nack, <span class="title function_ invoke__">Some</span>(error))</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; (XdsSignal::Ack, <span class="literal">None</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    send.<span class="title function_ invoke__">send</span>(DeltaDiscoveryRequest &#123;</span><br><span class="line">        type_url,              <span class="comment">// this is owned, OK to move</span></span><br><span class="line">        response_nonce: nonce, <span class="comment">// this is owned, OK to move</span></span><br><span class="line">        error_detail: error.<span class="title function_ invoke__">map</span>(|msg| Status &#123;</span><br><span class="line">            message: msg,</span><br><span class="line">            ..<span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>()</span><br><span class="line">        &#125;),</span><br><span class="line">        ..<span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">await</span></span><br><span class="line">    .<span class="title function_ invoke__">map_err</span>(|e| Error::<span class="title function_ invoke__">RequestFailure</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(e)))</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(|_| response_type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>istio</category>
        <category>ambient</category>
      </categories>
      <tags>
        <tag>istio</tag>
        <tag>ambient</tag>
      </tags>
  </entry>
  <entry>
    <title>Mosn源码速读</title>
    <url>/2020/08/18/go/mosn/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/08/20/uEJCp.png" alt="uEJCp.png"></p>
<p>本文基于 <code>0.15.0</code> 版本，因为 <code>Mosn</code> 代码非常的巨大，对于 <code>*</code> 开头的章节作为补充部分，可以跳过。</p>
<span id="more"></span>


<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<h2 id="MOSN-的-IO-模型"><a class="header-anchor" href="#MOSN-的-IO-模型">¶</a>MOSN 的 IO 模型</h2>
<p><code>Mosn</code> 支持两种网络模型 <code>Netpoll</code> / <code>RawEpoll</code></p>
<h3 id="Netpoll-模式"><a class="header-anchor" href="#Netpoll-模式">¶</a>Netpoll 模式</h3>
<p>Netpoll 模式是标准的 <code>Go</code> 的网络模型， <code>goroutine-per-connection</code> 相对缺点就是消耗高点，但是编程会简单很多。</p>
<p><img src="https://s3.jpg.cm/2020/08/18/uuloL.png" alt="uuloL.png"></p>
<h3 id="RawEpoll-模式"><a class="header-anchor" href="#RawEpoll-模式">¶</a>RawEpoll 模式</h3>
<p><img src="https://s3.jpg.cm/2020/08/19/uSvPQ.png" alt="uSvPQ.png"></p>
<ol>
<li>链接建立后，向 Epoll 注册 <code>oneshot</code> 可读事件监听；并且此时不允许有协程调用 <code>conn.read</code>，避免与 <code>runtime netpoll</code> 冲突。</li>
<li>可读事件到达，从 <code>goroutine pool</code> 挑选一个协程进行读事件处理；由于使用的是 <code>oneshot</code> 模式，该 fd 后续可读事件不会再触发。</li>
<li>请求处理过程中，协程调度与经典 <code>netpoll</code> 模式一致。</li>
<li>请求处理完成，将协程归还给协程池；同时将 <code>fd</code> 重新添加到 <code>RawEpoll</code> 中。</li>
</ol>
<h2 id="How-it-work"><a class="header-anchor" href="#How-it-work">¶</a>How it work</h2>
<p>大家先瞧一眼模块图，瞧瞧就好了。<br>
<img src="https://s3.jpg.cm/2020/09/03/1JDhU.png" alt="1JDhU.png"></p>
<h3 id="Start-Server"><a class="header-anchor" href="#Start-Server">¶</a>Start Server</h3>
<p>代码的入口在 <code>pkg/mosn/starter.go:300</code>，我们采用文件的方式进行启动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start -c config.json</span><br></pre></td></tr></table></figure>
<p>我们看到熟悉的对于 <code>Listener</code> 的构建，对于 <code>xDS</code> 协议来说， <code>Listener</code> 部分决定了对外的监听部分。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, _ := <span class="keyword">range</span> serverConfig.Listeners &#123;</span><br><span class="line">    lc := configmanager.ParseListenerConfig(&amp;serverConfig.Listeners[idx], inheritListeners, inheritPacketConn)</span><br><span class="line">    deprecatedRouter, err := configmanager.ParseRouterConfiguration(&amp;lc.FilterChains[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> _, err := srv.AddListener(lc); err != <span class="literal">nil</span> &#123; <span class="comment">// 此处添加 Listener</span></span><br><span class="line">        log.StartLogger.Fatalf(<span class="string">&quot;[mosn] [NewMosn] AddListener error:%s&quot;</span>, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于熟悉 <code>Linux</code> 编程的同学， <code>Listener</code> 势必是创建一个 <code>ServerSocket</code> 进行监听。对于处理的逻辑，应该也是在构建的过程中创建出来的，我们跳至创建处：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ch *connHandler)</span></span> AddOrUpdateListener(lc *v2.Listener) (types.ListenerEventListener, <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> listenerName <span class="type">string</span></span><br><span class="line">	<span class="keyword">if</span> lc.Name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		listenerName = utils.GenerateUUID()</span><br><span class="line">		lc.Name = listenerName</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		listenerName = lc.Name</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// currently, we just support one filter chain</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(lc.FilterChains) != <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;error updating listener, listener have filter chains count is not 1&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// set listener filter , network filter and stream filter</span></span><br><span class="line">	<span class="keyword">var</span> listenerFiltersFactories []api.ListenerFilterChainFactory</span><br><span class="line">	<span class="keyword">var</span> networkFiltersFactories []api.NetworkFilterChainFactory</span><br><span class="line">	<span class="keyword">var</span> streamFiltersFactories []api.StreamFilterChainFactory</span><br><span class="line">	listenerFiltersFactories = configmanager.GetListenerFilters(lc.ListenerFilters)</span><br><span class="line">	networkFiltersFactories = configmanager.GetNetworkFilters(&amp;lc.FilterChains[<span class="number">0</span>])</span><br><span class="line">	streamFiltersFactories = configmanager.GetStreamFilters(lc.StreamFilters)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> al *activeListener</span><br><span class="line">	<span class="keyword">if</span> al = ch.findActiveListenerByName(listenerName); al != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 略去更新的操作</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		listenerStopChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) ➊</span><br><span class="line">		l := network.NewListener(lc)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		al, err = newActiveListener(l, lc, als, listenerFiltersFactories, networkFiltersFactories, streamFiltersFactories, ch, listenerStopChan) ➋</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> al, err</span><br><span class="line">		&#125;</span><br><span class="line">		l.SetListenerCallbacks(al)</span><br><span class="line">		ch.listeners = <span class="built_in">append</span>(ch.listeners, al)</span><br><span class="line">		log.DefaultLogger.Infof(<span class="string">&quot;[server] [conn handler] [add listener] add listener: %s&quot;</span>, lc.Addr.String())</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	admin.SetListenerConfig(listenerName, *al.listener.Config())</span><br><span class="line">	<span class="keyword">return</span> al, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分的代码显然不能满足我们对于核心，怎么 <code>AC</code> 请求的需求，这里是简单的创建了 <code>Listener</code>，让我们继续跟踪下去，不过值得注意的在 ➊ 创建了一个 <code>StopChain</code>，这是非常标准 <code>Go</code> 中如何通知他人 <code>Close</code> 的方式。不过从 ➋ 处，我们可以看到一些熟悉的  <code>Filters</code> 的单字，想必也是通过 <code>FilterChains</code> 进行工作的。</p>
<p>在构建的 <code>newActiveListener</code> 进行了一些监控的初始化。真正进行工作的代码是在 <code>pkg/server/handler.go:StartListener</code></p>
<figure class="highlight go"><figcaption><span>Start</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *listener)</span></span> Start(lctx context.Context, restart <span class="type">bool</span>) &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> l.bindToPort &#123;</span><br><span class="line">		ignore := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">if</span> l.rawl == <span class="literal">nil</span> &amp;&amp; l.packetConn == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> err := l.listen(lctx); err != <span class="literal">nil</span> &#123; <span class="comment">// 实际上启动的地方</span></span><br><span class="line">						log.StartLogger.Fatalf(<span class="string">&quot;[network] [listener start] [listen] %s listen failed, %v&quot;</span>, l.name, err)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			l.state = ListenerRunning</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> l.network &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;udp&quot;</span>:</span><br><span class="line">			l.readMsgEventLoop(lctx)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			l.acceptEventLoop(lctx)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Start</code> 有两个重点 <code>listen(lctx)</code> 创建了监听器，在 <code>l.acceptEventLoop(lctx)</code> 进行接受的事件循环，<code>listen(lctx)</code> 的逻辑就比较简单就是标准的 <code>Go Net</code>，我们进入下个函数在 <code>l.acceptEventLoop(lctx)</code> 中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *listener)</span></span> acceptEventLoop(lctx context.Context) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := l.accept(lctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Timeout() &#123;</span><br><span class="line">				log.DefaultLogger.Infof(<span class="string">&quot;[network] [listener start] [accept] listener %s stop accepting connections by deadline&quot;</span>, l.name)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ope, ok := err.(*net.OpError); ok &#123;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Accept-Connection"><a class="header-anchor" href="#Accept-Connection">¶</a>Accept Connection</h3>
<p>直接只有 <code>loop</code> 循环，不断的去接受即可，标准的 <code>Networking</code> 编程。</p>
<figure class="highlight go"><figcaption><span>accept</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *listener)</span></span> accept(lctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">	rawc, err := l.rawl.Accept()</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> use thread pool</span></span><br><span class="line">	utils.GoWithRecover(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		l.cb.OnAccept(rawc, l.useOriginalDst, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>OnAccept</code> 中就是我们线程模型的开始</p>
<figure class="highlight go"><figcaption><span>OnAccept</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(al *activeListener)</span></span> OnAccept(rawc net.Conn, useOriginalDst <span class="type">bool</span>, oriRemoteAddr net.Addr, ch <span class="keyword">chan</span> api.Connection, buf []<span class="type">byte</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> rawf *os.File</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !useOriginalDst &#123;</span><br><span class="line">		<span class="keyword">if</span> network.UseNetpollMode &#123; ➊</span><br><span class="line">			<span class="comment">// store fd for further usage</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span> rawc.LocalAddr().Network() &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;udp&quot;</span>:</span><br><span class="line">				<span class="keyword">if</span> tc, ok := rawc.(*net.UDPConn); ok &#123;</span><br><span class="line">					rawf, _ = tc.File()</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">if</span> tc, ok := rawc.(*net.TCPConn); ok &#123;</span><br><span class="line">					rawf, _ = tc.File()</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arc := newActiveRawConn(rawc, al)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// listener filter chain.</span></span><br><span class="line">	<span class="keyword">for</span> _, lfcf := <span class="keyword">range</span> al.listenerFiltersFactories &#123;</span><br><span class="line">		arc.acceptedFilters = <span class="built_in">append</span>(arc.acceptedFilters, lfcf) ➋</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx := mosnctx.WithValue(context.Background(), types.ContextKeyListenerPort, al.listenPort)</span><br><span class="line">	<span class="comment">//略 大量的初始化对象的代码</span></span><br><span class="line"></span><br><span class="line">	arc.ctx = ctx</span><br><span class="line"></span><br><span class="line">	arc.ContinueFilterChain(ctx, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ➊ 处，我们就开始区分我们的 <code>RawEpoll</code> 和 <code>NetPoll</code> 的模式了。最重要的部分就是 ➋ 处理进行了 <code>Listener</code> 的 <code>FilterChain</code> 构建，我们继续往下探索</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arc *activeRawConn)</span></span> ContinueFilterChain(ctx context.Context, success <span class="type">bool</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !success &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ; arc.acceptedFilterIndex &lt; <span class="built_in">len</span>(arc.acceptedFilters); arc.acceptedFilterIndex++ &#123;</span><br><span class="line">		filterStatus := arc.acceptedFilters[arc.acceptedFilterIndex].OnAccept(arc)  ➊</span><br><span class="line">		<span class="keyword">if</span> filterStatus == api.Stop &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arc.activeListener.newConnection(ctx, arc.rawc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 ➊ 处，我们就发现了 <code>FliterChain</code> 从返回的对象也可以清晰的发现，这和 <code>Servlet Filter</code> 不同，每个 <code>Filter</code> 返回对象来决定是否需要继续下去。</p>
<p>在 <code>newConnection</code> 在中 处理下各种超时的设置，我们勇敢的往前进，后续的 <code>OnNewConnection</code> 有我们的大头戏了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(al *activeListener)</span></span> OnNewConnection(ctx context.Context, conn api.Connection) &#123;</span><br><span class="line">	<span class="comment">//在这里我们初始化我们的 FilterManager</span></span><br><span class="line">	filterManager := conn.FilterManager()</span><br><span class="line">	<span class="keyword">for</span> _, nfcf := <span class="keyword">range</span> al.networkFiltersFactories &#123;</span><br><span class="line">		nfcf.CreateFilterChain(ctx, filterManager)</span><br><span class="line">	&#125;</span><br><span class="line">	filterManager.InitializeReadFilters()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当我们并没有 ReadFilter 或者 WriterFilter 我们快速的返回即可</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(filterManager.ListReadFilter()) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">		<span class="built_in">len</span>(filterManager.ListWriteFilters()) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// no filter found, close connection</span></span><br><span class="line">		conn.Close(api.NoFlush, api.LocalClose)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	ac := newActiveConnection(al, conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里将请求按栈，有什么用我们后续再看</span></span><br><span class="line">	al.connsMux.Lock()</span><br><span class="line">	e := al.conns.PushBack(ac)</span><br><span class="line">	al.connsMux.Unlock()</span><br><span class="line">	ac.element = e</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始真实的处理阶段</span></span><br><span class="line">	conn.Start(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Let's Play!</code> 这里开始上文的不同IO模型了</p>
<figure class="highlight go"><figcaption><span>Start</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *connection)</span></span> Start(lctx context.Context) &#123;</span><br><span class="line">	c.startOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> UseNetpollMode &#123;</span><br><span class="line">			c.attachEventLoop(lctx)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c.startRWLoop(lctx)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Read-Connection"><a class="header-anchor" href="#Read-Connection">¶</a>Read Connection</h3>
<h4 id="Read-EventLoop-attachEventLoop"><a class="header-anchor" href="#Read-EventLoop-attachEventLoop">¶</a>Read: EventLoop [attachEventLoop]</h4>
<h5 id="Read-Write事件监听"><a class="header-anchor" href="#Read-Write事件监听">¶</a>Read/Write事件监听</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *connection)</span></span> attachEventLoop(lctx context.Context) &#123;</span><br><span class="line">	<span class="comment">// 这里用了当前的一个递增的序列号，取余 epoll poll 获得一个 eventloop</span></span><br><span class="line">	c.eventLoop = attach()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register read only, write is supported now because it is more complex than read.</span></span><br><span class="line">	<span class="comment">// We need to write our own code based on syscall.write to deal with the EAGAIN and writable epoll event</span></span><br><span class="line">	err := c.eventLoop.registerRead(c, &amp;connEventHandler&#123;</span><br><span class="line">		onRead: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> c.readEnabled &#123; ➊</span><br><span class="line">				err := c.doRead()</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> te, ok := err.(net.Error); ok &amp;&amp; te.Timeout() &#123;</span><br><span class="line">						<span class="keyword">if</span> c.readBuffer != <span class="literal">nil</span> &amp;&amp; c.readBuffer.Len() == <span class="number">0</span> &#123;</span><br><span class="line">							c.readBuffer.Free()</span><br><span class="line">							c.readBuffer.Alloc(DefaultBufferReadCapacity)</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-c.readEnabledChan:</span><br><span class="line">				<span class="keyword">case</span> &lt;-time.After(<span class="number">100</span> * time.Millisecond): ➋</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;,</span><br><span class="line"></span><br><span class="line">		onHup: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">			log.DefaultLogger.Errorf(<span class="string">&quot;[network] [event loop] [onHup] ReadHup error. Connection = %d, Remote Address = %s&quot;</span>, c.id, c.RemoteAddr().String())</span><br><span class="line">			c.Close(api.NoFlush, api.RemoteClose)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的  ➊ ➋ 做了一些 <code>ReadEnable</code> 的控制，应该是对 <code>Transfer FD</code> 部分进行设计，这里定义我们在读取和 <code>Hup</code> 时候的回调，我们看看回调事件是如何注册的。</p>
<figure class="highlight go"><figcaption><span>registerRead</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(el *eventLoop)</span></span> registerRead(conn *connection, handler *connEventHandler) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// handle read</span></span><br><span class="line">	read, err := netpoll.HandleFile(conn.file, netpoll.EventRead|netpoll.EventOneShot)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// register</span></span><br><span class="line">	el.poller.Start(read, el.readWrapper(read, handler))</span><br><span class="line"></span><br><span class="line">	el.mu.Lock()</span><br><span class="line">	<span class="comment">//store</span></span><br><span class="line">	el.conn[conn.id] = &amp;connEvent&#123;</span><br><span class="line">		read: read,</span><br><span class="line">	&#125;</span><br><span class="line">	el.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心的就是在 <code>el.poller.Start(read, el.readWrapper(read, handler))</code>  开始监听我们的执行事件，对 <code>Write</code>写事件也是一样的模式</p>
<figure class="highlight go"><figcaption><span>register</span></figcaption><table><tr><td class="code"><pre><span class="line">el.poller.Start(read, el.readWrapper(read, handler))</span><br><span class="line">el.poller.Start(write, el.writeWrapper(write, handler))</span><br></pre></td></tr></table></figure>
<p>不过值得注意是，对一个同一个请求的读写事件的 <code>Poller</code> 肯定是在同一个上面。那我们下面需要看我们最重要的部分，我们真实的读取数据从何而来，不过先小结一下：</p>
<h5 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h5>
<p><img src="https://s3.jpg.cm/2020/08/20/uES1T.png" alt="uES1T.png"></p>
<p>对于 <code>Mosn</code> 来说，我们对于 <code>Read/Write</code> 可以使用多个 <code>RawPoller</code> 进行操作，这样可以有效的利用多核的性质，不过这里又和我们后面的 <code>GoRoutine</code> 会冲突，这里需要好好设计你的 <code>poolsize</code>，不过从源码看现阶段仅支持 <code>1</code> 个的读写监听器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line"></span><br><span class="line">	readPool  = mosnsync.NewWorkerPool(runtime.NumCPU())</span><br><span class="line">	writePool = mosnsync.NewWorkerPool(runtime.NumCPU())</span><br><span class="line"></span><br><span class="line">	rrCounter                 <span class="type">uint32</span></span><br><span class="line">	poolSize                  <span class="type">uint32</span> = <span class="number">1</span> <span class="comment">//uint32(runtime.NumCPU()) ➊</span></span><br><span class="line">	eventLoopPool                    = <span class="built_in">make</span>([]*eventLoop, poolSize)</span><br><span class="line">	errEventAlreadyRegistered        = errors.New(<span class="string">&quot;event already registered&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在 ➊ 处已经被标记出来的，暂时还没有查找到修改的地方。</p>
<h5 id="读写事件处理"><a class="header-anchor" href="#读写事件处理">¶</a>读写事件处理</h5>
<p>本章在操作之前由于 <code>Master</code> 版本尚未完善 <code>pkg/network/eventloop.go:45</code> 此处需要打开初始化才能够工作</p>
<p>执行事件的循环肯定在我们最熟悉的 <code>epoll.wait()</code> 中，在 <code>netpoll/epoll.go:235</code> 中就不看了，我们直接看数据的读取的过程，在我们回调事件中</p>
<figure class="highlight go"><figcaption><span>pkg/network/eventloop.go:188</span></figcaption><table><tr><td class="code"><pre><span class="line">readPool.Schedule(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !handler.onRead() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	el.poller.Resume(desc)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们执行了 <code>readPool</code> 的操作，而这个 <code>Schedule</code> 操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *workerPool)</span></span> Schedule(task <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> p.work &lt;- task:</span><br><span class="line">	<span class="keyword">case</span> p.sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">		<span class="keyword">go</span> p.spawnWorker(task)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以简单的认为是发生了一个任务通知了我们 <code>work</code> 通道，在下面的代码进行处理</p>
<figure class="highlight go"><figcaption><span>spawnWorker</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *workerPool)</span></span> spawnWorker(task <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.DefaultLogger.Alertf(<span class="string">&quot;syncpool&quot;</span>, <span class="string">&quot;[syncpool] panic %v\n%s&quot;</span>, p, <span class="type">string</span>(debug.Stack()))</span><br><span class="line">		&#125;</span><br><span class="line">		&lt;-p.sem</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		task()</span><br><span class="line">		task = &lt;-p.work <span class="comment">//我们开始处理这个 Task</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="题外话1：Mosn-的-WorkerPool"><a class="header-anchor" href="#题外话1：Mosn-的-WorkerPool">¶</a>题外话1：Mosn 的 WorkerPool</h6>
<p>笔者之前写<code>Java</code>为主，这次看到这样的工作池设计，一时半会还没看懂，理了一下才行还是有点意思的。</p>
<figure class="highlight go"><figcaption><span>NewWorkerPool</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorkerPool</span><span class="params">(size <span class="type">int</span>)</span></span> WorkerPool &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;workerPool&#123;</span><br><span class="line">		work: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>), </span><br><span class="line">		sem:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, size), <span class="comment">// 这里 Channel 控制最多生成多少个 Worker。默认是 CPU CORE</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><figcaption><span>Schedule</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *workerPool)</span></span> Schedule(task <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> p.work &lt;- task:</span><br><span class="line">	<span class="keyword">case</span> p.sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;: <span class="comment">// ➊ 当我们执行一个 fun 的时候，如果 work 被阻塞就会触发这里的 case </span></span><br><span class="line">		<span class="keyword">go</span> p.spawnWorker(task) <span class="comment">// ➋ 我们这里创建一个 Worker</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><figcaption><span>spawnWorker</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *workerPool)</span></span> spawnWorker(task <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.DefaultLogger.Alertf(<span class="string">&quot;syncpool&quot;</span>, <span class="string">&quot;[syncpool] panic %v\n%s&quot;</span>, p, <span class="type">string</span>(debug.Stack()))</span><br><span class="line">		&#125;</span><br><span class="line">		&lt;-p.sem <span class="comment">// ➌ 最终结束这个 Loop 的时候回收这个 SEM</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		task()</span><br><span class="line">		task = &lt;-p.work <span class="comment">// ➍ 所有的 Worker 都在竞争这一个没有缓冲的 task channel</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的控制任务池的方法还是很精妙的， 如果请求量不大，处理很快的话不一定需要创建最大<code>Maxium</code>的<code>Worker</code>，不过缺点就是并不会在高峰之后并不会回收。</p>
<h4 id="Read-RWLoop-startRWLoop"><a class="header-anchor" href="#Read-RWLoop-startRWLoop">¶</a>Read: RWLoop [startRWLoop]</h4>
<p>看完了 <code>RawEpoll</code> 的模式，我们看看 <code>RWLoop</code> 的模式</p>
<figure class="highlight go"><figcaption><span>startRWLoop</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *connection)</span></span> startRWLoop(lctx context.Context) &#123;</span><br><span class="line">	c.internalLoopStarted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	utils.GoWithRecover(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		c.startReadLoop()</span><br><span class="line">	&#125;, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		c.Close(api.NoFlush, api.LocalClose)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>pkg/network/connection.go:startReadLoop</code> 和上面大同小异进行了一系列的处理，在这里我们就直接创建一个新的 <code>GoRotinue</code> 进行该请求的处理，核心的代码在 <code>pkg/network/connection.go:doRead()</code> 中。在 <code>doRead()</code> 的上半段就是在处理读取数据，从 <code>pkg/network/connection.go:507：</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c.onRead(bytesRead)</span><br></pre></td></tr></table></figure>
<p>进入了数据的读取阶段。可以发现对于 <code>RWLoop</code> 方式的代码是比较的简单的。</p>
<hr>
<h4 id="Read-Chian"><a class="header-anchor" href="#Read-Chian">¶</a>Read Chian</h4>
<p>对于不同的 <code>IO</code> 处理部分已经在上文结束，我们进入数据获得的部分：</p>
<figure class="highlight go"><figcaption><span>onRead()</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *connection)</span></span> onRead(bytesRead <span class="type">int64</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, cb := <span class="keyword">range</span> c.bytesReadCallbacks &#123;</span><br><span class="line">		cb(<span class="type">uint64</span>(bytesRead)) <span class="comment">// ➊ 预留的回调的 Hook</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.filterManager.OnRead()</span><br><span class="line">	c.updateReadBufStats(bytesRead, <span class="type">int64</span>(c.readBuffer.Len())) <span class="comment">// ➋ 统计部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们又看到了我们的老熟人 <code>FilterManager</code>，在 <code>Envoy 源码分析</code> 中，我们也发现了 <code>Envoy</code> 是相同的设计模式。我们看看这个 <code>FilterManager</code> 的工作机制</p>
<h5 id="FilterManager"><a class="header-anchor" href="#FilterManager">¶</a>FilterManager</h5>
<figure class="highlight go"><figcaption><span>FilterManager</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FilterManager <span class="keyword">interface</span> &#123;</span><br><span class="line">	AddReadFilter(rf ReadFilter)</span><br><span class="line">	AddWriteFilter(wf WriteFilter)</span><br><span class="line">	ListReadFilter() []ReadFilter</span><br><span class="line">	ListWriteFilters() []WriteFilter</span><br><span class="line">	InitializeReadFilters() <span class="type">bool</span></span><br><span class="line">	OnRead()</span><br><span class="line">	OnWrite(buffer []buffer.IoBuffer) FilterStatus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <code>FilterManager</code> 声明看，类似于 <code>Netty</code> 一样的 <code>Inbound Channel</code> 和 <code>Outbound Channel</code>。我们深入 <code>OnRead</code> 部分</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fm *filterManager)</span></span> onContinueReading(filter *activeReadFilter) &#123;</span><br><span class="line">	<span class="keyword">var</span> index <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> uf *activeReadFilter</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> filter != <span class="literal">nil</span> &#123;</span><br><span class="line">		index = filter.index + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ; index &lt; <span class="built_in">len</span>(fm.upstreamFilters); index++ &#123;</span><br><span class="line">		uf = fm.upstreamFilters[index]</span><br><span class="line">		uf.index = index</span><br><span class="line">		<span class="comment">// 源码此处有 !uf.initialized 这条路径是针对非 accept 成功的请求处理的，我们在 Read 部分不会进入这里</span></span><br><span class="line">		buf := fm.conn.GetReadBuffer()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; buf.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			status := uf.filter.OnData(buf) <span class="comment">// ➊ 和 netty 一样直接把 当前 获得所有的 bytes 传递给下层</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> status == api.Stop &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们需要处理的逻辑显然都是在 <code>Filter:OnData</code> 部分了。这部分的 <code>Filter</code> 类型，在 <code>yaml</code> 配置可以指定：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;filter_chains&quot;:</span> [&#123;</span><br><span class="line">	<span class="attr">&quot;filters&quot;:</span> [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;type&quot;:</span> <span class="string">&quot;proxy&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;config&quot;:</span> &#123;</span><br><span class="line">				<span class="attr">&quot;downstream_protocol&quot;:</span> <span class="string">&quot;Http1&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;upstream_protocol&quot;:</span> <span class="string">&quot;Http1&quot;</span>,</span><br><span class="line">				<span class="string">&quot;router_config_name&quot;</span><span class="string">:&quot;client_router&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>我们来看看最常用的 <code>ProxyFilter</code>。</p>
<h5 id="ProxyFilter"><a class="header-anchor" href="#ProxyFilter">¶</a>ProxyFilter</h5>
<p>在 阅读 <code>ProxyFilter</code> 之前，我们先看下 <code>pkg/proxy/proxy.go:InitializeReadFilterCallbacks</code> 这里我们创建了面向下游的 <code>ServerStreamConn</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *proxy)</span></span> InitializeReadFilterCallbacks(cb api.ReadFilterCallbacks) &#123;</span><br><span class="line">	p.readCallbacks.Connection().AddConnectionEventListener(p.downstreamListener)</span><br><span class="line">	<span class="keyword">if</span> p.config.DownstreamProtocol != <span class="type">string</span>(protocol.Auto) &#123;</span><br><span class="line">		p.serverStreamConn = stream.CreateServerStreamConnection(p.context, types.ProtocolName(p.config.DownstreamProtocol), p.readCallbacks.Connection(), p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是比较好理解的，我们向下游发送数据总是需要一个单独的连接的。对于 <code>OnData</code> 函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *proxy)</span></span> OnData(buf buffer.IoBuffer) api.FilterStatus &#123;</span><br><span class="line">	<span class="keyword">if</span> p.serverStreamConn == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">	p.serverStreamConn.Dispatch(buf)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> api.Stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接进入了 <code>ServerSteamConn</code> 的  <code>Dispatch</code> 函数而在其中很有趣，我们仅仅将 <code>bytes</code> 写入了一个 <code>byfChan</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *streamConnection)</span></span> Dispatch(buffer buffer.IoBuffer) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// ....</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> buffer.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		sc.bufChan &lt;- buffer</span><br><span class="line">		&lt;-sc.bufChan</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那显然我们需要一个地方进行 <code>Read</code>，没错就是下面几行</p>
<figure class="highlight go"><figcaption><span>Read</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(conn *streamConnection)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	data, ok := &lt;-conn.bufChan</span><br><span class="line">	n = <span class="built_in">copy</span>(p, data.Bytes())</span><br><span class="line">	data.Drain(n)</span><br><span class="line">	conn.bufChan &lt;- <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是有一个疑问放在我们面前，是谁启动这个 <code>Read()</code> 的处理者呢？这个问题要回溯到我们的 <code>ServerConnection</code> 创建的时刻</p>
<figure class="highlight go"><figcaption><span>newServerStreamConnection</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newServerStreamConnection</span><span class="params">(ctx context.Context, connection api.Connection,</span></span></span><br><span class="line"><span class="params"><span class="function">	callbacks types.ServerStreamConnectionEventListener)</span></span> types.ServerStreamConnection &#123;</span><br><span class="line">	ssc := &amp;serverStreamConnection&#123;</span><br><span class="line">		streamConnection: streamConnection&#123;</span><br><span class="line">			context:    ctx,</span><br><span class="line">			conn:       connection,</span><br><span class="line">			bufChan:    <span class="built_in">make</span>(<span class="keyword">chan</span> buffer.IoBuffer),</span><br><span class="line">			connClosed: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>),</span><br><span class="line">		&#125;,</span><br><span class="line">		contextManager:           str.NewContextManager(ctx),</span><br><span class="line">		serverStreamConnListener: callbacks,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// init first context</span></span><br><span class="line">	ssc.contextManager.Next()</span><br><span class="line"></span><br><span class="line">	ssc.br = bufio.NewReader(ssc)</span><br><span class="line">	ssc.bw = bufio.NewWriter(ssc)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reset would not be called in server-side scene, so add listener for connection event</span></span><br><span class="line">	connection.AddConnectionEventListener(ssc)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set not support transfer connection</span></span><br><span class="line">	ssc.conn.SetTransferEventListener(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		ssc.<span class="built_in">close</span> = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	utils.GoWithRecover(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ssc.serve()</span><br><span class="line">	&#125;, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ssc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在这里构建所有的变量，最重要的是 <code>callbacks</code>，我们接收到来自外侧的请求处理逻辑，而这个对象本身的处理逻辑都是在 <code>ssc.serve()</code> 中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(conn *serverStreamConnection)</span></span> serve() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		ctx := conn.contextManager.Get()</span><br><span class="line">		buffers := httpBuffersByContext(ctx)</span><br><span class="line">		request := &amp;buffers.serverRequest</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2. 这里用了 Fasthttp 来获取请求的数据</span></span><br><span class="line">		err := request.ReadLimitBody(conn.br, maxRequestBodySize)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 3. 生成一个唯一ID</span></span><br><span class="line">		id := protocol.GenerateID()</span><br><span class="line">		s := &amp;buffers.serverStream</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4. 处理请求</span></span><br><span class="line">		s.stream = stream&#123;</span><br><span class="line">			id:       id,</span><br><span class="line">			ctx:      mosnctx.WithValue(ctx, types.ContextKeyStreamID, id),</span><br><span class="line">			request:  request,</span><br><span class="line">			response: &amp;buffers.serverResponse,</span><br><span class="line">		&#125;</span><br><span class="line">		s.connection = conn</span><br><span class="line">		s.responseDoneChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line">		s.header = mosnhttp.RequestHeader&#123;&amp;s.request.Header, <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line">		conn.mutex.Lock()</span><br><span class="line">		conn.stream = s</span><br><span class="line">		conn.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> atomic.LoadInt32(&amp;s.readDisableCount) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">			s.handleRequest() <span class="comment">// IMP! 这里进行请求的处理</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 5. 等待请求处理完成</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-s.responseDoneChan:</span><br><span class="line">		<span class="keyword">case</span> &lt;-conn.connClosed:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		conn.contextManager.Next()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里给大家做个小结，我们先理清顺序</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+------------+               +-------------+          +--------------+</span><br><span class="line">|   upsteam  +--------------&gt;+     mosn    +---------&gt;+  downsteam   |</span><br><span class="line">+------------+               +-------------+          +--------------+</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.jpg.cm/2020/08/24/uyuC5.png" alt="uyuC5.png"></p>
<p>对于 <code>Upsteam Conn</code> 根据模型的不同，可能是 <code>RawEpoll</code>，而 <code>ServerSteamConn</code> 是一个被 <code>Pool</code> 化的 <code>Conn</code>，但是对于这个 <code>Conn</code> 本身也有自己的 <code>Read</code> 和 <code>Write</code> 处理函数，是在一个 <code>Gorotine</code> 中，启动的代码是在 <code>ssc.serve()</code> 中。</p>
<h5 id="OnReceive"><a class="header-anchor" href="#OnReceive">¶</a>OnReceive</h5>
<p>对于常见的 <code>Http proxy filter（pkg/proxy/proxy.go）</code> 来说，我们处理  <code>Http encoder</code> 之后，进入 <code>OnReceive</code> 部分。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *downStream)</span></span> OnReceive(ctx context.Context, headers types.HeaderMap, data types.IoBuffer, trailers types.HeaderMap) &#123;</span><br><span class="line">	s.downstreamReqHeaders = headers</span><br><span class="line">	s.context = mosnctx.WithValue(s.context, types.ContextKeyDownStreamHeaders, headers)</span><br><span class="line">	s.downstreamReqDataBuf = data</span><br><span class="line">	s.downstreamReqTrailers = trailers</span><br><span class="line"></span><br><span class="line">	id := s.ID</span><br><span class="line">	<span class="comment">// goroutine for proxy</span></span><br><span class="line">	pool.ScheduleAuto(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">//....</span></span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		phase := types.InitPhase</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			phase = s.receive(ctx, id, phase)</span><br><span class="line">			<span class="keyword">switch</span> phase &#123;</span><br><span class="line">			<span class="comment">//....</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里采用了一个状态机进行处理，。不过值得注意的最多进行 <code>10</code> 此的状态切换就必须进入 <code>End</code> 状态，不过此处其实一个小设计，应该后面的执行步骤刚好就是10次。真实的处理流程在 <code>pkg/proxy/downstream.go:394</code> 中。执行顺序是 <code>DownFilter</code> <code>MatchRoute</code> <code>DownFilterAfterRoute</code> <code>ChooseHost</code> <code>DownFilterAfterChooseHost</code> <code>DownRecvHeader</code> <code>DownRecvData</code> <code>DownRecvTrailer</code> <code>Oneway</code> <code>Retry</code> <code>WaitNotify</code> <code>UpFilter</code> <code>UpRecvHeader</code> <code>UpRecvData</code> <code>UpRecvTrailer</code> <code>End</code>，这里的处理恰好就是 <code>Mosn</code> 的处理核心部分。</p>
<h3 id="Receive-Data-Upstream"><a class="header-anchor" href="#Receive-Data-Upstream">¶</a>Receive Data [Upstream]</h3>
<p>对于 <code>receive</code> 部分值得详细的分析一下。对于前面分了很多种类型的阶段处理，大部分的状态会调用如下的代码，这里的代码是后续的拓展点，先不展开。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *downStream)</span></span> runReceiveFilters(p types.Phase, headers types.HeaderMap, data types.IoBuffer, trailers types.HeaderMap) &#123;</span><br><span class="line">	<span class="keyword">for</span> ; s.receiverFiltersIndex &lt; <span class="built_in">len</span>(s.receiverFilters); s.receiverFiltersIndex++ &#123;</span><br><span class="line">		f := s.receiverFilters[s.receiverFiltersIndex]</span><br><span class="line">		<span class="keyword">if</span> f.p != p &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		s.context = mosnctx.WithValue(s.context, types.ContextKeyStreamFilterPhase, p)</span><br><span class="line"></span><br><span class="line">		status := f.filter.OnReceive(s.context, headers, data, trailers)</span><br><span class="line">		<span class="keyword">switch</span> status &#123;</span><br><span class="line">			<span class="comment">//略....</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.receiverFiltersIndex = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑不啰嗦了，找到匹配的逻辑进行处理即可。而其他的有些状态处理各不相同。</p>
<h4 id="matchRoute"><a class="header-anchor" href="#matchRoute">¶</a>*matchRoute</h4>
<p>比如对于 <code>matchRoute</code> 部分</p>
<figure class="highlight go"><figcaption><span>matchRoute</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *downStream)</span></span> matchRoute() &#123;</span><br><span class="line">	headers := s.downstreamReqHeaders</span><br><span class="line">	<span class="keyword">if</span> s.proxy.routersWrapper == <span class="literal">nil</span> || s.proxy.routersWrapper.GetRouters() == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 没有路由配置。直接Ret了</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	routers := s.proxy.routersWrapper.GetRouters()</span><br><span class="line">	handlerChain := router.CallMakeHandlerChain(s.context, headers, routers, s.proxy.clusterManager)</span><br><span class="line">	<span class="keyword">if</span> handlerChain == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s.snapshot, s.route = handlerChain.DoNextHandler()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无处不在的 <code>Chain</code>，对于 <code>Route</code> 的匹配我们也需要创建一个 <code>RouteHandlerChain</code> 进行匹配。对于单个的 <code>RouteHandler</code> 里面来说最核心的就是包含的属性 <code>Route</code>,分为 <code>PathRoute</code> <code>PrefixRoute</code> <code>RegexRoute</code> <code>SofaRoute</code>，具体的逻辑就在内部不展开说了。</p>
<h4 id="DownRecvHeader"><a class="header-anchor" href="#DownRecvHeader">¶</a>DownRecvHeader</h4>
<p>在接收到数据处理过程中 <code>DownRecvHeader</code> 进行了数据的发送。发送数据也是蛮有趣的设计：</p>
<figure class="highlight go"><figcaption><span>appendHeaders</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *upstreamRequest)</span></span> appendHeaders(endStream <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> r.downStream.processDone() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	r.sendComplete = endStream</span><br><span class="line">	<span class="keyword">if</span> r.downStream.oneway &#123;</span><br><span class="line">		r.connPool.NewStream(r.downStream.context, <span class="literal">nil</span>, r)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		r.connPool.NewStream(r.downStream.context, r, r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实并没直接发送，而是从我们的 <code>ConnPool</code> 中获得一个对下游的 <code>Stream</code> 我们将这个 <code>r</code> 对象直接作为了构建这个下游请求连接的参数。而真正的写入在</p>
<figure class="highlight go"><figcaption><span>endStream</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *clientStream)</span></span> endStream() &#123;</span><br><span class="line">	err := s.doSend()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Proxy.Errorf(s.stream.ctx, <span class="string">&quot;[stream] [http] send client request error: %+v&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err == types.ErrConnectionHasClosed &#123;</span><br><span class="line">			s.ResetStream(types.StreamConnectionFailed)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			s.ResetStream(types.StreamLocalReset)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> log.Proxy.GetLogLevel() &gt;= log.DEBUG &#123;</span><br><span class="line">		log.Proxy.Debugf(s.stream.ctx, <span class="string">&quot;[stream] [http] send client request, requestId = %v&quot;</span>, s.stream.id)</span><br><span class="line">	&#125;</span><br><span class="line">	s.connection.requestSent &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将请求 <code>Send</code> 出去将 <code>requestSent</code> 标记置为 <code>true</code> 即可。而对于读取数据，就在下一个阶段 <code>DownRecvData</code></p>
<h3 id="Receive-Data-Downstream"><a class="header-anchor" href="#Receive-Data-Downstream">¶</a>Receive Data [Downstream]</h3>
<h4 id="DownRecvData"><a class="header-anchor" href="#DownRecvData">¶</a>DownRecvData</h4>
<p><code>DownRecvHeader</code> 先去获取了 <code>DownSteam</code> 的 <code>Header</code> 部分的数据，不过值得注意的如果是 <code>Get</code> 并不会走这里。在 <code>receiveHeaders</code> 中，我们首先调用了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *downStream)</span></span> receiveData(endStream <span class="type">bool</span>) &#123;</span><br><span class="line">	data := s.downstreamReqDataBuf</span><br><span class="line">	s.requestInfo.SetBytesReceived(s.requestInfo.BytesReceived() + <span class="type">uint64</span>(data.Len()))</span><br><span class="line">	s.downstreamRecvDone = endStream</span><br><span class="line">	s.upstreamRequest.appendData(endStream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在最开始标记我们需要获得多少数据在 <code>SetBytesReceived(s.requestInfo.BytesReceived() + uint64(data.Len()))</code>,然后将这些数据放到了发送的队列中。</p>
<h4 id="UpRecvHeader"><a class="header-anchor" href="#UpRecvHeader">¶</a>UpRecvHeader</h4>
<p>上面2步走完了发送的流程，而接受的流程从 <code>UpRecvHeader</code> 开始，我们一开始接收到的 <code>Downstream</code> 的 <code>HttpHeader</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *downStream)</span></span> appendHeaders(endStream <span class="type">bool</span>) &#123;</span><br><span class="line">	s.upstreamProcessDone = endStream</span><br><span class="line">	headers := s.convertHeader(s.downstreamRespHeaders)</span><br><span class="line">	<span class="keyword">if</span> err := s.responseSender.AppendHeaders(s.context, headers, endStream); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Proxy.Errorf(s.context, <span class="string">&quot;append headers error: %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后读取数据就在</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *downStream)</span></span> appendData(endStream <span class="type">bool</span>) &#123;</span><br><span class="line">	s.upstreamProcessDone = endStream</span><br><span class="line"></span><br><span class="line">	data := s.convertData(s.downstreamRespDataBuf)</span><br><span class="line">	s.requestInfo.SetBytesSent(s.requestInfo.BytesSent() + <span class="type">uint64</span>(data.Len()))</span><br><span class="line">	s.responseSender.AppendData(s.context, data, endStream)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> endStream &#123;</span><br><span class="line">		s.endStream()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说到这里，我们一定要好好分析下 这几个 <code>appendData</code> 是怎么工作的，其实看起来还是挺绕的。</p>
<h4 id="小结2-Upstream-和-DownStream-的交互"><a class="header-anchor" href="#小结2-Upstream-和-DownStream-的交互">¶</a>小结2: Upstream 和 DownStream 的交互</h4>
<p>对于整个处理流程的核心部分，我们就一直在和 <code>upstream</code> 和 <code>downstream</code> 这两个 package 的对象进行交互。<br>
大概有这么几个函数很重要：</p>
<ul>
<li>OnReceive：这是接收到数据时候的方法</li>
<li>receiveHeaders：接收到 http header 部分</li>
<li>receiveData： 接收到 http body 部分</li>
</ul>
<p>这里面有一个很重要的抽象是 <code>pkg/types/stream.go:StreamSender</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StreamSender <span class="keyword">interface</span> &#123;</span><br><span class="line">	AppendHeaders(ctx context.Context, headers api.HeaderMap, endStream <span class="type">bool</span>) <span class="type">error</span></span><br><span class="line">	AppendData(ctx context.Context, data buffer.IoBuffer, endStream <span class="type">bool</span>) <span class="type">error</span></span><br><span class="line">	AppendTrailers(ctx context.Context, trailers api.HeaderMap) <span class="type">error</span></span><br><span class="line">	GetStream() Stream</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: UpStream 和 DownStream 交互',
	 'Down#OnReceive->Down#receiveHeaders: 1. 接收到上游的请求',
	 'Down#receiveHeaders->Up#appendHeaders: 2. 将Upstream的Header置于连接池中的某个连接',
	 'Up#appendHeaders->Up#OnReady: 3. 连接就绪',
	 'Up#appendData->Up#convertData: 4. 将请求的Body写入连接，这个转换协议是可选部分',
	 'Down#OnReceive->Up#receiveHeaders: 5.将Donw的回传的Header回写',
	 'Up#receiveHeaders->Down#appendHeaders: 6.同上，这里又可以可选的重写 Header 的逻辑',
	 'Down#OnReceive->Up#receiveData: 7. 将 Down 的Body回写到 Upstream 中',
	 'Up#receiveData->Up#appendData: 8. 同上'
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>

<p>整个流程还是在 <code>Downstream:OnReceive</code> 进行控制，逻辑也就分为 <code>将输入的Header</code>/<code>输入的Body</code> 写入 <code>DownStream</code>，将输出按照同样的方式执行一次。不过值得注意的是，和架构图上一致。在处理单一请求的过程中，写入和回读都是同一个 <code>goroutinue</code>，对于 <code>Downstream</code> 的 <code>io</code> 处理是遵守标准的 <code>NetPoller</code> 的模型的，并没有  <code>RawPoller</code> 机制，<code>RawPoller</code> 机制仅在 <code>接受侧</code> 有单独的定义。</p>
<h3 id="小结：all-in-one"><a class="header-anchor" href="#小结：all-in-one">¶</a>小结：all in one</h3>
<p><img src="https://s3.jpg.cm/2020/09/02/1HMfG.png" alt="1HMfG.png"></p>
<p>对于 <code>Go Lanague</code> 因为 <code>Goroutine</code> 使用起来很方便，分析 <code>Go</code> 项目很难分析 <code>Theadmodel</code> 这块内容，或者也可以认为开 <code>Goroutine</code> 本身的成本很低，大家不用过于担心切换的成本。</p>
<p>作为对比，下面也放上官方的一张图。<br>
<img src="https://s3.jpg.cm/2020/09/03/1JAdf.png" alt="1JAdf.png"></p>
<p>直到这里我们已经将 <code>监听请求</code> <code>接受数据</code> <code>转发请求</code> <code>响应请求</code> 这几个部分都阅读过了，整个流程已经走通了，我们再去看看其他重要的功能。</p>
<h3 id="多协议机制"><a class="header-anchor" href="#多协议机制">¶</a>多协议机制</h3>
<p><code>Mosn</code> 支持多协议之间的转换，我们从想问的分析中，我们可以知道所谓的 <code>Proxy</code> 就是我们整个 <code>FilterManager</code> 中的一个 <code>Filter</code>。因此对于配置文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;proxy&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;downstream_protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Http1&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;upstream_protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Http1&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;router_config_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;server_router&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>Mosn</code> 这个功能非常的有趣，因为实际上因为RPC协议非常的多，因此想要支持多种协议的话，都是需要用户自行进行拓展的，不过 <code>Mosn</code> 帮大家做了一部分的工作，流程如下图：</p>
<p><img src="https://s3.jpg.cm/2020/09/03/1troW.png" alt="1troW.png"></p>
<p>在 <code>pkg/protocol/xprotocol/example/encoder.go</code> 中有一个例子。对于大多数的 <code>RPC</code> 协议我们都是需要获取到 <code>足够</code> 信息之后再处理，那第一步显然是我们需要先获得一些数据也就是 <code>MinimalDecodeLen</code></p>
<figure class="highlight go"><figcaption><span>Decode</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proto *proto)</span></span> Decode(ctx context.Context, data types.IoBuffer) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> data.Len() &gt;= MinimalDecodeLen &#123; <span class="comment">// 这里我们需要获得至少获得 Header 部分的信息</span></span><br><span class="line">		magic := data.Bytes()[<span class="number">0</span>]</span><br><span class="line">		dir := data.Bytes()[<span class="number">2</span>]</span><br><span class="line">		<span class="keyword">switch</span> dir &#123;</span><br><span class="line">		<span class="keyword">case</span> DirRequest:</span><br><span class="line">			<span class="keyword">return</span> decodeRequest(ctx, data)</span><br><span class="line">		<span class="keyword">case</span> DirResponse:</span><br><span class="line">			<span class="keyword">return</span> decodeResponse(ctx, data)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后我们需要获得完整的数据</p>
<figure class="highlight go"><figcaption><span>decodeRequest</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeRequest</span><span class="params">(ctx context.Context, data types.IoBuffer)</span></span> (cmd <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">	bytesLen := data.Len()</span><br><span class="line">	bytes := data.Bytes()</span><br><span class="line"></span><br><span class="line">	payloadLen := binary.BigEndian.Uint32(bytes[<span class="number">7</span>:])</span><br><span class="line">	frameLen := RequestHeaderLen + <span class="type">int</span>(payloadLen)</span><br><span class="line">	<span class="keyword">if</span> bytesLen &lt; frameLen &#123;</span><br><span class="line">		<span class="keyword">return</span>  <span class="comment">// 如果没有获取到足够的数据就等待下次执行</span></span><br><span class="line">	&#125;</span><br><span class="line">	data.Drain(frameLen)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//处理数据略</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> request, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就足够满足我们对于自定义数据的处理能力。而对于协议的解析部分还有一个困难的问题需要我们继续处理也就是 <code>多路复用</code>，我们不能在一个 <code>TCP</code> 链路上仅仅处理一个请求，这就是最低效的 <code>Http1</code>，因此协议需要能够定义出来，如果我在一个链路上进行多次请求是怎么区分的。对于 <code>Mosn</code> 来说这里还是有一个很精妙的设计，利用上下的隐性属性作为唯一的 <code>ID</code> 进行判断。这里就不展开，可以查看官方的 <a href="https://mosn.io/docs/concept/multi-protocol/#%E5%8D%8F%E8%AE%AE%E6%89%A9%E5%B1%95%E6%A1%86%E6%9E%B6-mosn">协议扩展框架</a></p>
<p>我们来关注下对于流程线上的问题，就是这段逻辑是镶嵌在我们的流程的何处的。在特殊的协议处理部分我们在启动时候定义的数据格式都类似于</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;proxy&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;downstream_protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;X&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;upstream_protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;X&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;router_config_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;server_router&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;extend_config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;sub_protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dubbo&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>因此我们在处理特定协议的时候需要传入指定的扩展协议如 <code>dubbo</code> 等。因此在构建的 <code>proxy</code> 的时候，将这个保存在 <code>proxy</code> 的属性中。</p>
<figure class="highlight go"><figcaption><span>proxy:NewProxy</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> json.Unmarshal([]<span class="type">byte</span>(extJSON), &amp;xProxyExtendConfig); xProxyExtendConfig.SubProtocol != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">	proxy.context = mosnctx.WithValue(proxy.context, types.ContextSubProtocol, xProxyExtendConfig.SubProtocol)</span><br><span class="line">	log.DefaultLogger.Tracef(<span class="string">&quot;[proxy] extend config subprotocol = %v&quot;</span>, xProxyExtendConfig.SubProtocol)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在我们收到数据的时候会发现在 <code>OnData</code> 的时候我们会创建 <code>ServerStream</code> 的时候传入协议属性</p>
<figure class="highlight go"><figcaption><span>proxy:OnData</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *proxy)</span></span> OnData(buf buffer.IoBuffer) api.FilterStatus &#123;</span><br><span class="line">	<span class="keyword">if</span> p.serverStreamConn == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 这里会创建我们的 ServerStreamConn 而这对象是需要传入 protocol，也就是这里进行了处理</span></span><br><span class="line">		protocol, err := stream.SelectStreamFactoryProtocol(p.context, prot, buf.Bytes())</span><br><span class="line">		p.serverStreamConn = stream.CreateServerStreamConnection(p.context, protocol, p.readCallbacks.Connection(), p)</span><br><span class="line">	&#125;</span><br><span class="line">	p.serverStreamConn.Dispatch(buf) <span class="comment">// 处理 Buf</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> api.Stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此如果我们使用扩展的 <code>协议</code> 这里创建的 <code>ServerStreamConn</code> 也就是 <code>pkg/stream/xprotocol/conn.go</code>，而他的处理逻辑如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *streamConn)</span></span> Dispatch(buf types.IoBuffer) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		streamCtx := sc.ctxManager.Get()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 进行 Decode 和我们上面分析的逻辑一致</span></span><br><span class="line">		frame, err := sc.protocol.Decode(streamCtx, buf)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.1 为null则等待下一次的 Dispatch</span></span><br><span class="line">		<span class="keyword">if</span> frame == <span class="literal">nil</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.3 处理协议包</span></span><br><span class="line">		<span class="keyword">if</span> frame != <span class="literal">nil</span> &#123;</span><br><span class="line">			xframe, ok := frame.(xprotocol.XFrame)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				log.Proxy.Errorf(sc.ctx, <span class="string">&quot;[stream] [xprotocol] conn %d, %v frame type not match : %T&quot;</span>, sc.netConn.ID(), sc.netConn.RemoteAddr(), frame)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			sc.handleFrame(streamCtx, xframe)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.4 下一个，这里其实就是在处理我们的 多路复用 部分</span></span><br><span class="line">		sc.ctxManager.Next()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此这段逻辑其实还是穿插在我们的 <code>Proxy</code> 中作为 <code>Filter</code> 中的一环，而这一环有需要依赖构建出不同的 <code>StreamConn</code> 进行处理，现在已知的支持 <code>http1</code> <code>http2</code> <code>xprotocol</code> 这3个类型。</p>
<h3 id="插件机制"><a class="header-anchor" href="#插件机制">¶</a>插件机制</h3>
<p>对于 <code>Mosn</code> 的插件机制也相对复杂，对于 <code>Envoy</code> 来说我们只有2处可以进行插件埋点，<code>Mosn</code> 也相对一致。</p>
<h4 id="SteamFilter"><a class="header-anchor" href="#SteamFilter">¶</a>SteamFilter</h4>
<p><img src="https://s3.jpg.cm/2020/09/03/1SLTy.png" alt="1SLTy.png"></p>
<p>MOSN 扩展中使用频率最高的扩展点。对于配置项如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;listeners&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;filter_chains&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;stream_filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;demo&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;User&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>从配置看，我可以发现 <code>StreamFilter</code> 和 <code>FilterChain</code> 是平级的（不过实际上并不是）。因此 <code>Stream</code> 分了两种类型：</p>
<blockquote>
<p>进入 proxy 流程以后，如果存在 ReceiverFilter，那么就会执行对应的逻辑，ReceiverFilter 包括两个阶段，“路由前”和“路由后”，在每个 Filter 处理完成以后，会返回一个状态，如果是 Stop 则会中止后续尚未执行的 ReceiverFilter，通常情况下，返回 Stop 状态的 Filter 都会回写一个响应。如果是 Continue 则会执行下一个 ReceiverFilter，直到本阶段的 ReceiverFilter 都执行完成或中止；路由前阶段的 ReceiverFIlter 执行完成后，就会执行路由后阶段，其逻辑和路由前一致。如果是正常转发，那么随后 MOSN 会收到一个响应或者发现其他异常直接回写一个响应，此时就会进入到 SenderFilter 的流程中，完成 SenderFilter 的处理。SenderFilter 处理完成以后，MOSN 会写响应给 Client，并且完成最后的收尾工作，收尾工作包括一些数据的回收、日志的记录，以及 StreamFilter 的“销毁”（调用 OnDestroy）。</p>
</blockquote>
<p>原文中有几个重点，在系统解析完一个 <code>请求</code> 之后才会进入这个流程，因此在 <code>pkg/stream/http/stream.go:serve</code> 中可以发现构建这个 <code>StreamFilter</code> 的逻辑</p>
<figure class="highlight go"><figcaption><span>pkg/proxy/downstream.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *downStream)</span></span> AddStreamSenderFilter(filter api.StreamSenderFilter) &#123;</span><br><span class="line">	sf := newActiveStreamSenderFilter(s, filter)</span><br><span class="line">	s.senderFilters = <span class="built_in">append</span>(s.senderFilters, sf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到我们熟悉的地方来 <code>DownStream:receive</code> 中</p>
<figure class="highlight go"><figcaption><span>receive</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> types.DownFilterAfterChooseHost:</span><br><span class="line">	<span class="keyword">if</span> log.Proxy.GetLogLevel() &gt;= log.DEBUG &#123;</span><br><span class="line">		s.printPhaseInfo(types.DownFilterAfterChooseHost, id)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里执行了我们注册在流程中的 `ReceiveFilter`</span></span><br><span class="line">	s.runReceiveFilters(phase, s.downstreamReqHeaders, s.downstreamReqDataBuf, s.downstreamReqTrailers)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> p, err := s.processError(id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p</span><br><span class="line">	&#125;</span><br><span class="line">	phase++</span><br></pre></td></tr></table></figure>
<p>官方的Demo可以看一下，使用起来还是很方便的 <a href="https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/simple_streamfilter">Stream Filter Demo</a></p>
<h4 id="MOSN-Plugin-机制"><a class="header-anchor" href="#MOSN-Plugin-机制">¶</a>MOSN Plugin 机制</h4>
<p><code>Mosn</code> 还提供了另外一种基于通讯机制的方式</p>
<p><img src="https://s3.jpg.cm/2020/09/03/1YSLR.png" alt="1YSLR.png"></p>
<p>在这里有个例子：<a href="https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/plugin/filter">Stream Filter Plugin demo</a></p>
<p>不过这种算是上面一种的变形，实际上我们依然需要将 <code>StreamFilter</code> 注册到系统中，不过这一次所有的逻辑处理不在编译器固定，而是有一个 <code>gRPC</code> 的外部服务可以进行通讯判断。因此其实不再限于单一语言，我们只需要遵守 <code>gRPC</code> 的协议即可。</p>
<h3 id="平滑升级"><a class="header-anchor" href="#平滑升级">¶</a>平滑升级</h3>
<p>平滑升级可以参考 <a href="/2020/06/12/other/hot-restart/">聊聊服务端热更新</a> 和 <a href="https://mosn.io/blog/posts/nginx-envoy-mosn-hot-upgrade/">Nginx vs Envoy vs MOSN 平滑升级原理解析</a> 不做展开了。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://mosn.io/blog/code/">官方源码分析</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>go</category>
        <category>mosn</category>
        <category>gateway</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>mosn</tag>
        <tag>gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Envoy的知识</title>
    <url>/2020/04/21/networking/envoy/around-envoy/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210312145904.png" alt=""></p>
<h2 id="开发环境搭建"><a class="header-anchor" href="#开发环境搭建">¶</a>开发环境搭建</h2>
<p>基于 Ubuntu 18.04 进行开发，一下的所有篇幅的Envoy版本基于 1.14.1</p>
<span id="more"></span>
<h3 id="基础工具下载"><a class="header-anchor" href="#基础工具下载">¶</a>基础工具下载</h3>
<h4 id="安装-Bazel"><a class="header-anchor" href="#安装-Bazel">¶</a>安装 Bazel</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wget -O /usr/local/bin/bazel https://github.com/bazelbuild/bazelisk/releases/latest/download/bazelisk-linux-amd64</span><br><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/bazel</span><br></pre></td></tr></table></figure>
<h4 id="安装基础依赖"><a class="header-anchor" href="#安装基础依赖">¶</a>安装基础依赖</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libtool cmake automake autoconf make ninja-build curl unzip virtualenv</span><br></pre></td></tr></table></figure>
<h4 id="Clang-构建环境-（可选）"><a class="header-anchor" href="#Clang-构建环境-（可选）">¶</a>Clang 构建环境 （可选）</h4>
<p>从 <a href="http://releases.llvm.org/download.html">llvm</a> 下载安装，9.0 版本比较兼容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bazel/setup_clang.sh &lt;PATH_TO_EXTRACTED_CLANG_LLVM&gt;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;build --config=clang&quot;</span> &gt;&gt; user.bazelrc</span><br></pre></td></tr></table></figure>
<h4 id="使用-bazel构建DEBUG版本"><a class="header-anchor" href="#使用-bazel构建DEBUG版本">¶</a>使用 bazel构建DEBUG版本</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bazel build -c dbg --spawn_strategy=standalone  //source/exe:envoy-static</span><br></pre></td></tr></table></figure>
<h2 id="集成-Clion"><a class="header-anchor" href="#集成-Clion">¶</a>集成 Clion</h2>
<h3 id="将-Bazel-转化为-Cmake"><a class="header-anchor" href="#将-Bazel-转化为-Cmake">¶</a>将 Bazel 转化为 Cmake</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lizan/bazel-cmakelists.git &lt;PATH&gt;</span><br><span class="line">&lt;bazel-cmakelists <span class="built_in">dir</span>&gt;/bazel-cmakelists --targets //source/exe:envoy-static //test/...</span><br><span class="line">// 如果不需要构建可以</span><br><span class="line">&lt;bazel-cmakelists <span class="built_in">dir</span>&gt;/bazel-cmakelists --targets //source/exe:envoy-static //test/... --skip_build</span><br></pre></td></tr></table></figure>
<ul>
<li>打开Clion导入Cmake项目即可，Clion的 <code>Bazel插件</code> 不能够针对Envoy良好的工作。</li>
<li>设置Debug启动即可。</li>
</ul>
<h3 id="开发环境搭建参考"><a class="header-anchor" href="#开发环境搭建参考">¶</a>开发环境搭建参考</h3>
<ul>
<li><a href="https://blog.gmem.cc/clion-faq#debug">CLion知识集锦</a></li>
<li><a href="https://github.com/envoyproxy/envoy/blob/master/bazel/README.md">Building Envoy with Bazel</a></li>
<li><a href="https://github.com/envoyproxy/envoy/issues/6297">How to set up develop environment on mac using clion or vs code #6297</a></li>
</ul>
<h2 id="Envoy-基础"><a class="header-anchor" href="#Envoy-基础">¶</a>Envoy 基础</h2>
<h3 id="Libevent"><a class="header-anchor" href="#Libevent">¶</a>Libevent</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Envoy is an L7 proxy and communication bus designed <span class="keyword">for</span> large modern service oriented architectures. The project was born out of the belief.</span><br></pre></td></tr></table></figure>
<p>如同在官网的介绍一样，Envoy是一个高性能的代理服务软件，支持 L4 和 L7 的代理能力。但是Envoy也并非是一个完全重复造轮子的产品，Envoy的底层与操作系统交互网络部分采用的是  <a href="https://libevent.org/">libevent</a>。</p>
<p>libevent 是一个轻量级的网络<strong>事件</strong>库，提供了对于底层 Socket 的读写等事件的回调处理能力。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        export函数
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> MESSAGE[] = <span class="string">&quot;Hello, World!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> PORT = <span class="number">9995</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">listener_cb</span><span class="params">(<span class="keyword">struct</span> evconnlistener *, <span class="type">evutil_socket_t</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> sockaddr *, <span class="type">int</span> socklen, <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">conn_writecb</span><span class="params">(<span class="keyword">struct</span> bufferevent *, <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">conn_eventcb</span><span class="params">(<span class="keyword">struct</span> bufferevent *, <span class="type">short</span>, <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">signal_cb</span><span class="params">(<span class="type">evutil_socket_t</span>, <span class="type">short</span>, <span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">listener</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">signal_event</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">	WSADATA wsa_data;</span><br><span class="line">	WSAStartup(<span class="number">0x0201</span>, &amp;wsa_data);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	base = event_base_new();</span><br><span class="line">	<span class="keyword">if</span> (!base) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not initialize libevent!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">	<span class="built_in">sin</span>.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">	listener = evconnlistener_new_bind(base, listener_cb, (<span class="type">void</span> *)base,</span><br><span class="line">	    LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, <span class="number">-1</span>,</span><br><span class="line">	    (<span class="keyword">struct</span> sockaddr*)&amp;<span class="built_in">sin</span>,</span><br><span class="line">	    <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!listener) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not create a listener!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	signal_event = evsignal_new(base, SIGINT, signal_cb, (<span class="type">void</span> *)base);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!signal_event || event_add(signal_event, <span class="literal">NULL</span>)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not create/add a signal event!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line">	evconnlistener_free(listener);</span><br><span class="line">	event_free(signal_event);</span><br><span class="line">	event_base_free(base);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;done\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">listener_cb</span><span class="params">(<span class="keyword">struct</span> evconnlistener *listener, <span class="type">evutil_socket_t</span> fd,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> sockaddr *sa, <span class="type">int</span> socklen, <span class="type">void</span> *user_data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> user_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span>;</span></span><br><span class="line"></span><br><span class="line">	bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line">	<span class="keyword">if</span> (!bev) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error constructing bufferevent!&quot;</span>);</span><br><span class="line">		event_base_loopbreak(base);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	bufferevent_setcb(bev, <span class="literal">NULL</span>, conn_writecb, conn_eventcb, <span class="literal">NULL</span>);</span><br><span class="line">	bufferevent_enable(bev, EV_WRITE);</span><br><span class="line">	bufferevent_disable(bev, EV_READ);</span><br><span class="line"></span><br><span class="line">	bufferevent_write(bev, MESSAGE, <span class="built_in">strlen</span>(MESSAGE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">conn_writecb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">void</span> *user_data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">output</span> =</span> bufferevent_get_output(bev);</span><br><span class="line">	<span class="keyword">if</span> (evbuffer_get_length(output) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;flushed answer\n&quot;</span>);</span><br><span class="line">		bufferevent_free(bev);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">conn_eventcb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">short</span> events, <span class="type">void</span> *user_data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (events &amp; BEV_EVENT_EOF) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Connection closed.\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; BEV_EVENT_ERROR) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Got an error on the connection: %s\n&quot;</span>,</span><br><span class="line">		    strerror(errno));<span class="comment">/*XXX win32*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* None of the other events can happen here, since we haven&#x27;t enabled</span></span><br><span class="line"><span class="comment">	 * timeouts */</span></span><br><span class="line">	bufferevent_free(bev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">signal_cb</span><span class="params">(<span class="type">evutil_socket_t</span> sig, <span class="type">short</span> events, <span class="type">void</span> *user_data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> user_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">delay</span> =</span> &#123; <span class="number">2</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Caught an interrupt signal; exiting cleanly in two seconds.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	event_base_loopexit(base, &amp;delay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    </div>
</div>
<p>从上文中我们自然可以很明白的看懂，我们处理 lister/read/write/signal 这四个事件进行了监听处理。</p>
<h3 id="Libevent-in-Envoy"><a class="header-anchor" href="#Libevent-in-Envoy">¶</a>Libevent in Envoy</h3>
<p>续上文，libevent在Envoy中的定位也是偏底层的，通过不同事件获得的数据包会真实的扭转至 Envoy 的系统内部进行处理，我们举一个常见的读取的例子。但是在讲这个之前，我们先来看看 Envoy 的代码的入口定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  std::unique_ptr&lt;Envoy::MainCommon&gt; main_common;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    main_common = std::<span class="built_in">make_unique</span>&lt;Envoy::MainCommon&gt;(argc, argv);</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> Envoy::NoServingException&amp; e) &#123;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> Envoy::MalformedArgvException&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> Envoy::EnvoyException&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> main_common-&gt;<span class="built_in">run</span>() ? EXIT_SUCCESS : EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛开那些兼容系统的代码，我们可以发现和绝大多数的系统设计一样，我们有一个最底层的设计称之为<code>MainCommon</code>，通过一顿类型跳转大法，我们可以定位到真正的启动位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InstanceImpl::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// RunHelper exists primarily to facilitate how we respond to early shutdown during</span></span><br><span class="line">  <span class="comment">// startup (see RunHelperTest in server_test.cc).</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> run_helper = <span class="built_in">RunHelper</span>(*<span class="keyword">this</span>, options_, *dispatcher_, <span class="built_in">clusterManager</span>(),</span><br><span class="line">                                    access_log_manager_, init_manager_, <span class="built_in">overloadManager</span>(), [<span class="keyword">this</span>] &#123;</span><br><span class="line">                                      <span class="built_in">notifyCallbacksForStage</span>(Stage::PostInit);</span><br><span class="line">                                      <span class="built_in">startWorkers</span>(); <span class="comment">// ➁</span></span><br><span class="line">                                    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the main dispatch loop waiting to exit.</span></span><br><span class="line">  <span class="built_in">ENVOY_LOG</span>(info, <span class="string">&quot;starting main dispatch loop&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> watchdog =</span><br><span class="line">      guard_dog_-&gt;<span class="built_in">createWatchDog</span>(api_-&gt;<span class="built_in">threadFactory</span>().<span class="built_in">currentThreadId</span>(), <span class="string">&quot;main_thread&quot;</span>);</span><br><span class="line">  watchdog-&gt;<span class="built_in">startWatchdog</span>(*dispatcher_);</span><br><span class="line">  dispatcher_-&gt;<span class="built_in">post</span>([<span class="keyword">this</span>] &#123; <span class="built_in">notifyCallbacksForStage</span>(Stage::Startup); &#125;);</span><br><span class="line">  dispatcher_-&gt;<span class="built_in">run</span>(Event::Dispatcher::RunType::Block); ➀</span><br><span class="line">  <span class="built_in">ENVOY_LOG</span>(info, <span class="string">&quot;main dispatch loop exited&quot;</span>);</span><br><span class="line">  guard_dog_-&gt;<span class="built_in">stopWatching</span>(watchdog);</span><br><span class="line">  watchdog.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">terminate</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 ➀ 处四周的代码暂且不管，实际上我们发现我们最终的主循环是在此处。在一顿跳转之后，我们终于拨开了层层外衣，看到了 Libevent 的部分。在 ➁ 处参考 <a href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F">线程模式</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LibeventScheduler::run</span><span class="params">(Dispatcher::RunType mode)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">  <span class="keyword">case</span> Dispatcher::RunType::NonBlock:</span><br><span class="line">    flag = EVLOOP_NONBLOCK;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Dispatcher::RunType::Block:</span><br><span class="line">    <span class="comment">// The default flags have &#x27;block&#x27; behavior. See</span></span><br><span class="line">    <span class="comment">// http://www.wangafu.net/~nickm/libevent-book/Ref3_eventloop.html</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Dispatcher::RunType::RunUntilExit:</span><br><span class="line">    flag = EVLOOP_NO_EXIT_ON_EMPTY;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">event_base_loop</span>(libevent_.<span class="built_in">get</span>(), flag); ➀</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➀ 处理刚好即是我们最终构建的 Libevent 的Loop循环，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">event_base_loop</span><span class="params">(<span class="keyword">struct</span> event_base *, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当 event_base 内部不存在任何注册事件之后，才会停止工作。那下一步，我们的目标是找到，我们何时何地的为这个 event_base 创建了各类事件的？</p>
<p>不难发现，经过我们的细心勘察，我们可以在 ListenerImpl::setupServerSocket 中发现监听端口的逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListenerImpl::setupServerSocket</span><span class="params">(Event::DispatcherImpl&amp; dispatcher, Socket&amp; socket)</span> </span>&#123;</span><br><span class="line">  listener_.<span class="built_in">reset</span>(</span><br><span class="line">      <span class="built_in">evconnlistener_new</span>(&amp;dispatcher.<span class="built_in">base</span>(), listenCallback, <span class="keyword">this</span>, <span class="number">0</span>, <span class="number">-1</span>, socket.<span class="built_in">ioHandle</span>().<span class="built_in">fd</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一点和 Netty 等网络框架不一样，Libevent 是一个全局性的事件监听库，他可以监听不同的端口，回忆一下，Socket 是不是区分为 <code>Server Socket</code> 和 <code>Client Socket</code> ，一点没错，这里做的事情，是创建一个 <code>Server Socket</code> 并且监听他的 listenCallback 也就创建新连接时的事件。</p>
<p>在 <code>ListenCallback</code> 函数中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListenerImpl::listenCallback</span><span class="params">(evconnlistener*, <span class="type">evutil_socket_t</span> fd, sockaddr* remote_addr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">int</span> remote_addr_len, <span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  ListenerImpl* listener = <span class="built_in">static_cast</span>&lt;ListenerImpl*&gt;(arg);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the IoSocketHandleImpl for the fd here.</span></span><br><span class="line">  IoHandlePtr io_handle = std::<span class="built_in">make_unique</span>&lt;IoSocketHandleImpl&gt;(fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the local address from the new socket if the listener is listening on IP ANY</span></span><br><span class="line">  <span class="comment">// (e.g., 0.0.0.0 for IPv4) (local_address_ is nullptr in this case).</span></span><br><span class="line">  <span class="type">const</span> Address::InstanceConstSharedPtr&amp; local_address =</span><br><span class="line">      listener-&gt;local_address_ ? listener-&gt;local_address_</span><br><span class="line">                               : listener-&gt;<span class="built_in">getLocalAddress</span>(io_handle-&gt;<span class="built_in">fd</span>());</span><br><span class="line">  listener-&gt;cb_.<span class="built_in">onAccept</span>(</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;AcceptedSocketImpl&gt;(std::<span class="built_in">move</span>(io_handle), local_address, remote_address));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最后一行就可以清晰的发现，当我们的 <code>ServerSocket</code> 获得一个新的客户端连接的时候就会将这个文件句柄 <code>fd</code> 。</p>
<blockquote>
<p>编者注: 这里的 <code>FD</code> 一切皆文件的思想，并且这里并没有使用 Libevent 的 Read 回调，所以这里在建立的时候，这个FD已经转交给 Envoy 的系统。</p>
</blockquote>
<p>当我们继续看下去，我们在真实的接受网络请求的时候此处的回调函数执行逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> ConnectionHandlerImpl::ActiveTcpListener::<span class="built_in">onAcceptWorker</span>(</span><br><span class="line">    Network::ConnectionSocketPtr&amp;&amp; socket, <span class="type">bool</span> hand_off_restored_destination_connections, <span class="type">bool</span> rebalanced) &#123;</span><br><span class="line">  <span class="keyword">auto</span> active_socket = std::<span class="built_in">make_unique</span>&lt;ActiveTcpSocket&gt;(*<span class="keyword">this</span>, std::<span class="built_in">move</span>(socket),</span><br><span class="line">                                                         hand_off_restored_destination_connections);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create and run the filters</span></span><br><span class="line">  config_.<span class="built_in">filterChainFactory</span>().<span class="built_in">createListenerFilterChain</span>(*active_socket); ➀</span><br><span class="line">  active_socket-&gt;<span class="built_in">continueFilterChain</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Move active_socket to the sockets_ list if filter iteration needs to continue later.</span></span><br><span class="line">  <span class="comment">// Otherwise we let active_socket be destructed when it goes out of scope.</span></span><br><span class="line">  <span class="keyword">if</span> (active_socket-&gt;iter_ != active_socket-&gt;accept_filters_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    active_socket-&gt;<span class="built_in">startTimer</span>();</span><br><span class="line">    active_socket-&gt;<span class="built_in">moveIntoListBack</span>(std::<span class="built_in">move</span>(active_socket), sockets_); ➁</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➀ 在这里为 Socket 创建了 FilterChain。<br>
➁ 将 socket 压入待处理的队列，从这里我们可以大胆的假设：对于已经和服务器建立起连接的Socket，Envoy会采用和Netty类型的 Reactor 模式类似的方式进行线程管理。也就是接受线程就是 Listener，真正的Worker会从这里的List中获取工作的Socket。</p>
<p>额外的资料 :</p>
<ul>
<li><a href="https://gist.github.com/fxsjy/0170293e75eb53bbf007">libevent multithread worker example</a></li>
</ul>
<p>又在一波骚操作之下，我们发来到了创建新连接的地方（其实更像是分配新连接） ConnectionHandlerImpl::ActiveTcpListener::newConnection。但是在这里我们依然不能发现Read的逻辑，献出我们的人肉Debug大法，我们在读取数据的 <strong>ConnectionImpl::onRead</strong> 放下断点这一大杀器。</p>
<p><img src="https://s1.ax1x.com/2020/04/26/JgPwQS.png" alt="JgPwQS.png"></p>
<p>我们依然发现起始点仍然是 event_base_loop，那我们的疑问自然就变成了，究竟是在哪里进行事件注册的，因为我们知道注册进来的是 event_base 对象，我们通过 usage 的方式进行查找，找到了一个可疑点 <strong>FileEventImpl::assignEvents</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileEventImpl::assignEvents</span><span class="params">(<span class="type">uint32_t</span> events, event_base* base)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ASSERT</span>(base != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">event_assign</span>(</span><br><span class="line">      &amp;raw_event_, base, fd_,</span><br><span class="line">      EV_PERSIST | (trigger_ == FileTriggerType::Level ? <span class="number">0</span> : EV_ET) |</span><br><span class="line">          (events &amp; FileReadyType::Read ? EV_READ : <span class="number">0</span>) |</span><br><span class="line">          (events &amp; FileReadyType::Write ? EV_WRITE : <span class="number">0</span>) |</span><br><span class="line">          (events &amp; FileReadyType::Closed ? EV_CLOSED : <span class="number">0</span>),</span><br><span class="line">      [](<span class="type">evutil_socket_t</span>, <span class="type">short</span> what, <span class="type">void</span>* arg) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span>* event = <span class="built_in">static_cast</span>&lt;FileEventImpl*&gt;(arg);</span><br><span class="line">        <span class="type">uint32_t</span> events = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// ... skip something</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来，在这里进行了事件的分配，我们打上断点，再走一遍。从调用的栈中，我们可以清晰的发现：</p>
<p><img src="https://s1.ax1x.com/2020/04/26/JgiIc8.png" alt="JgiIc8.png"></p>
<p>在 <code>OnAccpet</code> -&gt; <code>newConnection</code> -&gt; <code>AssignEvents</code> 这样的一个逻辑，只是因为整个过程的栈太深，我们不能轻易的发现，事件的注册是在创建客户端的 socket 的时候创建的。剩下来的注册逻辑是 libevent 部分，不做深入。</p>
<h3 id="线程模式"><a class="header-anchor" href="#线程模式">¶</a>线程模式</h3>
<p>首先可以阅读下 <a href="https://blog.envoyproxy.io/envoy-threading-model-a8d44b922310">Envoy threading model</a></p>
<p>在 <code>Envoy</code> 中 <code>Libevent</code> 充当了一个更底层的lib依赖，如同我们写 SpringWeb 时候的 Tomcat，对于 <code>Socket</code> 的读写等事件是委托给 <code>Libevnet</code> 的。第一步是为我们的 Event_base 创建了 Listen 的监听事件。之后，在建立起连接的时候，Envoy增加了对于 Socket 的Read/Write 事件的监听。</p>
<blockquote>
<p>其实如果在 AssginEvents 处设置断点再重新启动，第一个注册的事件是对于配置文件的读事件的事件（为的是热更新配置），之后是 DNS 的事件注册，之后我们启动了Envoy服务，再此之后，我们要初始化配置文件中的各种 Listener，但是值得注意的是，LibeventScheduler::run 的是在每一个 Worker 中都存在的。</p>
</blockquote>
<div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2020-04-26T14:37:09.852Z\&quot; agent=\&quot;5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.122 Safari/537.36\&quot; etag=\&quot;4g4FSudXRvnBnlDdvQeA\&quot; version=\&quot;13.0.1\&quot; type=\&quot;github\&quot;&gt;&lt;diagram id=\&quot;4hUaTbZ2IO-6oDbpjdxY\&quot; name=\&quot;第 1 页\&quot;&gt;7VnZcpswFP0aHpNhN36MlySdOpN20k6bp4wMMqgRiAp5IV9fyQgDRondxk5wW9sP0tWCdM4990pYs4bx6oqCNLohAcSaqQcrzRpppmnYpqmJnx7khcXTjcIQUhTITpXhDj1BadSldY4CmDU6MkIwQ2nT6JMkgT5r2AClZNnsNiO4+dQUhLBluPMBblu/oYBFchdmr7JfQxRG5ZMNt1+0xKDsLHeSRSAgy5rJGmvWkBLCilK8GkIswCtxKcZdPtO6WRiFCdtnwOQpopOf97e3i9z4Grnu6NL2z5xilgXAc7lhuViWlwhQMk8CKCbRNWuwjBCDdynwReuSc85tEYsxrxm8OEMYDwkmlNcTkvBOg/Y65dIXkDK4qpnkuq8giSGjOe9StpbeIJ3IdGV9WVFi2dIW1eiwdGkE0g3CzdwVUrwgwfoN4OyTAM7bwk1v4+aZCtxs+1i4GS3cJmgKF2KLr8LvEF7mNtGy+m20DBVa7rHAavsUDHh0klVCWURCkgA8rqyDJmpVnwkhqcTqB2Qsl6EWzBlpIskBpPl3Mf7cKav39bbRSk5e1HJZe5aBjMypD3f7BAM0hGx3P4HBi3xSiAFDi2YEPzg5VsuT1278MAUZfMAC7W3yuB+yJtYAozDhZZ8PhFz6A+GtiGefC9kQoyAoaIUZegLT9VQC7ZSghK235Aw0ZyTm4kxmBakHEsQmekpB2IZCEIZCEOaxBOG2MP8SUQgCMStfFqGPHMXdsGeMkke4FW4VEXh/elTRqanEQ/DRtxt8OFabD1UWPBodvZNIgk73Tg9ed7Og07ks2P83sqC3Zxb0OpUFS239xWmw17k0aJgt0MfJguTvC/WMJEzqScB5kPvLVuh2VRcYZeR+PfLe9dQI3JvFjXn28d5d3k4uPj8ori8ndgBpYa9g6IXrZJOOtzyAKOlw3yM1KOPvzpivXL+9Z8y33yjEv7TIms8PMVIdVcicYZRwty5fxekyKpRerZkW/16KZw9CCgIxy5bHN5VRH1CXB7fP1h9uD0AWbegs9TEBU4g/8ejEEBE6mRLGSKwQEBOkt3VWP5RWYc0wy7rctHgkyNJitzO0EusYZBFIRWO8CsU70XOwzOxzHk3XzvDBF+sRwbUoNXv5BbAHEetGiVKsiqzlHukYp3Sj3olr1TkFrbbf5/7X6glo1fW6pdX2/bR0lA4c5l+FtL11vTX2hPoPjjC8Wv27s26r/UdmjX8B&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
<p>和 <code>Netty</code> 的处理不同，这里的 Listener 也是分布在所有的 Thread 上的。也就是在接受到一个新的请求的时候，是随机在 Worker 中选择一个进行处理的。</p>
<h2 id="Chain-in-Envoy"><a class="header-anchor" href="#Chain-in-Envoy">¶</a>Chain in Envoy</h2>
<p>在上文中，我们已经知道，在 <code>ClientSocket</code> 建立的 <code>Listen</code> 事件中，我们就将此 <code>Socket</code> 的 <code>Read/Write</code> 事件注册到 <code>Event_Base</code>，我们在注册的事件中，我们轻而易举的定位到  <code>ConnectionImpl::onRead</code> 此处是读取逻辑处。</p>
<h3 id="请求处理链"><a class="header-anchor" href="#请求处理链">¶</a>请求处理链</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionImpl::onRead</span><span class="params">(<span class="type">uint64_t</span> read_buffer_size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!read_enabled_ || <span class="built_in">inDelayedClose</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ASSERT</span>(<span class="built_in">ioHandle</span>().<span class="built_in">isOpen</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read_buffer_size == <span class="number">0</span> &amp;&amp; !read_end_stream_) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  filter_manager_.<span class="built_in">onRead</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最后一行，我们就进入了整个流程处理的开始  <code>FilterManager</code> 开始处理的逻辑。在之后的几层跳转中，我们发现了处理逻辑的核心所在：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FilterManagerImpl::onContinueReading</span><span class="params">(ActiveReadFilter* filter,</span></span></span><br><span class="line"><span class="params"><span class="function"> </span></span></span><br><span class="line"><span class="params"><span class="function">  std::list&lt;ActiveReadFilterPtr&gt;::iterator entry;</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">if</span> (!filter) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    connection_.streamInfo().addBytesReceived(buffer_source.getReadBuffer().buffer.length());</span></span></span><br><span class="line"><span class="params"><span class="function">    entry = upstream_filters_.begin();</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    entry = std::next(filter-&gt;entry());</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">for</span> (; entry != upstream_filters_.end(); entry++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (!(*entry)-&gt;initialized_) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      (*entry)-&gt;initialized_ = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">      FilterStatus status = (*entry)-&gt;filter_-&gt;onNewConnection(); ➀</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">if</span> (status == FilterStatus::StopIteration || connection_.state() != Connection::State::Open) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">      &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    StreamBuffer read_buffer = buffer_source.getReadBuffer();</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (read_buffer.buffer.length() &gt; <span class="number">0</span> || read_buffer.end_stream) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      FilterStatus status = (*entry)-&gt;filter_-&gt;onData(read_buffer.buffer, read_buffer.end_stream); ➁</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">if</span> (status == FilterStatus::StopIteration || connection_.state() != Connection::State::Open) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">      &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>➀ 对于 Envoy 来说，也规定了一系列 Fitler 的抽象限定比如  <code>Network::ReadFilter</code> 就定义了 ReadFilter 一系列虚函数，我们可以看到在第一个Filter处，我们调用了 onNewConnection 这里必然是一个生命周期的回调函数，至于具体的内容我们需要去查看具体的实现类进行判断。</p>
<p>➁ 从这里我们发现真实的读取了数据的逻辑。从这里因为本文重点是在 Http协议的处理，我们这里的 ReadFilter 也会查看 <code>Http::ConnectionManagerImpl</code> 这个类的实现机制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">etwork::FilterStatus <span class="title">ConnectionManagerImpl::onData</span><span class="params">(Buffer::Instance&amp; data, <span class="type">bool</span>)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> redispatch;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    redispatch = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      codec_-&gt;<span class="built_in">dispatch</span>(data); <span class="comment">//将此数据分发出去</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (codec_-&gt;<span class="built_in">protocol</span>() &lt; Protocol::Http2) &#123;</span><br><span class="line">      <span class="keyword">if</span> (read_callbacks_-&gt;<span class="built_in">connection</span>().<span class="built_in">state</span>() == Network::Connection::State::Open &amp;&amp;</span><br><span class="line">          data.<span class="built_in">length</span>() &gt; <span class="number">0</span> &amp;&amp; streams_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        redispatch = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!streams_.<span class="built_in">empty</span>() &amp;&amp; streams_.<span class="built_in">front</span>()-&gt;state_.remote_complete_) &#123;</span><br><span class="line">        read_callbacks_-&gt;<span class="built_in">connection</span>().<span class="built_in">readDisable</span>(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (redispatch);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!read_callbacks_-&gt;<span class="built_in">connection</span>().<span class="built_in">streamInfo</span>().<span class="built_in">protocol</span>()) &#123;</span><br><span class="line">    read_callbacks_-&gt;<span class="built_in">connection</span>().<span class="built_in">streamInfo</span>().<span class="built_in">protocol</span>(codec_-&gt;<span class="built_in">protocol</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Network::FilterStatus::StopIteration;  <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里的实现过程中，我们至少发现了envoy 的 Filter 不是如同Java 的Fitler 是层层调用的，每一层只会做自己的事情，因为从代码内，我们可以发现这些因为如果正常处理的过程，我们应该会走完所有的 Fitler， 那基于这样的逻辑，我们可以判断出来，在这个 <code>codec_</code> 的逻辑里面，我们应该只是将 HTTP 进行解码，然而在实际的断点之中，其实在这个 codec 之中有一个优化是当我们 Pase 完成HTTP请求的时候，此处就会直接进行逻辑处理，具体的会跳转至如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ServerConnectionImpl::onMessageComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (active_request_.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; active_request = active_request_.<span class="built_in">value</span>();</span><br><span class="line">    active_request.remote_complete_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (deferred_end_stream_headers_) &#123;</span><br><span class="line">      active_request.request_decoder_-&gt;<span class="built_in">decodeHeaders</span>(</span><br><span class="line">          std::<span class="built_in">move</span>(absl::<span class="built_in">get</span>&lt;RequestHeaderMapPtr&gt;(headers_or_trailers_)), <span class="literal">true</span>); ➀</span><br><span class="line">      deferred_end_stream_headers_ = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processing_trailers_) &#123;</span><br><span class="line">      active_request.request_decoder_-&gt;<span class="built_in">decodeTrailers</span>(</span><br><span class="line">          std::<span class="built_in">move</span>(absl::<span class="built_in">get</span>&lt;RequestTrailerMapPtr&gt;(headers_or_trailers_)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Buffer::OwnedImpl buffer;</span><br><span class="line">      active_request.request_decoder_-&gt;<span class="built_in">decodeData</span>(buffer, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset to ensure no information from one requests persists to the next.</span></span><br><span class="line">    headers_or_trailers_.<span class="built_in">emplace</span>&lt;RequestHeaderMapPtr&gt;(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">http_parser_pause</span>(&amp;parser_, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ➀ 处会进入 Route 阶段（其实笔者觉得这里的设计是不太清晰，导致在阅读的过程中，不得不借助于Debug工具），在这里最终进入 <code>ConfigImpl::route</code> 逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">RouteConstSharedPtr <span class="title">RouteMatcher::route</span><span class="params">(<span class="type">const</span> Http::RequestHeaderMap&amp; headers,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> StreamInfo::StreamInfo&amp; stream_info,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint64_t</span> random_value)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> VirtualHostImpl* virtual_host = <span class="built_in">findVirtualHost</span>(headers);</span><br><span class="line">  <span class="keyword">if</span> (virtual_host) &#123;</span><br><span class="line">    <span class="keyword">return</span> virtual_host-&gt;<span class="built_in">getRouteFromEntries</span>(headers, stream_info, random_value); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过是否返回命中的 Route 来判断下一步的处理逻辑。在之后的逻辑中，我们随着断点来到了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> ConnectionManagerImpl::ActiveStream::<span class="built_in">decodeHeaders</span>(RequestHeaderMapPtr&amp;&amp; headers, <span class="type">bool</span> end_stream) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 略....</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">decodeHeaders</span>(<span class="literal">nullptr</span>, *request_headers_, end_stream);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reset it here for both global and overridden cases.</span></span><br><span class="line">  <span class="built_in">resetIdleTimer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>ConnectionManagerImpl::ActiveStream::decodeHeaders</code> 代码中有大量的处理 httpheader的逻辑，这里不做展开，我们进入，最重要的 decodeHeaders 的函数继续我们的探索,在这里的逻辑中，我们可以发现这里一个非常复杂的逻辑处理，我们慢慢的看一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Http::FilterHeadersStatus <span class="title">Filter::decodeHeaders</span><span class="params">(Http::RequestHeaderMap&amp; headers, <span class="type">bool</span> end_stream)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断是否拥有 Route，如果没有就直接Return了</span></span><br><span class="line">  route_ = callbacks_-&gt;<span class="built_in">route</span>();</span><br><span class="line">  <span class="keyword">if</span> (!route_) &#123;</span><br><span class="line">    config_.stats_.no_route_.<span class="built_in">inc</span>();</span><br><span class="line">    <span class="built_in">ENVOY_STREAM_LOG</span>(debug, <span class="string">&quot;no cluster match for URL &#x27;&#123;&#125;&#x27;&quot;</span>, *callbacks_,</span><br><span class="line">                     headers.<span class="built_in">Path</span>()-&gt;<span class="built_in">value</span>().<span class="built_in">getStringView</span>());</span><br><span class="line"></span><br><span class="line">    callbacks_-&gt;<span class="built_in">streamInfo</span>().<span class="built_in">setResponseFlag</span>(StreamInfo::ResponseFlag::NoRouteFound);</span><br><span class="line">    callbacks_-&gt;<span class="built_in">sendLocalReply</span>(Http::Code::NotFound, <span class="string">&quot;&quot;</span>, modify_headers, absl::<span class="literal">nullopt</span>,</span><br><span class="line">                               StreamInfo::ResponseCodeDetails::<span class="built_in">get</span>().RouteNotFound);</span><br><span class="line">    <span class="keyword">return</span> Http::FilterHeadersStatus::StopIteration;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 找到这个请求的路由对象</span></span><br><span class="line">  route_entry_ = route_-&gt;<span class="built_in">routeEntry</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 拿到配置的Cluster，其实也就是目标的地址</span></span><br><span class="line">  cluster_ = cluster-&gt;<span class="built_in">info</span>();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从上游获得连接为了获得 host</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; upstream_http_protocol_options = cluster_-&gt;<span class="built_in">upstreamHttpProtocolOptions</span>();</span><br><span class="line">  Http::ConnectionPool::Instance* http_pool = <span class="built_in">getHttpConnPool</span>();</span><br><span class="line">  Upstream::HostDescriptionConstSharedPtr host;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ENVOY_STREAM_LOG</span>(debug, <span class="string">&quot;router decoding headers:\n&#123;&#125;&quot;</span>, *callbacks_, headers);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将需要处理的数据压栈</span></span><br><span class="line">  modify_headers_ = modify_headers;</span><br><span class="line"></span><br><span class="line">  UpstreamRequestPtr upstream_request =</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;UpstreamRequest&gt;(*<span class="keyword">this</span>, std::<span class="built_in">make_unique</span>&lt;HttpConnPool&gt;(*http_pool));</span><br><span class="line">  upstream_request-&gt;<span class="built_in">moveIntoList</span>(std::<span class="built_in">move</span>(upstream_request), upstream_requests_);</span><br><span class="line">  upstream_requests_.<span class="built_in">front</span>()-&gt;<span class="built_in">encodeHeaders</span>(end_stream);</span><br><span class="line">  <span class="keyword">if</span> (end_stream) &#123;</span><br><span class="line">    <span class="built_in">onRequestComplete</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Http::FilterHeadersStatus::StopIteration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在   upstream_requests_.front()-&gt;encodeHeaders(end_stream) 这一步别有洞天</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpstreamRequest::encodeHeaders</span><span class="params">(<span class="type">bool</span> end_stream)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ASSERT</span>(!encode_complete_);</span><br><span class="line">  encode_complete_ = end_stream;</span><br><span class="line"></span><br><span class="line">  conn_pool_-&gt;<span class="built_in">newStream</span>(<span class="keyword">this</span>); ➀</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>➀ 在此处我们创建了一个向下游的 connection。随着我们代码的深入探索：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ConnPoolImplBase::ActiveClient::<span class="built_in">ActiveClient</span>(ConnPoolImplBase&amp; parent,</span><br><span class="line">                                             <span class="type">uint64_t</span> lifetime_request_limit,</span><br><span class="line">                                             <span class="type">uint64_t</span> concurrent_request_limit)</span><br><span class="line">    : <span class="built_in">parent_</span>(parent), <span class="built_in">remaining_requests_</span>(<span class="built_in">translateZeroToUnlimited</span>(lifetime_request_limit)),</span><br><span class="line">      <span class="built_in">concurrent_request_limit_</span>(<span class="built_in">translateZeroToUnlimited</span>(concurrent_request_limit)),</span><br><span class="line">      <span class="built_in">connect_timer_</span>(parent_.dispatcher_.<span class="built_in">createTimer</span>([<span class="keyword">this</span>]() -&gt; <span class="type">void</span> &#123; <span class="built_in">onConnectTimeout</span>(); &#125;)) &#123;</span><br><span class="line">  Upstream::Host::CreateConnectionData data = parent_.host_-&gt;<span class="built_in">createConnection</span>(</span><br><span class="line">      parent_.dispatcher_, parent_.socket_options_, parent_.transport_socket_options_);</span><br><span class="line">  real_host_description_ = data.host_description_;</span><br><span class="line">  codec_client_ = parent_.<span class="built_in">createCodecClient</span>(data);</span><br><span class="line">  codec_client_-&gt;<span class="built_in">addConnectionCallbacks</span>(*<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  conn_connect_ms_ = std::<span class="built_in">make_unique</span>&lt;Stats::HistogramCompletableTimespanImpl&gt;(</span><br><span class="line">      parent_.host_-&gt;<span class="built_in">cluster</span>().<span class="built_in">stats</span>().upstream_cx_connect_ms_, parent_.dispatcher_.<span class="built_in">timeSource</span>());</span><br><span class="line">  conn_length_ = std::<span class="built_in">make_unique</span>&lt;Stats::HistogramCompletableTimespanImpl&gt;(</span><br><span class="line">      parent_.host_-&gt;<span class="built_in">cluster</span>().<span class="built_in">stats</span>().upstream_cx_length_ms_, parent_.dispatcher_.<span class="built_in">timeSource</span>());</span><br><span class="line">  connect_timer_-&gt;<span class="built_in">enableTimer</span>(parent_.host_-&gt;<span class="built_in">cluster</span>().<span class="built_in">connectTimeout</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现在这里我才真正的去创建一个下游的连接。但是我们知道，对于一个高性能的WebServer，我们对于下游的访问也是不能进行 Blocking 的，因此，我们常见的处理能力应该是将下游的请求建立起来之后进行挂起，我们等待下游的返回再进行处理，因此在后面我们可以发现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ConnectionImpl::<span class="built_in">ConnectionImpl</span>(Event::Dispatcher&amp; dispatcher, ConnectionSocketPtr&amp;&amp; socket,</span><br><span class="line">                               TransportSocketPtr&amp;&amp; transport_socket,</span><br><span class="line">                               StreamInfo::StreamInfo&amp; stream_info, <span class="type">bool</span> connected)</span><br><span class="line">    : <span class="built_in">ConnectionImplBase</span>(dispatcher, next_global_id_++),</span><br><span class="line">  <span class="comment">// We never ask for both early close and read at the same time. If we are reading, we want to</span></span><br><span class="line">  <span class="comment">// consume all available data.</span></span><br><span class="line">  file_event_ = dispatcher_.<span class="built_in">createFileEvent</span>(</span><br><span class="line">      <span class="built_in">ioHandle</span>().<span class="built_in">fd</span>(), [<span class="keyword">this</span>](<span class="type">uint32_t</span> events) -&gt; <span class="type">void</span> &#123; <span class="built_in">onFileEvent</span>(events); &#125;, trigger,</span><br><span class="line">      Event::FileReadyType::Read | Event::FileReadyType::Write);</span><br><span class="line"></span><br><span class="line">  transport_socket_-&gt;<span class="built_in">setTransportSocketCallbacks</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建下游的链接的时候，我们就将下游回复数据的 <code>Read</code> 和 <code>Write</code> 事件注册到当前的 <code>Worker</code> 线程的 <code>Event_Base</code> 中。到这里我们先来看看前半段的整个流程：</p>


<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: Envoy下游响应前的处理流程',
	 'ConnectionImpl.onFileEvent->FilterManagerImpl.onRead: 1. 从Libevent触发的Read事件的数据倒腾到FilterManager',
	 'FilterManagerImpl.onRead->ConnectionImpl.dispatch: 2. 将数据进行分发',
   'ConnectionImpl.dispatch->ServerConnectionImpl.onMessageComplete: 3.当Http的数据读取完成进行下一步',
   'ServerConnectionImpl.onMessageComplete->Filter.decodeHeaders: 4.将数据导入FilterChain进行处理',
   'Filter.decodeHeaders->RouteImpl:route: 5.进行路由选择',
   'Filter.decodeHeaders->HostImpl.createConnection: 6.创建下游的HTTP连接',
   'HostImpl.createConnection->DispatcherImpl.createFileEvent: 7. 在Worker中创建响应连接的Read事件'
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>
<p>直至上面的内容，我们已经走过了接收到请求到创建到下游的请求的大部分流程，在此之后还有一些其他的事务性的需要处理，比如响应超时等，不做太多的深入，我们进入下一个环节：响应数据的处理链路。</p>
<h3 id="响应数据处理链路"><a class="header-anchor" href="#响应数据处理链路">¶</a>响应数据处理链路</h3>
<p>对于响应的数据，我们也知道在我们在执行完成之后，我们将后续的对 BackendSteam 的读写事件载入了 <code>EventBase</code> 我们看看后续这些数据如何处理，入口依然是 <code>OnRead()</code> 函数，之后的逻辑和之前类似，直到 <code>FilterManagerImpl::onRead</code> 之后调用的具体实现类是 <code>CodecClient</code> 相对会毕竟的简单，因为响应体我们不需要再进行什么路由设置等操作，然后当我们读取完成之后，就进入了 <code>ConnectionImpl::onMessageCompleteBase</code> 函数，进入了结束流程，我们就来看看，当我们从响应流里面读取完成所有的数据之后，又是如何响应最初的调用者的。然后就进入了 <code>ClientConnectionImpl::onMessageComplete</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClientConnectionImpl::onMessageComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ENVOY_CONN_LOG</span>(trace, <span class="string">&quot;message complete&quot;</span>, connection_);</span><br><span class="line">  <span class="keyword">if</span> (pending_response_.<span class="built_in">has_value</span>()) &#123; <span class="comment">// 当我们有挂起的 Response 的时候才处理</span></span><br><span class="line">    <span class="keyword">if</span> (connection_.<span class="built_in">state</span>() == Network::Connection::State::Open) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!connection_.<span class="built_in">readEnabled</span>()) &#123;</span><br><span class="line">        connection_.<span class="built_in">readDisable</span>(<span class="literal">false</span>); <span class="comment">// 让链接禁读，因为要写入了</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deferred_end_stream_headers_) &#123;</span><br><span class="line">      response.decoder_-&gt;<span class="built_in">decodeHeaders</span>(</span><br><span class="line">          std::<span class="built_in">move</span>(absl::<span class="built_in">get</span>&lt;ResponseHeaderMapPtr&gt;(headers_or_trailers_)), <span class="literal">true</span>);</span><br><span class="line">      deferred_end_stream_headers_ = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processing_trailers_) &#123;</span><br><span class="line">      response.decoder_-&gt;<span class="built_in">decodeTrailers</span>(</span><br><span class="line">          std::<span class="built_in">move</span>(absl::<span class="built_in">get</span>&lt;ResponseTrailerMapPtr&gt;(headers_or_trailers_)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Buffer::OwnedImpl buffer;</span><br><span class="line">      response.decoder_-&gt;<span class="built_in">decodeData</span>(buffer, <span class="literal">true</span>); <span class="comment">//写入数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset to ensure no information from one requests persists to the next.</span></span><br><span class="line">    pending_response_.<span class="built_in">reset</span>();</span><br><span class="line">    headers_or_trailers_.<span class="built_in">emplace</span>&lt;ResponseHeaderMapPtr&gt;(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在响应的过程中，调用了 <code>decodeData</code> 最终回归到 <code>ConnectionMangerImpl</code>中，然在一系列的操作中，我们来到了最终写入的地方</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionImpl::write</span><span class="params">(Buffer::Instance&amp; data, <span class="type">bool</span> end_stream, <span class="type">bool</span> through_filter_chain)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ASSERT</span>(!end_stream || enable_half_close_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write_end_stream_) &#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(data.<span class="built_in">length</span>() == <span class="number">0</span> &amp;&amp; end_stream);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (through_filter_chain) &#123;</span><br><span class="line">    current_write_buffer_ = &amp;data;</span><br><span class="line">    current_write_end_stream_ = end_stream;</span><br><span class="line">    FilterStatus status = filter_manager_.<span class="built_in">onWrite</span>(); <span class="comment">// ➀ 这里进入了写入流的 FilterChain</span></span><br><span class="line">    current_write_buffer_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FilterStatus::StopIteration == status) &#123; <span class="comment">// 值得注意的是这里是可以提前终结</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  write_end_stream_ = end_stream;</span><br><span class="line">  <span class="keyword">if</span> (data.<span class="built_in">length</span>() &gt; <span class="number">0</span> || end_stream) &#123;</span><br><span class="line">    <span class="built_in">ENVOY_CONN_LOG</span>(trace, <span class="string">&quot;writing &#123;&#125; bytes, end_stream &#123;&#125;&quot;</span>, *<span class="keyword">this</span>, data.<span class="built_in">length</span>(), end_stream);</span><br><span class="line">    write_buffer_-&gt;<span class="built_in">move</span>(data); <span class="comment">// ➁ 将数据流写入</span></span><br><span class="line">    <span class="keyword">if</span> (!connecting_) &#123;</span><br><span class="line">      <span class="built_in">ASSERT</span>(file_event_ != <span class="literal">nullptr</span>, <span class="string">&quot;ConnectionImpl file event was unexpectedly reset&quot;</span>);</span><br><span class="line">      file_event_-&gt;<span class="built_in">activate</span>(Event::FileReadyType::Write);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的所有的数据写入完成之后，进入了最终的 <code>Cleanup</code> 的过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionImpl::closeSocket</span><span class="params">(ConnectionEvent close_type)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">ENVOY_CONN_LOG</span>(debug, <span class="string">&quot;closing socket: &#123;&#125;&quot;</span>, *<span class="keyword">this</span>, <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(close_type));</span><br><span class="line">  transport_socket_-&gt;<span class="built_in">closeSocket</span>(close_type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drain input and output buffers.</span></span><br><span class="line">  <span class="built_in">updateReadBufferStats</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">updateWriteBufferStats</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  write_buffer_-&gt;<span class="built_in">drain</span>(write_buffer_-&gt;<span class="built_in">length</span>());</span><br><span class="line"></span><br><span class="line">  connection_stats_.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">  file_event_.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">  socket_-&gt;<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">raiseEvent</span>(close_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里算是结束了一个段落，我们将整个过程整理一下：</p>
<div style="width:100%; overflow-y:scroll;" id="envoy-life"></div>
<script>
	var data =
	[
    'Title: Envoy处理全流程',
    'Main->ServerSocket: 1. Main函数初始化ServerSocker，创建 Listener',
    'Main->Workers: 2. Main函数初始化Worker，将Listenr放置所有的Worker',
    'Workers->Worker.Accept: 3. Worker 中的任意一个接受到请求',
    'Worker.ServerConnection.Accept->Worker.ServerConnection.Read: 4. Worker 开始读取数据',
    'Worker.ServerConnection.Read->Worker.ServerConnection.ReadFilter: 5. Worker 进入 FilterChian 进行处理',
    'Worker.ServerConnection.ReadFilter->Route.route: 6. Filter 中的路由过程',
    'Worker.ServerConnection.ReadFilter->Host.createConnection: 7.创建下游的HTTP连接',
    'Host.createConnection->DispatcherImpl.createFileEvent: 8. 在Worker中创建响应连接的Read事件，在同一个Worker中',
    'Worker.ClentConnection.Read->Worker.ServerConnection.WriterFilter: 9. 回写数据，并且经WriteFilter处理',
    'Worker.ServerConnection.WriterFilter->Worker.ServerConnection.close: 10. 结束流程'
  ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("envoy-life", {theme: 'simple', scale: 0.5});
</script>
<h2 id="Envoy-Extend"><a class="header-anchor" href="#Envoy-Extend">¶</a>Envoy Extend</h2>
<p>从上文分析中，我们已经算是通读了代码的主要实现部分，剩下来，我们看Envoy给我们预留的扩展的部分。<a href="https://www.envoyproxy.io/docs/envoy/v1.14.1/extending/extending">Extending Envoy for custom use cases</a>，从配置文件中，我们也可以获得一些灵感：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">listeners:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">listener_0</span></span><br><span class="line">      <span class="attr">address:</span></span><br><span class="line">        <span class="attr">socket_address:</span> &#123; <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>, <span class="attr">port_value:</span> <span class="number">10000</span> &#125;</span><br><span class="line">      <span class="attr">filter_chains:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.http_connection_manager</span></span><br><span class="line">              <span class="attr">typed_config:</span></span><br><span class="line">                <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager</span></span><br><span class="line">                <span class="attr">stat_prefix:</span> <span class="string">ingress_http</span></span><br><span class="line">                <span class="attr">codec_type:</span> <span class="string">AUTO</span></span><br><span class="line">                <span class="attr">route_config:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">local_route</span></span><br><span class="line">                  <span class="attr">virtual_hosts:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">local_service</span></span><br><span class="line">                      <span class="attr">domains:</span> [<span class="string">&quot;*&quot;</span>]</span><br><span class="line">                      <span class="attr">routes:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="attr">match:</span> &#123; <span class="attr">prefix:</span> <span class="string">&quot;/&quot;</span> &#125;</span><br><span class="line">                          <span class="attr">route:</span> &#123; <span class="attr">cluster:</span> <span class="string">some_service</span> &#125;</span><br><span class="line">                <span class="attr">http_filters:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br></pre></td></tr></table></figure>
<p>我们可以发现，对于 Envoy 来说最为主要的部分是 FilterChains，虽然我们并没有写过CPP，但是从思想相近来看，我们应该是可以拓展 Filter 的实现，然后注册到这个 FilterChians 中，幸好对于官方来说，提供一个比较详尽的 <a href="https://github.com/envoyproxy/envoy-filter-example">DEMO</a>。从中可以看出，我们的核心是继承已于的Fitler的Interface然后实现之：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Envoy &#123;</span><br><span class="line"><span class="keyword">namespace</span> Filter &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation of a basic echo filter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Echo2</span> : <span class="keyword">public</span> Network::ReadFilter, Logger::Loggable&lt;Logger::Id::filter&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Network::ReadFilter</span></span><br><span class="line">  <span class="function">Network::FilterStatus <span class="title">onData</span><span class="params">(Buffer::Instance&amp; data, <span class="type">bool</span> end_stream)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">Network::FilterStatus <span class="title">onNewConnection</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> Network::FilterStatus::Continue; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">initializeReadFilterCallbacks</span><span class="params">(Network::ReadFilterCallbacks&amp; callbacks)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    read_callbacks_ = &amp;callbacks;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Network::ReadFilterCallbacks* read_callbacks_&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace Filter</span></span><br><span class="line">&#125; <span class="comment">// namespace Envoy</span></span><br></pre></td></tr></table></figure>
<p>使用起来也比较的简单</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">clusters:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cluster_0</span></span><br><span class="line">    <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">    <span class="attr">load_assignment:</span></span><br><span class="line">      <span class="attr">cluster_name:</span> <span class="string">cluster_0</span></span><br><span class="line">      <span class="attr">endpoints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">                <span class="attr">address:</span></span><br><span class="line">                  <span class="attr">socket_address:</span></span><br><span class="line">                    <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">                    <span class="attr">port_value:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>但是在这背后，这工作的机制是如何的呢？我们还是需要从源码中来。现在已经有的 <code>Extensions</code> 实现可以参考此处 <a href="https://github.com/envoyproxy/envoy/tree/v1.14.1/source/extensions">extensions</a></p>
<p>从上文代码中，我们可以很容易的定位到初始化 <code>FilterChain</code> 的逻辑在 <code>ListenerImpl::createNetworkFilterChain</code> 处</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListenerImpl::createNetworkFilterChain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Network::Connection&amp; connection,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;Network::FilterFactoryCb&gt;&amp; filter_factories)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Configuration::FilterChainUtility::<span class="built_in">buildFilterChain</span>(connection, filter_factories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见是一个很标准的工厂模式，根据不同的工厂我们会创建不同的Filter实例，在创建完成之后如果是 ReaderFliter 就直接加到 upsteam 的底部，如果是 WriterFliter 则会增加到 downsteam 的底部。代码也较为简单，如下图。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FilterManagerImpl::addReadFilter</span><span class="params">(ReadFilterSharedPtr filter)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ASSERT</span>(connection_.<span class="built_in">state</span>() == Connection::State::Open);</span><br><span class="line">  <span class="function">ActiveReadFilterPtr <span class="title">new_filter</span><span class="params">(<span class="keyword">new</span> ActiveReadFilter&#123;*<span class="keyword">this</span>, filter&#125;)</span></span>;</span><br><span class="line">  filter-&gt;<span class="built_in">initializeReadFilterCallbacks</span>(*new_filter);</span><br><span class="line">  new_filter-&gt;<span class="built_in">moveIntoListBack</span>(std::<span class="built_in">move</span>(new_filter), upstream_filters_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那问题就变成了我们的 <code>Filter_Factory</code> 从而来，我们从虚表中发现有两种实现 <code>Admin</code> &amp; <code>Impl</code>，如果度过官网文档的同学应该可以猜到<code>Admin</code>的实现是基于动态请求的。我还是重启下，从头来跟踪下流程，初始化FilterFactory 最早可以定位到 <code>ListenerManagerImpl::addOrUpdateListener</code> 和配置文件的层级类似，我们从首先创建的是Listerner，在创建  <code>Listener</code> 的过程中我们创建 <code>FilterChain</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">filter_chain_manager_.<span class="built_in">addFilterChain</span>(config.<span class="built_in">filter_chains</span>(), builder, filter_chain_manager_);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FilterChainManagerImpl::addFilterChain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::Span&lt;<span class="type">const</span> envoy::config::listener::v3::FilterChain* <span class="type">const</span>&gt; filter_chain_span,</span></span></span><br><span class="line"><span class="params"><span class="function">    FilterChainFactoryBuilder&amp; filter_chain_factory_builder,</span></span></span><br><span class="line"><span class="params"><span class="function">    FilterChainFactoryContextCreator&amp; context_creator)</span> </span>&#123;</span><br><span class="line">  <span class="function">Cleanup <span class="title">cleanup</span><span class="params">([<span class="keyword">this</span>]() &#123; origin_ = absl::<span class="literal">nullopt</span>; &#125;)</span></span>;</span><br><span class="line">  std::unordered_set&lt;envoy::config::listener::v3::FilterChainMatch, MessageUtil, MessageUtil&gt;</span><br><span class="line">      filter_chains;</span><br><span class="line">  <span class="type">uint32_t</span> new_filter_chain_size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; filter_chain : filter_chain_span) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; filter_chain_match = filter_chain-&gt;<span class="built_in">filter_chain_match</span>();</span><br><span class="line">    <span class="keyword">if</span> (!filter_chain_match.<span class="built_in">address_suffix</span>().<span class="built_in">empty</span>() || filter_chain_match.<span class="built_in">has_suffix_len</span>()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">EnvoyException</span>(fmt::format(<span class="string">&quot;error adding listener &#x27;&#123;&#125;&#x27;: contains filter chains with &quot;</span></span><br><span class="line">                                       <span class="string">&quot;unimplemented fields&quot;</span>,</span><br><span class="line">                                       address_-&gt;<span class="built_in">asString</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (filter_chains.<span class="built_in">find</span>(filter_chain_match) != filter_chains.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">EnvoyException</span>(fmt::format(<span class="string">&quot;error adding listener &#x27;&#123;&#125;&#x27;: multiple filter chains with &quot;</span></span><br><span class="line">                                       <span class="string">&quot;the same matching rules are defined&quot;</span>,</span><br><span class="line">                                       address_-&gt;<span class="built_in">asString</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    filter_chains.<span class="built_in">insert</span>(filter_chain_match);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate IP addresses.</span></span><br><span class="line">    std::vector&lt;std::string&gt; destination_ips;</span><br><span class="line">    destination_ips.<span class="built_in">reserve</span>(filter_chain_match.<span class="built_in">prefix_ranges</span>().<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; destination_ip : filter_chain_match.<span class="built_in">prefix_ranges</span>()) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; cidr_range = Network::Address::CidrRange::<span class="built_in">create</span>(destination_ip);</span><br><span class="line">      destination_ips.<span class="built_in">push_back</span>(cidr_range.<span class="built_in">asString</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::string&gt; source_ips;</span><br><span class="line">    source_ips.<span class="built_in">reserve</span>(filter_chain_match.<span class="built_in">source_prefix_ranges</span>().<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; source_ip : filter_chain_match.<span class="built_in">source_prefix_ranges</span>()) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; cidr_range = Network::Address::CidrRange::<span class="built_in">create</span>(source_ip);</span><br><span class="line">      source_ips.<span class="built_in">push_back</span>(cidr_range.<span class="built_in">asString</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reject partial wildcards, we don&#x27;t match on them.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; server_name : filter_chain_match.<span class="built_in">server_names</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (server_name.<span class="built_in">find</span>(<span class="string">&#x27;*&#x27;</span>) != std::string::npos &amp;&amp;</span><br><span class="line">          !FilterChainManagerImpl::<span class="built_in">isWildcardServerName</span>(server_name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">EnvoyException</span>(</span><br><span class="line">            fmt::format(<span class="string">&quot;error adding listener &#x27;&#123;&#125;&#x27;: partial wildcards are not supported in &quot;</span></span><br><span class="line">                        <span class="string">&quot;\&quot;server_names\&quot;&quot;</span>,</span><br><span class="line">                        address_-&gt;<span class="built_in">asString</span>()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reuse created filter chain if possible.</span></span><br><span class="line">    <span class="comment">// FilterChainManager maintains the lifetime of FilterChainFactoryContext</span></span><br><span class="line">    <span class="comment">// ListenerImpl maintains the dependencies of FilterChainFactoryContext</span></span><br><span class="line">    <span class="keyword">auto</span> filter_chain_impl = <span class="built_in">findExistingFilterChain</span>(*filter_chain);</span><br><span class="line">    <span class="keyword">if</span> (filter_chain_impl == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      filter_chain_impl =</span><br><span class="line">          filter_chain_factory_builder.<span class="built_in">buildFilterChain</span>(*filter_chain, context_creator);</span><br><span class="line">      ++new_filter_chain_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addFilterChainForDestinationPorts</span>(</span><br><span class="line">        destination_ports_map_,</span><br><span class="line">        <span class="built_in">PROTOBUF_GET_WRAPPED_OR_DEFAULT</span>(filter_chain_match, destination_port, <span class="number">0</span>), destination_ips,</span><br><span class="line">        filter_chain_match.<span class="built_in">server_names</span>(), filter_chain_match.<span class="built_in">transport_protocol</span>(),</span><br><span class="line">        filter_chain_match.<span class="built_in">application_protocols</span>(), filter_chain_match.<span class="built_in">source_type</span>(), source_ips,</span><br><span class="line">        filter_chain_match.<span class="built_in">source_ports</span>(), filter_chain_impl);</span><br><span class="line">    fc_contexts_[*filter_chain] = filter_chain_impl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">convertIPsToTries</span>();</span><br><span class="line">  <span class="built_in">ENVOY_LOG</span>(debug, <span class="string">&quot;new fc_contexts has &#123;&#125; filter chains, including &#123;&#125; newly built&quot;</span>,</span><br><span class="line">            fc_contexts_.<span class="built_in">size</span>(), new_filter_chain_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Envoy-Admin"><a class="header-anchor" href="#Envoy-Admin">¶</a>Envoy Admin</h2>
<p>我们构建 Example 的时候，有一段内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">admin:</span></span><br><span class="line">  <span class="attr">access_log_path:</span> <span class="string">/tmp/admin_access.log</span></span><br><span class="line">  <span class="attr">address:</span></span><br><span class="line">    <span class="attr">socket_address:</span> &#123; <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>, <span class="attr">port_value:</span> <span class="number">9901</span> &#125;</span><br></pre></td></tr></table></figure>
<p>是 Enovy 的管理端口。主要提供了一系列的统计数据等，详见 <a href="https://www.envoyproxy.io/docs/envoy/v1.14.1/operations/admin">Envoy-Admin</a></p>
<h2 id="Envoy-Dynamic-Manager"><a class="header-anchor" href="#Envoy-Dynamic-Manager">¶</a>Envoy Dynamic Manager</h2>
<p>我们分析了简单的从文件读入的过程，但是对于一个成熟的网关来说，动态载入数据的类型是不可少的，因此 Envoy 也提供了几种动态获得配置的能力，比如 <code>LDS</code> <code>XDS</code> 等。</p>
<h3 id="LDS"><a class="header-anchor" href="#LDS">¶</a>LDS</h3>
<blockquote>
<p>The listener discovery service (LDS) is an optional API that Envoy will call to dynamically fetch listeners. Envoy will reconcile the API response and add, modify, or remove known listeners depending on what is required.</p>
</blockquote>
<!-------------分割线---------------->
<div id="container" style="height: 500px"></div>
<div id="detail" style="position: absolute; bottom: 100px; left: 0px; z-index: 9999;">
        <div style="font-weight: bold;">相关文档</div>
        <div id="detail_infos"></div>
</div>
<script type="text/javascript" src="https://app.diagrams.net/js/viewer.min.js"></script>
<!-- <script src="https://cdn.bootcss.com/viewerjs/1.5.0/viewer.min.js"></script> -->
<script src="https://cdn.staticaly.com/npm/echarts/dist/echarts.min.js" type="text/javascript">
</script>
<script src="https://cdn.staticaly.com/npm/echarts-gl/dist/echarts-gl.min.js" type="text/javascript">
</script>
<script src="https://cdn.staticaly.com/npm/echarts-stat/dist/ecStat.min.js" type="text/javascript">
</script>
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<h3 id="Gaph"><a class="header-anchor" href="#Gaph">¶</a>Gaph</h3>
<script type="text/javascript">
    var dom = document.getElementById("container");
    var myChart = echarts.init(dom);
    var app = {};
        option = {
            title: {
                text: "Envoy knowledge map",
                subtext: 'Around Envoy',
                top: 'bottom',
                left: 'right'
            },
            tooltip: {},
            legend: [],
            animation: false,
            series: [
                {
                    name: "Yanick's knowledge map",
                    type: 'graph',
                    layout: 'force',
                    focusNodeAdjacency: true,
                    data: [
                    {
                        "name": "Envoy",
                        "value": 30,
                        "symbolSize": 30,
                        "articles": []
                    },
                    {
                        "name": "Libevent",
                        "value": 20,
                        "symbolSize": 20,
                        "articles": [
                            {
                            "name": "基于Libevent的聊天室",
                            "url": "https://github.com/yanickxia/chatroom-libevent"
                            }
                        ]
                    }],
                    links: [
                    {
                        "source": "Envoy",
                        "target": "Libevent"
                    }],
                    categories: [],
                    roam: true,
                    label: {
                        show: true,
                        position: 'right'
                    },
                    force: {
                        repulsion: 100
                    }
                }
            ]
        };

        myChart.setOption(option);

        myChart.on('click', function (params) {
            $("#detail_infos").empty();
            params.data.articles.forEach(it => {
                let newArticle = $(`<div><a href='${it.url}'>${it.name}</a></div>`);
                $("#detail_infos").append(newArticle);
            });
        });

        if (option && typeof option === "object") {
            myChart.setOption(option, true);
        }
</script>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>网络编程</category>
        <category>API</category>
        <category>Gateway</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>Gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>探索性阅读 Envoy</title>
    <url>/2022/10/31/networking/envoy/read-code/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2022/202211021523504.png" alt=""></p>
<p>一般阅读源码有两种模式</p>
<ul>
<li>验证式阅读：大致上就是先了解抽象，然后按照抽象去验证系统是否按照我们所理解的方式进行工作。</li>
<li>探索性阅读：和上一种略有不同，当我们有类似软件经验的时候，我们经常会参考其他软件的实现方式（一些通用需要解决的问题），去探索 Envoy 是如何解决这类通用的问题的。<br>
这两者阅读源码的方式并没有什么好坏，更像是自顶向下和自底向上的差异。</li>
</ul>
<span id="more"></span>
<p>本次我们就采用 探索性 阅读的方式来阅读 Envoy，那当然是探索性阅读肯定是需要一个问题之后才能去探索，这次我们想知道一个问题。</p>
<blockquote>
<p>在 FilterChain  的处理过程中，状态数据是如何保存的？</p>
</blockquote>
<p>我们知道在很多逻辑中是需要保存临时状态的，比如我们需要对系统做 <code>ratelimit</code> 的时候，比如我需要限制某个 API ，每分钟只能访问 N 次，这个 N 显然是需要存储起来的。我们这里以一个如下的 Yaml 为例子</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        example yaml
    </div>
    <div class='spoiler-content'>
        <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">listeners:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span></span><br><span class="line">      <span class="attr">socket_address:</span></span><br><span class="line">        <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        <span class="attr">port_value:</span> <span class="number">10000</span></span><br><span class="line">    <span class="attr">filter_chains:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.http_connection_manager</span></span><br><span class="line">        <span class="attr">typed_config:</span></span><br><span class="line">          <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager</span></span><br><span class="line">          <span class="attr">codec_type:</span> <span class="string">AUTO</span></span><br><span class="line">          <span class="attr">stat_prefix:</span> <span class="string">ingress_http</span></span><br><span class="line">          <span class="attr">route_config:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">local_route</span></span><br><span class="line">            <span class="attr">virtual_hosts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">              <span class="attr">domains:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">              <span class="attr">routes:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">                  <span class="attr">prefix:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">                <span class="attr">direct_response:</span></span><br><span class="line">                  <span class="attr">status:</span> <span class="number">200</span></span><br><span class="line">                  <span class="attr">body:</span></span><br><span class="line">                    <span class="attr">inline_string:</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line">                <span class="attr">typed_per_filter_config:</span></span><br><span class="line">                  <span class="attr">envoy.filters.http.local_ratelimit:</span></span><br><span class="line">                    <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit</span></span><br><span class="line">                    <span class="attr">stat_prefix:</span> <span class="string">http_local_rate_limiter</span></span><br><span class="line">                    <span class="attr">token_bucket:</span></span><br><span class="line">                      <span class="attr">max_tokens:</span> <span class="number">1</span></span><br><span class="line">                      <span class="attr">tokens_per_fill:</span> <span class="number">1</span></span><br><span class="line">                      <span class="attr">fill_interval:</span> <span class="string">5s</span></span><br><span class="line">                    <span class="attr">filter_enabled:</span></span><br><span class="line">                      <span class="attr">runtime_key:</span> <span class="string">local_rate_limit_enabled</span></span><br><span class="line">                      <span class="attr">default_value:</span></span><br><span class="line">                        <span class="attr">numerator:</span> <span class="number">100</span></span><br><span class="line">                        <span class="attr">denominator:</span> <span class="string">HUNDRED</span></span><br><span class="line">                    <span class="attr">filter_enforced:</span></span><br><span class="line">                      <span class="attr">runtime_key:</span> <span class="string">local_rate_limit_enforced</span></span><br><span class="line">                      <span class="attr">default_value:</span></span><br><span class="line">                        <span class="attr">numerator:</span> <span class="number">100</span></span><br><span class="line">                        <span class="attr">denominator:</span> <span class="string">HUNDRED</span></span><br><span class="line">                    <span class="attr">response_headers_to_add:</span></span><br><span class="line">                      <span class="bullet">-</span> <span class="attr">append_action:</span> <span class="string">OVERWRITE_IF_EXISTS_OR_ADD</span></span><br><span class="line">                        <span class="attr">header:</span></span><br><span class="line">                          <span class="attr">key:</span> <span class="string">x-local-rate-limit</span></span><br><span class="line">                          <span class="attr">value:</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">          <span class="attr">http_filters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.local_ratelimit</span></span><br><span class="line">            <span class="attr">typed_config:</span></span><br><span class="line">              <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit</span></span><br><span class="line">              <span class="attr">stat_prefix:</span> <span class="string">http_local_rate_limiter</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br><span class="line">            <span class="attr">typed_config:</span></span><br><span class="line">              <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.router.v3.Router</span></span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="Filter-实例"><a class="header-anchor" href="#Filter-实例">¶</a>Filter 实例</h2>
<h3 id="猜想"><a class="header-anchor" href="#猜想">¶</a>猜想</h3>
<p>对于探索性编程，最为重要的就是提出猜想。那根据我们之前的一些编码经验来看，我们可以首先可以提出一个问题。</p>
<blockquote>
<p>filter 是单例的还是多实例的？</p>
</blockquote>
<p>因为我们知道我们总是要存储临时状态的，如果 <code>Filter</code> 是一个多实例的对象，那状态是可能存储在 <code>Filter</code> 之中的，那如果 <code>Filter</code> 是单例的，那我们是需要把状态按照一些特殊的逻辑存储到一个地方，然后再获取出来。</p>
<p>从配置上，其实我们已经可以比较大胆的猜测，<code>Filter</code> 显然是一个多实例的，因为我们可以为不同的路径，配置不一样的 <code>RateLimiter</code></p>
<h3 id="验证"><a class="header-anchor" href="#验证">¶</a>验证</h3>
<p>我们找到 <code>local rate limiter</code> 的代码所在地，加上一个日志看一下。</p>
<figure class="highlight cpp"><figcaption><span>decodeHeaders</span><a href="https://github.com/envoyproxy/envoy/blob/dacd8914f9c7eb2f374c9e86d6af9a60ac69f37b/source/extensions/filters/http/local_ratelimit/local_ratelimit.cc#L117-L131">github</a></figcaption><table><tr><td class="code"><pre><span class="line marked"><span class="type">void</span>* address = <span class="keyword">this</span>;</span><br><span class="line marked"><span class="built_in">ENVOY_LOG</span>(info, <span class="string">&quot;rate limit address: &#123;&#125;&quot;</span>, address);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">requestAllowed</span>(descriptors)) &#123;</span><br><span class="line">  config-&gt;<span class="built_in">stats</span>().ok_.<span class="built_in">inc</span>();</span><br><span class="line">  <span class="keyword">return</span> Http::FilterHeadersStatus::Continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们修改点我们的启动文件，增加一个不一样的 <code>RateLimiter</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">  <span class="attr">domains:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">      <span class="attr">prefix:</span> <span class="string">&quot;/hello&quot;</span></span><br><span class="line">    <span class="attr">direct_response:</span></span><br><span class="line">      <span class="attr">status:</span> <span class="number">200</span></span><br><span class="line">      <span class="attr">body:</span></span><br><span class="line">        <span class="attr">inline_string:</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    <span class="attr">typed_per_filter_config:</span></span><br><span class="line">      <span class="attr">envoy.filters.http.local_ratelimit:</span></span><br><span class="line">        <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit</span></span><br><span class="line">        <span class="attr">stat_prefix:</span> <span class="string">http_local_rate_limiter</span></span><br><span class="line">        <span class="attr">token_bucket:</span></span><br><span class="line">          <span class="attr">max_tokens:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">tokens_per_fill:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">fill_interval:</span> <span class="string">5s</span></span><br><span class="line">        <span class="attr">filter_enabled:</span></span><br><span class="line">          <span class="attr">runtime_key:</span> <span class="string">local_rate_limit_enabled</span></span><br><span class="line">          <span class="attr">default_value:</span></span><br><span class="line">            <span class="attr">numerator:</span> <span class="number">100</span></span><br><span class="line">            <span class="attr">denominator:</span> <span class="string">HUNDRED</span></span><br><span class="line">        <span class="attr">filter_enforced:</span></span><br><span class="line">          <span class="attr">runtime_key:</span> <span class="string">local_rate_limit_enforced</span></span><br><span class="line">          <span class="attr">default_value:</span></span><br><span class="line">            <span class="attr">numerator:</span> <span class="number">100</span></span><br><span class="line">            <span class="attr">denominator:</span> <span class="string">HUNDRED</span></span><br><span class="line">        <span class="attr">response_headers_to_add:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">append_action:</span> <span class="string">OVERWRITE_IF_EXISTS_OR_ADD</span></span><br><span class="line">            <span class="attr">header:</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">x-local-rate-limit</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">      <span class="attr">prefix:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">    <span class="attr">direct_response:</span></span><br><span class="line">      <span class="attr">status:</span> <span class="number">200</span></span><br><span class="line">      <span class="attr">body:</span></span><br><span class="line">        <span class="attr">inline_string:</span> <span class="string">&quot;Default&quot;</span></span><br><span class="line">    <span class="attr">typed_per_filter_config:</span></span><br><span class="line">      <span class="attr">envoy.filters.http.local_ratelimit:</span></span><br><span class="line">        <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit</span></span><br><span class="line">        <span class="attr">stat_prefix:</span> <span class="string">http_local_rate_limiter</span></span><br><span class="line">        <span class="attr">token_bucket:</span></span><br><span class="line">          <span class="attr">max_tokens:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">tokens_per_fill:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">fill_interval:</span> <span class="string">5s</span></span><br><span class="line">        <span class="attr">filter_enabled:</span></span><br><span class="line">          <span class="attr">runtime_key:</span> <span class="string">local_rate_limit_enabled</span></span><br><span class="line">          <span class="attr">default_value:</span></span><br><span class="line">            <span class="attr">numerator:</span> <span class="number">100</span></span><br><span class="line">            <span class="attr">denominator:</span> <span class="string">HUNDRED</span></span><br><span class="line">        <span class="attr">filter_enforced:</span></span><br><span class="line">          <span class="attr">runtime_key:</span> <span class="string">local_rate_limit_enforced</span></span><br><span class="line">          <span class="attr">default_value:</span></span><br><span class="line">            <span class="attr">numerator:</span> <span class="number">100</span></span><br><span class="line">            <span class="attr">denominator:</span> <span class="string">HUNDRED</span></span><br><span class="line">        <span class="attr">response_headers_to_add:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">append_action:</span> <span class="string">OVERWRITE_IF_EXISTS_OR_ADD</span></span><br><span class="line">            <span class="attr">header:</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">x-local-rate-limit</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&#x27;true&#x27;</span></span><br></pre></td></tr></table></figure>
<p>随后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl localhost:10000/hello</span><br><span class="line">curl localhost:10000/</span><br></pre></td></tr></table></figure>
<p>可以看到日志中不同的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2022-11-01 08:13:17.005][38344][info][filter] [<span class="built_in">source</span>/extensions/filters/http/local_ratelimit/local_ratelimit.cc:126] rate <span class="built_in">limit</span> address: 0x57ac3f57b900</span><br><span class="line">[2022-11-01 08:13:17.733][38344][info][filter] [<span class="built_in">source</span>/extensions/filters/http/local_ratelimit/local_ratelimit.cc:126] rate <span class="built_in">limit</span> address: 0x57ac3f57b820</span><br></pre></td></tr></table></figure>
<p>显然这两者并不是同一个对象，但是在多次的重复执行中，地址是不会变化的。</p>
<p>那我们显然可以得到一个结论。</p>
<blockquote>
<p>Envoy Filter 就是按照配置文件的维度做到多副本的。</p>
</blockquote>
<p>随着我们得到一个验证之后，我们就会提出两个全新的问题</p>
<ul>
<li>Filter 是谁构建的</li>
<li>Filter 是如何工作的</li>
</ul>
<h3 id="Filter-初始化"><a class="header-anchor" href="#Filter-初始化">¶</a>Filter 初始化</h3>
<p>对于 <code>Filter</code> 初始化，我们可以换一种方式来验证，通过断点来快速判断。</p>
<figure class="highlight cpp"><figcaption><span>Filter</span><a href="https://github.com/envoyproxy/envoy/blob/dacd8914f9c7eb2f374c9e86d6af9a60ac69f37b/source/extensions/filters/http/local_ratelimit/local_ratelimit.h#L137-L139">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Filter</span> : <span class="keyword">public</span> Http::PassThroughFilter, Logger::Loggable&lt;Logger::Id::filter&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line marked">  <span class="built_in">Filter</span>(FilterConfigSharedPtr config) : <span class="built_in">config_</span>(config) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在目标处置下断点，运行之后就很容易知道</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter::Filter@0x0000555558f776c8 (/workspaces/envoy/source/extensions/filters/http/local_ratelimit/local_ratelimit.h:139)</span><br><span class="line">__gnu_cxx::new_allocator&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter&gt;::construct&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter, std::shared_ptr&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::FilterConfig&gt; const&amp;&gt;@0x0000555558f77675 (/usr/include/c++/9/ext/new_allocator.h:146)</span><br><span class="line">std::allocator_traits&lt;std::allocator&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter&gt; &gt;::construct&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter, std::shared_ptr&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::FilterConfig&gt; const&amp;&gt;@0x0000555558f7744d (/usr/include/c++/9/bits/alloc_traits.h:483)</span><br><span class="line">std::_Sp_counted_ptr_inplace&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter, std::allocator&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter&gt;, (__gnu_cxx::_Lock_policy)2&gt;::_Sp_counted_ptr_inplace&lt;std::shared_ptr&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::FilterConfig&gt; const&amp;&gt;@0x0000555558f771d8 (/usr/include/c++/9/bits/shared_ptr_base.h:548)</span><br><span class="line">std::__shared_count&lt;(__gnu_cxx::_Lock_policy)2&gt;::__shared_count&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter, std::allocator&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter&gt;, std::shared_ptr&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::FilterConfig&gt; const&amp;&gt;@0x0000555558f76fce (/usr/include/c++/9/bits/shared_ptr_base.h:680)</span><br><span class="line">std::__shared_ptr&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter, (__gnu_cxx::_Lock_policy)2&gt;::__shared_ptr&lt;std::allocator&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter&gt;, std::shared_ptr&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::FilterConfig&gt; const&amp;&gt;@0x0000555558f76f10 (/usr/include/c++/9/bits/shared_ptr_base.h:1344)</span><br><span class="line">std::shared_ptr&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter&gt;::shared_ptr&lt;std::allocator&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter&gt;, std::shared_ptr&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::FilterConfig&gt; const&amp;&gt;@0x0000555558f76ead (/usr/include/c++/9/bits/shared_ptr.h:359)</span><br><span class="line">std::allocate_shared&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter, std::allocator&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter&gt;, std::shared_ptr&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::FilterConfig&gt; const&amp;&gt;@0x0000555558f76e10 (/usr/include/c++/9/bits/shared_ptr.h:701)</span><br><span class="line">std::make_shared&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::Filter, std::shared_ptr&lt;Envoy::Extensions::HttpFilters::LocalRateLimitFilter::FilterConfig&gt; const&amp;&gt;@0x0000555558f76d31 (/usr/include/c++/9/bits/shared_ptr.h:717)</span><br><span class="line">Envoy::Extensions::HttpFilters::LocalRateLimitFilter::LocalRateLimitFilterConfig::createFilterFactoryFromProtoTyped(envoy::extensions::filters::http::local_ratelimit::v3::LocalRateLimit const&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, Envoy::Server::Configuration::FactoryContext&amp;)::<span class="variable">$_0</span>::operator()(Envoy::Http::FilterChainFactoryCallbacks&amp;) const@0x0000555558f74909 (/workspaces/envoy/source/extensions/filters/http/local_ratelimit/config.cc:22)</span><br><span class="line">std::_Function_handler&lt;void (Envoy::Http::FilterChainFactoryCallbacks&amp;), Envoy::Extensions::HttpFilters::LocalRateLimitFilter::LocalRateLimitFilterConfig::createFilterFactoryFromProtoTyped(envoy::extensions::filters::http::local_ratelimit::v3::LocalRateLimit const&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, Envoy::Server::Configuration::FactoryContext&amp;)::<span class="variable">$_0</span>&gt;::_M_invoke(std::_Any_data const&amp;, Envoy::Http::FilterChainFactoryCallbacks&amp;)@0x0000555558f74772 (/usr/include/c++/9/bits/std_function.h:300)</span><br><span class="line">std::<span class="keyword">function</span>&lt;void (Envoy::Http::FilterChainFactoryCallbacks&amp;)&gt;::operator()(Envoy::Http::FilterChainFactoryCallbacks&amp;) const@0x0000555558cd2d05 (/usr/include/c++/9/bits/std_function.h:688)</span><br><span class="line">std::__invoke_impl&lt;void, std::<span class="keyword">function</span>&lt;void (Envoy::Http::FilterChainFactoryCallbacks&amp;)&gt;&amp;, Envoy::Http::FilterChainFactoryCallbacks&amp;&gt;(std::__invoke_other, std::<span class="keyword">function</span>&lt;void (Envoy::Http::FilterChainFactoryCallbacks&amp;)&gt;&amp;, Envoy::Http::FilterChainFactoryCallbacks&amp;)@0x000055555d644692 (/usr/include/c++/9/bits/invoke.h:60)</span><br><span class="line">std::__invoke&lt;std::<span class="keyword">function</span>&lt;void (Envoy::Http::FilterChainFactoryCallbacks&amp;)&gt;&amp;, Envoy::Http::FilterChainFactoryCallbacks&amp;&gt;(std::<span class="keyword">function</span>&lt;void (Envoy::Http::FilterChainFactoryCallbacks&amp;)&gt;&amp;, Envoy::Http::FilterChainFactoryCallbacks&amp;)@0x000055555d644632 (/usr/include/c++/9/bits/invoke.h:95)</span><br><span class="line">std::reference_wrapper&lt;std::<span class="keyword">function</span>&lt;void (Envoy::Http::FilterChainFactoryCallbacks&amp;)&gt; &gt;::operator()&lt;Envoy::Http::FilterChainFactoryCallbacks&amp;&gt;(Envoy::Http::FilterChainFactoryCallbacks&amp;) const@0x000055555d6278e2 (/usr/include/c++/9/bits/refwrap.h:340)</span><br><span class="line">Envoy::Extensions::NetworkFilters::HttpConnectionManager::HttpConnectionManagerConfig::createFilterChainForFactories(Envoy::Http::FilterChainFactoryCallbacks&amp;, std::__cxx11::list&lt;std::unique_ptr&lt;Envoy::Config::ExtensionConfigProvider&lt;std::<span class="keyword">function</span>&lt;void (Envoy::Http::FilterChainFactoryCallbacks&amp;)&gt; &gt;, std::default_delete&lt;Envoy::Config::ExtensionConfigProvider&lt;std::<span class="keyword">function</span>&lt;void (Envoy::Http::FilterChainFactoryCallbacks&amp;)&gt; &gt; &gt; &gt;, std::allocator&lt;std::unique_ptr&lt;Envoy::Config::ExtensionConfigProvider&lt;std::<span class="keyword">function</span>&lt;void (Envoy::Http::FilterChainFactoryCallbacks&amp;)&gt; &gt;, std::default_delete&lt;Envoy::Config::ExtensionConfigProvider&lt;std::<span class="keyword">function</span>&lt;void (Envoy::Http::FilterChainFactoryCallbacks&amp;)&gt; &gt; &gt; &gt; &gt; &gt; const&amp;)@0x000055555d61e611 (/workspaces/envoy/source/extensions/filters/network/http_connection_manager/config.cc:733)</span><br><span class="line">Envoy::Extensions::NetworkFilters::HttpConnectionManager::HttpConnectionManagerConfig::createFilterChain@0x000055555d61ee84 (/workspaces/envoy/source/extensions/filters/network/http_connection_manager/config.cc:750)</span><br><span class="line">Envoy::Http::FilterManager::createFilterChain@0x000055555d6c2f1a (/workspaces/envoy/source/common/http/filter_manager.cc:1458)</span><br><span class="line">Envoy::Http::ConnectionManagerImpl::ActiveStream::decodeHeaders@0x000055555d6771d8 (/workspaces/envoy/source/common/http/conn_manager_impl.cc:1066)</span><br><span class="line">Envoy::Http::Http1::ServerConnectionImpl::onMessageCompleteBase@0x000055555d7445be (/workspaces/envoy/source/common/http/http1/codec_impl.cc:1184)</span><br><span class="line">Envoy::Http::Http1::ConnectionImpl::onMessageComplete@0x000055555d73e21c (/workspaces/envoy/source/common/http/http1/codec_impl.cc:861)</span><br><span class="line">Envoy::Http::Http1::LegacyHttpParserImpl::Impl::Impl(http_parser_type, void*)::&#123;lambda(http_parser*)<span class="comment">#3&#125;::operator()(http_parser*) const@0x000055555d75de71 (/workspaces/envoy/source/common/http/http1/legacy_parser_impl.cc:80)</span></span><br><span class="line">Envoy::Http::Http1::LegacyHttpParserImpl::Impl::Impl(http_parser_type, void*)::&#123;lambda(http_parser*)<span class="comment">#3&#125;::__invoke(http_parser*)@0x000055555d75de35 (/workspaces/envoy/source/common/http/http1/legacy_parser_impl.cc:78)</span></span><br><span class="line">http_parser_execute@0x000055555e26ae93 (/workspaces/envoy/bazel/external/http_parser/http_parser.c:1933)</span><br><span class="line">Envoy::Http::Http1::LegacyHttpParserImpl::Impl::execute@0x000055555d75d1ef (/workspaces/envoy/source/common/http/http1/legacy_parser_impl.cc:97)</span><br><span class="line">Envoy::Http::Http1::LegacyHttpParserImpl::execute@0x000055555d75c65f (/workspaces/envoy/source/common/http/http1/legacy_parser_impl.cc:158)</span><br><span class="line">Envoy::Http::Http1::ConnectionImpl::dispatchSlice@0x000055555d73731c (/workspaces/envoy/source/common/http/http1/codec_impl.cc:639)</span><br><span class="line">Envoy::Http::Http1::ConnectionImpl::dispatch@0x000055555d73524b (/workspaces/envoy/source/common/http/http1/codec_impl.cc:602)</span><br><span class="line">Envoy::Http::Http1::ServerConnectionImpl::dispatch@0x000055555d743919 (/workspaces/envoy/source/common/http/http1/codec_impl.cc:1158)</span><br><span class="line">Envoy::Http::ConnectionManagerImpl::onData@0x000055555d66c7bd (/workspaces/envoy/source/common/http/conn_manager_impl.cc:380)</span><br><span class="line">Envoy::Network::FilterManagerImpl::onContinueReading@0x000055555e00708a (/workspaces/envoy/source/common/network/filter_manager_impl.cc:78)</span><br><span class="line">Envoy::Network::FilterManagerImpl::onRead@0x000055555e00760c (/workspaces/envoy/source/common/network/filter_manager_impl.cc:88)</span><br><span class="line">Envoy::Network::ConnectionImpl::onRead@0x000055555dfea503 (/workspaces/envoy/source/common/network/connection_impl.cc:340)</span><br><span class="line">Envoy::Network::ConnectionImpl::onReadReady@0x000055555dff7b34 (/workspaces/envoy/source/common/network/connection_impl.cc:646)</span><br><span class="line">Envoy::Network::ConnectionImpl::onFileEvent@0x000055555dff2f5e (/workspaces/envoy/source/common/network/connection_impl.cc:597)</span><br><span class="line">Envoy::Network::ConnectionImpl::ConnectionImpl(Envoy::Event::Dispatcher&amp;, std::unique_ptr&lt;Envoy::Network::ConnectionSocket, std::default_delete&lt;Envoy::Network::ConnectionSocket&gt; &gt;&amp;&amp;, std::unique_ptr&lt;Envoy::Network::TransportSocket, std::default_delete&lt;Envoy::Network::TransportSocket&gt; &gt;&amp;&amp;, Envoy::StreamInfo::StreamInfo&amp;, bool)::<span class="variable">$_6</span>::operator()(unsigned int) const@0x000055555dffe3fe (/workspaces/envoy/source/common/network/connection_impl.cc:94)</span><br><span class="line">std::_Function_handler&lt;void (unsigned int), Envoy::Network::ConnectionImpl::ConnectionImpl(Envoy::Event::Dispatcher&amp;, std::unique_ptr&lt;Envoy::Network::ConnectionSocket, std::default_delete&lt;Envoy::Network::ConnectionSocket&gt; &gt;&amp;&amp;, std::unique_ptr&lt;Envoy::Network::TransportSocket, std::default_delete&lt;Envoy::Network::TransportSocket&gt; &gt;&amp;&amp;, Envoy::StreamInfo::StreamInfo&amp;, bool)::<span class="variable">$_6</span>&gt;::_M_invoke(std::_Any_data const&amp;, unsigned int&amp;&amp;)@0x000055555dffe2c1 (/usr/include/c++/9/bits/std_function.h:300)</span><br><span class="line">std::<span class="keyword">function</span>&lt;void (unsigned int)&gt;::operator()(unsigned int) const@0x000055555c823494 (/usr/include/c++/9/bits/std_function.h:688)</span><br><span class="line">Envoy::Event::DispatcherImpl::createFileEvent(int, std::<span class="keyword">function</span>&lt;void (unsigned int)&gt;, Envoy::Event::FileTriggerType, unsigned int)::<span class="variable">$_5</span>::operator()(unsigned int) const@0x000055555dfbce9f (/workspaces/envoy/source/common/event/dispatcher_impl.cc:183)</span><br><span class="line">std::_Function_handler&lt;void (unsigned int), Envoy::Event::DispatcherImpl::createFileEvent(int, std::<span class="keyword">function</span>&lt;void (unsigned int)&gt;, Envoy::Event::FileTriggerType, unsigned int)::<span class="variable">$_5</span>&gt;::_M_invoke(std::_Any_data const&amp;, unsigned int&amp;&amp;)@0x000055555dfbccf1 (/usr/include/c++/9/bits/std_function.h:300)</span><br></pre></td></tr></table></figure>
<p>通过 <code>callstack</code> 我们就可以非常快速的知道，通过如下代码进行构建，而 <code>HttpConnectionManager</code> 显然就是上层的配置，也就是按照 <code>Factory</code> 的模式逐层构建出来。</p>
<figure class="highlight cpp"><figcaption><span>createFilterChain</span><a href="https://github.com/envoyproxy/envoy/blob/b26b45eaacb810be390d7cfc7e21b8f5de32abfd/source/common/http/filter_manager.cc#L1444-L1459">github</a></figcaption><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (upgrade != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="type">const</span> Router::RouteEntry::UpgradeMap* upgrade_map = filter_manager_callbacks_.<span class="built_in">upgradeMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filter_chain_factory_.<span class="built_in">createUpgradeFilterChain</span>(upgrade-&gt;<span class="built_in">value</span>().<span class="built_in">getStringView</span>(),</span><br><span class="line">                                                       upgrade_map, *<span class="keyword">this</span>)) &#123;</span><br><span class="line">      filter_manager_callbacks_.<span class="built_in">upgradeFilterChainCreated</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      upgrade_rejected = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// Fall through to the default filter chain. The function calling this</span></span><br><span class="line">      <span class="comment">// will send a local reply indicating that the upgrade failed.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  create here !</span></span><br><span class="line">  filter_chain_factory_.<span class="built_in">createFilterChain</span>(*<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> !upgrade_rejected;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Filter-是如何工作的"><a class="header-anchor" href="#Filter-是如何工作的">¶</a>Filter 是如何工作的</h2>
<p>当我们知道这个生命周期的变化之后，我们就想知道，这个 <code>Filter</code> 是如何工作的。从配置上，我们可以发现采用的是 <code>Bucket</code>的方式进行限流，显然这里涉及到几个问题。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">token_bucket:</span></span><br><span class="line">  <span class="attr">max_tokens:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">tokens_per_fill:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">fill_interval:</span> <span class="string">5s</span></span><br></pre></td></tr></table></figure>
<ol>
<li>bucket 是怎么填充的?</li>
<li>判断逻辑又是怎么工作的?</li>
</ol>
<h3 id="验证-判断逻辑是怎么工作的"><a class="header-anchor" href="#验证-判断逻辑是怎么工作的">¶</a>验证 <code>判断逻辑是怎么工作的</code></h3>
<p>对于 <code>判断逻辑又是怎么工作的</code> 这件事情，对于大多数的 <code>RateLimit</code> 工作都是通过直接判断当前的 <code>bucket</code> 是否还有剩余量来判断是不是限流，大多数应该都是这样的逻辑。<br>
由于我们又知道 <code>Filter</code> 的都是基于继承的逻辑来实现，那我们就可以非常轻松的定位到</p>
<figure class="highlight cpp"><figcaption><span>decodeHeaders</span><a href="https://github.com/envoyproxy/envoy/blob/dacd8914f9c7eb2f374c9e86d6af9a60ac69f37b/source/extensions/filters/http/local_ratelimit/local_ratelimit.cc#L100-L151">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Http::FilterHeadersStatus <span class="title">Filter::decodeHeaders</span><span class="params">(Http::RequestHeaderMap&amp; headers, <span class="type">bool</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>* config = <span class="built_in">getConfig</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!config-&gt;<span class="built_in">enabled</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Http::FilterHeadersStatus::Continue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  config-&gt;<span class="built_in">stats</span>().enabled_.<span class="built_in">inc</span>();</span><br><span class="line"></span><br><span class="line">  std::vector&lt;RateLimit::LocalDescriptor&gt; descriptors;</span><br><span class="line">  <span class="keyword">if</span> (config-&gt;<span class="built_in">hasDescriptors</span>()) &#123;</span><br><span class="line">    <span class="built_in">populateDescriptors</span>(descriptors, headers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Store descriptors which is used to generate x-ratelimit-* headers in encoding response headers.</span></span><br><span class="line">  stored_descriptors_ = descriptors;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ENVOY_LOG_CHECK_LEVEL</span>(debug)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; request_descriptor : descriptors) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> Envoy::RateLimit::DescriptorEntry&amp; entry : request_descriptor.entries_) &#123;</span><br><span class="line">        <span class="built_in">ENVOY_LOG</span>(debug, <span class="string">&quot;populate descriptors: key=&#123;&#125; value=&#123;&#125;&quot;</span>, entry.key_, entry.value_);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line marked">  <span class="keyword">if</span> (<span class="built_in">requestAllowed</span>(descriptors)) &#123;</span><br><span class="line">    config-&gt;<span class="built_in">stats</span>().ok_.<span class="built_in">inc</span>();</span><br><span class="line">    <span class="keyword">return</span> Http::FilterHeadersStatus::Continue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  config-&gt;<span class="built_in">stats</span>().rate_limited_.<span class="built_in">inc</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!config-&gt;<span class="built_in">enforced</span>()) &#123;</span><br><span class="line">    config-&gt;<span class="built_in">requestHeadersParser</span>().<span class="built_in">evaluateHeaders</span>(headers, decoder_callbacks_-&gt;<span class="built_in">streamInfo</span>());</span><br><span class="line">    <span class="keyword">return</span> Http::FilterHeadersStatus::Continue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  config-&gt;<span class="built_in">stats</span>().enforced_.<span class="built_in">inc</span>();</span><br><span class="line"></span><br><span class="line">  decoder_callbacks_-&gt;<span class="built_in">sendLocalReply</span>(</span><br><span class="line">      config-&gt;<span class="built_in">status</span>(), <span class="string">&quot;local_rate_limited&quot;</span>,</span><br><span class="line">      [<span class="keyword">this</span>, config](Http::HeaderMap&amp; headers) &#123;</span><br><span class="line">        config-&gt;<span class="built_in">responseHeadersParser</span>().<span class="built_in">evaluateHeaders</span>(headers, decoder_callbacks_-&gt;<span class="built_in">streamInfo</span>());</span><br><span class="line">      &#125;,</span><br><span class="line">      absl::<span class="literal">nullopt</span>, <span class="string">&quot;local_rate_limited&quot;</span>);</span><br><span class="line">  decoder_callbacks_-&gt;<span class="built_in">streamInfo</span>().<span class="built_in">setResponseFlag</span>(StreamInfo::ResponseFlag::RateLimited);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Http::FilterHeadersStatus::StopIteration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然 <code>requestAllowed</code> 中就是我们判断请求是否运行的地方。 <code>descriptors</code> 我们 Skip 掉，这是区分同一个路径下不同的 Header 的处理逻辑。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">descriptors:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">entries:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">client_cluster</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">foo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">path</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">/foo/bar</span></span><br><span class="line">  <span class="attr">token_bucket:</span></span><br><span class="line">    <span class="attr">max_tokens:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">tokens_per_fill:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">fill_interval:</span> <span class="string">60s</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">entries:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">client_cluster</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">foo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">path</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">/foo/bar2</span></span><br><span class="line">  <span class="attr">token_bucket:</span></span><br><span class="line">    <span class="attr">max_tokens:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">tokens_per_fill:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">fill_interval:</span> <span class="string">60s</span></span><br></pre></td></tr></table></figure>
<p>通过一通小代码，我们就很快找到了，具体的执行逻辑</p>
<figure class="highlight cpp"><figcaption><span>requestAllowedHelper</span><a href="https://github.com/envoyproxy/envoy/blob/5c56e45a041a4446411a8dccb5262b12323ff9be/source/extensions/filters/common/local_ratelimit/local_ratelimit_impl.cc#L110-L129">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LocalRateLimiterImpl::requestAllowedHelper</span><span class="params">(<span class="type">const</span> TokenState&amp; tokens)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Relaxed consistency is used for all operations because we don&#x27;t care about ordering, just the</span></span><br><span class="line">  <span class="comment">// final atomic correctness.</span></span><br><span class="line">  <span class="type">uint32_t</span> expected_tokens = tokens.tokens_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// expected_tokens is either initialized above or reloaded during the CAS failure below.</span></span><br><span class="line">    <span class="keyword">if</span> (expected_tokens == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Testing hook.</span></span><br><span class="line">    synchronizer_.<span class="built_in">syncPoint</span>(<span class="string">&quot;allowed_pre_cas&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop while the weak CAS fails trying to subtract 1 from expected.</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (!tokens.tokens_.<span class="built_in">compare_exchange_weak</span>(expected_tokens, expected_tokens - <span class="number">1</span>,</span><br><span class="line">                                                 std::memory_order_relaxed));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We successfully decremented the counter by 1.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断如果 <code>expected_tokens == 0</code> 直接失败，其他通过 <code>CAS</code> 将期望的 Token - 1，返回成功。</p>
<h3 id="验证-Token-是如何填充的"><a class="header-anchor" href="#验证-Token-是如何填充的">¶</a>验证 <code>Token</code> 是如何填充的</h3>
<p>对于 <code>Token</code> 的填充，势必是需要一个 <code>Timer</code> 来进行的，我们在代码中搜索一下即可发现</p>
<figure class="highlight cpp"><figcaption><span>LocalRateLimiterImpl</span><a href="https://github.com/envoyproxy/envoy/blob/5c56e45a041a4446411a8dccb5262b12323ff9be/source/extensions/filters/common/local_ratelimit/local_ratelimit_impl.cc#L13-L24">github</a></figcaption><table><tr><td class="code"><pre><span class="line">LocalRateLimiterImpl::<span class="built_in">LocalRateLimiterImpl</span>(</span><br><span class="line">    <span class="type">const</span> std::chrono::milliseconds fill_interval, <span class="type">const</span> <span class="type">uint32_t</span> max_tokens,</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> tokens_per_fill, Event::Dispatcher&amp; dispatcher,</span><br><span class="line">    <span class="type">const</span> Protobuf::RepeatedPtrField&lt;</span><br><span class="line">        envoy::extensions::common::ratelimit::v3::LocalRateLimitDescriptor&gt;&amp; descriptors)</span><br><span class="line marked">    : <span class="built_in">fill_timer_</span>(fill_interval &gt; std::chrono::<span class="built_in">milliseconds</span>(<span class="number">0</span>)</span><br><span class="line marked">                      ? dispatcher.<span class="built_in">createTimer</span>([<span class="keyword">this</span>] &#123; <span class="built_in">onFillTimer</span>(); &#125;)</span><br><span class="line">                      : <span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">time_source_</span>(dispatcher.<span class="built_in">timeSource</span>()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (fill_timer_ &amp;&amp; fill_interval &lt; std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">EnvoyException</span>(<span class="string">&quot;local rate limit token bucket fill timer must be &gt;= 50ms&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    token_bucket_.fill_interval_ = absl::<span class="built_in">FromChrono</span>(fill_interval);</span><br><span class="line">  tokens_.tokens_ = max_tokens;</span><br><span class="line">  tokens_.fill_time_ = time_source_.<span class="built_in">monotonicTime</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fill_timer_) &#123;</span><br><span class="line">    fill_timer_-&gt;<span class="built_in">enableTimer</span>(fill_interval);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>显然通过 <code>dispatcher</code> 创建一个 <code>timer</code>，然后在后面通过 <code>enableTimer</code> 启动了这个定时器。</p>
<p>下一个疑问就接踵而来，<code>dispatcher</code> 这是啥东西，这里我们知道它可以创建一个 <code>timer</code></p>
<h2 id="dispatcher-探索"><a class="header-anchor" href="#dispatcher-探索">¶</a>dispatcher 探索</h2>
<p>对于一个全新的概念，我们最初的时候会使用联想大法，之前有没有什么类似的东西。恰好如果以前是一个 <code>Java Boy</code> 我们自然会想到 <code>dispatcherServlet</code> 这个抽象，是作为分发 <code>Http</code> 请求的，而这里的创建 <code>timer</code> 好像完全对不上号。那我们先来看看这个对象的定义。</p>
<figure class="highlight cpp"><figcaption><span>Dispatcher</span><a href="https://github.com/envoyproxy/envoy/blob/f8fd6e36dc9447a8f51c574f6c4c112fb349d487/envoy/event/dispatcher.h#L109-L309">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dispatcher</span> : <span class="keyword">public</span> DispatcherBase, <span class="keyword">public</span> ScopeTracker &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the name that identifies this dispatcher, such as &quot;worker_2&quot; or &quot;main_thread&quot;.</span></span><br><span class="line"><span class="comment">   * @return const std::string&amp; the name that identifies this dispatcher.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a file event that will signal when a file is readable or writable. On UNIX systems this</span></span><br><span class="line"><span class="comment">   * can be used for any file like interface (files, sockets, etc.).</span></span><br><span class="line"><span class="comment">   * @param fd supplies the fd to watch.</span></span><br><span class="line"><span class="comment">   * @param cb supplies the callback to fire when the file is ready.</span></span><br><span class="line"><span class="comment">   * @param trigger specifies whether to edge or level trigger.</span></span><br><span class="line"><span class="comment">   * @param events supplies a logical OR of FileReadyType events that the file event should</span></span><br><span class="line"><span class="comment">   *               initially listen on.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> FileEventPtr <span class="title">createFileEvent</span><span class="params">(<span class="type">os_fd_t</span> fd, FileReadyCb cb, FileTriggerType trigger,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">uint32_t</span> events)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Allocates a timer. @see Timer for docs on how to use the timer.</span></span><br><span class="line"><span class="comment">   * @param cb supplies the callback to invoke when the timer fires.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Event::TimerPtr <span class="title">createTimer</span><span class="params">(TimerCb cb)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Allocates a scaled timer. @see Timer for docs on how to use the timer.</span></span><br><span class="line"><span class="comment">   * @param timer_type the type of timer to create.</span></span><br><span class="line"><span class="comment">   * @param cb supplies the callback to invoke when the timer fires.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Event::TimerPtr <span class="title">createScaledTimer</span><span class="params">(Event::ScaledTimerType timer_type, TimerCb cb)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Allocates a scaled timer. @see Timer for docs on how to use the timer.</span></span><br><span class="line"><span class="comment">   * @param minimum the rule for computing the minimum value of the timer.</span></span><br><span class="line"><span class="comment">   * @param cb supplies the callback to invoke when the timer fires.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Event::TimerPtr <span class="title">createScaledTimer</span><span class="params">(Event::ScaledTimerMinimum minimum, TimerCb cb)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Allocates a schedulable callback. @see SchedulableCallback for docs on how to use the wrapped</span></span><br><span class="line"><span class="comment">   * callback.</span></span><br><span class="line"><span class="comment">   * @param cb supplies the callback to invoke when the SchedulableCallback is triggered on the</span></span><br><span class="line"><span class="comment">   * event loop.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Event::SchedulableCallbackPtr <span class="title">createSchedulableCallback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; cb)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Register a watchdog for this dispatcher. The dispatcher is responsible for touching the</span></span><br><span class="line"><span class="comment">   * watchdog at least once per touch interval. Dispatcher implementations may choose to touch more</span></span><br><span class="line"><span class="comment">   * often to avoid spurious miss events when processing long callback queues.</span></span><br><span class="line"><span class="comment">   * @param min_touch_interval Touch interval for the watchdog.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">registerWatchdog</span><span class="params">(<span class="type">const</span> Server::WatchDogSharedPtr&amp; watchdog,</span></span></span><br><span class="line"><span class="params"><span class="function">                                std::chrono::milliseconds min_touch_interval)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a time-source to use with this dispatcher.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> TimeSource&amp; <span class="title">timeSource</span><span class="params">()</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a recently cached MonotonicTime value.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> MonotonicTime <span class="title">approximateMonotonicTime</span><span class="params">()</span> <span class="type">const</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Initializes stats for this dispatcher. Note that this can&#x27;t generally be done at construction</span></span><br><span class="line"><span class="comment">   * time, since the main and worker thread dispatchers are constructed before</span></span><br><span class="line"><span class="comment">   * ThreadLocalStoreImpl::initializeThreading.</span></span><br><span class="line"><span class="comment">   * @param scope the scope to contain the new per-dispatcher stats created here.</span></span><br><span class="line"><span class="comment">   * @param prefix the stats prefix to identify this dispatcher. If empty, the dispatcher will be</span></span><br><span class="line"><span class="comment">   *               identified by its name.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">initializeStats</span><span class="params">(Stats::Scope&amp; scope,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> absl::optional&lt;std::string&gt;&amp; prefix = absl::<span class="literal">nullopt</span>)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clears any items in the deferred deletion queue.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">clearDeferredDeleteList</span><span class="params">()</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Wraps an already-accepted socket in an instance of Envoy&#x27;s server Network::Connection.</span></span><br><span class="line"><span class="comment">   * @param socket supplies an open file descriptor and connection metadata to use for the</span></span><br><span class="line"><span class="comment">   *        connection. Takes ownership of the socket.</span></span><br><span class="line"><span class="comment">   * @param transport_socket supplies a transport socket to be used by the connection.</span></span><br><span class="line"><span class="comment">   * @param stream_info info object for the server connection</span></span><br><span class="line"><span class="comment">   * @return Network::ConnectionPtr a server connection that is owned by the caller.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Network::ServerConnectionPtr</span></span><br><span class="line"><span class="function">  <span class="title">createServerConnection</span><span class="params">(Network::ConnectionSocketPtr&amp;&amp; socket,</span></span></span><br><span class="line"><span class="params"><span class="function">                         Network::TransportSocketPtr&amp;&amp; transport_socket,</span></span></span><br><span class="line"><span class="params"><span class="function">                         StreamInfo::StreamInfo&amp; stream_info)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates an instance of Envoy&#x27;s Network::ClientConnection. Does NOT initiate the connection;</span></span><br><span class="line"><span class="comment">   * the caller must then call connect() on the returned Network::ClientConnection.</span></span><br><span class="line"><span class="comment">   * @param address supplies the address to connect to.</span></span><br><span class="line"><span class="comment">   * @param source_address supplies an address to bind to or nullptr if no bind is necessary.</span></span><br><span class="line"><span class="comment">   * @param transport_socket supplies a transport socket to be used by the connection.</span></span><br><span class="line"><span class="comment">   * @param options the socket options to be set on the underlying socket before anything is sent</span></span><br><span class="line"><span class="comment">   *        on the socket.</span></span><br><span class="line"><span class="comment">   * @return Network::ClientConnectionPtr a client connection that is owned by the caller.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Network::ClientConnectionPtr</span></span><br><span class="line"><span class="function">  <span class="title">createClientConnection</span><span class="params">(Network::Address::InstanceConstSharedPtr address,</span></span></span><br><span class="line"><span class="params"><span class="function">                         Network::Address::InstanceConstSharedPtr source_address,</span></span></span><br><span class="line"><span class="params"><span class="function">                         Network::TransportSocketPtr&amp;&amp; transport_socket,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> Network::ConnectionSocket::OptionsSharedPtr&amp; options)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return Filesystem::WatcherPtr a filesystem watcher owned by the caller.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Filesystem::WatcherPtr <span class="title">createFilesystemWatcher</span><span class="params">()</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a listener on a specific port.</span></span><br><span class="line"><span class="comment">   * @param socket supplies the socket to listen on.</span></span><br><span class="line"><span class="comment">   * @param cb supplies the callbacks to invoke for listener events.</span></span><br><span class="line"><span class="comment">   * @param runtime supplies the runtime for this server.</span></span><br><span class="line"><span class="comment">   * @param bind_to_port controls whether the listener binds to a transport port or not.</span></span><br><span class="line"><span class="comment">   * @param ignore_global_conn_limit controls whether the listener is limited by the global</span></span><br><span class="line"><span class="comment">   * connection limit.</span></span><br><span class="line"><span class="comment">   * @return Network::ListenerPtr a new listener that is owned by the caller.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Network::ListenerPtr <span class="title">createListener</span><span class="params">(Network::SocketSharedPtr&amp;&amp; socket,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              Network::TcpListenerCallbacks&amp; cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              Runtime::Loader&amp; runtime, <span class="type">bool</span> bind_to_port,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">bool</span> ignore_global_conn_limit)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a logical udp listener on a specific port.</span></span><br><span class="line"><span class="comment">   * @param socket supplies the socket to listen on.</span></span><br><span class="line"><span class="comment">   * @param cb supplies the udp listener callbacks to invoke for listener events.</span></span><br><span class="line"><span class="comment">   * @param config provides the UDP socket configuration.</span></span><br><span class="line"><span class="comment">   * @return Network::ListenerPtr a new listener that is owned by the caller.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Network::UdpListenerPtr</span></span><br><span class="line"><span class="function">  <span class="title">createUdpListener</span><span class="params">(Network::SocketSharedPtr socket, Network::UdpListenerCallbacks&amp; cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> envoy::config::core::v3::UdpSocketConfig&amp; config)</span> PURE</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Submits an item for deferred delete. @see DeferredDeletable.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">deferredDelete</span><span class="params">(DeferredDeletablePtr&amp;&amp; to_delete)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Exits the event loop.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">exit</span><span class="params">()</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Listens for a signal event. Only a single dispatcher in the process can listen for signals.</span></span><br><span class="line"><span class="comment">   * If more than one dispatcher calls this routine in the process the behavior is undefined.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param signal_num supplies the signal to listen on.</span></span><br><span class="line"><span class="comment">   * @param cb supplies the callback to invoke when the signal fires.</span></span><br><span class="line"><span class="comment">   * @return SignalEventPtr a signal event that is owned by the caller.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> SignalEventPtr <span class="title">listenForSignal</span><span class="params">(<span class="type">signal_t</span> signal_num, SignalCb cb)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Post the deletable to this dispatcher. The deletable objects are guaranteed to be destroyed on</span></span><br><span class="line"><span class="comment">   * the dispatcher&#x27;s thread before dispatcher destroy. This is safe cross thread.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">deleteInDispatcherThread</span><span class="params">(DispatcherThreadDeletableConstPtr deletable)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Runs the event loop. This will not return until exit() is called either from within a callback</span></span><br><span class="line"><span class="comment">   * or from a different thread.</span></span><br><span class="line"><span class="comment">   * @param type specifies whether to run in blocking mode (run() will not return until exit() is</span></span><br><span class="line"><span class="comment">   *              called) or non-blocking mode where only active events will be executed and then</span></span><br><span class="line"><span class="comment">   *              run() will return.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">enum class</span> <span class="title class_">RunType</span> &#123;</span><br><span class="line">    Block,       <span class="comment">// Runs the event-loop until there are no pending events.</span></span><br><span class="line">    NonBlock,    <span class="comment">// Checks for any pending events to activate, executes them,</span></span><br><span class="line">                 <span class="comment">// then exits. Exits immediately if there are no pending or</span></span><br><span class="line">                 <span class="comment">// active events.</span></span><br><span class="line">    RunUntilExit <span class="comment">// Runs the event-loop until loopExit() is called, blocking</span></span><br><span class="line">                 <span class="comment">// until there are pending or active events.</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">(RunType type)</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a factory which connections may use for watermark buffer creation.</span></span><br><span class="line"><span class="comment">   * @return the watermark buffer factory for this dispatcher.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Buffer::WatermarkFactory&amp; <span class="title">getWatermarkFactory</span><span class="params">()</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Updates approximate monotonic time to current value.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">updateApproximateMonotonicTime</span><span class="params">()</span> PURE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Shutdown the dispatcher by clear dispatcher thread deletable.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">shutdown</span><span class="params">()</span> PURE</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过 <code>API</code> 定义，我们其实就可以有一个感性的认识，<code>dispatch</code> 像一个在 <code>Thread</code> 级别上的东西，为每一个 <code>工作线程</code> 提供了最开始的入口函数，无论是 <code>Listener</code> 还是 <code>Timer</code>最终要作用在某个线程上，集合传统的 <a href="https://www.appsdeveloperblog.com/reactor-execution-model-threading-and-schedulers/"><code>Reactor</code> 编程模型</a>，我们可以自然的推测出，这里的 <code>Dispatch</code> 就是和我们在启动的时候</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--concurrency 并发数</span><br></pre></td></tr></table></figure>
<p>有关系。</p>
<h2 id="验证猜想"><a class="header-anchor" href="#验证猜想">¶</a>验证猜想</h2>
<p>随即我们在代码的各处就可以发现对象创建的身影，比如创建主线程对象</p>
<figure class="highlight cpp"><figcaption><span>InstanceImpl</span><a href="https://github.com/envoyproxy/envoy/blob/d0ff27196eb94456f8a413526189ba9596ca4794/source/server/server.cc#L84">gitub</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatcher_</span>(api_-&gt;<span class="built_in">allocateDispatcher</span>(<span class="string">&quot;main_thread&quot;</span>)),</span><br></pre></td></tr></table></figure>
<p>又比如创建 <code>worker</code> 线程的对象</p>
<figure class="highlight cpp"><figcaption><span>createWorker</span><a href="https://github.com/envoyproxy/envoy/blob/f8fd6e36dc9447a8f51c574f6c4c112fb349d487/source/server/worker_impl.cc#L17-L24">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">WorkerPtr <span class="title">ProdWorkerFactory::createWorker</span><span class="params">(<span class="type">uint32_t</span> index, OverloadManager&amp; overload_manager,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> std::string&amp; worker_name)</span> </span>&#123;</span><br><span class="line">  <span class="function">Event::DispatcherPtr <span class="title">dispatcher</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      api_.allocateDispatcher(worker_name, overload_manager.scaledTimerFactory()))</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> conn_handler = std::<span class="built_in">make_unique</span>&lt;ConnectionHandlerImpl&gt;(*dispatcher, index);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;WorkerImpl&gt;(tls_, hooks_, std::<span class="built_in">move</span>(dispatcher), std::<span class="built_in">move</span>(conn_handler),</span><br><span class="line">                                      overload_manager, api_, stat_names_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终找到了我们猜想的地方。啊哈，Eureka!</p>
<figure class="highlight cpp"><figcaption><span>ListenerManager</span><a href="https://github.com/envoyproxy/envoy/blob/7943cb1c7ab51ab95f0bf24fcfa2ba867468ea7d/source/server/listener_manager_impl.cc#L239-L256">github</a></figcaption><table><tr><td class="code"><pre><span class="line">ListenerManagerImpl::<span class="built_in">ListenerManagerImpl</span>(Instance&amp; server,</span><br><span class="line">                                         ListenerComponentFactory&amp; listener_factory,</span><br><span class="line">                                         WorkerFactory&amp; worker_factory,</span><br><span class="line">                                         <span class="type">bool</span> enable_dispatcher_stats,</span><br><span class="line">                                         Quic::QuicStatNames&amp; quic_stat_names)</span><br><span class="line">    : <span class="built_in">server_</span>(server), <span class="built_in">factory_</span>(listener_factory),</span><br><span class="line">      <span class="built_in">scope_</span>(server.<span class="built_in">stats</span>().<span class="built_in">createScope</span>(<span class="string">&quot;listener_manager.&quot;</span>)), <span class="built_in">stats_</span>(<span class="built_in">generateStats</span>(*scope_)),</span><br><span class="line">      <span class="built_in">config_tracker_entry_</span>(server.<span class="built_in">admin</span>().<span class="built_in">getConfigTracker</span>().<span class="built_in">add</span>(</span><br><span class="line">          <span class="string">&quot;listeners&quot;</span>,</span><br><span class="line">          [<span class="keyword">this</span>](<span class="type">const</span> Matchers::StringMatcher&amp; name_matcher) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dumpListenerConfigs</span>(name_matcher);</span><br><span class="line">          &#125;)),</span><br><span class="line">      <span class="built_in">enable_dispatcher_stats_</span>(enable_dispatcher_stats), <span class="built_in">quic_stat_names_</span>(quic_stat_names) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; server.<span class="built_in">options</span>().<span class="built_in">concurrency</span>(); i++) &#123;</span><br><span class="line">    workers_.<span class="built_in">emplace_back</span>(</span><br><span class="line">        worker_factory.<span class="built_in">createWorker</span>(i, server.<span class="built_in">overloadManager</span>(), absl::<span class="built_in">StrCat</span>(<span class="string">&quot;worker_&quot;</span>, i)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Timer"><a class="header-anchor" href="#Timer">¶</a>Timer</h3>
<p>让我们回归 <code>timer</code> 的逻辑本身，定时器在所有的系统中都是非常重要的实现，<a href="https://book.douban.com/subject/24722611/">《Linux高性能服务器编程》</a>中有单独的一个章节：定时器 章节。</p>
<p>不过在 <code>Envoy</code>中，这块比较的简单直接委托给 <code>libevent</code> 的来实现了。</p>
<figure class="highlight cpp"><figcaption><span>createTimer</span><a href="https://github.com/envoyproxy/envoy/blob/0fae6970ddaf93f024908ba304bbd2b34e997a51/source/common/event/libevent_scheduler.cc#L38-L40">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">TimerPtr <span class="title">LibeventScheduler::createTimer</span><span class="params">(<span class="type">const</span> TimerCb&amp; cb, Dispatcher&amp; dispatcher)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;TimerImpl&gt;(libevent_, cb, dispatcher);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>随着我们对限流的代码的阅读，我们发现对 Envoy 来说，还是非常符合我们的编程习惯的。让我们看了 <code>local_rate_limiter</code> 我们就来看看与之非常类似的 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/bandwidth_limit_filter#config-http-filters-bandwidth-limit"><code>BandwidthLimit</code></a>，从文档中可以得知，<code>Local_rate_limiter</code> 对于超出的请求直接失败了，但是我们有另外一个场景就是我们希望对用户有限流的场景，比如限制非会员 <strong>100kb/s</strong> 那这样的场景下就是 <code>BandwidthLimit</code> 所适用的场景。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">route_config:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">local_route</span></span><br><span class="line">  <span class="attr">virtual_hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">local_service</span></span><br><span class="line">    <span class="attr">domains:</span> [<span class="string">&quot;*&quot;</span>]</span><br><span class="line">    <span class="attr">routes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">match:</span> &#123;<span class="attr">prefix:</span> <span class="string">&quot;/path/with/bandwidth/limit&quot;</span>&#125;</span><br><span class="line">      <span class="attr">route:</span> &#123;<span class="attr">cluster:</span> <span class="string">service_protected_by_bandwidth_limit</span>&#125;</span><br><span class="line">      <span class="attr">typed_per_filter_config:</span></span><br><span class="line">        <span class="attr">envoy.filters.http.bandwidth_limit:</span></span><br><span class="line">          <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.bandwidth_limit.v3.BandwidthLimit</span></span><br><span class="line">          <span class="attr">stat_prefix:</span> <span class="string">bandwidth_limiter_custom_route</span></span><br><span class="line">          <span class="attr">enable_mode:</span> <span class="string">REQUEST_AND_RESPONSE</span></span><br><span class="line">          <span class="attr">limit_kbps:</span> <span class="number">500</span></span><br><span class="line">          <span class="attr">fill_interval:</span> <span class="number">0.</span><span class="string">1s</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">match:</span> &#123;<span class="attr">prefix:</span> <span class="string">&quot;/&quot;</span>&#125;</span><br><span class="line">      <span class="attr">route:</span> &#123;<span class="attr">cluster:</span> <span class="string">web_service</span>&#125;</span><br></pre></td></tr></table></figure>
<p>根据我们之前读 <code>local_rate_limiter</code> 的代码，我们就很容易推测出 <code>BandwidthLimit</code> 的逻辑。</p>
<ul>
<li>在创建 Filter 的时候配置了 <code>BandwidthLimit</code> 对象，有局部变量储存</li>
<li>在 Dispatch 中增加定时更新 <code>Token</code> 的逻辑</li>
</ul>
<p>但是我们会有一个疑问，这个请求是如何做到限流的，如果请求量比我们限制多的时候，这个请求是如何处理的，这里显然需要解决一个问题 <code>Thread 不能被阻塞</code>。</p>
<p>有了上次的经验，我们直接来阅读 核心部分</p>
<figure class="highlight cpp"><figcaption><span>writeData</span><a href="https://github.com/envoyproxy/envoy/blob/8b8ece8adb8c9282cbd9405151993fa1bc5cebee/source/extensions/filters/http/common/stream_rate_limiter.cc#L91-L115">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamRateLimiter::writeData</span><span class="params">(Buffer::Instance&amp; incoming_buffer, <span class="type">bool</span> end_stream,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">bool</span> trailer_added)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> len = incoming_buffer.<span class="built_in">length</span>();</span><br><span class="line">  buffer_.<span class="built_in">move</span>(incoming_buffer);</span><br><span class="line">  saw_end_stream_ = end_stream;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trailer_added) &#123;</span><br><span class="line">    saw_trailers_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ENVOY_LOG</span>(debug,</span><br><span class="line">            <span class="string">&quot;StreamRateLimiter &lt;writeData&gt;: got new &#123;&#125; bytes of data. token &quot;</span></span><br><span class="line">            <span class="string">&quot;timer &#123;&#125; scheduled.&quot;</span>,</span><br><span class="line">            len, !token_timer_-&gt;<span class="built_in">enabled</span>() ? <span class="string">&quot;now&quot;</span> : <span class="string">&quot;already&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!token_timer_-&gt;<span class="built_in">enabled</span>()) &#123;</span><br><span class="line">    token_timer_-&gt;<span class="built_in">enableTimer</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">0</span>), &amp;scope_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写入的数据直接会被 <code>move</code> 到一个 <code>buffer</code> 中，而不是直接处理，放入 <code>buffer</code>之中之后，然后触发 <code>enableTimer</code> 也就是让 timer 继续工作，那显然逻辑会放在 <code>onTokenTimer</code>  的逻辑之中</p>
<figure class="highlight cpp"><figcaption><span>onTokenTimer</span><a href="https://github.com/envoyproxy/envoy/blob/8b8ece8adb8c9282cbd9405151993fa1bc5cebee/source/extensions/filters/http/common/stream_rate_limiter.cc#L51-L89">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamRateLimiter::onTokenTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Buffer::OwnedImpl data_to_write;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先我们确定，我们能够使用的 token 数量，和 buffer 必读，来确定我们能处理的数据长度</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> tokens_obtained = token_bucket_-&gt;<span class="built_in">consume</span>(buffer_.<span class="built_in">length</span>(), <span class="literal">true</span>);</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> bytes_to_write = std::<span class="built_in">min</span>(tokens_obtained, buffer_.<span class="built_in">length</span>());</span><br><span class="line">  <span class="built_in">ENVOY_LOG</span>(debug,</span><br><span class="line">            <span class="string">&quot;StreamRateLimiter &lt;onTokenTimer&gt;: tokens_needed=&#123;&#125; &quot;</span></span><br><span class="line">            <span class="string">&quot;tokens_obtained=&#123;&#125; to_write=&#123;&#125;&quot;</span>,</span><br><span class="line">            buffer_.<span class="built_in">length</span>(), tokens_obtained, bytes_to_write);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将limit能放行的数据量移动到 buffer 里面</span></span><br><span class="line">  data_to_write.<span class="built_in">move</span>(buffer_, bytes_to_write);</span><br><span class="line">  <span class="built_in">write_stats_cb_</span>(bytes_to_write, buffer_.<span class="built_in">length</span>() &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果数据包已经取完，就不用安排下一次的执行时间了，但是如果还有就要在下次 fill token 的是，处理逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (buffer_.<span class="built_in">length</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">ENVOY_LOG</span>(debug,</span><br><span class="line">              <span class="string">&quot;StreamRateLimiter &lt;onTokenTimer&gt;: scheduling wakeup for &#123;&#125;ms, &quot;</span></span><br><span class="line">              <span class="string">&quot;buffered=&#123;&#125;&quot;</span>,</span><br><span class="line">              fill_interval_.<span class="built_in">count</span>(), buffer_.<span class="built_in">length</span>());</span><br><span class="line">    token_timer_-&gt;<span class="built_in">enableTimer</span>(fill_interval_, &amp;scope_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用回调函数来继续处理</span></span><br><span class="line">  <span class="built_in">write_data_cb_</span>(data_to_write, saw_end_stream_ &amp;&amp; buffer_.<span class="built_in">length</span>() == <span class="number">0</span> &amp;&amp; !saw_trailers_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If there is no more data to send and we saw trailers, we need to continue iteration to release</span></span><br><span class="line">  <span class="comment">// the trailers to further filters.</span></span><br><span class="line">  <span class="keyword">if</span> (buffer_.<span class="built_in">length</span>() == <span class="number">0</span> &amp;&amp; saw_trailers_) &#123;</span><br><span class="line">    <span class="built_in">continue_cb_</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>网络编程</category>
        <category>API</category>
        <category>Gateway</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>Gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>RT-Thread 简明阅读</title>
    <url>/2021/03/25/os/rt-thread/rt-thread/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210325155834.png" alt=""></p>
<p>对于一个<code>软件工程师</code>来说，我并不是很关心 <code>BootLoader</code> 这些东西，几乎都比较接近于硬件，<code>Linux</code> 的代码又普遍太过于工业级，因此尝试用 <code>rt-thread</code> 这样一<br>
个比较小型的 <code>real time</code> 系统来解析操作系统的工作。</p>
<blockquote>
<p>For My Lovely Wife</p>
</blockquote>
<!-- more --->
<h2 id="环境准备"><a class="header-anchor" href="#环境准备">¶</a>环境准备</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/RT-Thread/</span><br><span class="line"><span class="built_in">cd</span> rt-thread/bsp/qemu-vexpress-a9</span><br><span class="line">scons</span><br><span class="line">./run-qemu.sh</span><br></pre></td></tr></table></figure>
<h2 id="Clock-时钟"><a class="header-anchor" href="#Clock-时钟">¶</a>Clock 时钟</h2>
<blockquote>
<p>建议初学者先阅读 <a href="https://www.rt-thread.org/document/site/programming-manual/basic/basic/">内核基础</a></p>
</blockquote>
<p>对于操作系统来说，我们需要依赖时间，无论是显示的时间，还是说我们的进程运行了多久，这些都非常依赖于一个硬件 <a href="http://murata.eetrend.com/article/2019-05/1002740.html"><code>晶振</code></a>，晶振的作用很简单，但是这种事比较初级的版本，后来在 CPU 中集成了 <a href="https://en.m.wikipedia.org/wiki/Programmable_interval_timer"><code>PIT</code></a>，Whatever 我们暂时不管具体怎么实现，对于 <code>OS</code> 来说，当时间发生了变化，CPU就会触发 <code>interrupt</code></p>
<h3 id="中断"><a class="header-anchor" href="#中断">¶</a>中断</h3>
<p>对于不同的架构的 <code>CPU</code>，中断的设计不太一样，这里我们就拿手机上的 <code>Cortex-A53</code> 作为例子。在 <a href="https://github.com/RT-Thread/rt-thread/blob/master/libcpu/aarch64/cortex-a53/interrupt.h"><code>interrupt.h</code></a> 暴露了如何注册中端函数的方法 <code>rt_hw_interrupt_install</code></p>
<p>相对应的 <code>BSP - qemu-vexpress-a9</code> 中，我们可以找到注册的调用处</p>
<figure class="highlight c"><figcaption><span>rt_hw_timer_init</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/bsp/qemu-vexpress-a9/drivers/drv_timer.c#L64">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rt_hw_timer_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册中断的处理函数</span></span><br><span class="line">    rt_hw_interrupt_install(IRQ_PBA8_TIMER2_3, rt_hw_timer_isr, RT_NULL, <span class="string">&quot;tick&quot;</span>);</span><br><span class="line">    rt_hw_interrupt_umask(IRQ_PBA8_TIMER2_3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>接下来，我们就看到我们软件部分的逻辑了</p>
<figure class="highlight c"><figcaption><span>clock.c</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/src/clock.c">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_tick_increase</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increase the global tick */</span></span><br><span class="line"><span class="comment">// 对于多核系统需要针对此核心</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_SMP</span></span><br><span class="line">    rt_cpu_self()-&gt;tick ++;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ++ rt_tick;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check time slice */</span></span><br><span class="line">    <span class="comment">// 这里获得当前的进程</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每执行一次 rt_tick_increase 函数，我们都要看看进程是否已经耗完了所有的tick，如果耗完了就需要进行调度了</span></span><br><span class="line">    -- thread-&gt;remaining_tick;</span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;remaining_tick == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* change to initialized tick */</span></span><br><span class="line">        thread-&gt;remaining_tick = thread-&gt;init_tick;</span><br><span class="line"></span><br><span class="line">        thread-&gt;stat |= RT_THREAD_STAT_YIELD;</span><br><span class="line"></span><br><span class="line">        rt_schedule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check timer */</span></span><br><span class="line">    rt_timer_check();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时钟函数是系统中最为简单的部分，仅仅用作计数，重新调度也仅仅是顺带而为之，那我们接下来看看进程调度。</p>
<h2 id="进程调度"><a class="header-anchor" href="#进程调度">¶</a>进程调度</h2>
<p><code>RT-Thread </code>线程管理的主要功能是对线程进行管理和调度，系统中总共存在两类线程，分别是系统线程和用户线程。对于进程来说，我们需要保留运行的状态进行调度。</p>
<figure class="highlight c"><figcaption><span>rtdef.h</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/include/rtdef.h#L572">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* rt 对象 */</span></span><br><span class="line">    <span class="type">char</span>        name[RT_NAME_MAX];     <span class="comment">/* 线程名称 */</span></span><br><span class="line">    <span class="type">rt_uint8_t</span>  type;                   <span class="comment">/* 对象类型 */</span></span><br><span class="line">    <span class="type">rt_uint8_t</span>  flags;                  <span class="comment">/* 标志位 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">rt_list_t</span>   <span class="built_in">list</span>;                   <span class="comment">/* 对象列表 */</span></span><br><span class="line">    <span class="type">rt_list_t</span>   tlist;                  <span class="comment">/* 线程列表 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 栈指针与入口指针 */</span></span><br><span class="line">    <span class="type">void</span>       *sp;                      <span class="comment">/* 栈指针 */</span></span><br><span class="line">    <span class="type">void</span>       *entry;                   <span class="comment">/* 入口函数指针 */</span></span><br><span class="line">    <span class="type">void</span>       *parameter;              <span class="comment">/* 参数 */</span></span><br><span class="line">    <span class="type">void</span>       *stack_addr;             <span class="comment">/* 栈地址指针 */</span></span><br><span class="line">    <span class="type">rt_uint32_t</span> stack_size;            <span class="comment">/* 栈大小 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 错误代码 */</span></span><br><span class="line">    <span class="type">rt_err_t</span>    error;                  <span class="comment">/* 线程错误代码 */</span></span><br><span class="line">    <span class="type">rt_uint8_t</span>  stat;                   <span class="comment">/* 线程状态 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 优先级 */</span></span><br><span class="line">    <span class="type">rt_uint8_t</span>  current_priority;    <span class="comment">/* 当前优先级 */</span></span><br><span class="line">    <span class="type">rt_uint8_t</span>  init_priority;        <span class="comment">/* 初始优先级 */</span></span><br><span class="line">    <span class="type">rt_uint32_t</span> number_mask;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="type">rt_ubase_t</span>  init_tick;               <span class="comment">/* 线程初始化计数值 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span>  remaining_tick;         <span class="comment">/* 线程剩余计数值 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_timer</span> <span class="title">thread_timer</span>;</span>      <span class="comment">/* 内置线程定时器 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> rt_thread *tid);  <span class="comment">/* 线程退出清除函数 */</span></span><br><span class="line">    <span class="type">rt_uint32_t</span> user_data;                      <span class="comment">/* 用户数据 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对 <code>RT-Thread</code> 也包含了一组进程的状态切换。</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210325163941.png" alt=""></p>
<h3 id="Try-it"><a class="header-anchor" href="#Try-it">¶</a>Try it</h3>
<p>我们修改 <code>/rt-thread/bsp/qemu-vexpress-a9/applications/main.c</code></p>
<figure class="highlight c"><figcaption><span>main.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_STACK_SIZE   1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_PRIORITY     20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_TIMESLICE    10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程入口 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread_entry</span><span class="params">(<span class="type">void</span>* parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_uint32_t</span> value;</span><br><span class="line">    <span class="type">rt_uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    value = (<span class="type">rt_uint32_t</span>)parameter;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == (count % <span class="number">5</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            rt_kprintf(<span class="string">&quot;thread %d is running ,thread %d count = %d\n&quot;</span>, value , value , count);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(count&gt; <span class="number">200</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         count++;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timeslice_sample</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_thread_t</span> tid = RT_NULL;</span><br><span class="line">    <span class="comment">/* 创建线程 1 */</span></span><br><span class="line">    tid = rt_thread_create(<span class="string">&quot;thread1&quot;</span>,</span><br><span class="line">                            thread_entry, (<span class="type">void</span>*)<span class="number">1</span>,</span><br><span class="line">                            THREAD_STACK_SIZE,</span><br><span class="line">                            THREAD_PRIORITY, THREAD_TIMESLICE);</span><br><span class="line">    <span class="keyword">if</span> (tid != RT_NULL)</span><br><span class="line">        rt_thread_startup(tid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建线程 2 */</span></span><br><span class="line">    tid = rt_thread_create(<span class="string">&quot;thread2&quot;</span>,</span><br><span class="line">                            thread_entry, (<span class="type">void</span>*)<span class="number">2</span>,</span><br><span class="line">                            THREAD_STACK_SIZE,</span><br><span class="line">                            THREAD_PRIORITY, THREAD_TIMESLICE<span class="number">-5</span>);</span><br><span class="line">    <span class="keyword">if</span> (tid != RT_NULL)</span><br><span class="line">        rt_thread_startup(tid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    timeslice_sample();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><figcaption><span>execute</span></figcaption><table><tr><td class="code"><pre><span class="line">$ scons</span><br><span class="line">$ ./qemu-nographic.sh</span><br><span class="line"></span><br><span class="line">msh /&gt;thread 1 is running ,thread 1 count = 0</span><br><span class="line">thread 1 is running ,thread 1 count = 5</span><br><span class="line">thread 1 is running ,thread 1 count = 10</span><br><span class="line">thread 1 is running ,thread 1 count = 15</span><br><span class="line">thread 1 is running ,thread 1 count = 20</span><br><span class="line">thread 1 is running ,thread 1 count = 25</span><br><span class="line">thread 1 is running ,thread 1 count = 30</span><br><span class="line">thread 1 is running ,thread 1 count = 35</span><br><span class="line">thread 1 is running ,thread 1 count = 40</span><br><span class="line">thread 1 is running ,thread 1 count = 45</span><br><span class="line">thread 1 is running ,thread 1 count = 50</span><br><span class="line">thread 1 is running ,thread 1 count = 55</span><br><span class="line">thread 1 is running ,thread 1 count = 60</span><br><span class="line">thread 1 is running ,thread 1 count = 65</span><br><span class="line">thread 1 is running ,thread 1 count = 70</span><br><span class="line">thread 1 is running ,thread 1 count = 75</span><br><span class="line">thread 1 is running ,thread 1 count = 80</span><br><span class="line">thread 1 is running ,thread 1 count = 85</span><br><span class="line">thread 1 is running ,thread 1 count = 90</span><br><span class="line">thread 1 is running ,thread 1 count = 95</span><br><span class="line">thread 1 is running ,thread 1 count = 100</span><br><span class="line">thread 1 is running ,thread 1 count = 105</span><br><span class="line">thread 1 is running ,thread 1 count = 110</span><br><span class="line">thread 1 is running ,thread 1 count = 115</span><br><span class="line">thread 1 is running ,thread 1 count = 1thread 2 is running ,thread 2 count = 0</span><br></pre></td></tr></table></figure>
<p>由运行的计数结果可以看出，线程 2 的运行时间是线程 1 的一半。</p>
<hr>
<h3 id="线程的创建"><a class="header-anchor" href="#线程的创建">¶</a>线程的创建</h3>
<p>对于线程的创建</p>
<figure class="highlight c"><figcaption><span>thread.c</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/src/thread.c">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">rt_err_t</span> _rt_thread_init(<span class="keyword">struct</span> rt_thread *thread,</span><br><span class="line">                                <span class="type">const</span> <span class="type">char</span>       *name,</span><br><span class="line">                                <span class="type">void</span> (*entry)(<span class="type">void</span> *parameter),</span><br><span class="line">                                <span class="type">void</span>             *parameter,</span><br><span class="line">                                <span class="type">void</span>             *stack_start,</span><br><span class="line">                                <span class="type">rt_uint32_t</span>       stack_size,</span><br><span class="line">                                <span class="type">rt_uint8_t</span>        priority,</span><br><span class="line">                                <span class="type">rt_uint32_t</span>       tick)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* init thread list */</span></span><br><span class="line">    rt_list_init(&amp;(thread-&gt;tlist)); <span class="comment">// 在此之间 rt_object_init((rt_object_t)thread, RT_Object_Class_Thread, name); 将线程对象创建在操作系统进行维护</span></span><br><span class="line"></span><br><span class="line">    thread-&gt;entry = (<span class="type">void</span> *)entry; <span class="comment">// 执行的代码部分，也就是线程的 entry</span></span><br><span class="line">    thread-&gt;parameter = parameter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* stack init 初始化栈，下同 */</span></span><br><span class="line">    thread-&gt;stack_addr = stack_start;</span><br><span class="line">    thread-&gt;stack_size = stack_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init thread stack */</span></span><br><span class="line">    rt_memset(thread-&gt;stack_addr, <span class="string">&#x27;#&#x27;</span>, thread-&gt;stack_size);</span><br><span class="line">    thread-&gt;sp = (<span class="type">void</span> *)rt_hw_stack_init(thread-&gt;entry, thread-&gt;parameter,</span><br><span class="line">                                          (<span class="type">rt_uint8_t</span> *)((<span class="type">char</span> *)thread-&gt;stack_addr + thread-&gt;stack_size - <span class="keyword">sizeof</span>(<span class="type">rt_ubase_t</span>)),</span><br><span class="line">                                          (<span class="type">void</span> *)rt_thread_exit);</span><br><span class="line">    <span class="comment">/* priority init 设置线程的优先级 */</span></span><br><span class="line">    RT_ASSERT(priority &lt; RT_THREAD_PRIORITY_MAX);</span><br><span class="line">    thread-&gt;init_priority    = priority;</span><br><span class="line">    thread-&gt;current_priority = priority;</span><br><span class="line"></span><br><span class="line">    thread-&gt;number_mask = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* tick init 初始化 tick */</span></span><br><span class="line">    thread-&gt;init_tick      = tick;</span><br><span class="line">    thread-&gt;remaining_tick = tick;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* error and flags */</span></span><br><span class="line">    thread-&gt;error = RT_EOK;</span><br><span class="line">    thread-&gt;stat  = RT_THREAD_INIT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize cleanup function and user data */</span></span><br><span class="line">    thread-&gt;cleanup   = <span class="number">0</span>;</span><br><span class="line">    thread-&gt;user_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize thread timer 这里为此线程增加了 Timer，定时器如何工作，我们下面再说，因为在特定时间进行工作，我们在下面将此线程 Hook 在我们的内核上 */</span></span><br><span class="line">    rt_timer_init(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                  thread-&gt;name,</span><br><span class="line">                  rt_thread_timeout,</span><br><span class="line">                  thread,</span><br><span class="line">                  <span class="number">0</span>,</span><br><span class="line">                  RT_TIMER_FLAG_ONE_SHOT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 就是在这里</span></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_thread_inited_hook, (thread));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实也不用读的多么详细，大致上知道又这么多的字段需要维护。</p>
<h3 id="线程的运行"><a class="header-anchor" href="#线程的运行">¶</a>线程的运行</h3>
<p>使用 <code>rt_err_t rt_thread_startup(rt_thread_t thread);</code> 进行启动线程，而且启动的逻辑并不复杂。</p>
<figure class="highlight c"><figcaption><span>thread.c</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/src/thread.c#L316">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_startup</span><span class="params">(<span class="type">rt_thread_t</span> thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 设置优先级 */</span></span><br><span class="line">    thread-&gt;current_priority = thread-&gt;init_priority;</span><br><span class="line"></span><br><span class="line">    RT_DEBUG_LOG(RT_DEBUG_THREAD, (<span class="string">&quot;startup a thread:%s with priority:%d\n&quot;</span>,</span><br><span class="line">                                   thread-&gt;name, thread-&gt;init_priority));</span><br><span class="line">    <span class="comment">/* 最开始是 SUSPEND */</span></span><br><span class="line">    thread-&gt;stat = RT_THREAD_SUSPEND;</span><br><span class="line">    <span class="comment">/* 然后 RESUME */</span></span><br><span class="line">    rt_thread_resume(thread);</span><br><span class="line">    <span class="keyword">if</span> (rt_thread_self() != RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 然后直接调度，为什么上面需要判断下，可能在 SMP 情况下被其他的 Thread 调度了 */</span></span><br><span class="line">        rt_schedule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程的调度"><a class="header-anchor" href="#线程的调度">¶</a>线程的调度</h3>
<figure class="highlight c"><figcaption><span>scheduler.c</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/src/scheduler.c#L289">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_base_t</span> level;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">to_thread</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">current_thread</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_cpu</span>    *<span class="title">pcpu</span>;</span></span><br><span class="line">    <span class="type">int</span> cpu_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 防止硬中端抢占此进程 */</span></span><br><span class="line">    level  = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    cpu_id = rt_hw_cpu_id();</span><br><span class="line">    pcpu   = rt_cpu_index(cpu_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到当前的线程</span></span><br><span class="line">    current_thread = pcpu-&gt;current_thread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_thread-&gt;scheduler_lock_nest == <span class="number">1</span>) <span class="comment">/* whether lock scheduler 确保调度器是唯一运行的 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">rt_ubase_t</span> highest_ready_priority;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rt_thread_ready_priority_group != <span class="number">0</span> || pcpu-&gt;priority_group != <span class="number">0</span>) <span class="comment">/* 有需要运行的 thread */</span></span><br><span class="line">        &#123;</span><br><span class="line">            to_thread = _get_highest_priority_thread(&amp;highest_ready_priority); <span class="comment">// 找到高优先级的 thread</span></span><br><span class="line">            current_thread-&gt;oncpu = RT_CPU_DETACHED;</span><br><span class="line">            <span class="keyword">if</span> ((current_thread-&gt;stat &amp; RT_THREAD_STAT_MASK) == RT_THREAD_RUNNING)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果当前线程的优先级比运行池还要高，还是运行当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (current_thread-&gt;current_priority &lt; highest_ready_priority)</span><br><span class="line">                &#123;</span><br><span class="line">                    to_thread = current_thread;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (current_thread-&gt;current_priority == highest_ready_priority &amp;&amp; (current_thread-&gt;stat &amp; RT_THREAD_STAT_YIELD_MASK) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    to_thread = current_thread;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;   <span class="comment">// 放弃运行就放入调度气中</span></span><br><span class="line">                    rt_schedule_insert_thread(current_thread);</span><br><span class="line">                &#125;</span><br><span class="line">                current_thread-&gt;stat &amp;= ~RT_THREAD_STAT_YIELD_MASK;</span><br><span class="line">            &#125;</span><br><span class="line">            to_thread-&gt;oncpu = cpu_id;</span><br><span class="line">            <span class="keyword">if</span> (to_thread != current_thread)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* if the destination thread is not the same as current thread */</span></span><br><span class="line">                pcpu-&gt;current_priority = (<span class="type">rt_uint8_t</span>)highest_ready_priority;</span><br><span class="line"></span><br><span class="line">                RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (current_thread, to_thread));</span><br><span class="line"></span><br><span class="line">                rt_schedule_remove_thread(to_thread); <span class="comment">// 从调度器中删除马上要运行的线程</span></span><br><span class="line">                to_thread-&gt;stat = RT_THREAD_RUNNING | (to_thread-&gt;stat &amp; ~RT_THREAD_STAT_MASK);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 切换线程即可 */</span></span><br><span class="line">                rt_hw_context_switch((<span class="type">rt_ubase_t</span>)&amp;current_thread-&gt;sp,</span><br><span class="line">                        (<span class="type">rt_ubase_t</span>)&amp;to_thread-&gt;sp, to_thread);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重新启动中端 */</span></span><br><span class="line">    rt_hw_interrupt_enable(level);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码分析，其实我们可以发现，<code>RT Thread</code> 如果包含高优先级的进程是不会给低优先级运行的机会的。我们修改代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int timeslice_sample(void)</span><br><span class="line">&#123;</span><br><span class="line">    rt_thread_t tid = RT_NULL;</span><br><span class="line">    tid = rt_thread_create(&quot;thread1&quot;,</span><br><span class="line">                            thread_entry, (void*)1,</span><br><span class="line">                            THREAD_STACK_SIZE,</span><br><span class="line">                            THREAD_PRIORITY - 1, THREAD_TIMESLICE);</span><br><span class="line">    if (tid != RT_NULL)</span><br><span class="line">        rt_thread_startup(tid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    tid = rt_thread_create(&quot;thread2&quot;,</span><br><span class="line">                            thread_entry, (void*)2,</span><br><span class="line">                            THREAD_STACK_SIZE,</span><br><span class="line">                            THREAD_PRIORITY, THREAD_TIMESLICE-5);</span><br><span class="line">    if (tid != RT_NULL)</span><br><span class="line">        rt_thread_startup(tid);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight bash"><figcaption><span>exeute</span></figcaption><table><tr><td class="code"><pre><span class="line">thread 1 is running ,thread 1 count = msh /&gt;140</span><br><span class="line">thread 1 is running ,thread 1 count = 145</span><br><span class="line">thread 1 is running ,thread 1 count = 150</span><br><span class="line">thread 1 is running ,thread 1 count = 155</span><br><span class="line">thread 1 is running ,thread 1 count = 160</span><br><span class="line">thread 1 is running ,thread 1 count = 165</span><br><span class="line">thread 1 is running ,thread 1 count = 170</span><br><span class="line">thread 1 is running ,thread 1 count = 175</span><br><span class="line">thread 1 is running ,thread 2 counthread 2t = 0</span><br><span class="line"></span><br><span class="line">thread 1 is run is running ,thread 1 count = 18ning ,thread 2 count = 5</span><br><span class="line"></span><br><span class="line">thread 1 is running thread 1 is running ,thread 1 count ,thread 1 count = = 190</span><br><span class="line">thread 191 thread is r2 is running ,threunnad 2 count = 10</span><br><span class="line">thread 1 is trunnhreadi 1 is running ,ng ,thread 1 count = 205thread 2 countthr = 20</span><br><span class="line">ead 2 is running ,thread 2 count = 20</span><br><span class="line">thread 2 is running ,thread 2 count = 25</span><br><span class="line">thread 2 is running ,thread 2 count = 30</span><br><span class="line">thread 2 is running ,thread 2 count = 35</span><br><span class="line">thread 2 is running ,thread 2 count = 40</span><br><span class="line">thread 2 is running ,thread 2 count = 45</span><br><span class="line">thread 2 is running ,thread 2 count = 50</span><br></pre></td></tr></table></figure>
<p>我们可以发现 <code>thread 1</code> 执行完成之后才会有 <code>thread 2</code> 进行执行。至于 <code>rt_hw_context_switch</code> 就是将线程状态恢复到 <code>寄存器</code> 中</p>
<h3 id="线程调度触发"><a class="header-anchor" href="#线程调度触发">¶</a>线程调度触发</h3>
<p>什么时候会触发 <code>rt_schedule</code> 进行调度呢？这个事情其实绝大多数的系统都分为两类</p>
<ul>
<li>主动型：调用 rt_schedule() | rt_thread_yield()，都属于线程将自己的执行放弃了</li>
<li>被动型：当我们的线程不满足条件的时候，比如获得锁失败等等</li>
</ul>
<h2 id="线程间同步"><a class="header-anchor" href="#线程间同步">¶</a>线程间同步</h2>
<p>对于OS来说，一般有 信号量（semaphore）、互斥量（mutex），RT 还提供了  <code>Event</code> 这个模式</p>
<h3 id="信号量"><a class="header-anchor" href="#信号量">¶</a>信号量</h3>
<p>信号量的定义非常的简单</p>
<figure class="highlight c"><figcaption><span>rt_semaphore</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/include/rtdef.h#L683">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span>                       <span class="comment">/* 继承自 ipc_object 类 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">rt_uint16_t</span>          value;                         <span class="comment">/* 信号量的值 */</span></span><br><span class="line">    <span class="type">rt_uint16_t</span>          reserved;                      <span class="comment">/* 保留 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由 <code>IPC</code> 容器所管理，信号量的最大值是 <code>65535</code></p>
<h4 id="How-it-works"><a class="header-anchor" href="#How-it-works">¶</a>How it works</h4>
<p>说起来信号量本来也只是一个普通变量，因此就是分配在内核中的一个变量，在 rt_sem_create 中</p>
<figure class="highlight c"><figcaption><span>ipc.c</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/src/ipc.c#L294">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">rt_sem_t</span> <span class="title function_">rt_sem_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">rt_uint32_t</span> value, <span class="type">rt_uint8_t</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_sem_t</span> sem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配对象 */</span></span><br><span class="line">    sem = (<span class="type">rt_sem_t</span>)rt_object_allocate(RT_Object_Class_Semaphore, name);</span><br><span class="line">    <span class="keyword">if</span> (sem == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> sem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化，其实就是 hook 到 内核 */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(sem-&gt;parent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始值 */</span></span><br><span class="line">    sem-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set parent */</span></span><br><span class="line">    sem-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们创建了 信号量 之后，就可以通过 <code>rt_sem_take()</code> 和 <code>rt_sem_trytake()</code> 进行操作，我们一窥究竟</p>
<figure class="highlight c"><figcaption><span>ipc.c</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/src/ipc.c#L357">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_sem_take</span><span class="params">(<span class="type">rt_sem_t</span> sem, <span class="type">rt_int32_t</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">rt_base_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭中断防止出错 */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 value 还是大于 0 的时候就运行进入</span></span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 减少 1 即可 */</span> </span><br><span class="line">        sem-&gt;value --;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 重开中断 */</span></span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果 time == 0，就立马返回 */</span></span><br><span class="line">        <span class="keyword">if</span> (time == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> -RT_ETIMEOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获得当前线程</span></span><br><span class="line">            thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 设置下错误码 */</span></span><br><span class="line">            thread-&gt;error = RT_EOK;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 暂停这个线程，因此获取不到信号量 */</span></span><br><span class="line">            rt_ipc_list_suspend(&amp;(sem-&gt;parent.suspend_thread),</span><br><span class="line">                                thread,</span><br><span class="line">                                sem-&gt;parent.parent.flag);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 这里我们设定一个回调 */</span></span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 这里在特定时间后将其唤醒</span></span><br><span class="line">                rt_timer_control(&amp;(thread-&gt;thread_timer),</span><br><span class="line">                                 RT_TIMER_CTRL_SET_TIME,</span><br><span class="line">                                 &amp;time);</span><br><span class="line">                rt_timer_start(&amp;(thread-&gt;thread_timer));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* enable interrupt */</span></span><br><span class="line">            rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 进行调度，因为这里就是资源不足 */</span></span><br><span class="line">            rt_schedule();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (thread-&gt;error != RT_EOK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> thread-&gt;error;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>定时器</code>的部分，我们在后续再讨论。</p>
<h3 id="互斥量"><a class="header-anchor" href="#互斥量">¶</a>互斥量</h3>
<p>互斥量相较于信号量来说，互斥量支持递归访问且能防止线程<a href="https://docs.rt-thread.org/#/rt-thread-version/rt-thread-standard/programming-manual/ipc1/ipc1?id=%e4%ba%92%e6%96%a5%e9%87%8f%e5%b7%a5%e4%bd%9c%e6%9c%ba%e5%88%b6">优先级翻转</a>；并且互斥量只能由持有线程释放，而信号量则可以由任何线程释放。</p>
<figure class="highlight c"><figcaption><span>rtdef.h</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/include/rtdef.h#L697">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span>                        <span class="comment">/**&lt; inherit from ipc_object */</span></span><br><span class="line">    <span class="type">rt_uint16_t</span>          value;                         <span class="comment">/**&lt; value of mutex */</span></span><br><span class="line">    <span class="type">rt_uint8_t</span>           original_priority;             <span class="comment">/**&lt; priority of last thread hold the mutex */</span></span><br><span class="line">    <span class="type">rt_uint8_t</span>           hold;                          <span class="comment">/**&lt; numbers of thread hold the mutex */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span>    *<span class="title">owner</span>;</span>                         <span class="comment">/**&lt; current owner of mutex */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="How-it-works-v2"><a class="header-anchor" href="#How-it-works-v2">¶</a>How it works</h4>
<p>我们创建 <code>mutex</code> 如下</p>
<figure class="highlight c"><figcaption><span>ipc.c</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/src/ipc.c#L633">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">rt_mutex_t</span> <span class="title function_">rt_mutex_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">rt_uint8_t</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> *<span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在内核中分配对象 */</span></span><br><span class="line">    mutex = (<span class="type">rt_mutex_t</span>)rt_object_allocate(RT_Object_Class_Mutex, name);</span><br><span class="line">    <span class="keyword">if</span> (mutex == RT_NULL)</span><br><span class="line">        <span class="keyword">return</span> mutex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 */</span></span><br><span class="line">    rt_ipc_object_init(&amp;(mutex-&gt;parent));</span><br><span class="line"></span><br><span class="line">    mutex-&gt;value              = <span class="number">1</span>;</span><br><span class="line">    mutex-&gt;owner              = RT_NULL;</span><br><span class="line">    mutex-&gt;original_priority  = <span class="number">0xFF</span>;</span><br><span class="line">    mutex-&gt;hold               = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set flag */</span></span><br><span class="line">    mutex-&gt;parent.parent.flag = flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们去 <code>rt_mutex_take</code> 获得一个 <code>mutex</code> 时候</p>
<figure class="highlight c"><figcaption><span>ipc.c</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/src/ipc.c#L697">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mutex_take</span><span class="params">(<span class="type">rt_mutex_t</span> mutex, <span class="type">rt_int32_t</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">rt_base_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    thread-&gt;error = RT_EOK;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果mutex的获得者是自己，那就快速通过</span></span><br><span class="line">    <span class="keyword">if</span> (mutex-&gt;owner == thread)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 如果是 mutex &gt; 0，那就让此线程获得，Fast Path</span></span><br><span class="line">        <span class="keyword">if</span> (mutex-&gt;value &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* mutex is available */</span></span><br><span class="line">            mutex-&gt;value --;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* set mutex owner and original priority */</span></span><br><span class="line">            mutex-&gt;owner             = thread;</span><br><span class="line">            mutex-&gt;original_priority = thread-&gt;current_priority;</span><br><span class="line">            <span class="keyword">if</span>(mutex-&gt;hold &lt; RT_MUTEX_HOLD_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                mutex-&gt;hold ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                rt_hw_interrupt_enable(temp); <span class="comment">/* enable interrupt */</span></span><br><span class="line">                <span class="keyword">return</span> -RT_EFULL; <span class="comment">/* value overflowed */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 其他是无法获得，当 time == 0 就快速失败了 */</span></span><br><span class="line">            <span class="keyword">if</span> (time == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* set error as timeout */</span></span><br><span class="line">                thread-&gt;error = -RT_ETIMEOUT;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* enable interrupt */</span></span><br><span class="line">                rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> -RT_ETIMEOUT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 如果获取这个 thread 的优先级高 &gt; 已经获得锁的进程 */</span></span><br><span class="line">                <span class="keyword">if</span> (thread-&gt;current_priority &lt; mutex-&gt;owner-&gt;current_priority)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 修改这个锁Owner的优先级 */</span></span><br><span class="line">                    rt_thread_control(mutex-&gt;owner,</span><br><span class="line">                                      RT_THREAD_CTRL_CHANGE_PRIORITY,</span><br><span class="line">                                      &amp;thread-&gt;current_priority);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 暂停一下这个线程，下面准备重新调度 */</span></span><br><span class="line">                rt_ipc_list_suspend(&amp;(mutex-&gt;parent.suspend_thread),</span><br><span class="line">                                    thread,</span><br><span class="line">                                    mutex-&gt;parent.parent.flag);</span><br><span class="line"></span><br><span class="line">                rt_hw_interrupt_enable(temp);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 再调度 */</span></span><br><span class="line">                rt_schedule();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210325184809.png" alt=""></p>
<blockquote>
<p>RT-Thread 操作系统中，互斥量可以解决优先级翻转问题，实现的是优先级继承算法。优先级继承是通过在线程 A 尝试获取共享资源而被挂起的期间内，将线程 C 的优先级提升到线程 A 的优先级别，从而解决优先级翻转引起的问题。这样能够防止 C（间接地防止 A）被 B 抢占，如下图所示。优先级继承是指，提高某个占有某种资源的低优先级线程的优先级，使之与所有等待该资源的线程中优先级最高的那个线程的优先级相等，然后执行，而当这个低优先级线程释放该资源时，优先级重新回到初始设定。因此，继承优先级的线程避免了系统资源被任何中间优先级的线程抢占。</p>
</blockquote>
<p>不过值得注意的，并不是将 <code>C</code> 直接放弃执行，给 <code>A</code> 执行，而是将 <code>C</code> 提升到 <code>A</code> 的优先级，从而保证在 <code>C</code> 释放锁之后，第一个执行的就是 <code>A</code>，而不是 <code>B</code></p>
<h2 id="线程间通讯"><a class="header-anchor" href="#线程间通讯">¶</a>线程间通讯</h2>
<p>我们完成了线程之间的锁，之后，我们可以进行线程间的通讯。<code>RT</code> 提供了一种 <code>mailbox</code> 机制</p>
<h3 id="Mailbox"><a class="header-anchor" href="#Mailbox">¶</a>Mailbox</h3>
<figure class="highlight c"><figcaption><span>rtdef.h</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/include/rtdef.h#L735">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mailbox</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">rt_uint32_t</span>* msg_pool;                <span class="comment">/* 邮箱缓冲区的开始地址 */</span></span><br><span class="line">    <span class="type">rt_uint16_t</span> size;                     <span class="comment">/* 邮箱缓冲区的大小     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">rt_uint16_t</span> entry;                    <span class="comment">/* 邮箱中邮件的数目     */</span></span><br><span class="line">    <span class="type">rt_uint16_t</span> in_offset, out_offset;    <span class="comment">/* 邮箱缓冲的进出指针   */</span></span><br><span class="line">    <span class="type">rt_list_t</span> suspend_sender_thread;      <span class="comment">/* 发送线程的挂起等待队列 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_mailbox</span>* <span class="title">rt_mailbox_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>当我们需要发送消息的时候，就可以 <code>rt_mb_send_wait()</code> 与 <code>rt_mb_send()</code></p>
<figure class="highlight c"><figcaption><span>ipc.c</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/src/ipc.c#L1554">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_send_wait</span><span class="params">(<span class="type">rt_mailbox_t</span> mb, <span class="type">rt_ubase_t</span> value, <span class="type">rt_int32_t</span> timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="type">rt_ubase_t</span> temp;</span><br><span class="line">    <span class="type">rt_uint32_t</span> tick_delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize delta tick */</span></span><br><span class="line">    tick_delta = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* get current thread */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果满了 &amp; timeout 之后退出 */</span></span><br><span class="line">    <span class="keyword">if</span> (mb-&gt;entry == mb-&gt;size &amp;&amp; timeout == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_hw_interrupt_enable(temp);</span><br><span class="line">        <span class="keyword">return</span> -RT_EFULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 邮箱满了 */</span></span><br><span class="line">    <span class="keyword">while</span> (mb-&gt;entry == mb-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在事件没有 Timeout 的时候，我们就睡一下，等下次再重试</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将消息放入即可 */</span></span><br><span class="line">    mb-&gt;msg_pool[mb-&gt;in_offset] = value;</span><br><span class="line">    <span class="comment">/* increase input offset */</span></span><br><span class="line">    ++ mb-&gt;in_offset;</span><br><span class="line">    <span class="keyword">if</span> (mb-&gt;in_offset &gt;= mb-&gt;size)</span><br><span class="line">        mb-&gt;in_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mb-&gt;entry &lt; RT_MB_ENTRY_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* increase message entry */</span></span><br><span class="line">        mb-&gt;entry ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        rt_hw_interrupt_enable(temp); <span class="comment">/* enable interrupt */</span></span><br><span class="line">        <span class="keyword">return</span> -RT_EFULL; <span class="comment">/* value overflowed */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号"><a class="header-anchor" href="#信号">¶</a>信号</h3>
<p>信号其实也就是软中断，在原理上，一个线程收到一个信号与处理器收到一个中断请求可以说是类似的。</p>
<figure class="highlight c"><figcaption><span>example</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 线程 1 的信号处理函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1_signal_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;thread1 received signal %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程 1 的入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 安装信号 */</span></span><br><span class="line">    rt_signal_install(SIGUSR1, thread1_signal_handler);</span><br><span class="line">    rt_signal_unmask(SIGUSR1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 运行 10 次 */</span></span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 线程 1 采用低优先级运行，一直打印计数值 */</span></span><br><span class="line">        rt_kprintf(<span class="string">&quot;thread1 count : %d\n&quot;</span>, cnt);</span><br><span class="line"></span><br><span class="line">        cnt++;</span><br><span class="line">        rt_thread_mdelay(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号示例的初始化 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">signal_sample</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建线程 1 */</span></span><br><span class="line">    tid1 = rt_thread_create(<span class="string">&quot;thread1&quot;</span>,</span><br><span class="line">                            thread1_entry, RT_NULL,</span><br><span class="line">                            THREAD_STACK_SIZE,</span><br><span class="line">                            THREAD_PRIORITY, THREAD_TIMESLICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tid1 != RT_NULL)</span><br><span class="line">        rt_thread_startup(tid1);</span><br><span class="line"></span><br><span class="line">    rt_thread_mdelay(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送信号 SIGUSR1 给线程 1 */</span></span><br><span class="line">    rt_thread_kill(tid1, SIGUSR1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号就是注册了一个回调函数在线程上，我们可以直接对着线程发送指令。</p>
<h2 id="定时器"><a class="header-anchor" href="#定时器">¶</a>定时器</h2>
<p>我们从上面一看到了绝大多数的时候，都会非常依赖于 <code>Timer</code> 的功能。而 <code>Timer</code> 本身也是有硬件和软件两种模式，<code>RT</code> 提供的是软时钟的模式。<br>
软件的定时器也提供了 <code>HARD_TIMER</code> <code>SOFT_TIMER</code> 两种模式，区别在于 <code>HARD_TIMER</code> 以中断的行为触发， <code>SOFT_TIMER</code> 是一个独立线程进行调度。</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210326093513.png" alt=""></p>
<p>默认的 <code>HARD_TIMER</code> 模式下，将定时任务按照一个 <code>Link List</code> 储存起来，当节拍器触发到相对应的时候，就可以运行这个任务了。回忆一下，我们最初的 <code>Clock</code> 章节</p>
<figure class="highlight c"><figcaption><span>clock.c</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/src/clock.c">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_tick_increase</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* check timer */</span></span><br><span class="line">    rt_timer_check();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步就我们的 <code>Timer</code> 检查。</p>
<figure class="highlight c"><figcaption><span>timer.c</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/src/timer.c#L529">link</a></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rt_timer_check</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    current_tick = rt_tick_get();</span><br><span class="line">    <span class="comment">// 如果 timer 的列表为空就没有任务，快速结束了</span></span><br><span class="line">    <span class="keyword">while</span> (!rt_list_isempty(&amp;rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - <span class="number">1</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        t = rt_list_entry(rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - <span class="number">1</span>].next,</span><br><span class="line">                          <span class="keyword">struct</span> rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里因为 current_tick 和 timeout_tick 都无符号数，记得要溢出运算，这里的逻辑也就是 &lt; 0</span></span><br><span class="line">        <span class="keyword">if</span> ((current_tick - t-&gt;timeout_tick) &lt; RT_TICK_MAX / <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* add timer to temporary list  */</span></span><br><span class="line">            rt_list_insert_after(&amp;<span class="built_in">list</span>, &amp;(t-&gt;row[RT_TIMER_SKIP_LIST_LEVEL - <span class="number">1</span>]));</span><br><span class="line">            <span class="comment">/* call timeout function */</span></span><br><span class="line">            t-&gt;timeout_func(t-&gt;parameter);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* re-get tick */</span></span><br><span class="line">            current_tick = rt_tick_get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>到这里整个系统雏形已经完成，我们分析了整个内核的工作，下面我们去看看比较无聊但是很重要的 IO 设备。</p>
<h2 id="网络驱动"><a class="header-anchor" href="#网络驱动">¶</a>网络驱动</h2>
<h3 id="网卡概念"><a class="header-anchor" href="#网卡概念">¶</a>网卡概念</h3>
<p>RT-Thread 系统中目前支持三种协议栈类型： lwIP 协议栈、AT Socket 协议栈、WIZnet TCP/IP硬件协议栈。每种协议栈对应一种协议簇类型（family），上述协议栈分别对应的协议簇类型为：AF_INET、AF_AT、AF_WIZ。</p>
<h3 id="Net-设备"><a class="header-anchor" href="#Net-设备">¶</a>Net 设备</h3>
<p>以网络设备为例，有如下定义</p>
<figure class="highlight c"><figcaption><span>netdev.h</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/components/net/netdev/include/netdev.h">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 网卡结构体对象 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netdev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">rt_slist_t</span> <span class="built_in">list</span>;                                   <span class="comment">/* 网卡列表 */</span></span><br><span class="line">    <span class="type">char</span> name[RT_NAME_MAX];                            <span class="comment">/* 网卡名称 */</span></span><br><span class="line">    <span class="type">ip_addr_t</span> ip_addr;                                 <span class="comment">/* IP 地址 */</span></span><br><span class="line">    <span class="type">ip_addr_t</span> netmask;                                 <span class="comment">/* 子网掩码地址 */</span></span><br><span class="line">    <span class="type">ip_addr_t</span> gw;                                      <span class="comment">/* 网关地址 */</span></span><br><span class="line">    <span class="type">ip_addr_t</span> dns_servers[NETDEV_DNS_SERVERS_NUM];     <span class="comment">/* DNS 服务器地址 */</span></span><br><span class="line">    <span class="type">uint8_t</span> hwaddr_len;                                <span class="comment">/* 硬件地址长度 */</span></span><br><span class="line">    <span class="type">uint8_t</span> hwaddr[NETDEV_HWADDR_MAX_LEN];             <span class="comment">/* 硬件地址 */</span></span><br><span class="line">    <span class="type">uint16_t</span> flags;                                    <span class="comment">/* 网卡状态位 */</span></span><br><span class="line">    <span class="type">uint16_t</span> mtu;                                      <span class="comment">/* 网卡最大传输单元 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">netdev_ops</span> *<span class="title">ops</span>;</span>                      <span class="comment">/* 网卡操作回调函数 */</span></span><br><span class="line">    netdev_callback_fn status_callback;                <span class="comment">/* 网卡状态改变回调 */</span></span><br><span class="line">    netdev_callback_fn addr_callback;                  <span class="comment">/* 网卡地址改变回调 */</span></span><br><span class="line">    <span class="type">void</span> *user_data;                                   <span class="comment">/* 预留用户数据 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在系统启动完成之后，会调用 <code>netdev_register</code> 进行系统的注册，而在这个函数中，会调动 <code>device_init</code> 进行设备注册。设备注册部分的逻辑在 <code>ethernetif.c</code> 中，相对固定不做展开，我们来看看数据的读写</p>
<h3 id="网络读写"><a class="header-anchor" href="#网络读写">¶</a>网络读写</h3>
<p>对于 <code>RT</code> 也提供了一个 <code>Socket</code> 抽象叫 <code>SAL</code></p>
<figure class="highlight c"><figcaption><span>sal_socket.c</span><a href="https://github.com/RT-Thread/rt-thread/blob/master/components/net/sal_socket/src/sal_socket.c">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sal_socket</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> magic;                    <span class="comment">/* SAL socket magic word */</span></span><br><span class="line">    <span class="type">int</span> socket;                        <span class="comment">/* SAL socket descriptor */</span></span><br><span class="line">    <span class="type">int</span> domain;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">int</span> protocol;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netdev</span> *<span class="title">netdev</span>;</span>             <span class="comment">/* SAL network interface device */</span></span><br><span class="line">    <span class="type">void</span> *user_data;                   <span class="comment">/* user-specific data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以发现，比较核心的就是 <code>socket</code> 会对应着一个 <code>protocol</code> <code>type</code> <code>netdev</code> 这样我们就知道我们的数据从什么网卡出去和进来了。</p>
<p>对于数据的读取如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sal_recvfrom</span><span class="params">(<span class="type">int</span> socket, <span class="type">void</span> *mem, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *from, <span class="type">socklen_t</span> *fromlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sal_socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sal_proto_family</span> *<span class="title">pf</span>;</span></span><br><span class="line">    <span class="keyword">return</span> pf-&gt;skt_ops-&gt;recvfrom((<span class="type">int</span>) sock-&gt;user_data, mem, len, flags, from, fromlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 <code>pf</code> 协议的不同，我们用不同的方式读取。我们从参数中就可以发现读取的核心处理对象，从 <code>mem</code> 将数据拷贝到 <code>user_data</code>。一顿搜索一下，我们就自然找到了这个。</p>
<figure class="highlight c"><figcaption><span>socket.c</span><a href="https://github.com/RT-Thread/rt-thread/blob/13044b1e290a3aef4e57c3d443da1c571d33789d/components/net/lwip-2.0.2/src/api/sockets.c#L765">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">lwip_recvfrom</span><span class="params">(<span class="type">int</span> s, <span class="type">void</span> *mem, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> sockaddr *from, <span class="type">socklen_t</span> *fromlen)</span></span><br><span class="line">&#123; </span><br><span class="line">  sock = get_socket(s); <span class="comment">// 这里是 lwip_sock</span></span><br><span class="line">  <span class="keyword">if</span> (!sock) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (NETCONNTYPE_GROUP(netconn_type(sock-&gt;conn)) == NETCONN_TCP) &#123;</span><br><span class="line">    err = netconn_recv_tcp_pbuf(sock-&gt;conn, (<span class="keyword">struct</span> pbuf **)&amp;buf);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    err = netconn_recv(sock-&gt;conn, (<span class="keyword">struct</span> netbuf **)&amp;buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以读取的过程是 <code>netconn_recv_tcp_pbuf</code> 进行操作的，对于 <code>LWIP</code> 的逻辑，我们后续再讨论，我们来细讨论下，网卡的数据和内核之间的交流。</p>
<h3 id="网卡驱动"><a class="header-anchor" href="#网卡驱动">¶</a>网卡驱动</h3>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/20210326154641.png" alt=""></p>
<p>现在的网卡普遍已经不再使用 <code>中断</code> 来通知操作系统来获得数据了，因为中断频繁发生是很浪费上下文切换的。因此都是 <code>NAPI</code> 模式，也就是网卡自己处理数据从 TX/RX 中，不过在 <code>RT</code> 中还是使用 <code>中断</code> 来处理了。<br>
比如在网卡读取数据时</p>
<figure class="highlight c"><figcaption><span>drv_smc911x.c</span><a href="https://github.com/RT-Thread/rt-thread/blob/13044b1e29/bsp/qemu-vexpress-a9/drivers/drv_smc911x.c">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> pbuf *<span class="title function_">smc911x_emac_rx</span><span class="params">(<span class="type">rt_device_t</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span>* <span class="title">p</span> =</span> RT_NULL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eth_device_smc911x</span> *<span class="title">emac</span>;</span></span><br><span class="line"></span><br><span class="line">    emac = SMC911X_EMAC_DEVICE(dev);</span><br><span class="line">    RT_ASSERT(emac != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((smc911x_reg_read(emac, RX_FIFO_INF) &amp; RX_FIFO_INF_RXSUSED) &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> status;</span><br><span class="line">        <span class="type">uint32_t</span> pktlen, tmplen;</span><br><span class="line"></span><br><span class="line">        status = smc911x_reg_read(emac, RX_STATUS_FIFO); <span class="comment">// 读取 FIFO 队列的状态</span></span><br><span class="line">        <span class="comment">/* get frame length */</span></span><br><span class="line">        pktlen = (status &amp; RX_STS_PKT_LEN) &gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        smc911x_reg_write(emac, RX_CFG, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        tmplen = (pktlen + <span class="number">3</span>) / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* allocate pbuf */</span></span><br><span class="line">        p = pbuf_alloc(PBUF_RAW, tmplen * <span class="number">4</span>, PBUF_RAM);</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">uint32_t</span> *data = (<span class="type">uint32_t</span> *)p-&gt;payload;</span><br><span class="line">            <span class="keyword">while</span> (tmplen--)</span><br><span class="line">            &#123;</span><br><span class="line">                *data++ = smc911x_reg_read(emac, RX_DATA_FIFO);  <span class="comment">// 网卡的缓冲区获得数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>init</code> 时候</p>
<figure class="highlight c"><figcaption><span>smc911x_emac_init</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">rt_err_t</span> <span class="title function_">smc911x_emac_init</span><span class="params">(<span class="type">rt_device_t</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">/* Turn on Tx + Rx */</span></span><br><span class="line">    smc911x_enable(emac);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Interrupt on every received packet */</span></span><br><span class="line">    smc911x_reg_write(emac, FIFO_INT, <span class="number">0x01</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    smc911x_reg_write(emac, INT_EN, INT_EN_RDFL_EN | INT_EN_RSFL_EN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt */</span></span><br><span class="line">    smc911x_reg_write(emac, INT_CFG, INT_CFG_IRQ_EN | INT_CFG_IRQ_POL | INT_CFG_IRQ_TYPE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们将 IRQ 注册了中断</span></span><br><span class="line">    rt_hw_interrupt_install(emac-&gt;irqno, smc911x_isr, emac, <span class="string">&quot;smc911x&quot;</span>);</span><br><span class="line">    rt_hw_interrupt_umask(emac-&gt;irqno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>os</category>
        <category>rt-thread</category>
      </categories>
      <tags>
        <tag>os</tag>
        <tag>rt-thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Ambient Mesh Works</title>
    <url>/2022/09/08/networking/istio/ambient-mesh/ambient-mesh/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2022/202209131754322.png" alt=""></p>
<p>在最新的一次发布中，<code>Istio</code> 带来一个超级重磅的消息，带来了无 <code>Sidecar</code> 的版本 <a href="https://istio.io/latest/blog/2022/get-started-ambient/"><code>Ambient Mesh</code></a></p>
<span id="more"></span>
<h2 id="Intro"><a class="header-anchor" href="#Intro">¶</a>Intro</h2>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2022/202209131758697.png" alt=""></p>
<p>在官方的文档中，我们可以发现这次我们取消了 <code>App</code> 同样 <code>POD</code> 的 <code>Sidecar</code> 转而将转发的逻辑下沉到 2个全新的组件上</p>
<ul>
<li><code>ztunnel</code> 一个处理 L4 请求的 <code>Node</code> 级别的组件</li>
<li><code>waypoint</code> 一个处理 L7 请求的 <code>Namespace</code> 级别的组件</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2022/202209131758097.png" alt=""></p>
<p>可以理解成当前的 gateway 有四种角色</p>
<ul>
<li>ingressGateway: 消费 Gateway CR</li>
<li>eastwestGateway: 消费 VS/DR 但是仅仅为跨集群通讯服务</li>
<li>Ztunnel: Node 级别的 Gateway 进行 mtls+tcp 流量传播</li>
<li>Waypoint: Namespace 级别的 Gateway 进行 L7  流量治理。</li>
</ul>
<h3 id="Ztunnel"><a class="header-anchor" href="#Ztunnel">¶</a>Ztunnel</h3>
<p>对于 <code>Ztunnel</code> 的实现，官方描述的比较少，不过在社区的体验分支中有这么一些说明</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">* ambient-mesh: uproxy l4 implementation with Envoy</span><br></pre></td></tr></table></figure>
<p>显然 <code>L4</code> 还是基于 <code>Envoy</code>，具体的逻辑在 <a href="https://github.com/istio/proxy/compare/master...experimental-ambient"><code>istio proxy: experimental-ambient</code></a></p>
<p>按照架构图的思路，我们很好去理解，<code>Ztunnel</code> 需要做两件事情，分别是转发 L4 请求和判断权限(含mtls)因此，在 <code>istio</code> 中包含了全新的生成器来协助新组件完成工作。</p>
<ul>
<li>UProxyConfigGenerator： 负责生成转发的逻辑</li>
<li>PEPGenerator: 负责生成安全策略</li>
</ul>
<p>后来做了二合一</p>
<ul>
<li>ZTunnelConfigGenerator: 负责所有策略</li>
</ul>
<figure class="highlight go"><figcaption><span>ztunnelgen.go</span><a href="https://github.com/istio/istio/blob/ccca32c20b5247ae85ea606e91792bce272b2144/pilot/pkg/networking/ambientgen/ztunnelgen.go#L107-L123">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *ZTunnelConfigGenerator)</span></span> Generate(</span><br><span class="line">	proxy *model.Proxy,</span><br><span class="line">	w *model.WatchedResource,</span><br><span class="line">	req *model.PushRequest,</span><br><span class="line">) (model.Resources, model.XdsLogDetails, <span class="type">error</span>) &#123;</span><br><span class="line">	push := req.Push</span><br><span class="line">	<span class="keyword">switch</span> w.TypeUrl &#123;</span><br><span class="line">	<span class="keyword">case</span> v3.ListenerType:</span><br><span class="line">		<span class="keyword">return</span> g.BuildListeners(proxy, push, w.ResourceNames), model.DefaultXdsLogDetails, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> v3.ClusterType:</span><br><span class="line">		<span class="keyword">return</span> g.BuildClusters(proxy, push, w.ResourceNames), model.DefaultXdsLogDetails, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> v3.EndpointType:</span><br><span class="line">		<span class="keyword">return</span> g.BuildEndpoints(proxy, push, w.ResourceNames), model.DefaultXdsLogDetails, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, model.DefaultXdsLogDetails, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里再配合原先生成 Cluster 的逻辑等等，我们就把整个流程给串联起来。</p>
<h3 id="Waypoint"><a class="header-anchor" href="#Waypoint">¶</a>Waypoint</h3>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2022/202209131759402.png" alt=""></p>
<p><code>Waypoint</code> 显然是处理 <code>L7</code> 逻辑的。</p>
<blockquote>
<p>Ambient mesh uses HTTP CONNECT over mTLS to implement its secure tunnels and insert waypoint proxies in the path, a pattern we call HBONE (HTTP-Based Overlay Network Environment). HBONE provides for a cleaner encapsulation of traffic than TLS on its own while enabling interoperability with common load-balancer infrastructure. FIPS builds are used by default to meet compliance needs. More details on HBONE, its standards-based approach, and plans for UDP and other non-TCP protocols will be provided in a future blog.</p>
</blockquote>
<p>而对于 <code>Waypoint</code> 的创建，因为是一个 <code>Namespace</code> 的组件。有一个 <code>Watch NS</code> 的 <code>Controller</code> 来完成这个事情。</p>
<figure class="highlight go"><figcaption><span>waypoint_controller.go</span><a href="https://github.com/istio/istio/blob/ccca32c20b5247ae85ea606e91792bce272b2144/pilot/pkg/ambient/controller/waypoint_controller.go#L125-L234">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rc *WaypointProxyController)</span></span> Reconcile(name types.NamespacedName) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> rc.injectConfig().Values.Struct().GetGlobal().GetHub() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// Mostly used to avoid issues with local runs</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;injection config invalid, skipping reconile&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	log := waypointLog.WithLabels(<span class="string">&quot;gateway&quot;</span>, name.String())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询所有的 waypoint</span></span><br><span class="line">	gw, err := rc.gateways.Gateways(name.Namespace).Get(name.Name)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找有的，和需要有的</span></span><br><span class="line">	haveProxies := sets.New()</span><br><span class="line">	wantProxies := sets.New()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去创建 waypoint</span></span><br><span class="line">	<span class="keyword">for</span> _, k := <span class="keyword">range</span> add &#123;</span><br><span class="line">		log.Infof(<span class="string">&quot;adding waypoint proxy %v&quot;</span>, k+<span class="string">&quot;-waypoint-proxy&quot;</span>)</span><br><span class="line">		input := MergedInput&#123;</span><br><span class="line">			Namespace:      gw.Namespace,</span><br><span class="line">			GatewayName:    gw.Name,</span><br><span class="line">			UID:            <span class="type">string</span>(gw.UID),</span><br><span class="line">			ServiceAccount: k,</span><br><span class="line">			Cluster:        rc.cluster.String(),</span><br><span class="line">		&#125;</span><br><span class="line">		proxyDeploy, err := rc.RenderDeploymentMerged(input)</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Waypoint</code> 还是一个 <code>Envoy</code> 实例，对其的配置项和 <code>Ztunnel</code> 一致。</p>
<figure class="highlight go"><figcaption><span>waypointgen.go  github</span><a href="https://github.com/istio/istio/blob/ccca32c20b5247ae85ea606e91792bce272b2144/pilot/pkg/networking/ambientgen/waypointgen.go#L67-L87">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *WaypointGenerator)</span></span> Generate(proxy *model.Proxy, w *model.WatchedResource, req *model.PushRequest) (model.Resources, model.XdsLogDetails, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> out model.Resources</span><br><span class="line">	<span class="keyword">switch</span> w.TypeUrl &#123;</span><br><span class="line">	<span class="keyword">case</span> v3.ListenerType:</span><br><span class="line">		sidecarListeners := p.ConfigGenerator.BuildListeners(proxy, req.Push)</span><br><span class="line">		resources := model.Resources&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> sidecarListeners &#123;</span><br><span class="line">			resources = <span class="built_in">append</span>(resources, &amp;discovery.Resource&#123;</span><br><span class="line">				Name:     c.Name,</span><br><span class="line">				Resource: protoconv.MessageToAny(c),</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		out = <span class="built_in">append</span>(p.buildWaypointListeners(proxy, req.Push), resources...)</span><br><span class="line">		out = <span class="built_in">append</span>(out, outboundTunnelListener(<span class="string">&quot;tunnel&quot;</span>, proxy.Metadata.ServiceAccount))</span><br><span class="line">	<span class="keyword">case</span> v3.ClusterType:</span><br><span class="line">		sidecarClusters, _ := p.ConfigGenerator.BuildClusters(proxy, req)</span><br><span class="line">		waypointClusters := p.buildClusters(proxy, req.Push)</span><br><span class="line">		out = <span class="built_in">append</span>(waypointClusters, sidecarClusters...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out, model.DefaultXdsLogDetails, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>Ztuunel</code> 访问 <code>Waypoint</code> 通过一个 <code>Proxy</code> 组件，这个就比较简单了</p>
<figure class="highlight go"><figcaption><span>server.go</span><a href="https://github.com/istio/istio/blob/ccca32c20b5247ae85ea606e91792bce272b2144/pkg/hbone/server.go#L53-L83">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnect</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	t0 := time.Now()</span><br><span class="line">	log.WithLabels(<span class="string">&quot;host&quot;</span>, r.Host, <span class="string">&quot;source&quot;</span>, r.RemoteAddr).Info(<span class="string">&quot;Received CONNECT&quot;</span>)</span><br><span class="line">	<span class="comment">// Send headers back immediately so we can start getting the body</span></span><br><span class="line">	w.(http.Flusher).Flush()</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	dst, err := (&amp;net.Dialer&#123;&#125;).DialContext(ctx, <span class="string">&quot;tcp&quot;</span>, r.Host)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusServiceUnavailable)</span><br><span class="line">		log.Errorf(<span class="string">&quot;failed to dial upstream: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	log.Infof(<span class="string">&quot;Connected to %v&quot;</span>, r.Host)</span><br><span class="line">	w.WriteHeader(http.StatusOK)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// downstream (hbone client) &lt;-- upstream (app)</span></span><br><span class="line">		copyBuffered(w, dst, log.WithLabels(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;dst to w&quot;</span>))</span><br><span class="line">		r.Body.Close()</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// downstream (hbone client) --&gt; upstream (app)</span></span><br><span class="line">	copyBuffered(dst, r.Body, log.WithLabels(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;body to dst&quot;</span>))</span><br><span class="line">	wg.Wait()</span><br><span class="line">	log.Infof(<span class="string">&quot;connection closed in %v&quot;</span>, time.Since(t0))</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链路分析-黑盒版"><a class="header-anchor" href="#链路分析-黑盒版">¶</a>链路分析 [黑盒版]</h2>
<p>我们先按照社区的文档，使用 <code>kind</code> 准备下我们的环境，最终形态如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ k get pod -owide</span><br><span class="line">NAME                                                   READY   STATUS    RESTARTS   AGE    IP           NODE              NOMINATED NODE   READINESS GATES</span><br><span class="line">bookinfo-productpage-waypoint-proxy-5c9c4d858b-bcmx5   1/1     Running   0          116m   10.244.1.9   ambient-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">details-v1-5ffd6b64f7-tmxz2                            1/1     Running   0          120m   10.244.1.4   ambient-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">notsleep-6d6c8669b5-8t9rk                              1/1     Running   0          120m   10.244.2.6   ambient-worker    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">productpage-v1-979d4d9fc-j84w2                         1/1     Running   0          120m   10.244.1.8   ambient-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ratings-v1-5f9699cfdf-6l4xf                            1/1     Running   0          120m   10.244.1.5   ambient-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">reviews-v1-569db879f5-4w4p4                            1/1     Running   0          120m   10.244.1.6   ambient-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">reviews-v2-65c4dc6fdc-tnjxt                            1/1     Running   0          120m   10.244.1.7   ambient-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">reviews-v3-c9c4fb987-254lm                             1/1     Running   0          120m   10.244.2.4   ambient-worker    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">sleep-7b85956664-nvfkm                                 1/1     Running   0          11m    10.244.2.7   ambient-worker    &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ k get pod -n istio-system -owide</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE    IP           NODE                    NOMINATED NODE   READINESS GATES</span><br><span class="line">istio-cni-node-2klk6                    1/1     Running   0          122m   172.18.0.3   ambient-worker2         &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-cni-node-d6xpk                    1/1     Running   0          122m   172.18.0.4   ambient-control-plane   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-cni-node-kbbq4                    1/1     Running   0          122m   172.18.0.2   ambient-worker          &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-ingressgateway-7879f6cd5c-z5wqs   1/1     Running   0          122m   10.244.1.3   ambient-worker2         &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istiod-56dcbdc66b-hfdkg                 1/1     Running   0          123m   10.244.2.2   ambient-worker          &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ztunnel-4gkmd                           1/1     Running   0          123m   10.244.2.3   ambient-worker          &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ztunnel-q55t5                           1/1     Running   0          123m   10.244.1.2   ambient-worker2         &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ztunnel-wxmvw                           1/1     Running   0          123m   10.244.0.5   ambient-control-plane   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">$ k get nodes -owide</span><br><span class="line">NAME                    STATUS   ROLES           AGE     VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION      CONTAINER-RUNTIME</span><br><span class="line">ambient-control-plane   Ready    control-plane   6h37m   v1.25.0   172.18.0.4    &lt;none&gt;        Ubuntu 22.04.1 LTS   5.4.0-105-generic   containerd://1.6.7</span><br><span class="line">ambient-worker          Ready    &lt;none&gt;          6h37m   v1.25.0   172.18.0.2    &lt;none&gt;        Ubuntu 22.04.1 LTS   5.4.0-105-generic   containerd://1.6.7</span><br><span class="line">ambient-worker2         Ready    &lt;none&gt;          6h37m   v1.25.0   172.18.0.3    &lt;none&gt;        Ubuntu 22.04.1 LTS   5.4.0-105-generic   containerd://1.6.7</span><br></pre></td></tr></table></figure>
<p>我们使用一个常见的 HTTP 请求分析链路</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> deploy/sleep -- curl -s http://productpage:9080/ | <span class="built_in">head</span> -n1</span><br></pre></td></tr></table></figure>
<p>从 <code>sleep(work2)</code> 访问 <code>productpage(work1)</code></p>
<h3 id="Sleep-zTunnel"><a class="header-anchor" href="#Sleep-zTunnel">¶</a>Sleep -&gt; zTunnel</h3>
<p>从 <code>istio-cni-node</code> 的日志里我们可以看到修改的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2022-09-16T05:27:57.759272Z        info        cni        Adding pod <span class="string">&#x27;sleep-7b85956664-nvfkm/default&#x27;</span> (d7e030b1-3269-4016-8742-e2322bea7fcb) to ipset</span><br><span class="line">2022-09-16T05:27:57.759275Z        info        cni        Adding route <span class="keyword">for</span> sleep-7b85956664-nvfkm/default: [table 100 10.244.2.7/32 via 192.168.126.2 dev istioin src 10.244.2.1] </span><br></pre></td></tr></table></figure>
<p>显然我们增加一个路由信息，将访问导入了 10.244.2.1 这个地址， 从容器内也可以发现是这样的一个逻辑。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> sleep-7b85956664-nvfkm -- ip route</span><br><span class="line">default via 10.244.2.1 dev eth0</span><br><span class="line">10.244.2.0/24 via 10.244.2.1 dev eth0  src 10.244.2.7</span><br><span class="line">10.244.2.1 dev eth0 scope <span class="built_in">link</span>  src 10.244.2.7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ kubectl <span class="built_in">exec</span> sleep-7b85956664-nvfkm  -- nslookup productpage</span><br><span class="line">Server:                10.96.0.10</span><br><span class="line">Address:        10.96.0.10:53</span><br><span class="line"></span><br><span class="line">Name:        productpage.default.svc.cluster.local</span><br><span class="line">Address: 10.96.4.220</span><br></pre></td></tr></table></figure>
<p>而这个地址并没什么真的 <code>POD</code> 在运行，这是一个 <code>Veth</code> 设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ k <span class="built_in">exec</span> -n istio-system istio-cni-node-kbbq4  -- ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: veth7de83706@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether fe:88:8c:cf:58:3e brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet 10.244.2.1/32 scope global veth7de83706</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: veth2e666193@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether aa:d1:d4:6d:c1:7b brd ff:ff:ff:ff:ff:ff link-netnsid 2</span><br><span class="line">    inet 10.244.2.1/32 scope global veth2e666193</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>而这里就可以清晰的发现，流量只不过被 Route 转到 宿主机上来了，然后宿主机上看一看。就发现了端倪</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ambient-worker:/$ ip route show table 101</span><br><span class="line">default via 192.168.127.2 dev istioout</span><br><span class="line">10.244.2.3 dev veth2e666193 scope <span class="built_in">link</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@ambient-worker:/$ ip rule</span><br><span class="line">0:        from all lookup <span class="built_in">local</span></span><br><span class="line">100:        from all fwmark 0x200/0x200 goto 32766</span><br><span class="line">101:        from all fwmark 0x100/0x100 lookup 101</span><br><span class="line">102:        from all fwmark 0x40/0x40 lookup 102</span><br><span class="line">103:        from all lookup 100</span><br><span class="line">32766:        from all lookup main</span><br><span class="line">32767:        from all lookup default</span><br><span class="line"></span><br><span class="line">root@ambient-worker:/$ iptables-save</span><br><span class="line">-A ztunnel-POSTROUTING -m mark --mark 0x100/0x100 -j ACCEPT</span><br><span class="line">-A ztunnel-PREROUTING -m mark --mark 0x100/0x100 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>通过对请求 <code>Mark</code> 的方式，流量走了 <code>Table 101</code>，然后进入了  <code>istioout</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">6: istioout: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UNKNOWN group default</span><br><span class="line">    <span class="built_in">link</span>/ether 96:99:db:e4:ca:ad brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.127.1/30 brd 192.168.127.3 scope global istioout</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>而这个恰好就是 zTunnel 组件。</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2022/202209181045072.png" alt=""></p>
<h3 id="zTunnel-Waypoint"><a class="header-anchor" href="#zTunnel-Waypoint">¶</a>zTunnel -&gt; Waypoint</h3>
<p>到这里就非常的符合我们的经验了，直接看 <code>Envoy</code> 就好了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ k <span class="built_in">exec</span> -n istio-system ztunnel-4gkmd    --  iptables</span><br><span class="line"></span><br><span class="line">:POSTROUTING ACCEPT [19284:5797390]</span><br><span class="line">-A PREROUTING -j LOG --log-prefix <span class="string">&quot;mangle pre [ztunnel-4gkmd] &quot;</span></span><br><span class="line">-A PREROUTING -i pistioin -p tcp -m tcp --dport 15008 -j TPROXY --on-port 15008 --on-ip 127.0.0.1 --tproxy-mark 0x400/0xfff</span><br><span class="line">-A PREROUTING -i pistioout -p tcp -j TPROXY --on-port 15001 --on-ip 127.0.0.1 --tproxy-mark 0x400/0xfff</span><br><span class="line">-A PREROUTING -i pistioin -p tcp -j TPROXY --on-port 15006 --on-ip 127.0.0.1 --tproxy-mark 0x400/0xfff</span><br><span class="line">-A PREROUTING ! -d 10.244.2.3/32 -i eth0 -p tcp -j MARK --set-xmark 0x4d3/0xfff</span><br></pre></td></tr></table></figure>
<p>请求被重定向到 <code>15001 ztunnel_outbound</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;10.96.4.220&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;matcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;matcher_tree&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;port&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;typed_config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;exact_match_map&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;map&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;9080&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="attr">&quot;typed_config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type.googleapis.com/google.protobuf.StringValue&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>按照 <code>orgin_ip</code> 和 <code>target_port</code> 一通转换，然后就走到 <code>cluster</code> 咯</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::observability_name::spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::default_priority::max_connections::1024</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::default_priority::max_pending_requests::1024</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::default_priority::max_requests::1024</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::default_priority::max_retries::3</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::high_priority::max_connections::1024</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::high_priority::max_pending_requests::1024</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::high_priority::max_requests::1024</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::high_priority::max_retries::3</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::added_via_api::true</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::cx_active::0</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::cx_connect_fail::0</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::cx_total::0</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::rq_active::0</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::rq_error::0</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::rq_success::0</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::rq_timeout::0</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::rq_total::0</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::hostname::</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::health_flags::healthy</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::weight::1</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::region::</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::zone::</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::sub_zone::</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::canary::false</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::priority::0</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::success_rate::-1</span><br><span class="line">spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage::10.244.1.9:15006::local_origin_success_rate::-1</span><br><span class="line">prometheus_stats::observability_name::prometheus_stats</span><br></pre></td></tr></table></figure>
<p><code>10.244.1.9:15006</code> 这就是我们 <code>waypoint</code> 的入口，而在这里我们已经进入了 <code>mtls</code> 的保护范围，具体可以看 <code>cluster</code> 的信息。</p>
<h3 id="Waypoint-zTunnel"><a class="header-anchor" href="#Waypoint-zTunnel">¶</a>Waypoint -&gt; zTunnel</h3>
<p>这部分就更加的清晰了。直接 Route 下就到服务的地址了。如果需要更多的 L7 的治理策略，也会是在这个 <code>Level</code> 去处理的。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inbound_CONNECT_terminate&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;active_state&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;version_info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2022-09-16T03:43:55Z/36&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;listener&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">               <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type.googleapis.com/envoy.config.listener.v3.Listener&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inbound_CONNECT_terminate&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;socket_address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                         <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                         <span class="attr">&quot;port_value&quot;</span><span class="punctuation">:</span> <span class="number">15006</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">               <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="attr">&quot;filter_chains&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                         <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                              <span class="punctuation">&#123;</span></span><br><span class="line">                                   <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;capture_tls&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                   <span class="attr">&quot;typed_config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type.googleapis.com/udpa.type.v1.TypedStruct&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                        <span class="attr">&quot;type_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type.googleapis.com/istio.tls_passthrough.v1.CaptureTLS&quot;</span></span><br><span class="line">                                   <span class="punctuation">&#125;</span></span><br><span class="line">                              <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                              <span class="punctuation">&#123;</span></span><br><span class="line">                                   <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;envoy.filters.network.http_connection_manager&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                   <span class="attr">&quot;typed_config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                        <span class="attr">&quot;stat_prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inbound_hcm&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                        <span class="attr">&quot;route_config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                             <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local_route&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                             <span class="attr">&quot;virtual_hosts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                                  <span class="punctuation">&#123;</span></span><br><span class="line">                                                       <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;connect&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                                       <span class="attr">&quot;domains&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                                            <span class="string">&quot;*&quot;</span></span><br><span class="line">                                                       <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                                                       <span class="attr">&quot;routes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                                            <span class="punctuation">&#123;</span></span><br><span class="line">                                                                 <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                                                      <span class="attr">&quot;headers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                                                           <span class="punctuation">&#123;</span></span><br><span class="line">                                                                                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;:authority&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                                                                <span class="attr">&quot;exact_match&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.96.4.220:9080&quot;</span></span><br><span class="line">                                                                           <span class="punctuation">&#125;</span></span><br><span class="line">                                                                      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                                                                      <span class="attr">&quot;connect_matcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">                                                                 <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                                                                 <span class="attr">&quot;route&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                                                      <span class="attr">&quot;cluster&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inbound-vip|9080|internal|productpage.default.svc.cluster.local&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                                                      <span class="attr">&quot;upgrade_configs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                                                           <span class="punctuation">&#123;</span></span><br><span class="line">                                                                                <span class="attr">&quot;upgrade_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CONNECT&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                                                                <span class="attr">&quot;connect_config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">                                                                           <span class="punctuation">&#125;</span></span><br><span class="line">                                                                      <span class="punctuation">]</span></span><br><span class="line">                                                                 <span class="punctuation">&#125;</span></span><br><span class="line">                                                            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                                                            </span><br><span class="line">                                                       <span class="punctuation">]</span></span><br><span class="line">                                                  <span class="punctuation">&#125;</span></span><br><span class="line">                                             <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                                             <span class="attr">&quot;validate_clusters&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">                                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                                   <span class="punctuation">&#125;</span></span><br><span class="line">                              <span class="punctuation">&#125;</span></span><br><span class="line">                         <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                         <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inbound_CONNECT_terminate&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">               <span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;last_updated&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2022-09-16T09:40:30.193Z&quot;</span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">outbound|9080||productpage.default.svc.cluster.local::observability_name::outbound|9080||productpage.default.svc.cluster.local</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::default_priority::max_connections::4294967295</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::default_priority::max_pending_requests::4294967295</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::default_priority::max_requests::4294967295</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::default_priority::max_retries::4294967295</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::high_priority::max_connections::1024</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::high_priority::max_pending_requests::1024</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::high_priority::max_requests::1024</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::high_priority::max_retries::3</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::added_via_api::true</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::cx_active::0</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::cx_connect_fail::0</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::cx_total::0</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::rq_active::0</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::rq_error::0</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::rq_success::0</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::rq_timeout::0</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::rq_total::0</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::hostname::</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::health_flags::healthy</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::weight::1</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::region::</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::zone::</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::sub_zone::</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::canary::false</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::priority::0</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::success_rate::-1</span><br><span class="line">outbound|9080||productpage.default.svc.cluster.local::envoy://tunnel/10.244.1.8:9080::local_origin_success_rate::-1</span><br></pre></td></tr></table></figure>
<p>也就是将请求发送给 <code>proudctpage</code> 这个服务的<code> pod 10.244.1.8</code><br>
下面的逻辑通路是由 <code>kube</code> 本身保持通讯，那我们就知道通过宿主机的 <code>ipvs/iptables</code> 的修改就会访问到 <code>worker2</code> 节点</p>
<h3 id="ZTunnel-Inbound"><a class="header-anchor" href="#ZTunnel-Inbound">¶</a>ZTunnel Inbound</h3>
<p>流量到了宿主机上的时候，通过 <code>IP Rule</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ambient-worker2:/<span class="comment"># ip route show table 100</span></span><br><span class="line">10.244.1.2 dev veth983ae22d scope <span class="built_in">link</span></span><br><span class="line">10.244.1.4 via 192.168.126.2 dev istioin src 10.244.1.1</span><br><span class="line">10.244.1.5 via 192.168.126.2 dev istioin src 10.244.1.1</span><br><span class="line">10.244.1.6 via 192.168.126.2 dev istioin src 10.244.1.1</span><br><span class="line">10.244.1.7 via 192.168.126.2 dev istioin src 10.244.1.1</span><br><span class="line">10.244.1.8 via 192.168.126.2 dev istioin src 10.244.1.1</span><br></pre></td></tr></table></figure>
<p>显然所有的被纳入管理范围的 POD 的流量都被导入了 istioin 这个网卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ k get pod -owide | grep ambient-worker2</span><br><span class="line">bookinfo-productpage-waypoint-proxy-5c9c4d858b-bcmx5   1/1     Running   0          46h   10.244.1.9   ambient-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">details-v1-5ffd6b64f7-tmxz2                            1/1     Running   0          46h   10.244.1.4   ambient-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">productpage-v1-979d4d9fc-j84w2                         1/1     Running   0          46h   10.244.1.8   ambient-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ratings-v1-5f9699cfdf-6l4xf                            1/1     Running   0          46h   10.244.1.5   ambient-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">reviews-v1-569db879f5-4w4p4                            1/1     Running   0          46h   10.244.1.6   ambient-worker2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">reviews-v2-65c4dc6fdc-tnjxt                            1/1     Running   0          46h   10.244.1.7   ambient-worker2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>这个正是 <code>ztunnel</code> 的设备。</p>
<h3 id="Ztunnel-ProductPage"><a class="header-anchor" href="#Ztunnel-ProductPage">¶</a>Ztunnel -&gt; ProductPage</h3>
<p>最后一条其实就相对简单了，按照 <code>spiffe</code> 的方式，分流下，然后就直接将数据转发给真实的 POD 即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./istioctl pc listener -n istio-system ztunnel-q55t5</span><br><span class="line">ADDRESS PORT  MATCH               DESTINATION</span><br><span class="line">        0     ALL                 Cluster: outbound_tunnel_clus_spiffe://cluster.local/ns/default/sa/bookinfo-reviews</span><br><span class="line">        0     ALL                 Cluster: outbound_tunnel_clus_spiffe://cluster.local/ns/default/sa/bookinfo-details</span><br><span class="line">        0     ALL                 Cluster: outbound_tunnel_clus_spiffe://cluster.local/ns/default/sa/notsleep</span><br><span class="line">        0     ALL                 Cluster: outbound_tunnel_clus_spiffe://cluster.local/ns/default/sa/bookinfo-ratings</span><br><span class="line">        0     ALL                 Cluster: outbound_tunnel_clus_spiffe://cluster.local/ns/default/sa/bookinfo-productpage</span><br><span class="line">        0     ALL                 Cluster: outbound_tunnel_clus_spiffe://cluster.local/ns/default/sa/sleep</span><br><span class="line">0.0.0.0 15001 ALL                 PassthroughCluster</span><br><span class="line">0.0.0.0 15001 ALL                 PassthroughCluster</span><br><span class="line">0.0.0.0 15001 ALL                 Non-HTTP/Non-TCP</span><br><span class="line">0.0.0.0 15001 ALL                 Cluster: spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_status-port_istio-ingressgateway.istio-system.svc.cluster.local_outbound_internal</span><br><span class="line">0.0.0.0 15001 ALL                 Cluster: spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_server_waypoint_proxy_spiffe://cluster.local/ns/default/sa/bookinfo-productpage</span><br><span class="line">0.0.0.0 15001 ALL                 Cluster: spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_metrics_kube-dns.kube-system.svc.cluster.local_outbound_internal</span><br><span class="line">0.0.0.0 15001 ALL                 Cluster: spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_https_istio-ingressgateway.istio-system.svc.cluster.local_outbound_internal</span><br><span class="line">0.0.0.0 15001 ALL                 Cluster: spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_https-webhook_istiod.istio-system.svc.cluster.local_outbound_internal</span><br><span class="line">0.0.0.0 15001 ALL                 Cluster: spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_https-dns_istiod.istio-system.svc.cluster.local_outbound_internal</span><br><span class="line">0.0.0.0 15001 ALL                 Cluster: spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_http_sleep.default.svc.cluster.local_outbound_internal</span><br><span class="line">0.0.0.0 15001 ALL                 Cluster: spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_http_reviews.default.svc.cluster.local_outbound_internal</span><br><span class="line">0.0.0.0 15001 ALL                 Cluster: spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_http_ratings.default.svc.cluster.local_outbound_internal</span><br><span class="line">0.0.0.0 15001 ALL                 Cluster: spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_http_notsleep.default.svc.cluster.local_outbound_internal</span><br><span class="line">0.0.0.0 15001 ALL                 Cluster: spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_http_details.default.svc.cluster.local_outbound_internal</span><br><span class="line">0.0.0.0 15001 ALL                 Cluster: spiffe://cluster.local/ns/default/sa/bookinfo-reviews_to_http2_istio-ingressgateway.istio-system.svc.cluster.local_outbound_internal</span><br></pre></td></tr></table></figure>


<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: ambient mesh',
	 'SourcePod->OutboundzTunnel: 1. iptables marks & ip rule route',
	 'OutboundzTunnel->Waypoint: 2. proxy to wapoint inbound',
	 'Waypoint->InboundzTunnel: 3. dest ip route ',
	 'InboundzTunnel->DestPod: 4. spiffe'
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>istio</category>
      </categories>
      <tags>
        <tag>istio</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB 自学指南</title>
    <url>/2022/08/19/database/leveldb/</url>
    <content><![CDATA[<p><img src="https://fastly.jsdelivr.net/gh/yanickxia/picture-bed@master/20220819165427.png" alt=""></p>
<p>LevelDB是一款写性能十分优秀的可持久化的KV存储引擎，其实现原理是依据LSM-Tree（Log Structed-Merge Tree），由Google开源。今天聊聊这个。</p>
<span id="more"></span>
<h2 id="准备环境"><a class="header-anchor" href="#准备环境">¶</a>准备环境</h2>
<p>首先我们先下载代码，编译试试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recurse-submodules https://github.com/google/leveldb.git</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake --build .</span><br></pre></td></tr></table></figure>
<p>然后我们增加我们自己的测试代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.simple.cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Set up database connection information and open database</span></span><br><span class="line">  leveldb::DB* db;</span><br><span class="line">  leveldb::Options options;</span><br><span class="line">  options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;./testdb&quot;</span>, &amp;db);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span> == status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Unable to open/create test database &#x27;./testdb&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cerr &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add 256 values to the database</span></span><br><span class="line">  leveldb::WriteOptions writeOptions;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">    ostringstream keyStream;</span><br><span class="line">    keyStream &lt;&lt; <span class="string">&quot;Key&quot;</span> &lt;&lt; i;</span><br><span class="line"></span><br><span class="line">    ostringstream valueStream;</span><br><span class="line">    valueStream &lt;&lt; <span class="string">&quot;Test data value: &quot;</span> &lt;&lt; i;</span><br><span class="line"></span><br><span class="line">    db-&gt;<span class="built_in">Put</span>(writeOptions, keyStream.<span class="built_in">str</span>(), valueStream.<span class="built_in">str</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterate over each item in the database and print them</span></span><br><span class="line">  leveldb::Iterator* it = db-&gt;<span class="built_in">NewIterator</span>(leveldb::<span class="built_in">ReadOptions</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (it-&gt;<span class="built_in">SeekToFirst</span>(); it-&gt;<span class="built_in">Valid</span>(); it-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;<span class="built_in">key</span>().<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; it-&gt;<span class="built_in">value</span>().<span class="built_in">ToString</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span> == it-&gt;<span class="built_in">status</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;An error was found during the scan&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cerr &lt;&lt; it-&gt;<span class="built_in">status</span>().<span class="built_in">ToString</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> it;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Close the database</span></span><br><span class="line">  <span class="keyword">delete</span> db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在我们的 <code>Makefile</code> 中增加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  leveldb_test(&quot;db/c_test.c&quot;)</span><br><span class="line">++leveldb_test(&quot;example/simple.cc&quot;)</span><br></pre></td></tr></table></figure>
<p>然后就可以执行我们的测试逻辑了。</p>
<h2 id="基础知识"><a class="header-anchor" href="#基础知识">¶</a>基础知识</h2>
<p><img src="https://fastly.jsdelivr.net/gh/yanickxia/picture-bed@master/20220823174409.png" alt=""></p>
<p>对于 <code>LevelDB</code> 的基础知识就不做展开了，鉴于有很多全面的资料，非常推荐阅读 &lt;LevelDB源码剖析&gt;<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 。</p>
<p>LevelDB的存储引擎主要分为三个部件：</p>
<ul>
<li><code>SSTable</code>，就是Sorted String Table，是一个持久化的、有序的 <code>SortedMap</code>，存储在磁盘上；</li>
<li><code>WAL</code>，Write Ahead Log，数据库里面经常用的技术，要写数据时，不直接写数据文件，而是先写一条日志，这样可以把对磁盘的随机写转换成顺序写</li>
<li><code>MemTable</code>，保存了最近写入的键值对，数据写入 <code>WAL</code> 后，会同时写入 <code>MemTable</code>，这样便于查询。</li>
</ul>
<p>SSTable是数据最终落盘的地方，而 <code>WAL</code> 保存了最近写入的数据，持久化到磁盘上，<code>MemTable</code> 则是 <code>WAL</code> 里数据的内存表示，因为日志的格式不便于查询，在内存中才便于快速查询。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── 000018.ldb  &lt;----- SSTable</span><br><span class="line">├── 000020.ldb  &lt;----- SSTable</span><br><span class="line">├── 000023.ldb  &lt;----- SSTable</span><br><span class="line">├── 000026.ldb  &lt;----- SSTable</span><br><span class="line">├── 000028.ldb  &lt;----- SSTable</span><br><span class="line">├── 000031.<span class="built_in">log</span>  &lt;----- WAL <span class="built_in">log</span></span><br><span class="line">├── 000032.ldb  &lt;----- SSTable</span><br><span class="line">├── 000033.ldb</span><br><span class="line">├── CURRENT     &lt;----- 当前版本</span><br><span class="line">├── LOCK</span><br><span class="line">├── LOG         &lt;----- 运行日志</span><br><span class="line">├── LOG.old</span><br><span class="line">└── MANIFEST-000030</span><br></pre></td></tr></table></figure>
<h3 id="SST"><a class="header-anchor" href="#SST">¶</a>SST</h3>
<p><code>SSTable</code> 最早来自于 Google 的 Bigtable 论文</p>
<blockquote>
<p>An SSTable provides a persistent, ordered immutable map from keys to values, where both keys and values are arbitrary byte strings. Operations are provided to look up the value associated with a specified key, and to iterate over all key/value pairs in a specified key range. Internally, each SSTable contains a sequence of blocks (typically each block is 64KB in size, but this is configurable). A block index (stored at the end of the SSTable) is used to locate blocks; the index is loaded into memory when the SSTable is opened. A lookup can be performed with a single disk seek: we first find the appropriate block by performing a binary search in the in-memory index, and then reading the appropriate block from disk. Optionally, an SSTable can be completely mapped into memory, which allows us to perform lookups and scans without touching disk.</p>
</blockquote>
<p>在 <code>Leveldb</code> 中的具体实现参考 <a href="https://github.com/google/leveldb/blob/main/doc/table_format.md">leveldb File format</a></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;beginning_of_file&gt;</span><br><span class="line">[data block 1]</span><br><span class="line">[data block 2]</span><br><span class="line">...</span><br><span class="line">[data block N]</span><br><span class="line">[filter block 1]  &lt;--- 仅仅 FilterPolicy 开启的时候</span><br><span class="line">...</span><br><span class="line">[filter block K]</span><br><span class="line">[meta block 1]</span><br><span class="line">...</span><br><span class="line">[meta block K]</span><br><span class="line">[metaindex block]</span><br><span class="line">[index block]</span><br><span class="line">[Footer]        (fixed size; starts at file_size - sizeof(Footer))</span><br><span class="line">&lt;end_of_file&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Data Block</code>存储数据，按照键的顺序进行排序；</li>
<li>在<code>Data Block</code>后是<code>Filter Block</code>，也设计成为多个，存储了布隆过滤器的二进制数据；</li>
<li><code>Meta Index Block</code>存储了指向<code>Filter Block</code>的指针，根据这个指针可以找到某个<code>Filter Block</code>开始的位置</li>
<li><code>Index Block</code>存储了指向每一个<code>Data Block</code>的指针的数组；</li>
<li>最后有一个大小固定的<code>Footer</code>，保存两个<code>BlockHandler</code>，分别指向<code>Meta Index Block</code>和<code>Index Block</code>。</li>
</ul>
<h4 id="Footer"><a class="header-anchor" href="#Footer">¶</a>Footer</h4>
<p><code>Footer</code> 一共是 <code>48</code> 字节</p>
<figure class="highlight cpp"><figcaption><span>EncodeTo</span><a href="https://github.com/google/leveldb/blob/297e66afc1dda3f3d7a7cc2022030164c302cb7a/table/format.cc#L31-L40">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Footer::EncodeTo</span><span class="params">(std::string* dst)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> original_size = dst-&gt;<span class="built_in">size</span>();</span><br><span class="line">  metaindex_handle_.<span class="built_in">EncodeTo</span>(dst);</span><br><span class="line">  index_handle_.<span class="built_in">EncodeTo</span>(dst);</span><br><span class="line">  dst-&gt;<span class="built_in">resize</span>(<span class="number">2</span> * BlockHandle::kMaxEncodedLength);  <span class="comment">// Padding</span></span><br><span class="line">  <span class="built_in">PutFixed32</span>(dst, <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(kTableMagicNumber &amp; <span class="number">0xffffffff</span>u));</span><br><span class="line">  <span class="built_in">PutFixed32</span>(dst, <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(kTableMagicNumber &gt;&gt; <span class="number">32</span>));</span><br><span class="line">  <span class="built_in">assert</span>(dst-&gt;<span class="built_in">size</span>() == original_size + kEncodedLength);</span><br><span class="line">  (<span class="type">void</span>)original_size;  <span class="comment">// Disable unused variable warning.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换做定义的话就是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Footer</span> &#123;</span><br><span class="line">    BlockHandler meta_index_block;  <span class="comment">// 定位Meta Index Block</span></span><br><span class="line">    BlockHandler index_block;       <span class="comment">// 定位Index Block</span></span><br><span class="line">    byte[n] padding;                <span class="comment">// 补齐到48字节</span></span><br><span class="line">    int64 magic;                    <span class="comment">// 魔数 echo http://code.google.com/p/leveldb/ | sha1sum</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Block"><a class="header-anchor" href="#Block">¶</a>Block</h4>
<p>其他的区域都是 <code>Block</code> 类型的数据， 换做定义的是 （并没有实际的定义）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">    byte[] data;</span><br><span class="line">    byte compress_type;</span><br><span class="line">    int32 crc;  &lt;---- 可选的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要参考 <a href="https://github.com/google/leveldb/blob/297e66afc1dda3f3d7a7cc2022030164c302cb7a/table/format.cc#L64-L139">ReadBlock</a> 推导出来。</p>
<h5 id="Data-Block"><a class="header-anchor" href="#Data-Block">¶</a>Data Block</h5>
<p><img src="https://fastly.jsdelivr.net/gh/yanickxia/picture-bed@master/20220828152704.png" alt=""></p>
<p><code>DataBlock</code> 用了一种压缩的手段来储存数据，我们知道 Data 中其实是 KV 的结构，这里用了 Key 压缩的手段。</p>
<p>用结构定义的话，是这样的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Kv</span> &#123;</span><br><span class="line">    varint32 shared_key_length;       <span class="comment">// 和前一个键相同的前缀长度</span></span><br><span class="line">    varint32 non_shared_key_length;   <span class="comment">// 不相同的键长度</span></span><br><span class="line">    varint32 value_length;            <span class="comment">// 值的长度</span></span><br><span class="line">    byte[] non_shared_key_content;    <span class="comment">// 不相同的键的内容</span></span><br><span class="line">    byte[] value;                     <span class="comment">// 值的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过这种方式将多个<code>Kv</code>连续存放在<code>Data Block</code>里，可以进行键的前缀压缩。然而这样会有一个问题，不管得到哪一个键的值，都需要从Block的第一个键开始依次构造，搜索一个键的时候，也需要遍历整个Block，如果一个Block里有大量的键的话，效率会比较低。<br>
针对这个问题，LevelDB设置了restart point，每16个Kv里第一个Kv是一个restart point，这个Kv的shared_key_length始终为0，也就是这个Kv不采用前缀编码，non_shared_key_content里的内容就是整个键的内容。这样就不需要从每一个Data Block的开头开始构造键了，只需要从每一个restart point开始构造。另外在每个Data Block的末尾存储了一个restart point数组，指向了每一个restart point所在Kv的在块中的偏移，这样便可以支持二分搜索，搜索出键属于哪一个restart point的组里，然后去搜索这个组里面的16个Kv就可以找到这个键。restart point数组就像是一个Data Block的稀疏索引，可以加快键的查找。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DataBlock</span> &#123;</span><br><span class="line">    Kv[] kv;                        <span class="comment">// Kv数组</span></span><br><span class="line">    int32[] restart_point_offsets;  <span class="comment">// restart point偏移数组，指向每一个restart point</span></span><br><span class="line">    int32 restart_point_count;      <span class="comment">// restart point数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取的逻辑如下</p>
<figure class="highlight cpp"><figcaption><span>DecodeEntry</span><a href="https://github.com/google/leveldb/blob/8cce47e450b365347769959c53b8836ef0216df9/table/block.cc#L55-L75">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 P 的位置开始读取</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">DecodeEntry</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">const</span> <span class="type">char</span>* limit,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">uint32_t</span>* shared, <span class="type">uint32_t</span>* non_shared,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">uint32_t</span>* value_length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (limit - p &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// shared_key 长度</span></span><br><span class="line">  *shared = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(p)[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// non_shared_key 长度</span></span><br><span class="line">  *non_shared = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(p)[<span class="number">1</span>];</span><br><span class="line">  <span class="comment">// value 长度</span></span><br><span class="line">  *value_length = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(p)[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> ((*shared | *non_shared | *value_length) &lt; <span class="number">128</span>) &#123;</span><br><span class="line">    <span class="comment">// Fast path: all three values are encoded in one byte each</span></span><br><span class="line">    p += <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">GetVarint32Ptr</span>(p, limit, shared)) == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">GetVarint32Ptr</span>(p, limit, non_shared)) == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">GetVarint32Ptr</span>(p, limit, value_length)) == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(limit - p) &lt; (*non_shared + *value_length)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Index-Block"><a class="header-anchor" href="#Index-Block">¶</a>Index Block</h5>
<p><img src="https://fastly.jsdelivr.net/gh/yanickxia/picture-bed@master/20220828154813.png" alt=""></p>
<p><code>Index Block</code>就非常简单了，它其实就是存储了一个Kv数组，每一个Kv对应一个<code>Data Block</code>，其中键大于等于对应的<code>Data Block</code>中最后一个键，值为一个<code>BlockHandler</code>，可以定位到一个<code>Data Block</code>。<code>Index Block</code>就是<code>Data Block</code>的索引，搜索时可以对<code>Index Block</code>二分搜索，找到键对应的<code>Data Block</code>。</p>
<blockquote>
<p>作者注：这里不去讨论 Bloom 过滤器，主要侧重在 LSM 和 LevelDB 的本地逻辑。</p>
</blockquote>
<hr>
<p>有了上面这两部分的基础知识，我们就可以知道是如何从磁盘中读取一个值了。</p>
<ol>
<li>读取 <code>Footer</code>，根据里面的读取 <code>Meta Index Block</code> 和 <code>Index Block</code> ，将 <code>Index Block</code> 的内容缓存到内存中</li>
<li>根据键对 <code>Index Block</code> 的 <code>restart point</code> 进行二分搜索，找到这个键对应的 <code>Data Block</code> 的 <code>BlockHandler</code></li>
<li>读取对应的 <code>Data Block</code></li>
<li>对<code> Data Block</code> 里的 <code>restart point</code> 进行二分搜索，找到搜索键对应的 <code>restart point</code>;</li>
</ol>
<p>那我们来看看读取的全流程，我们从 <code>Table::InternalGet</code> 开始</p>
<figure class="highlight cpp"><figcaption><span>InternalGet</span><a href="https://github.com/google/leveldb/blob/10bc0f2595b8672c0c1756f22051ec420036fdf2/table/table.cc#L214-L242">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Table::InternalGet</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options, <span class="type">const</span> Slice&amp; k, <span class="type">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">void</span> (*handle_result)(<span class="type">void</span>*, <span class="type">const</span> Slice&amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">const</span> Slice&amp;))</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="comment">// 找到 index block</span></span><br><span class="line">  Iterator* iiter = rep_-&gt;index_block-&gt;<span class="built_in">NewIterator</span>(rep_-&gt;options.comparator);</span><br><span class="line">  <span class="comment">// 定位到对应的 Data block 索引</span></span><br><span class="line">  iiter-&gt;<span class="built_in">Seek</span>(k);</span><br><span class="line">  <span class="keyword">if</span> (iiter-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    Slice handle_value = iiter-&gt;<span class="built_in">value</span>();</span><br><span class="line">    FilterBlockReader* filter = rep_-&gt;filter;</span><br><span class="line">    BlockHandle handle;</span><br><span class="line">    <span class="comment">// Bloom 过滤 SKIP </span></span><br><span class="line">    <span class="keyword">if</span> (filter != <span class="literal">nullptr</span> &amp;&amp; handle.<span class="built_in">DecodeFrom</span>(&amp;handle_value).<span class="built_in">ok</span>() &amp;&amp;</span><br><span class="line">        !filter-&gt;<span class="built_in">KeyMayMatch</span>(handle.<span class="built_in">offset</span>(), k)) &#123;</span><br><span class="line">      <span class="comment">// Not found</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 读取 Data Block</span></span><br><span class="line">      Iterator* block_iter = <span class="built_in">BlockReader</span>(<span class="keyword">this</span>, options, iiter-&gt;<span class="built_in">value</span>());</span><br><span class="line">      <span class="comment">// 二分查找 Data Block</span></span><br><span class="line">      block_iter-&gt;<span class="built_in">Seek</span>(k);</span><br><span class="line">      <span class="keyword">if</span> (block_iter-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">        (*handle_result)(arg, block_iter-&gt;<span class="built_in">key</span>(), block_iter-&gt;<span class="built_in">value</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      s = block_iter-&gt;<span class="built_in">status</span>();</span><br><span class="line">      <span class="keyword">delete</span> block_iter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    s = iiter-&gt;<span class="built_in">status</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> iiter;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Iterator</code> 的 <code>Seek</code> 是一致的，因为数据结构我们分析是一样的，不过 <code>IndexBlock</code> 中的一个 <code>Restart</code> 对应了一个 <code>KV</code>，而 <code>DataBlock</code> 中会对应多个，最后一段的 <code>Linear Search</code> 对于两者也是一样的。</p>
<figure class="highlight cpp"><figcaption><span>Seek</span><a href="https://github.com/google/leveldb/blob/8cce47e450b365347769959c53b8836ef0216df9/table/block.cc#L164-L227">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">const</span> Slice&amp; target)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// left -&gt; 0 , right -&gt; restart pointer</span></span><br><span class="line">    <span class="type">uint32_t</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> right = num_restarts_ - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> current_key_compare = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找 </span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">uint32_t</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">      <span class="type">uint32_t</span> region_offset = <span class="built_in">GetRestartPoint</span>(mid);</span><br><span class="line">      <span class="type">uint32_t</span> shared, non_shared, value_length;</span><br><span class="line">      <span class="type">const</span> <span class="type">char</span>* key_ptr =</span><br><span class="line">          <span class="built_in">DecodeEntry</span>(data_ + region_offset, data_ + restarts_, &amp;shared,</span><br><span class="line">                      &amp;non_shared, &amp;value_length);</span><br><span class="line">      <span class="keyword">if</span> (key_ptr == <span class="literal">nullptr</span> || (shared != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">CorruptionError</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function">Slice <span class="title">mid_key</span><span class="params">(key_ptr, non_shared)</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Compare</span>(mid_key, target) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Key at &quot;mid&quot; is smaller than &quot;target&quot;.  Therefore all</span></span><br><span class="line">        <span class="comment">// blocks before &quot;mid&quot; are uninteresting.</span></span><br><span class="line">        left = mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Key at &quot;mid&quot; is &gt;= &quot;target&quot;.  Therefore all blocks at or</span></span><br><span class="line">        <span class="comment">// after &quot;mid&quot; are uninteresting.</span></span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Linear search (within restart block) for first key &gt;= target</span></span><br><span class="line">    <span class="comment">// 最终的线性查找，在某个 restart block 区间内</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">ParseNextKey</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Compare</span>(key_, target) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="New-DB"><a class="header-anchor" href="#New-DB">¶</a>New DB</h2>
<figure class="highlight cpp"><figcaption><span>open</span><a href="https://github.com/google/leveldb/blob/8f1861462b27727dfc5b2c4687112108e6ba88eb/db/db_impl.cc#L1483">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DB::Open</span><span class="params">(<span class="type">const</span> Options&amp; options, <span class="type">const</span> std::string&amp; dbname, DB** dbptr)</span> </span>&#123;</span><br><span class="line">  *dbptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  DBImpl* impl = <span class="keyword">new</span> <span class="built_in">DBImpl</span>(options, dbname);</span><br><span class="line">  impl-&gt;mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  <span class="comment">// Recover handles create_if_missing, error_if_exists</span></span><br><span class="line">  <span class="type">bool</span> save_manifest = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先第一步就是先 Recover</span></span><br><span class="line">  Status s = impl-&gt;<span class="built_in">Recover</span>(&amp;edit, &amp;save_manifest);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Read-Write"><a class="header-anchor" href="#Read-Write">¶</a>Read &amp; Write</h2>
<p>我们先看读写，再看其他的边缘 Case</p>
<h3 id="Write"><a class="header-anchor" href="#Write">¶</a>Write</h3>
<p>我们知道 <code>Leveldb</code> 收到消息第一步就是写 <code>WAL</code></p>
<figure class="highlight cpp"><figcaption><span>Put</span><a href="https://github.com/google/leveldb/blob/8f1861462b27727dfc5b2c4687112108e6ba88eb/db/db_impl.cc#L1469-L1473">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DB::Put</span><span class="params">(<span class="type">const</span> WriteOptions&amp; opt, <span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  batch.<span class="built_in">Put</span>(key, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Write</span>(opt, &amp;batch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WriteBatch</code> 看名字就知道是一个批量操作，用于将多个写入一起写入。 不过这个 <code>WriteBatch</code> 还是挺抽象的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> WriteBatch &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">WriteBatch</span>();</span><br><span class="line">  ~<span class="built_in">WriteBatch</span>();</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WriteBatchInternal</span>;</span><br><span class="line"></span><br><span class="line">  std::string rep_;  <span class="comment">// See comment in write_batch.cc for the format of rep_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Intentionally copyable</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于 <code>leveldb</code> 里面只有一个 <code>rep_</code> 来储存真正的内存，其他的内容都在按照一些特殊的方式进行处理的。</p>
<p>这里参考下 <a href="https://zhuanlan.zhihu.com/p/275699183">[LevelDB] 数据库3：循序渐进 —— 操作接口</a> 中的拿过来，大概是这样的结构<br>
<img src="https://fastly.jsdelivr.net/gh/yanickxia/picture-bed@master/20220824152226.png" alt=""></p>
<p>所以看下面的操作的时候，比如生成序列号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatchInternal::SetSequence</span><span class="params">(WriteBatch* b, SequenceNumber seq)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(&amp;b-&gt;rep_[<span class="number">0</span>], seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Write</code> 就是真实写入的函数了，将一个 <code>WriteBatch</code> 的内容写入到数据库，写入分为两步：</p>
<ul>
<li>写入数据到日志；</li>
<li>写入数据到MemTable。</li>
</ul>
<figure class="highlight cpp"><figcaption><span>Write</span><a href="https://github.com/google/leveldb/blob/8f1861462b27727dfc5b2c4687112108e6ba88eb/db/db_impl.cc#L1200">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>&#123;</span><br><span class="line">  <span class="function">Writer <span class="title">w</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  w.batch = updates;</span><br><span class="line">  w.sync = options.sync;</span><br><span class="line">  <span class="comment">// 默认非 DONE</span></span><br><span class="line">  w.done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  writers_.<span class="built_in">push_back</span>(&amp;w);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里有可能别的线程帮助写入了，就是 DONE了，所以下面有个 Return，并且自己是 Head就真的开始写入，不然就是等</span></span><br><span class="line">  <span class="keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.<span class="built_in">front</span>()) &#123;</span><br><span class="line">    w.cv.<span class="built_in">Wait</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (w.done) &#123;</span><br><span class="line">    <span class="keyword">return</span> w.status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// May temporarily unlock and wait.</span></span><br><span class="line">  <span class="comment">// MakeRoomForWrite 的主要逻辑是将 MemTable 变成 ImmuateMemTable, 然后创建一个新的 MemTable</span></span><br><span class="line">  Status status = <span class="built_in">MakeRoomForWrite</span>(updates == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">uint64_t</span> last_sequence = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">  <span class="comment">// 这里的 last_writer 现在就是 Head</span></span><br><span class="line">  Writer* last_writer = &amp;w;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; updates != <span class="literal">nullptr</span>) &#123;  <span class="comment">// nullptr batch is for compactions</span></span><br><span class="line">    <span class="comment">// BuildBatchGroup 会根据队列里面的值尽量的多一次性取出来去 Write</span></span><br><span class="line">    <span class="comment">// 在这里会更新 last_writer，也就是合并写入的最后一个</span></span><br><span class="line">    WriteBatch* write_batch = <span class="built_in">BuildBatchGroup</span>(&amp;last_writer);</span><br><span class="line">    WriteBatchInternal::<span class="built_in">SetSequence</span>(write_batch, last_sequence + <span class="number">1</span>);</span><br><span class="line">    last_sequence += WriteBatchInternal::<span class="built_in">Count</span>(write_batch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add to log and apply to memtable.  We can release the lock</span></span><br><span class="line">    <span class="comment">// during this phase since &amp;w is currently responsible for logging</span></span><br><span class="line">    <span class="comment">// and protects against concurrent loggers and concurrent writes</span></span><br><span class="line">    <span class="comment">// into mem_.</span></span><br><span class="line">    <span class="comment">// 注意这一步解锁，很关键，因为接下来的写入可能是一个费时的过程，解锁后，其它线程可以Get，其它线程也可以继续将writer</span></span><br><span class="line">    <span class="comment">// 插入到writers_里面，但是插入后，因为不是头元素，会等待，所以不会冲突</span></span><br><span class="line">    &#123;</span><br><span class="line">      mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">      <span class="comment">// 写入log</span></span><br><span class="line">      status = log_-&gt;<span class="built_in">AddRecord</span>(WriteBatchInternal::<span class="built_in">Contents</span>(write_batch));</span><br><span class="line">      <span class="type">bool</span> sync_error = <span class="literal">false</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 根据选项sync,不开就可以会丢数据</span></span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; options.sync) &#123;</span><br><span class="line">        status = logfile_-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          sync_error = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        status = WriteBatchInternal::<span class="built_in">InsertInto</span>(write_batch, mem_);</span><br><span class="line">      &#125;</span><br><span class="line">      mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (sync_error) &#123;</span><br><span class="line">        <span class="comment">// The state of the log file is indeterminate: the log record we</span></span><br><span class="line">        <span class="comment">// just added may or may not show up when the DB is re-opened.</span></span><br><span class="line">        <span class="comment">// So we force the DB into a mode where all future writes fail.</span></span><br><span class="line">        <span class="built_in">RecordBackgroundError</span>(status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (write_batch == tmp_batch_) tmp_batch_-&gt;<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">    versions_-&gt;<span class="built_in">SetLastSequence</span>(last_sequence);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新 SEQ，到这里就写完了。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知下个等待的 Write 过来写。</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Writer* ready = writers_.<span class="built_in">front</span>();</span><br><span class="line">    writers_.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">if</span> (ready != &amp;w) &#123;</span><br><span class="line">      ready-&gt;status = status;</span><br><span class="line">      ready-&gt;done = <span class="literal">true</span>;</span><br><span class="line">      ready-&gt;cv.<span class="built_in">Signal</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ready == last_writer) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Notify new head of write queue</span></span><br><span class="line">  <span class="keyword">if</span> (!writers_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    writers_.<span class="built_in">front</span>()-&gt;cv.<span class="built_in">Signal</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于写来说，流程还是比较简单的。</p>
<ol>
<li>创建一个批量的 Writebatch</li>
<li>确保有足够的内存空间</li>
<li>写 Log &amp; 写 内存</li>
</ol>
<h3 id="Read"><a class="header-anchor" href="#Read">¶</a>Read</h3>
<p>通过各种网络小知识，我们知道 <code>Leveldb</code> 是一层层的读的，因此我们来看看 <code>Get</code> 是怎么工作的。</p>
<figure class="highlight cpp"><figcaption><span>Get</span><a href="https://github.com/google/leveldb/blob/8f1861462b27727dfc5b2c4687112108e6ba88eb/db/db_impl.cc#L1115-L1160">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Get</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options, <span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::string* value)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line">  <span class="comment">// 读取快照版本，这个后面再解释</span></span><br><span class="line">  <span class="keyword">if</span> (options.snapshot != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    snapshot =</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;<span class="built_in">sequence_number</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    snapshot = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前的 mem/imm 挨个去读</span></span><br><span class="line">  MemTable* mem = mem_;</span><br><span class="line">  MemTable* imm = imm_;</span><br><span class="line">  Version* current = versions_-&gt;<span class="built_in">current</span>();</span><br><span class="line">  <span class="comment">// mem ref +1 代表这个正在被使用，下同</span></span><br><span class="line">  mem-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  current-&gt;<span class="built_in">Ref</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> have_stat_update = <span class="literal">false</span>;</span><br><span class="line">  Version::GetStats stats;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">    <span class="comment">// 读 Memtable -&gt; IMM -&gt; DISK</span></span><br><span class="line">    <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">nullptr</span> &amp;&amp; imm-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = current-&gt;<span class="built_in">Get</span>(options, lkey, value, &amp;stats);</span><br><span class="line">      have_stat_update = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;<span class="built_in">UpdateStats</span>(stats)) &#123;</span><br><span class="line">    <span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  mem-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  current-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主逻辑非常的清晰，比较复杂的是读取硬盘上的 <code>SST</code><br>
<img src="https://fastly.jsdelivr.net/gh/yanickxia/picture-bed@master/20220825171342.png" alt=""></p>
<p><code>SST</code> 在代码中的表示是</p>
<figure class="highlight cpp"><figcaption><span>FileMeta</span><a href="https://github.com/google/leveldb/blob/a0191e5563b7a6c24b39edcbdbff29e602e0acfc/db/version_edit.h#L18-L27">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FileMetaData</span> &#123;</span><br><span class="line">  <span class="built_in">FileMetaData</span>() : <span class="built_in">refs</span>(<span class="number">0</span>), <span class="built_in">allowed_seeks</span>(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), <span class="built_in">file_size</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> refs;</span><br><span class="line">  <span class="type">int</span> allowed_seeks;  <span class="comment">// Seeks allowed until compaction</span></span><br><span class="line">  <span class="type">uint64_t</span> number;</span><br><span class="line">  <span class="type">uint64_t</span> file_size;    <span class="comment">// File size in bytes</span></span><br><span class="line">  InternalKey smallest;  <span class="comment">// Smallest internal key served by table</span></span><br><span class="line">  InternalKey largest;   <span class="comment">// Largest internal key served by table</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List of files per level</span></span><br><span class="line">std::vector&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br></pre></td></tr></table></figure>
<p>因此我们只要根据 <code>smallest</code> 和 <code>larget</code> 就可以定位到对应的 <code>SST</code> 然后读进内存就好了，找到那个 <code>Key</code> 就好了。分层读取的逻辑在 <a href="https://github.com/google/leveldb/blob/068a0f12148d38204d8231ad2cd03d9cfd5eb3dc/db/version_set.cc#L282-L323">ForEachOverlapping</a> 就不展开了。</p>
<h2 id="版本管理"><a class="header-anchor" href="#版本管理">¶</a>版本管理</h2>
<p>在上面的 <code>Read</code> 中，我们看到了 <code>Version</code> 但是我们并没有深究。</p>
<blockquote>
<p>那么为什么要版本管理呢？ 在数据不断写入后，MemTable写满了，这时候就会转换为Level 0的一个SSTable，或者Level n的一个文件和Level n + 1的多个文件进行Compaction，会转换成Level n + 1的多个文件。这会使SSTable文件数量改变，文件内容改变，也就是版本信息改变了，所以需要管理版本。</p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/yanickxia/picture-bed@master/20220825174346.png" alt=""></p>
<ul>
<li>Version标识了一个版本，主要信息是这个版本包含的 SSTable 信息</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br></pre></td></tr></table></figure>
<ul>
<li>VersionSet是一个版本集，里面保存了Version的一个双链表，其中有一个Version是当前版本，因为只有一个实例，还保存了其它的一些全局的元数据， Dummy Version是链表头</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br></pre></td></tr></table></figure>
<ul>
<li>VersionEdit保存了要对Version做的修改，在一个Version上应用一个VersionEdit，可以生成一个新的Version；</li>
<li>Builder是一个帮助类，帮助Version上应用VersionEdit，生成新版本。</li>
</ul>
<p>运行流程</p>
<ul>
<li><code>VersionSet</code> 里保存着当前版本，以及被引用的历史版本；</li>
<li>当有 <code>Compaction</code> 发生时，会将更改的内容写入到一个 <code>VersionEdit</code> 中；</li>
<li>利用 <code>Builder</code> 将 <code>VersionEdit</code> 应用到当前版本上面生成一个新的版本；</li>
<li>将新版本链接到 <code>VersionSet</code> 的双链表上面；</li>
<li>将新的版本设置为当前版本；</li>
<li>将旧的当前版本 <code>Unref</code> ，就是引用计数减 1。</li>
</ul>
<h3 id="VersionSet"><a class="header-anchor" href="#VersionSet">¶</a>VersionSet</h3>
<p>那么我们看起来首先，对于某个版本的查询，核心的就是要一直读取对应时间的 <code>IMM</code> <code>MMT</code> <code>SSTABLE</code> ，这个做法就是就是在 <code>VersionSet</code> 中</p>
<figure class="highlight cpp"><figcaption><span>VersionSet</span><a href="https://github.com/google/leveldb/blob/54340b4a1020737e17ae4efacc31afeb53022be9/db/version_set.h#L291-L315">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VersionSet</span> &#123;</span><br><span class="line">    Env* <span class="type">const</span> env_;                      <span class="comment">// 封装部分操作系统调用，包括文件、线程操作等</span></span><br><span class="line">    <span class="type">const</span> std::string dbname_;            <span class="comment">// 数据库名称，Open时传入</span></span><br><span class="line">    <span class="type">const</span> Options* <span class="type">const</span> options_;        <span class="comment">// 数据库选项，Open时传入</span></span><br><span class="line">    TableCache* <span class="type">const</span> table_cache_;       <span class="comment">// 打开的SSTable的缓存，Open时创建</span></span><br><span class="line">    <span class="type">const</span> InternalKeyComparator icmp_;    <span class="comment">// 根据User Key生成的Internal Key的Comparator</span></span><br><span class="line">    <span class="type">uint64_t</span> next_file_number_;           <span class="comment">// ldb、log和MANIFEST生成新文件时都有一个序号单调递增</span></span><br><span class="line">    <span class="type">uint64_t</span> manifest_file_number_;       <span class="comment">// 当前的MANIFEST的编号 [重点]</span></span><br><span class="line">    <span class="type">uint64_t</span> last_sequence_;              <span class="comment">// 上一个使用的SequenceNumber</span></span><br><span class="line">    <span class="type">uint64_t</span> log_number_;                 <span class="comment">// 当前的日志的编号</span></span><br><span class="line"></span><br><span class="line">    WritableFile* descriptor_file_;       <span class="comment">// MANIFEST打开的文件描述符</span></span><br><span class="line">    log::Writer* descriptor_log_;         <span class="comment">// MANIFEST实际存储的格式是WAL日志的格式，所以这里用来写入数据</span></span><br><span class="line">    Version dummy_versions_;              <span class="comment">// Version链表的头结点</span></span><br><span class="line">    Version* current_;                    <span class="comment">// 当前的Version</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是用来记录Compact的进度，Compact总是从某一Level的最小的键开始到某个键结束，</span></span><br><span class="line">    <span class="comment">// 下次再从下一个键开始，所以这个就是下一次这个Level从哪个键开始Compact</span></span><br><span class="line">    std::string compact_pointer_[config::kNumLevels];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是通过 <code>MANIFEST</code> 来维护，也就是为什么我们的 <code>MANIFEST</code> 会有那么多的后缀了。</p>
<h3 id="VersionEdit"><a class="header-anchor" href="#VersionEdit">¶</a>VersionEdit</h3>
<p><code>VersionEdit</code> 中记录了一次变更的内容。</p>
<figure class="highlight cpp"><figcaption><span>VersionEdit</span><a href="https://github.com/google/leveldb/blob/a0191e5563b7a6c24b39edcbdbff29e602e0acfc/db/version_edit.h#L88-L101">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VersionEdit</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">uint64_t</span>&gt;&gt; DeletedFileSet;</span><br><span class="line"></span><br><span class="line">    std::string comparator_;             <span class="comment">// 比较器的名称，持久化后，下次打开时需要对比一致</span></span><br><span class="line">    <span class="type">uint64_t</span> log_number_;                <span class="comment">// 日志文件的编号</span></span><br><span class="line">    <span class="type">uint64_t</span> next_file_number_;          <span class="comment">// ldb、log和MANIFEST下一个文件的编号</span></span><br><span class="line">    SequenceNumber last_sequence_;       <span class="comment">// 上一个使用的SequenceNumber</span></span><br><span class="line">    <span class="type">bool</span> has_comparator_;                <span class="comment">// 记录上面4个字段是否存在，存在才会持久化的MANIFEST中</span></span><br><span class="line">    <span class="type">bool</span> has_log_number_;</span><br><span class="line">    <span class="type">bool</span> has_next_file_number_;</span><br><span class="line">    <span class="type">bool</span> has_last_sequence_</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和VersionSet里面的compact_pointers_相同</span></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, InternalKey&gt;&gt; compact_pointers_;</span><br><span class="line">    <span class="comment">// 有哪些文件被删除，就是Version里哪些SSTable被删除</span></span><br><span class="line">    DeletedFileSet deleted_files_;</span><br><span class="line">    <span class="comment">// 有哪些文件被增加，pair的第一个参数是Level，第二个参数是文件的元信息</span></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, FileMetaData&gt;&gt; new_files_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>VersionEdit + Version = NextVersion</p>
<p>在 <code>VersionEdit</code> 包含集中类型数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">  kComparator = <span class="number">1</span>,            <span class="comment">// 记录Comparator的名字</span></span><br><span class="line">  kLogNumber = <span class="number">2</span>,             <span class="comment">// 记录当前时刻的log_number</span></span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,        <span class="comment">// 记录当前时刻的next_file_number_</span></span><br><span class="line">  kLastSequence = <span class="number">4</span>,          <span class="comment">// 记录当前时刻的last_sequence</span></span><br><span class="line">  kCompactPointer = <span class="number">5</span>,        <span class="comment">// 记录compact_pointer</span></span><br><span class="line">  kDeletedFile = <span class="number">6</span>,           <span class="comment">// 记录删除的文件信息</span></span><br><span class="line">  kNewFile = <span class="number">7</span>                <span class="comment">// 记录新增的文件信息</span></span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而这些内容都会写到 <code>MANIFEST</code> 之中，在最初的启动逻辑中(以已有的 MANIFEST，恢复需要创建一个新的)，我们从下面的代码就会看到 edit 会负责把记录写到 <code>MANIFEST</code> 中</p>
<figure class="highlight cpp"><figcaption><span>WriteSnapshot</span><a href="https://github.com/google/leveldb/blob/068a0f12148d38204d8231ad2cd03d9cfd5eb3dc/db/version_set.cc#L1070-L1098">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::WriteSnapshot</span><span class="params">(log::Writer* log)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Break up into multiple records to reduce memory usage on recovery?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save metadata</span></span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  edit.<span class="built_in">SetComparatorName</span>(icmp_.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Name</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!compact_pointer_[level].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      InternalKey key;</span><br><span class="line">      key.<span class="built_in">DecodeFrom</span>(compact_pointer_[level]);</span><br><span class="line">      edit.<span class="built_in">SetCompactPointer</span>(level, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="type">const</span> std::vector&lt;FileMetaData*&gt;&amp; files = current_-&gt;files_[level];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> FileMetaData* f = files[i];</span><br><span class="line">      edit.<span class="built_in">AddFile</span>(level, f-&gt;number, f-&gt;file_size, f-&gt;smallest, f-&gt;largest);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string record;</span><br><span class="line">  edit.<span class="built_in">EncodeTo</span>(&amp;record);</span><br><span class="line">  <span class="keyword">return</span> log-&gt;<span class="built_in">AddRecord</span>(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://fastly.jsdelivr.net/gh/yanickxia/picture-bed@master/2022/202208311731014.png" alt=""></p>
<h3 id="Builder"><a class="header-anchor" href="#Builder">¶</a>Builder</h3>
<p>为了完成更新任务，还需要一个辅助类 <code>Builder</code></p>
<p>对于 <code>Builder</code> 最重要的工作就是 下面的 <code>Apply</code></p>
<figure class="highlight cpp"><figcaption><span>Apply</span><a href="https://github.com/google/leveldb/blob/068a0f12148d38204d8231ad2cd03d9cfd5eb3dc/db/version_set.cc#L630-L670">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Apply</span><span class="params">(<span class="type">const</span> VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 更新 压缩指针</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> level = edit-&gt;compact_pointers_[i].first;</span><br><span class="line">    vset_-&gt;compact_pointer_[level] =</span><br><span class="line">        edit-&gt;compact_pointers_[i].second.<span class="built_in">Encode</span>().<span class="built_in">ToString</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除不存在的文件</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">    levels_[level].deleted_files.<span class="built_in">insert</span>(number);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增加新增的文件</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">    FileMetaData* f = <span class="keyword">new</span> <span class="built_in">FileMetaData</span>(edit-&gt;new_files_[i].second);</span><br><span class="line">    f-&gt;refs = <span class="number">1</span>;</span><br><span class="line">    f-&gt;allowed_seeks = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>));</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    levels_[level].deleted_files.<span class="built_in">erase</span>(f-&gt;number);</span><br><span class="line">    levels_[level].added_files-&gt;<span class="built_in">insert</span>(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><figcaption><span>SaveTo</span><a href="https://github.com/google/leveldb/blob/068a0f12148d38204d8231ad2cd03d9cfd5eb3dc/db/version_set.cc#L673-L698">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Builder::SaveTo</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">    BySmallestKey cmp;</span><br><span class="line">    cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">        <span class="comment">// 拿出原本Version里的文件，以及Builder里累积的，添加的文件</span></span><br><span class="line">        <span class="type">const</span> std::vector&lt;FileMetaData*&gt;&amp; base_files = base_-&gt;files_[level];</span><br><span class="line">        std::vector&lt;FileMetaData*&gt;::const_iterator base_iter = base_files.<span class="built_in">begin</span>();</span><br><span class="line">        std::vector&lt;FileMetaData*&gt;::const_iterator base_end = base_files.<span class="built_in">end</span>();</span><br><span class="line">        <span class="type">const</span> FileSet* added_files = levels_[level].added_files;</span><br><span class="line">        v-&gt;files_[level].<span class="built_in">reserve</span>(base_files.<span class="built_in">size</span>() + added_files-&gt;<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">// 按顺序进行合并</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; added_file : *added_files) &#123;</span><br><span class="line">            <span class="comment">// 找到base里面比added_file小的文件，添加到新的Version里</span></span><br><span class="line">            <span class="comment">// 采用MaybeAddFile，让被删除的文件无法添加</span></span><br><span class="line">            <span class="keyword">for</span> (std::vector&lt;FileMetaData*&gt;::const_iterator bpos =</span><br><span class="line">                    std::<span class="built_in">upper_bound</span>(base_iter, base_end, added_file, cmp);</span><br><span class="line">                base_iter != bpos; ++base_iter) &#123;</span><br><span class="line">                <span class="built_in">MaybeAddFile</span>(v, level, *base_iter);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">MaybeAddFile</span>(v, level, added_file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加剩下的文件</span></span><br><span class="line">        <span class="keyword">for</span> (; base_iter != base_end; ++base_iter) &#123;</span><br><span class="line">            <span class="built_in">MaybeAddFile</span>(v, level, *base_iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里显然有一个问题，随着系统的长时间运行，我们的 <code>MANIFEST</code> 显然会越来越大，随着时间的流逝，早期的版本是没有意义的，我们没必要还原所有的版本的情况，我们只需要还原还活着的版本的信息。MANIFEST只有一个机会变小，抛弃早期过时的VersionEdit，给当前的VersionSet来个快照，然后从新的起点开始累加VerisonEdit。这个机会就是重新开启DB。在后续的 <code>Recover</code> 里面再聊聊</p>
<h3 id="流程"><a class="header-anchor" href="#流程">¶</a>流程</h3>
<p>版本变迁的逻辑主要是在 <code>VersionSet::LogAndApply</code> 中</p>
<figure class="highlight cpp"><figcaption><span>LogAndApply</span><a href="https://github.com/google/leveldb/blob/068a0f12148d38204d8231ad2cd03d9cfd5eb3dc/db/version_set.cc#L778-L860">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设定当前的log number</span></span><br><span class="line">  <span class="keyword">if</span> (edit-&gt;has_log_number_) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(edit-&gt;log_number_ &gt;= log_number_);</span><br><span class="line">    <span class="built_in">assert</span>(edit-&gt;log_number_ &lt; next_file_number_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    edit-&gt;<span class="built_in">SetLogNumber</span>(log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) &#123;</span><br><span class="line">    edit-&gt;<span class="built_in">SetPrevLogNumber</span>(prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设定当前的next_file_number和last_sequence，这些都会被持久化到MANIFEST</span></span><br><span class="line">  edit-&gt;<span class="built_in">SetNextFile</span>(next_file_number_);</span><br><span class="line">  edit-&gt;<span class="built_in">SetLastSequence</span>(last_sequence_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个新版本，新版本是current_和edit的结合</span></span><br><span class="line">  Version* v = <span class="keyword">new</span> <span class="built_in">Version</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">    builder.<span class="built_in">Apply</span>(edit);</span><br><span class="line">    builder.<span class="built_in">SaveTo</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Finalize</span>(v);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入比较吃 磁盘的 MANIFEST 日志</span></span><br><span class="line">  &#123;</span><br><span class="line">    mu-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      std::string record;</span><br><span class="line">      <span class="comment">// 在这里写入文件</span></span><br><span class="line">      edit-&gt;<span class="built_in">EncodeTo</span>(&amp;record);</span><br><span class="line">      s = descriptor_log_-&gt;<span class="built_in">AddRecord</span>(record);</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        s = descriptor_file_-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="built_in">Log</span>(options_-&gt;info_log, <span class="string">&quot;MANIFEST write: %s\n&quot;</span>, s.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里更新了 Current 文件，指向对应的 MANIFEST</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; !new_manifest_file.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      s = <span class="built_in">SetCurrentFile</span>(env_, dbname_, manifest_file_number_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mu-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 安装新版本，会把v放到VersionSet的链表中，然后将当前Version指向v</span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">AppendVersion</span>(v);</span><br><span class="line">    log_number_ = edit-&gt;log_number_;</span><br><span class="line">    prev_log_number_ = edit-&gt;prev_log_number_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">    <span class="keyword">if</span> (!new_manifest_file.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">      descriptor_log_ = <span class="literal">nullptr</span>;</span><br><span class="line">      descriptor_file_ = <span class="literal">nullptr</span>;</span><br><span class="line">      env_-&gt;<span class="built_in">RemoveFile</span>(new_manifest_file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实从流程看还是比较的清晰的，在当前的 <code>VersionSet</code> 上，通过 <code>VersionEdit</code> 和 <code>Builder</code> 创建一个新的 <code>Version</code> 并且更新 <code>MANIFEST</code> 就是更新的事情，那问题又随之到来，那 <code>VersionEdit</code> 是怎么创建出来的呢？这里就涉及到我们下面的那个知识点了。</p>
<h2 id="Compaction"><a class="header-anchor" href="#Compaction">¶</a>Compaction</h2>
<ol>
<li>当 <code>MemTable</code> 写满后，需要将 <code>MemTable</code> 的数据写入磁盘，生成一个 <code>Level 0</code> 的 <code>SSTable</code></li>
<li><code>Level 0</code> 的 <code>SSTable</code> 的键范围可能有重叠</li>
<li><code>Compaction</code> 将 <code>Level 0</code> 的 <code>SSTable</code> 推向 <code>Level 1</code>，使得 <code>Level 0</code> 的 <code>SSTable</code> 数量保持在一个较低的水平；</li>
<li><code>Level 1</code> 的文件数量可能太多，导致一次 <code>Compaction</code> 消耗太多磁盘 <code>IO</code> ，所以需要将 <code>Level 1</code> 的文件继续 <code>Compaction</code> 到更高 <code>Level</code> 去。</li>
</ol>
<p><img src="https://fastly.jsdelivr.net/gh/yanickxia/picture-bed@master/2022/202208311938767.png" alt=""></p>
<ul>
<li>Level0 -&gt; Level1: 因为 Key 可能重叠，采用多路归并，最终 <code>Level 1</code> 的文件依然是有序并且无重叠的</li>
<li>Level n -&gt; Level n + 1： 选择一个文件进行Compaction时，不可能有其它同层的文件有重叠，所以只需要一个文件即可，然后选择Level n + 1和Level n有重叠的文件，后面的步骤都是一样的。</li>
</ul>
<h3 id="Compaction-触发条件"><a class="header-anchor" href="#Compaction-触发条件">¶</a>Compaction 触发条件</h3>
<h4 id="Size-Compaction"><a class="header-anchor" href="#Size-Compaction">¶</a>Size Compaction</h4>
<p>按照 <code>Size</code> 计算每一 <code>Level</code> 实际大小相对于最大大小的比率，优先 <code>Compaction</code> 比率最大的Level。</p>
<figure class="highlight cpp"><figcaption><span>Finalize</span><a href="https://github.com/google/leveldb/blob/068a0f12148d38204d8231ad2cd03d9cfd5eb3dc/db/version_set.cc#L1032-L1068">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VersionSet::Finalize</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="type">int</span> best_level = <span class="number">-1</span>;    <span class="comment">// 最大的比率的Level</span></span><br><span class="line">  <span class="type">double</span> best_score = <span class="number">-1</span>; <span class="comment">// 最大的比率</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Level 0特殊处理，使用文件的个数，而不是大小来确定比率，因为对于大的writer-buffer</span></span><br><span class="line">      <span class="comment">// Level 0的文件会更大，这时候如果限定总大小，Compaction会偏多</span></span><br><span class="line">      <span class="comment">// 对于小的Level 0文件，数量会太多，影响读取的速度</span></span><br><span class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">              <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(config::kL0_CompactionTrigger);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 计算文件总大小相对于最大大小的比率 </span></span><br><span class="line">      <span class="type">const</span> <span class="type">uint64_t</span> level_bytes = <span class="built_in">TotalFileSize</span>(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(level_bytes) / <span class="built_in">MaxBytesForLevel</span>(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将计算得到的最大的score和level赋值，后台线程看到赋值后会开始Compaction</span></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Seek-Compaction"><a class="header-anchor" href="#Seek-Compaction">¶</a>Seek Compaction</h4>
<p>TODO</p>
<h4 id="Compaction实现"><a class="header-anchor" href="#Compaction实现">¶</a>Compaction实现</h4>
<figure class="highlight cpp"><figcaption><span>Compaction</span><a href="https://github.com/google/leveldb/blob/54340b4a1020737e17ae4efacc31afeb53022be9/db/version_set.h#L319-L391">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compaction</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> level_;                      <span class="comment">// Compaction文件所在的Level</span></span><br><span class="line">    <span class="type">uint64_t</span> max_output_file_size_;  <span class="comment">// 生成的文件的最大值</span></span><br><span class="line">    Version* input_version_;         <span class="comment">// Compaction发生时的Version</span></span><br><span class="line">    VersionEdit edit_;               <span class="comment">// Compaction结果保存的VersionEdit</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;FileMetaData*&gt; inputs_[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然 inputs 最多涉及到 <code>level</code> 和 <code>level+1</code>，具体的逻辑在  <code>DoCompactionWork</code> 中</p>
<figure class="highlight cpp"><figcaption><span>DoCompactionWork</span><a href="https://github.com/google/leveldb/blob/8f1861462b27727dfc5b2c4687112108e6ba88eb/db/db_impl.cc#L892-L1051">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::DoCompactionWork</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> start_micros = env_-&gt;<span class="built_in">NowMicros</span>();</span><br><span class="line">  <span class="type">int64_t</span> imm_micros = <span class="number">0</span>;  <span class="comment">// Micros spent doing imm_ compactions</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取当前最小的使用中的SequenceNumber</span></span><br><span class="line">  <span class="keyword">if</span> (snapshots_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    compact-&gt;smallest_snapshot = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compact-&gt;smallest_snapshot = snapshots_.<span class="built_in">oldest</span>()-&gt;<span class="built_in">sequence_number</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参与Compaction的SSTable组成一个迭代器</span></span><br><span class="line">  <span class="comment">// MakeInputIterator 代码比较简单就不看了, 这里值得主要的就是 如果 Level0 就得把所有的 Level0 文件都带上···</span></span><br><span class="line">  Iterator* input = versions_-&gt;<span class="built_in">MakeInputIterator</span>(compact-&gt;compaction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release mutex while we&#x27;re actually doing the compaction work</span></span><br><span class="line">  mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">  input-&gt;<span class="built_in">SeekToFirst</span>();</span><br><span class="line">  Status status;</span><br><span class="line">  ParsedInternalKey ikey;</span><br><span class="line">  std::string current_user_key;  <span class="comment">// 记录当前的User Key</span></span><br><span class="line">  <span class="type">bool</span> has_current_user_key = <span class="literal">false</span>;  <span class="comment">// 记录是否碰到过一个同样的User Key</span></span><br><span class="line">  SequenceNumber last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">  <span class="keyword">while</span> (input-&gt;<span class="built_in">Valid</span>() &amp;&amp; !shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// Prioritize immutable compaction work</span></span><br><span class="line">    <span class="keyword">if</span> (has_imm_.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">uint64_t</span> imm_start = env_-&gt;<span class="built_in">NowMicros</span>();</span><br><span class="line">      mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果还有 imm 的存在，先处理 imm 到 sstable</span></span><br><span class="line">        <span class="built_in">CompactMemTable</span>();</span><br><span class="line">        background_work_finished_signal_.<span class="built_in">SignalAll</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">      imm_micros += (env_-&gt;<span class="built_in">NowMicros</span>() - imm_start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Slice key = input-&gt;<span class="built_in">key</span>();</span><br><span class="line">    <span class="comment">// 当前输出文件的构建是否应该在指定key之前停下，若到达指定key时当前输出文件与level+2层的文件重合的内容数量超出阈值，则新起一个输出文件。</span></span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;compaction-&gt;<span class="built_in">ShouldStopBefore</span>(key) &amp;&amp;</span><br><span class="line">        compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建一个新的SSTable，写入文件</span></span><br><span class="line">      status = <span class="built_in">FinishCompactionOutputFile</span>(compact, input);</span><br><span class="line">      <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里要判断这个 Key 是不是要处理，用 drop 来标记</span></span><br><span class="line">    <span class="type">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ParseInternalKey</span>(key, &amp;ikey)) &#123;</span><br><span class="line">      <span class="comment">// Do not hide error keys</span></span><br><span class="line">      current_user_key.<span class="built_in">clear</span>();</span><br><span class="line">      has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">      last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!has_current_user_key ||</span><br><span class="line">          <span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Compare</span>(ikey.user_key, <span class="built_in">Slice</span>(current_user_key)) !=</span><br><span class="line">              <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一次遇见 user key。标记了下当前处理的一些状态</span></span><br><span class="line">        current_user_key.<span class="built_in">assign</span>(ikey.user_key.<span class="built_in">data</span>(), ikey.user_key.<span class="built_in">size</span>());</span><br><span class="line">        has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">        last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果上一个Key的SequenceNumber &lt;= 最小的存活的Snapshot，这个Key就不会被任何线程看到了，可以被丢弃</span></span><br><span class="line">      <span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;</span><br><span class="line">        <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">        drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line">                 ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">                 compact-&gt;compaction-&gt;<span class="built_in">IsBaseLevelForKey</span>(ikey.user_key)) &#123;</span><br><span class="line">        <span class="comment">// 如果碰到了一个删除操作，并且SequenceNumber &lt;= 最小的Snapshot，</span></span><br><span class="line">        <span class="comment">// 通过IsBaseLevelForKey判断更高Level不会有这个User Key存在，那么这个Key就被丢弃</span></span><br><span class="line">        drop = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      last_sequence_for_key = ikey.sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">      <span class="comment">// Open output file if necessary</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        status = <span class="built_in">OpenCompactionOutputFile</span>(compact);</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;<span class="built_in">NumEntries</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        compact-&gt;<span class="built_in">current_output</span>()-&gt;smallest.<span class="built_in">DecodeFrom</span>(key);</span><br><span class="line">      &#125;</span><br><span class="line">      compact-&gt;<span class="built_in">current_output</span>()-&gt;largest.<span class="built_in">DecodeFrom</span>(key);</span><br><span class="line">      compact-&gt;builder-&gt;<span class="built_in">Add</span>(key, input-&gt;<span class="built_in">value</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 达到文件大小，就写入文件，生成新文件</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;<span class="built_in">FileSize</span>() &gt;=</span><br><span class="line">          compact-&gt;compaction-&gt;<span class="built_in">MaxOutputFileSize</span>()) &#123;</span><br><span class="line">        status = <span class="built_in">FinishCompactionOutputFile</span>(compact, input);</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input-&gt;<span class="built_in">Next</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// 创建压缩的结果对象，下解释</span></span><br><span class="line">    status = <span class="built_in">InstallCompactionResults</span>(compact);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将变更的记录都放到 edit 里面，然后触发 LogAndApply</span></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::InstallCompactionResults</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="comment">// Add compaction outputs</span></span><br><span class="line">  compact-&gt;compaction-&gt;<span class="built_in">AddInputDeletions</span>(compact-&gt;compaction-&gt;<span class="built_in">edit</span>());</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> level = compact-&gt;compaction-&gt;<span class="built_in">level</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="type">const</span> CompactionState::Output&amp; out = compact-&gt;outputs[i];</span><br><span class="line">    compact-&gt;compaction-&gt;<span class="built_in">edit</span>()-&gt;<span class="built_in">AddFile</span>(level + <span class="number">1</span>, out.number, out.file_size,</span><br><span class="line">                                         out.smallest, out.largest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> versions_-&gt;<span class="built_in">LogAndApply</span>(compact-&gt;compaction-&gt;<span class="built_in">edit</span>(), &amp;mutex_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Recover"><a class="header-anchor" href="#Recover">¶</a>Recover</h2>
<p><img src="https://fastly.jsdelivr.net/gh/yanickxia/picture-bed@master/2022/202209011722512.png" alt=""></p>
<ul>
<li>如果数据库目录不存在，创建目录；</li>
<li>加文件锁，锁住整个数据库；</li>
<li>读取 <code>MANIFEST</code> 文件，恢复系统关闭时的元数据，也就是版本信息，或者新建MAINFEST文件；</li>
<li>如果上一次关闭时，<code>MemTable</code> 里有数据，或者 <code>Immutable</code> <code>MemTable</code> 写入到 <code>SSTable</code> 未完成，那么需要做数据恢复，从 <code>WAL</code> 恢复数据；</li>
<li>创建数据库相关的内存数据结构，如 <code>Version</code>、<code>VersionSet</code> 等。</li>
</ul>
<figure class="highlight cpp"><figcaption><span>Recover</span><a href="https://github.com/google/leveldb/blob/8f1861462b27727dfc5b2c4687112108e6ba88eb/db/db_impl.cc#L292-L383">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Recover</span><span class="params">(VersionEdit* edit, <span class="type">bool</span>* save_manifest)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建数据库目录</span></span><br><span class="line">  env_-&gt;<span class="built_in">CreateDir</span>(dbname_);</span><br><span class="line">  <span class="built_in">assert</span>(db_lock_ == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 文件锁，禁止多进程的操作</span></span><br><span class="line">  Status s = env_-&gt;<span class="built_in">LockFile</span>(<span class="built_in">LockFileName</span>(dbname_), &amp;db_lock_);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 干净的就创建一个单独的 DB，不然就 恢复</span></span><br><span class="line">  <span class="keyword">if</span> (!env_-&gt;<span class="built_in">FileExists</span>(<span class="built_in">CurrentFileName</span>(dbname_))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options_.create_if_missing) &#123;</span><br><span class="line">      <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Creating DB %s since it was missing.&quot;</span>,</span><br><span class="line">          dbname_.<span class="built_in">c_str</span>());</span><br><span class="line">      s = <span class="built_in">NewDB</span>();</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">InvalidArgument</span>(</span><br><span class="line">          dbname_, <span class="string">&quot;does not exist (create_if_missing is false)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (options_.error_if_exists) &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">InvalidArgument</span>(dbname_,</span><br><span class="line">                                     <span class="string">&quot;exists (error_if_exists is true)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  从 Manifest 恢复最后的版本</span></span><br><span class="line">  s = versions_-&gt;<span class="built_in">Recover</span>(save_manifest);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">SequenceNumber <span class="title">max_sequence</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 之前的MANIFEST恢复，会得到版本信息，里面包含了之前的log number</span></span><br><span class="line">  <span class="comment">// 搜索文件系统里的log，如果这些日志的编号 &gt;= 这个log number，那么这些</span></span><br><span class="line">  <span class="comment">// 日志都是关闭时丢失的数据，需要恢复，这里将日志按顺序存储在logs里面</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> min_log = versions_-&gt;<span class="built_in">LogNumber</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> prev_log = versions_-&gt;<span class="built_in">PrevLogNumber</span>();</span><br><span class="line">  std::vector&lt;std::string&gt; filenames;</span><br><span class="line">  s = env_-&gt;<span class="built_in">GetChildren</span>(dbname_, &amp;filenames);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  std::set&lt;<span class="type">uint64_t</span>&gt; expected;</span><br><span class="line">  versions_-&gt;<span class="built_in">AddLiveFiles</span>(&amp;expected);</span><br><span class="line">  <span class="type">uint64_t</span> number;</span><br><span class="line">  FileType type;</span><br><span class="line">  std::vector&lt;<span class="type">uint64_t</span>&gt; logs;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; filenames.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ParseFileName</span>(filenames[i], &amp;number, &amp;type)) &#123;</span><br><span class="line">      expected.<span class="built_in">erase</span>(number);</span><br><span class="line">      <span class="keyword">if</span> (type == kLogFile &amp;&amp; ((number &gt;= min_log) || (number == prev_log)))</span><br><span class="line">        logs.<span class="built_in">push_back</span>(number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!expected.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    std::<span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%d missing files; e.g.&quot;</span>,</span><br><span class="line">                  <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(expected.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(buf, <span class="built_in">TableFileName</span>(dbname_, *(expected.<span class="built_in">begin</span>())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recover in the order in which the logs were generated</span></span><br><span class="line">  std::<span class="built_in">sort</span>(logs.<span class="built_in">begin</span>(), logs.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; logs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    s = <span class="built_in">RecoverLogFile</span>(logs[i], (i == logs.<span class="built_in">size</span>() - <span class="number">1</span>), save_manifest, edit,</span><br><span class="line">                       &amp;max_sequence);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The previous incarnation may not have written any MANIFEST</span></span><br><span class="line">    <span class="comment">// records after allocating this log number.  So we manually</span></span><br><span class="line">    <span class="comment">// update the file number allocation counter in VersionSet.</span></span><br><span class="line">    versions_-&gt;<span class="built_in">MarkFileNumberUsed</span>(logs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (versions_-&gt;<span class="built_in">LastSequence</span>() &lt; max_sequence) &#123;</span><br><span class="line">    versions_-&gt;<span class="built_in">SetLastSequence</span>(max_sequence);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于系统来说比较重要的恢复显然是 <code>Recover</code> 的逻辑</p>
<figure class="highlight cpp"><figcaption><span>Recover</span><a href="https://github.com/google/leveldb/blob/068a0f12148d38204d8231ad2cd03d9cfd5eb3dc/db/version_set.cc#L862-L993">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::Recover</span><span class="params">(<span class="type">bool</span>* save_manifest)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">LogReporter</span> : <span class="keyword">public</span> log::Reader::Reporter &#123;</span><br><span class="line">    Status* status;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Corruption</span><span class="params">(<span class="type">size_t</span> bytes, <span class="type">const</span> Status&amp; s)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;status-&gt;<span class="built_in">ok</span>()) *<span class="keyword">this</span>-&gt;status = s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取CURRENT文件的内容，获取当前使用的MANIFEST文件</span></span><br><span class="line">  <span class="comment">// 读取MANIFEST文件，将里面的VersionEdit读取应用到一个builder里</span></span><br><span class="line">  std::string current;</span><br><span class="line">  Status s = <span class="built_in">ReadFileToString</span>(env_, <span class="built_in">CurrentFileName</span>(dbname_), &amp;current);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (current.<span class="built_in">empty</span>() || current[current.<span class="built_in">size</span>() - <span class="number">1</span>] != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;CURRENT file does not end with newline&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  current.<span class="built_in">resize</span>(current.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  std::string dscname = dbname_ + <span class="string">&quot;/&quot;</span> + current;</span><br><span class="line">  SequentialFile* file;</span><br><span class="line">  s = env_-&gt;<span class="built_in">NewSequentialFile</span>(dscname, &amp;file);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">IsNotFound</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;CURRENT points to a non-existent file&quot;</span>,</span><br><span class="line">                                s.<span class="built_in">ToString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> have_log_number = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> have_prev_log_number = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> have_next_file = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> have_last_sequence = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">uint64_t</span> next_file = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> last_sequence = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> log_number = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> prev_log_number = <span class="number">0</span>;</span><br><span class="line">  <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">  <span class="type">int</span> read_records = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Record 挨个的读取</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> file;</span><br><span class="line">  file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!have_next_file) &#123;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;no meta-nextfile entry in descriptor&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!have_log_number) &#123;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;no meta-lognumber entry in descriptor&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!have_last_sequence) &#123;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;no last-sequence-number entry in descriptor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_prev_log_number) &#123;</span><br><span class="line">      prev_log_number = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MarkFileNumberUsed</span>(prev_log_number);</span><br><span class="line">    <span class="built_in">MarkFileNumberUsed</span>(log_number);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    Version* v = <span class="keyword">new</span> <span class="built_in">Version</span>(<span class="keyword">this</span>);</span><br><span class="line">    builder.<span class="built_in">SaveTo</span>(v);</span><br><span class="line">    <span class="comment">// Install recovered version</span></span><br><span class="line">    <span class="built_in">Finalize</span>(v);</span><br><span class="line">    <span class="built_in">AppendVersion</span>(v);</span><br><span class="line">    manifest_file_number_ = next_file;</span><br><span class="line">    next_file_number_ = next_file + <span class="number">1</span>;</span><br><span class="line">    last_sequence_ = last_sequence;</span><br><span class="line">    log_number_ = log_number;</span><br><span class="line">    prev_log_number_ = prev_log_number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if we can reuse the existing MANIFEST file.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ReuseManifest</span>(dscname, current)) &#123;</span><br><span class="line">      <span class="comment">// No need to save new manifest</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *save_manifest = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::string error = s.<span class="built_in">ToString</span>();</span><br><span class="line">    <span class="built_in">Log</span>(options_-&gt;info_log, <span class="string">&quot;Error recovering version set with %d records: %s&quot;</span>,</span><br><span class="line">        read_records, error.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考-推荐阅读"><a class="header-anchor" href="#参考-推荐阅读">¶</a>参考 &amp; 推荐阅读</h2>
<ul>
<li><a href="https://wiesen.github.io/post/leveldb-introduction/">Leveldb: Introduction</a></li>
<li><a href="https://www.zhihu.com/column/c_1282795241104465920">LevelDB源码剖析</a></li>
<li><a href="https://leveldb-handbook.readthedocs.io/zh/latest/index.html">leveldb-handbook</a></li>
<li><a href="https://bean-li.github.io/leveldb-manifest/">leveldb之MANIFEST</a></li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://www.zhihu.com/column/c_1282795241104465920">LevelDB源码剖析</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>database</category>
        <category>leveldb</category>
        <category>kv</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>leveldb</tag>
        <tag>kv</tag>
      </tags>
  </entry>
  <entry>
    <title>Isito Pliot 代码大全</title>
    <url>/2022/10/21/networking/istio/how-it-works/istio-complete/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2022/202210211117213.png" alt=""></p>
<p>虽然起了一个很大的标题，有点标题党的意思，但是本篇会覆盖大多数 <code>istio pliot</code> 的功能，可以耐着性子看下去。</p>
<p>我们在对 istio 有一个初步了解的情况下，我们很容易得知，istio 的整个抽象架构就是一个标准的 CS 模型，对于我们需要解答的就是 istio 是如何将那些配置项和k8s的运行状态，转为 Envoy 所需要使用的数据结构的。</p>
<span id="more"></span>
<p>那这里我们分成 4 个部分来阐述</p>
<ul>
<li>数据模型  istio 内部是如何存储数据的</li>
<li>数据源 istio 使用到的数据是如何获取的，涵盖 MCP 是怎么工作的</li>
<li>XdsResourceGenerator  istio 是如何将数据转为 Envoy 需要的数据结构的</li>
<li>XDS  istiod 是如何作为一个 xDS Server 和 Envoy 进行通讯的</li>
</ul>
<figure class="highlight go"><figcaption><span>Server</span><a href="https://github.com/istio/istio/blob/60c49981cf3c6d7985542ff8d17e8f78ecef6d27/pilot/pkg/bootstrap/server.go#L113-L189">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 实现的 XDS 服务，和 Envoy 进行通讯, 在 [XDS] 章节中涉及</span></span><br><span class="line">    XDSServer *xds.DiscoveryServer</span><br><span class="line"></span><br><span class="line">    clusterID   cluster.ID</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前环境信息</span></span><br><span class="line">    environment *model.Environment</span><br><span class="line"></span><br><span class="line">    kubeClient kubelib.Client</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Istio 各种数据源，在 [数据源] 章节涉及</span></span><br><span class="line">    multiclusterController *multicluster.Controller</span><br><span class="line">    configController  model.ConfigStoreCache</span><br><span class="line">    ConfigStores      []model.ConfigStoreCache</span><br><span class="line">    serviceEntryStore *serviceentry.ServiceEntryStore</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// RWConfigStore is the configstore which allows updates, particularly for status.</span></span><br><span class="line">    RWConfigStore model.ConfigStoreCache</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据模型"><a class="header-anchor" href="#数据模型">¶</a>数据模型</h2>
<p>学习一个系统的最佳方式大概就是阅读它的数据结构。这部分的代码都在   <code>pilot/pkg/model</code> 这个目录下。</p>
<p>对于 istio 系统来说，最为重要的数据来源就是</p>
<ul>
<li>Service | ServiceEntry 这两者会转为为 model.Service</li>
<li>POD | workloadEntry 这两者转为 model.WorkloadInstance</li>
<li>Enpoints | EndpointSlice 转为 model.ServiceInstance</li>
</ul>
<p>这些对象都在后续的构建 XDS 协议上，大量的被使用。</p>
<h3 id="Service"><a class="header-anchor" href="#Service">¶</a>Service</h3>
<p>对于 K8s Service 和 ServiceEntry 都会转为下述代码的 model.Service 的模型</p>
<figure class="highlight go"><figcaption><span>Service</span><a href="https://github.com/istio/istio/blob/4f5b41f609296f901cbfb850ccea5f24a28c9bca/pilot/pkg/model/service.go#L59-L111">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Attributes contains additional attributes associated with the service</span></span><br><span class="line">    <span class="comment">// used mostly by RBAC for policy enforcement purposes.</span></span><br><span class="line">    Attributes ServiceAttributes</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ports is the set of network ports where the service is listening for</span></span><br><span class="line">    <span class="comment">// connections</span></span><br><span class="line">    Ports PortList <span class="string">`json:&quot;ports,omitempty&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServiceAccounts specifies the service accounts that run the service.</span></span><br><span class="line">    ServiceAccounts []<span class="type">string</span> <span class="string">`json:&quot;serviceAccounts,omitempty&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// CreationTime records the time this service was created, if available.</span></span><br><span class="line">    CreationTime time.Time <span class="string">`json:&quot;creationTime,omitempty&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Name of the service, e.g. &quot;catalog.mystore.com&quot;</span></span><br><span class="line">    Hostname host.Name <span class="string">`json:&quot;hostname&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ClusterVIPs specifies the service address of the load balancer</span></span><br><span class="line">    <span class="comment">// in each of the clusters where the service resides</span></span><br><span class="line">    ClusterVIPs AddressMap <span class="string">`json:&quot;clusterVIPs,omitempty&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// DefaultAddress specifies the default service IP of the load balancer.</span></span><br><span class="line">    <span class="comment">// Do not access directly. Use GetAddressForProxy</span></span><br><span class="line">    DefaultAddress <span class="type">string</span> <span class="string">`json:&quot;defaultAddress,omitempty&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// AutoAllocatedAddress specifies the automatically allocated</span></span><br><span class="line">    <span class="comment">// IPv4 address out of the reserved Class E subnet</span></span><br><span class="line">    <span class="comment">// (240.240.0.0/16) for service entries with non-wildcard</span></span><br><span class="line">    <span class="comment">// hostnames. The IPs assigned to services are not</span></span><br><span class="line">    <span class="comment">// synchronized across istiod replicas as the DNS resolution</span></span><br><span class="line">    <span class="comment">// for these service entries happens completely inside a pod</span></span><br><span class="line">    <span class="comment">// whose proxy is managed by one istiod. That said, the algorithm</span></span><br><span class="line">    <span class="comment">// to allocate IPs is pretty deterministic that at stable state, two</span></span><br><span class="line">    <span class="comment">// istiods will allocate the exact same set of IPs for a given set of</span></span><br><span class="line">    <span class="comment">// service entries.</span></span><br><span class="line">    AutoAllocatedAddress <span class="type">string</span> <span class="string">`json:&quot;autoAllocatedAddress,omitempty&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resolution indicates how the service instances need to be resolved before routing</span></span><br><span class="line">    <span class="comment">// traffic. Most services in the service registry will use static load balancing wherein</span></span><br><span class="line">    <span class="comment">// the proxy will decide the service instance that will receive the traffic. Service entries</span></span><br><span class="line">    <span class="comment">// could either use DNS load balancing (i.e. proxy will query DNS server for the IP of the service)</span></span><br><span class="line">    <span class="comment">// or use the passthrough model (i.e. proxy will forward the traffic to the network endpoint requested</span></span><br><span class="line">    <span class="comment">// by the caller)</span></span><br><span class="line">    Resolution Resolution</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MeshExternal (if true) indicates that the service is external to the mesh.</span></span><br><span class="line">    <span class="comment">// These services are defined using Istio&#x27;s ServiceEntry spec.</span></span><br><span class="line">    MeshExternal <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ResourceVersion represents the internal version of this object.</span></span><br><span class="line">    ResourceVersion <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Convert"><a class="header-anchor" href="#Convert">¶</a>Convert</h4>
<ol>
<li>从 K8s Serivce 转为 model.Service 的逻辑在 ConvertService 中</li>
</ol>
<figure class="highlight go"><figcaption><span>Convert</span><a href="https://github.com/istio/istio/blob/8ce0defcc905873dadf3fa1d8c3f3629cd39895c/pilot/pkg/serviceregistry/kube/conversion.go#L56-L73">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConvertService</span><span class="params">(svc coreV1.Service, domainSuffix <span class="type">string</span>, clusterID cluster.ID)</span></span> *model.Service &#123;</span><br><span class="line">    addr := constants.UnspecifiedIP</span><br><span class="line">    resolution := model.ClientSideLB</span><br><span class="line">    meshExternal := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    ports := <span class="built_in">make</span>([]*model.Port, <span class="number">0</span>, <span class="built_in">len</span>(svc.Spec.Ports))</span><br><span class="line">    <span class="keyword">for</span> _, port := <span class="keyword">range</span> svc.Spec.Ports &#123;</span><br><span class="line">        ports = <span class="built_in">append</span>(ports, convertPort(port))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    istioService := &amp;model.Service&#123;</span><br><span class="line">        <span class="comment">// 转为 FQDN </span></span><br><span class="line">        Hostname: ServiceHostname(svc.Name, svc.Namespace, domainSuffix),</span><br><span class="line">        ClusterVIPs: model.AddressMap&#123;</span><br><span class="line">            Addresses: <span class="keyword">map</span>[cluster.ID][]<span class="type">string</span>&#123;</span><br><span class="line">                clusterID: &#123;addr&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        Ports:           ports,</span><br><span class="line">        DefaultAddress:  addr,</span><br><span class="line">        ServiceAccounts: serviceaccounts,</span><br><span class="line">        MeshExternal:    meshExternal,</span><br><span class="line">        Resolution:      resolution,</span><br><span class="line">        CreationTime:    svc.CreationTimestamp.Time,</span><br><span class="line">        ResourceVersion: svc.ResourceVersion,</span><br><span class="line">        Attributes: model.ServiceAttributes&#123;</span><br><span class="line">            ServiceRegistry: provider.Kubernetes,</span><br><span class="line">            Name:            svc.Name,</span><br><span class="line">            Namespace:       svc.Namespace,</span><br><span class="line">            Labels:          svc.Labels,</span><br><span class="line">            ExportTo:        exportTo,</span><br><span class="line">            LabelSelectors:  svc.Spec.Selector,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> istioService</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多参考<a href="https://github.com/istio/istio/blob/8ce0defcc905873dadf3fa1d8c3f3629cd39895c/pilot/pkg/serviceregistry/kube/conversion_test.go#L130-L229">单侧</a></p>
<ol start="2">
<li>从 ServiceEntry 转化</li>
</ol>
<figure class="highlight go"><figcaption><span>convertServices</span><a href="https://github.com/istio/istio/blob/c88d0356096bdf45c431a2a8389994d9a4d51c31/pilot/pkg/serviceregistry/serviceentry/conversion.go#L146-L204">githhub</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// convertServices transforms a ServiceEntry config to a list of internal Service objects.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertServices</span><span class="params">(cfg config.Config)</span></span> []*model.Service &#123;</span><br><span class="line">    serviceEntry := cfg.Spec.(*networking.ServiceEntry)</span><br><span class="line">    creationTime := cfg.CreationTimestamp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resolution model.Resolution</span><br><span class="line">    <span class="keyword">switch</span> serviceEntry.Resolution &#123;</span><br><span class="line">    <span class="keyword">case</span> networking.ServiceEntry_NONE:</span><br><span class="line">        resolution = model.Passthrough</span><br><span class="line">    <span class="keyword">case</span> networking.ServiceEntry_DNS:</span><br><span class="line">        resolution = model.DNSLB</span><br><span class="line">    <span class="keyword">case</span> networking.ServiceEntry_DNS_ROUND_ROBIN:</span><br><span class="line">        resolution = model.DNSRoundRobinLB</span><br><span class="line">    <span class="keyword">case</span> networking.ServiceEntry_STATIC:</span><br><span class="line">        resolution = model.ClientSideLB</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    svcPorts := <span class="built_in">make</span>(model.PortList, <span class="number">0</span>, <span class="built_in">len</span>(serviceEntry.Ports))</span><br><span class="line">    <span class="keyword">for</span> _, port := <span class="keyword">range</span> serviceEntry.Ports &#123;</span><br><span class="line">        svcPorts = <span class="built_in">append</span>(svcPorts, convertPort(port))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> exportTo <span class="keyword">map</span>[visibility.Instance]<span class="type">bool</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(serviceEntry.ExportTo) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        exportTo = <span class="built_in">make</span>(<span class="keyword">map</span>[visibility.Instance]<span class="type">bool</span>)</span><br><span class="line">        <span class="keyword">for</span> _, e := <span class="keyword">range</span> serviceEntry.ExportTo &#123;</span><br><span class="line">            exportTo[visibility.Instance(e)] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> labelSelectors <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">    <span class="keyword">if</span> serviceEntry.WorkloadSelector != <span class="literal">nil</span> &#123;</span><br><span class="line">        labelSelectors = serviceEntry.WorkloadSelector.Labels</span><br><span class="line">    &#125;</span><br><span class="line">    hostAddresses := []*HostAddress&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, hostname := <span class="keyword">range</span> serviceEntry.Hosts &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(serviceEntry.Addresses) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _, address := <span class="keyword">range</span> serviceEntry.Addresses &#123;</span><br><span class="line">                <span class="comment">// Check if address is an IP first because that is the most common case.</span></span><br><span class="line">                <span class="keyword">if</span> net.ParseIP(address) != <span class="literal">nil</span> &#123;</span><br><span class="line">                    hostAddresses = <span class="built_in">append</span>(hostAddresses, &amp;HostAddress&#123;hostname, address&#125;)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ip, network, cidrErr := net.ParseCIDR(address); cidrErr == <span class="literal">nil</span> &#123;</span><br><span class="line">                    newAddress := address</span><br><span class="line">                    ones, zeroes := network.Mask.Size()</span><br><span class="line">                    <span class="keyword">if</span> ones == zeroes &#123;</span><br><span class="line">                        <span class="comment">// /32 mask. Remove the /32 and make it a normal IP address</span></span><br><span class="line">                        newAddress = ip.String()</span><br><span class="line">                    &#125;</span><br><span class="line">                    hostAddresses = <span class="built_in">append</span>(hostAddresses, &amp;HostAddress&#123;hostname, newAddress&#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hostAddresses = <span class="built_in">append</span>(hostAddresses, &amp;HostAddress&#123;hostname, constants.UnspecifiedIP&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buildServices(hostAddresses, cfg.Namespace, svcPorts, serviceEntry.Location, resolution,</span><br><span class="line">        exportTo, labelSelectors, serviceEntry.SubjectAltNames, creationTime, cfg.Labels)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更多参考<a href="https://github.com/istio/istio/blob/8b1867efdfdba15f60d97fd5948c724d46735aa0/pilot/pkg/serviceregistry/serviceentry/servicediscovery_test.go#L1279-L1297">单测</a></p>
<h3 id="Instance"><a class="header-anchor" href="#Instance">¶</a>Instance</h3>
<p>而实例会使用如下定义 <a href="https://github.com/istio/istio/blob/4f5b41f609296f901cbfb850ccea5f24a28c9bca/pilot/pkg/model/service.go#L234-L238">ServiceInstance</a> 和 <a href="https://github.com/istio/istio/blob/4f5b41f609296f901cbfb850ccea5f24a28c9bca/pilot/pkg/model/service.go#L273-L282">WorkloadInstance</a> 两种，后续会提及有什么区别。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更简单的表示</span></span><br><span class="line"><span class="keyword">type</span> ServiceInstance <span class="keyword">struct</span> &#123;</span><br><span class="line">        Service     *Service       <span class="string">`json:&quot;service,omitempty&quot;`</span></span><br><span class="line">        ServicePort *Port          <span class="string">`json:&quot;servicePort,omitempty&quot;`</span></span><br><span class="line">        Endpoint    *IstioEndpoint <span class="string">`json:&quot;endpoint,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用在内部逻辑上，需要更多信息的时候</span></span><br><span class="line"><span class="keyword">type</span> WorkloadInstance <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name      <span class="type">string</span> <span class="string">`json:&quot;name,omitempty&quot;`</span></span><br><span class="line">    Namespace <span class="type">string</span> <span class="string">`json:&quot;namespace,omitempty&quot;`</span></span><br><span class="line">    <span class="comment">// Where the workloadInstance come from, valid values are`Pod` or `WorkloadEntry`</span></span><br><span class="line">    Kind     workloadKind      <span class="string">`json:&quot;kind&quot;`</span></span><br><span class="line">    Endpoint *IstioEndpoint    <span class="string">`json:&quot;endpoint,omitempty&quot;`</span></span><br><span class="line">    PortMap  <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">uint32</span> <span class="string">`json:&quot;portMap,omitempty&quot;`</span></span><br><span class="line">    <span class="comment">// Can only be selected by service entry of DNS type.</span></span><br><span class="line">    DNSServiceEntryOnly <span class="type">bool</span> <span class="string">`json:&quot;dnsServiceEntryOnly,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Convert-v2"><a class="header-anchor" href="#Convert-v2">¶</a>Convert</h4>
<ol>
<li>将 WorkloadEntry 转为 model.ServiceInstance 的采用的是 convertWorkloadInstanceToServiceInstance</li>
</ol>
<figure class="highlight go"><figcaption><span>convertWorkloadInstanceToServiceInstance</span><a href="https://github.com/istio/istio/blob/c88d0356096bdf45c431a2a8389994d9a4d51c31/pilot/pkg/serviceregistry/serviceentry/conversion.go#L351-L380">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertWorkloadInstanceToServiceInstance</span><span class="params">(workloadInstance *model.WorkloadInstance, serviceEntryServices []*model.Service,</span></span></span><br><span class="line"><span class="params"><span class="function">    serviceEntry *networking.ServiceEntry)</span></span> []*model.ServiceInstance &#123;</span><br><span class="line">    out := <span class="built_in">make</span>([]*model.ServiceInstance, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> _, service := <span class="keyword">range</span> serviceEntryServices &#123;</span><br><span class="line">        <span class="keyword">for</span> _, serviceEntryPort := <span class="keyword">range</span> serviceEntry.Ports &#123;</span><br><span class="line">            <span class="comment">// note: this is same as workloadentry handler</span></span><br><span class="line">            <span class="comment">// endpoint port will first use the port defined in wle with same port name,</span></span><br><span class="line">            <span class="comment">// if not port name does not match, use the targetPort specified in ServiceEntry</span></span><br><span class="line">            <span class="comment">// if both not matched, fallback to ServiceEntry port number.</span></span><br><span class="line">            <span class="keyword">var</span> targetPort <span class="type">uint32</span></span><br><span class="line">            <span class="keyword">if</span> port, ok := workloadInstance.PortMap[serviceEntryPort.Name]; ok &amp;&amp; port &gt; <span class="number">0</span> &#123;</span><br><span class="line">                targetPort = port</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> serviceEntryPort.TargetPort &gt; <span class="number">0</span> &#123;</span><br><span class="line">                targetPort = serviceEntryPort.TargetPort</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                targetPort = serviceEntryPort.Number</span><br><span class="line">            &#125;</span><br><span class="line">            ep := *workloadInstance.Endpoint</span><br><span class="line">            ep.ServicePortName = serviceEntryPort.Name</span><br><span class="line">            ep.EndpointPort = targetPort</span><br><span class="line">            ep.EnvoyEndpoint = <span class="literal">nil</span></span><br><span class="line">            out = <span class="built_in">append</span>(out, &amp;model.ServiceInstance&#123;</span><br><span class="line">                Endpoint:    &amp;ep,</span><br><span class="line">                Service:     service,</span><br><span class="line">                ServicePort: convertPort(serviceEntryPort),</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>从 POD 转为 WorkloadInstace</li>
</ol>
<figure class="highlight go"><figcaption><span>Builder</span><a href="https://github.com/istio/istio/blob/6f258dc65d418fb60bc8099db8abc0927002ce11/pilot/pkg/serviceregistry/kube/controller/pod.go#L171-L178">github</a></figcaption><table><tr><td class="code"><pre><span class="line">ep := NewEndpointBuilder(pc.c, pod).buildIstioEndpoint(pod.Status.PodIP, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, model.AlwaysDiscoverable)</span><br><span class="line">    workloadInstance := &amp;model.WorkloadInstance&#123;</span><br><span class="line">        Name:      pod.Name,</span><br><span class="line">        Namespace: pod.Namespace,</span><br><span class="line">        Kind:      model.PodKind,</span><br><span class="line">        Endpoint:  ep,</span><br><span class="line">        PortMap:   getPortMap(pod),</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>从 Entpoint 转为 ServiceInstance</li>
</ol>
<figure class="highlight go"><figcaption><span>buildEnpoints</span><a href="https://github.com/istio/istio/blob/1c82a227a4e258b0db9bb2922484dbd277fd79ac/pilot/pkg/serviceregistry/kube/controller/endpoints.go#L195-L217">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpointsController)</span></span> buildIstioEndpoints(endpoint <span class="keyword">interface</span>&#123;&#125;, host host.Name) []*model.IstioEndpoint &#123;</span><br><span class="line">    <span class="keyword">var</span> endpoints []*model.IstioEndpoint</span><br><span class="line">    ep := endpoint.(*v1.Endpoints)</span><br><span class="line"></span><br><span class="line">    discoverabilityPolicy := e.c.exports.EndpointDiscoverabilityPolicy(e.c.GetService(host))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, ss := <span class="keyword">range</span> ep.Subsets &#123;</span><br><span class="line">        <span class="keyword">for</span> _, ea := <span class="keyword">range</span> ss.Addresses &#123;</span><br><span class="line">            pod, expectedPod := getPod(e.c, ea.IP, &amp;metav1.ObjectMeta&#123;Name: ep.Name, Namespace: ep.Namespace&#125;, ea.TargetRef, host)</span><br><span class="line">            <span class="keyword">if</span> pod == <span class="literal">nil</span> &amp;&amp; expectedPod &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            builder := NewEndpointBuilder(e.c, pod)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// EDS and ServiceEntry use name for service port - ADS will need to map to numbers.</span></span><br><span class="line">            <span class="keyword">for</span> _, port := <span class="keyword">range</span> ss.Ports &#123;</span><br><span class="line">                istioEndpoint := builder.buildIstioEndpoint(ea.IP, port.Port, port.Name, discoverabilityPolicy)</span><br><span class="line">                endpoints = <span class="built_in">append</span>(endpoints, istioEndpoint)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> endpoints</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据源"><a class="header-anchor" href="#数据源">¶</a>数据源</h2>
<p>本章节主要阐述，大多数日常操作的 CR 资源如</p>
<ul>
<li>VirtualService [istio资源]</li>
<li>Service [k8s资源]</li>
</ul>
<p>是如何在 Istio 存储并被使用的</p>
<p>Istio 的数据大致分为2种类型，</p>
<ul>
<li>Config 类型的：也就是 VirtualService 之类的配置</li>
<li>Data 类型的：也就是运行期的 Service POD 之类的</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2022/202210211128395.png" alt=""></p>
<p>在系统的启动之初就明确的得知，系统有三个部分的 资源 Controller</p>
<figure class="highlight go"><figcaption><span>initControllers</span><a href="https://github.com/istio/istio/blob/60c49981cf3c6d7985542ff8d17e8f78ecef6d27/pilot/pkg/bootstrap/server.go#L1075-L1091">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// initControllers initializes the controllers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> initControllers(args *PilotArgs) <span class="type">error</span> &#123;</span><br><span class="line">    log.Info(<span class="string">&quot;initializing controllers&quot;</span>)</span><br><span class="line">    s.initMulticluster(args)</span><br><span class="line">    <span class="comment">// Certificate controller is created before MCP controller in case MCP server pod</span></span><br><span class="line">    <span class="comment">// waits to mount a certificate to be provisioned by the certificate controller.</span></span><br><span class="line">    <span class="keyword">if</span> err := s.initCertController(args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error initializing certificate controller: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置类 Controller</span></span><br><span class="line">    <span class="keyword">if</span> err := s.initConfigController(args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error initializing config controller: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Data 数据类 Controller</span></span><br><span class="line">    <span class="keyword">if</span> err := s.initServiceControllers(args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error initializing service controllers: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Config-类数据源"><a class="header-anchor" href="#Config-类数据源">¶</a>Config 类数据源</h3>
<p>代码大多数在 pkg/config 这个目录下，在启动的时候我们就看到端倪，支持</p>
<ul>
<li>File 文件类型</li>
<li>XDS xds 服务类型</li>
<li>k8s k8s 类型</li>
</ul>
<figure class="highlight go"><figcaption><span>initConfigSources</span><a href="https://github.com/istio/istio/blob/a3050945ccb797d6aeafaaad30f6a34b9148b7a5/pilot/pkg/bootstrap/configcontroller.go#L222-L285">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> initConfigSources(args *PilotArgs) (err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, configSource := <span class="keyword">range</span> s.environment.Mesh().ConfigSources &#123;</span><br><span class="line">        srcAddress, err := url.Parse(configSource.Address)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid config URL %s %v&quot;</span>, configSource.Address, err)</span><br><span class="line">        &#125;</span><br><span class="line">        scheme := ConfigSourceAddressScheme(srcAddress.Scheme)</span><br><span class="line">        <span class="keyword">switch</span> scheme &#123;</span><br><span class="line">        <span class="keyword">case</span> File:</span><br><span class="line">            <span class="keyword">if</span> srcAddress.Path == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid fs config URL %s, contains no file path&quot;</span>, configSource.Address)</span><br><span class="line">            &#125;</span><br><span class="line">            store := memory.Make(collections.Pilot)</span><br><span class="line">            configController := memory.NewController(store)</span><br><span class="line"></span><br><span class="line">            err := s.makeFileMonitor(srcAddress.Path, args.RegistryOptions.KubeOptions.DomainSuffix, configController)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            s.ConfigStores = <span class="built_in">append</span>(s.ConfigStores, configController)</span><br><span class="line">        <span class="keyword">case</span> XDS:</span><br><span class="line">            xdsMCP, err := adsc.New(srcAddress.Host, &amp;adsc.Config&#123;</span><br><span class="line">                Namespace: args.Namespace,</span><br><span class="line">                Workload:  args.PodName,</span><br><span class="line">                Revision:  args.Revision,</span><br><span class="line">                Meta: model.NodeMetadata&#123;</span><br><span class="line">                    Generator: <span class="string">&quot;api&quot;</span>,</span><br><span class="line">                    <span class="comment">// To reduce transported data if upstream server supports. Especially for custom servers.</span></span><br><span class="line">                    IstioRevision: args.Revision,</span><br><span class="line">                &#125;.ToStruct(),</span><br><span class="line">                InitialDiscoveryRequests: adsc.ConfigInitialRequests(),</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to dial XDS %s %v&quot;</span>, configSource.Address, err)</span><br><span class="line">            &#125;</span><br><span class="line">            store := memory.MakeSkipValidation(collections.Pilot)</span><br><span class="line">            configController := memory.NewController(store)</span><br><span class="line">            configController.RegisterHasSyncedHandler(xdsMCP.HasSynced)</span><br><span class="line">            xdsMCP.Store = model.MakeIstioStore(configController)</span><br><span class="line">            err = xdsMCP.Run()</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;MCP: failed running %v&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">            s.ConfigStores = <span class="built_in">append</span>(s.ConfigStores, configController)</span><br><span class="line">            log.Warn(<span class="string">&quot;Started XDS config &quot;</span>, s.ConfigStores)</span><br><span class="line">        <span class="keyword">case</span> Kubernetes:</span><br><span class="line">            <span class="keyword">if</span> srcAddress.Path == <span class="string">&quot;&quot;</span> || srcAddress.Path == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">                err2 := s.initK8SConfigStore(args)</span><br><span class="line">                <span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Warn(<span class="string">&quot;Error loading k8s &quot;</span>, err2)</span><br><span class="line">                    <span class="keyword">return</span> err2</span><br><span class="line">                &#125;</span><br><span class="line">                log.Warn(<span class="string">&quot;Started K8S config&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.Warnf(<span class="string">&quot;Not implemented, ignore: %v&quot;</span>, configSource.Address)</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle k8s:// scheme for remote cluster. Use same mechanism as service registry,</span></span><br><span class="line">                <span class="comment">// using the cluster name as key to match a secret.</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            log.Warnf(<span class="string">&quot;Ignoring unsupported config source: %v&quot;</span>, configSource.Address)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 Istio 有多种数据源，最近提供了统一的聚合访问方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> store <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// schemas is the unified</span></span><br><span class="line">    schemas collection.Schemas</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stores is a mapping from config type to a store</span></span><br><span class="line">    stores <span class="keyword">map</span>[config.GroupVersionKind][]model.ConfigStore</span><br><span class="line"></span><br><span class="line">    writer model.ConfigStore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Istio 的资源都放在了 IstioConfigStore 中</p>
<figure class="highlight go"><figcaption><span>IstioConfigStore</span><a href="https://github.com/istio/istio/blob/4f5b41f609296f901cbfb850ccea5f24a28c9bca/pilot/pkg/model/config.go#L200-L211">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IstioConfigStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    ConfigStore</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServiceEntries lists all service entries</span></span><br><span class="line">    ServiceEntries() []config.Config</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gateways lists all gateways bound to the specified workload labels</span></span><br><span class="line">    Gateways(workloadLabels labels.Collection) []config.Config</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AuthorizationPolicies selects AuthorizationPolicies in the specified namespace.</span></span><br><span class="line">    AuthorizationPolicies(namespace <span class="type">string</span>) []config.Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的3个函数很明显，第一个 ConfigStore 是一个通用接口，类似于 RuntimeClient 提供了通用的 Get List 的接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ConfigStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Schemas exposes the configuration type schema known by the config store.</span></span><br><span class="line">    <span class="comment">// The type schema defines the bidirectional mapping between configuration</span></span><br><span class="line">    <span class="comment">// types and the protobuf encoding schema.</span></span><br><span class="line">    Schemas() collection.Schemas</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get retrieves a configuration element by a type and a key</span></span><br><span class="line">    Get(typ config.GroupVersionKind, name, namespace <span class="type">string</span>) *config.Config</span><br><span class="line"></span><br><span class="line">    <span class="comment">// List returns objects by type and namespace.</span></span><br><span class="line">    <span class="comment">// Use &quot;&quot; for the namespace to list across namespaces.</span></span><br><span class="line">    List(typ config.GroupVersionKind, namespace <span class="type">string</span>) ([]config.Config, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create adds a new configuration object to the store. If an object with the</span></span><br><span class="line">    <span class="comment">// same name and namespace for the type already exists, the operation fails</span></span><br><span class="line">    <span class="comment">// with no side effects.</span></span><br><span class="line">    Create(config config.Config) (revision <span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update modifies an existing configuration object in the store.  Update</span></span><br><span class="line">    <span class="comment">// requires that the object has been created.  Resource version prevents</span></span><br><span class="line">    <span class="comment">// overriding a value that has been changed between prior _Get_ and _Put_</span></span><br><span class="line">    <span class="comment">// operation to achieve optimistic concurrency. This method returns a new</span></span><br><span class="line">    <span class="comment">// revision if the operation succeeds.</span></span><br><span class="line">    Update(config config.Config) (newRevision <span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line">    UpdateStatus(config config.Config) (newRevision <span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Patch applies only the modifications made in the PatchFunc rather than doing a full replace. Useful to avoid</span></span><br><span class="line">    <span class="comment">// read-modify-write conflicts when there are many concurrent-writers to the same resource.</span></span><br><span class="line">    Patch(orig config.Config, patchFn config.PatchFunc) (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete removes an object from the store by key</span></span><br><span class="line">    <span class="comment">// For k8s, resourceVersion must be fulfilled before a deletion is carried out.</span></span><br><span class="line">    <span class="comment">// If not possible, a 409 Conflict status will be returned.</span></span><br><span class="line">    Delete(typ config.GroupVersionKind, name, namespace <span class="type">string</span>, resourceVersion *<span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这部分配置来说，就是属于拿来即用的方式，在每一次 Push 之前直接获取即可，比如下面的对于 DR 的使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEndpointBuilder</span><span class="params">(clusterName <span class="type">string</span>, proxy *model.Proxy, push *model.PushContext)</span></span> EndpointBuilder &#123;</span><br><span class="line">   _, subsetName, hostname, port := model.ParseSubsetKey(clusterName)</span><br><span class="line">   svc := push.ServiceForHostname(proxy, hostname)</span><br><span class="line">   dr := push.DestinationRule(proxy, svc) <span class="comment">// 直接去cache中获得</span></span><br><span class="line">   b := EndpointBuilder&#123;</span><br><span class="line">      clusterName:     clusterName,</span><br><span class="line">      network:         proxy.Metadata.Network,</span><br><span class="line">      networkView:     proxy.GetNetworkView(),</span><br><span class="line">      clusterID:       proxy.Metadata.ClusterID,</span><br><span class="line">      locality:        proxy.Locality,</span><br><span class="line">      service:         svc,</span><br><span class="line">      clusterLocal:    push.IsClusterLocal(svc),</span><br><span class="line">      destinationRule: dr,</span><br><span class="line">      tunnelType:      GetTunnelBuilderType(clusterName, proxy, push),</span><br><span class="line"></span><br><span class="line">      push:       push,</span><br><span class="line">      proxy:      proxy,</span><br><span class="line">      subsetName: subsetName,</span><br><span class="line">      hostname:   hostname,</span><br><span class="line">      port:       port,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// We need this for multi-network, or for clusters meant for use with AUTO_PASSTHROUGH.</span></span><br><span class="line">   <span class="keyword">if</span> features.EnableAutomTLSCheckPolicies ||</span><br><span class="line">      b.push.NetworkManager().IsMultiNetworkEnabled() || model.IsDNSSrvSubsetKey(clusterName) &#123;</span><br><span class="line">      b.mtlsChecker = newMtlsChecker(push, port, dr)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Data-类数据源"><a class="header-anchor" href="#Data-类数据源">¶</a>Data 类数据源</h3>
<p>Data 类型的分为了2个部分</p>
<ul>
<li><code>Kube</code> 中的 <code>POD</code> <code>Service</code></li>
<li><code>Istio</code> 提供的  <code>ServiceEntry</code> <code>WorkloadEntry</code> 的资源</li>
</ul>
<p>这两部分也就对应了下面的代码</p>
<figure class="highlight go"><figcaption><span>initServiceControllers</span><a href="https://github.com/istio/istio/blob/9aae4e1476e0dcc3611e2825cc1e98da601f47aa/pilot/pkg/bootstrap/servicecontroller.go#L75-L97">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> initServiceControllers(args *PilotArgs) <span class="type">error</span> &#123;</span><br><span class="line">    serviceControllers := s.ServiceController()</span><br><span class="line"></span><br><span class="line">    s.serviceEntryStore = serviceentry.NewServiceDiscovery(</span><br><span class="line">        s.configController, s.environment.IstioConfigStore, s.XDSServer,</span><br><span class="line">        serviceentry.WithClusterID(s.clusterID),</span><br><span class="line">    )</span><br><span class="line">    serviceControllers.AddRegistry(s.serviceEntryStore)</span><br><span class="line"></span><br><span class="line">    registered := <span class="built_in">make</span>(<span class="keyword">map</span>[provider.ID]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> args.RegistryOptions.Registries &#123;</span><br><span class="line">        serviceRegistry := provider.ID(r)</span><br><span class="line">        <span class="keyword">if</span> _, exists := registered[serviceRegistry]; exists &#123;</span><br><span class="line">            log.Warnf(<span class="string">&quot;%s registry specified multiple times.&quot;</span>, r)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        registered[serviceRegistry] = <span class="literal">true</span></span><br><span class="line">        log.Infof(<span class="string">&quot;Adding %s registry adapter&quot;</span>, serviceRegistry)</span><br><span class="line">        <span class="keyword">switch</span> serviceRegistry &#123;</span><br><span class="line">        <span class="keyword">case</span> provider.Kubernetes:</span><br><span class="line">            <span class="keyword">if</span> err := s.initKubeRegistry(args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> provider.Mock:</span><br><span class="line">            s.initMockRegistry()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;service registry %s is not supported&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Defer running of the service controllers.</span></span><br><span class="line">    s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">go</span> serviceControllers.Run(stop)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是初始化 K8S 的逻辑</span></span><br><span class="line"><span class="comment">// initKubeRegistry creates all the k8s service controllers under this pilot</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> initKubeRegistry(args *PilotArgs) (err <span class="type">error</span>) &#123;</span><br><span class="line">    args.RegistryOptions.KubeOptions.ClusterID = s.clusterID</span><br><span class="line">    args.RegistryOptions.KubeOptions.Metrics = s.environment</span><br><span class="line">    args.RegistryOptions.KubeOptions.XDSUpdater = s.XDSServer</span><br><span class="line">    args.RegistryOptions.KubeOptions.NetworksWatcher = s.environment.NetworksWatcher</span><br><span class="line">    args.RegistryOptions.KubeOptions.MeshWatcher = s.environment.Watcher</span><br><span class="line">    args.RegistryOptions.KubeOptions.SystemNamespace = args.Namespace</span><br><span class="line">    args.RegistryOptions.KubeOptions.MeshServiceController = s.ServiceController()</span><br><span class="line"></span><br><span class="line">    s.multiclusterController.AddHandler(kubecontroller.NewMulticluster(args.PodName,</span><br><span class="line">        s.kubeClient,</span><br><span class="line">        args.RegistryOptions.ClusterRegistriesNamespace,</span><br><span class="line">        args.RegistryOptions.KubeOptions,</span><br><span class="line">        s.serviceEntryStore,</span><br><span class="line">        s.istiodCertBundleWatcher,</span><br><span class="line">        args.Revision,</span><br><span class="line">        s.shouldStartNsController(),</span><br><span class="line">        s.environment.ClusterLocal(),</span><br><span class="line">        s.server))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Kubernetes-资源"><a class="header-anchor" href="#Kubernetes-资源">¶</a>Kubernetes 资源</h4>
<p>这部分的数据代码都大多数放在 pilot/pkg/serviceregistry 这个目录下, 作为一个  Controller 通过 Information 的机制来关注各种资源的变化</p>
<figure class="highlight go"><figcaption><span>controller</span><a href="https://github.com/istio/istio/blob/10d662f2439554b814a4879aad469deb1d4c92c0/pilot/pkg/serviceregistry/kube/controller/controller.go#L224-L409">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">   opts Options</span><br><span class="line"></span><br><span class="line">   client kubelib.Client</span><br><span class="line"></span><br><span class="line">   queue queue.Instance</span><br><span class="line"></span><br><span class="line">   nsInformer cache.SharedIndexInformer</span><br><span class="line">   nsLister   listerv1.NamespaceLister</span><br><span class="line"></span><br><span class="line">   serviceInformer filter.FilteredSharedIndexInformer</span><br><span class="line">   serviceLister   listerv1.ServiceLister</span><br><span class="line"></span><br><span class="line">   endpoints kubeEndpointsController</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Used to watch node accessible from remote cluster.</span></span><br><span class="line">   <span class="comment">// In multi-cluster(shared control plane multi-networks) scenario, ingress gateway service can be of nodePort type.</span></span><br><span class="line">   <span class="comment">// With this, we can populate mesh&#x27;s gateway address with the node ips.</span></span><br><span class="line">   nodeInformer cache.SharedIndexInformer</span><br><span class="line">   nodeLister   listerv1.NodeLister</span><br><span class="line"></span><br><span class="line">   exports serviceExportCache</span><br><span class="line">   imports serviceImportCache</span><br><span class="line">   pods    *PodCache</span><br><span class="line"></span><br><span class="line">   handlers model.ControllerHandlers</span><br><span class="line"></span><br><span class="line">   <span class="comment">// This is only used for test</span></span><br><span class="line">   stop <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   sync.RWMutex</span><br><span class="line">   <span class="comment">// servicesMap stores hostname ==&gt; service, it is used to reduce convertService calls.</span></span><br><span class="line">   servicesMap <span class="keyword">map</span>[host.Name]*model.Service</span><br><span class="line">   <span class="comment">// hostNamesForNamespacedName returns all possible hostnames for the given service name.</span></span><br><span class="line">   <span class="comment">// If Kubernetes Multi-Cluster Services (MCS) is enabled, this will contain the regular</span></span><br><span class="line">   <span class="comment">// hostname as well as the MCS hostname (clusterset.local). Otherwise, only the regular</span></span><br><span class="line">   <span class="comment">// hostname will be returned.</span></span><br><span class="line">   hostNamesForNamespacedName <span class="function"><span class="keyword">func</span><span class="params">(name types.NamespacedName)</span></span> []host.Name</span><br><span class="line">   <span class="comment">// servicesForNamespacedName returns all services for the given service name.</span></span><br><span class="line">   <span class="comment">// If Kubernetes Multi-Cluster Services (MCS) is enabled, this will contain the regular</span></span><br><span class="line">   <span class="comment">// service as well as the MCS service (clusterset.local), if available. Otherwise,</span></span><br><span class="line">   <span class="comment">// only the regular service will be returned.</span></span><br><span class="line">   servicesForNamespacedName <span class="function"><span class="keyword">func</span><span class="params">(name types.NamespacedName)</span></span> []*model.Service</span><br><span class="line">   <span class="comment">// nodeSelectorsForServices stores hostname =&gt; label selectors that can be used to</span></span><br><span class="line">   <span class="comment">// refine the set of node port IPs for a service.</span></span><br><span class="line">   nodeSelectorsForServices <span class="keyword">map</span>[host.Name]labels.Instance</span><br><span class="line">   <span class="comment">// map of node name and its address+labels - this is the only thing we need from nodes</span></span><br><span class="line">   <span class="comment">// for vm to k8s or cross cluster. When node port services select specific nodes by labels,</span></span><br><span class="line">   <span class="comment">// we run through the label selectors here to pick only ones that we need.</span></span><br><span class="line">   <span class="comment">// Only nodes with ExternalIP addresses are included in this map !</span></span><br><span class="line">   nodeInfoMap <span class="keyword">map</span>[<span class="type">string</span>]kubernetesNode</span><br><span class="line">   <span class="comment">// externalNameSvcInstanceMap stores hostname ==&gt; instance, is used to store instances for ExternalName k8s services</span></span><br><span class="line">   externalNameSvcInstanceMap <span class="keyword">map</span>[host.Name][]*model.ServiceInstance</span><br><span class="line">   <span class="comment">// workload instances from workload entries  - map of ip -&gt; workload instance</span></span><br><span class="line">   workloadInstancesByIP <span class="keyword">map</span>[<span class="type">string</span>]*model.WorkloadInstance</span><br><span class="line">   <span class="comment">// Stores a map of workload instance name/namespace to address</span></span><br><span class="line">   workloadInstancesIPsByName <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"></span><br><span class="line">   multinetwork</span><br><span class="line">   <span class="comment">// informerInit is set to true once the controller is running successfully. This ensures we do not</span></span><br><span class="line">   <span class="comment">// return HasSynced=true before we are running</span></span><br><span class="line">   informerInit *atomic.Bool</span><br><span class="line">   <span class="comment">// beginSync is set to true when calling SyncAll, it indicates the controller has began sync resources.</span></span><br><span class="line">   beginSync *atomic.Bool</span><br><span class="line">   <span class="comment">// initialSync is set to true after performing an initial in-order processing of all objects.</span></span><br><span class="line">   initialSync *atomic.Bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewController creates a new Kubernetes controller</span></span><br><span class="line"><span class="comment">// Created by bootstrap and multicluster (see multicluster.Controller).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(kubeClient kubelib.Client, options Options)</span></span> *Controller &#123;</span><br><span class="line">   c := &amp;Controller&#123;</span><br><span class="line">      opts:                       options,</span><br><span class="line">      client:                     kubeClient,</span><br><span class="line">      queue:                      queue.NewQueueWithID(<span class="number">1</span>*time.Second, <span class="type">string</span>(options.ClusterID)),</span><br><span class="line">      servicesMap:                <span class="built_in">make</span>(<span class="keyword">map</span>[host.Name]*model.Service),</span><br><span class="line">      nodeSelectorsForServices:   <span class="built_in">make</span>(<span class="keyword">map</span>[host.Name]labels.Instance),</span><br><span class="line">      nodeInfoMap:                <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]kubernetesNode),</span><br><span class="line">      externalNameSvcInstanceMap: <span class="built_in">make</span>(<span class="keyword">map</span>[host.Name][]*model.ServiceInstance),</span><br><span class="line">      workloadInstancesByIP:      <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*model.WorkloadInstance),</span><br><span class="line">      workloadInstancesIPsByName: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>),</span><br><span class="line">      informerInit:               atomic.NewBool(<span class="literal">false</span>),</span><br><span class="line">      beginSync:                  atomic.NewBool(<span class="literal">false</span>),</span><br><span class="line">      initialSync:                atomic.NewBool(<span class="literal">false</span>),</span><br><span class="line"></span><br><span class="line">      multinetwork: initMultinetwork(),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   c.nsInformer = kubeClient.KubeInformer().Core().V1().Namespaces().Informer()</span><br><span class="line">   c.nsLister = kubeClient.KubeInformer().Core().V1().Namespaces().Lister()</span><br><span class="line">   c.initDiscoveryHandlers(kubeClient, options.EndpointMode, options.MeshWatcher, c.opts.DiscoveryNamespacesFilter)</span><br><span class="line"></span><br><span class="line">   c.serviceInformer = filter.NewFilteredSharedIndexInformer(c.opts.DiscoveryNamespacesFilter.Filter, kubeClient.KubeInformer().Core().V1().Services().Informer())</span><br><span class="line">   c.serviceLister = listerv1.NewServiceLister(c.serviceInformer.GetIndexer())</span><br><span class="line">   c.registerHandlers(c.serviceInformer, <span class="string">&quot;Services&quot;</span>, c.onServiceEvent, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> options.EndpointMode &#123;</span><br><span class="line">   <span class="keyword">case</span> EndpointsOnly:</span><br><span class="line">      c.endpoints = newEndpointsController(c)</span><br><span class="line">   <span class="keyword">case</span> EndpointSliceOnly:</span><br><span class="line">      c.endpoints = newEndpointSliceController(c)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// This is for getting the node IPs of a selected set of nodes</span></span><br><span class="line">   c.nodeInformer = kubeClient.KubeInformer().Core().V1().Nodes().Informer()</span><br><span class="line">   c.nodeLister = kubeClient.KubeInformer().Core().V1().Nodes().Lister()</span><br><span class="line">   c.registerHandlers(c.nodeInformer, <span class="string">&quot;Nodes&quot;</span>, c.onNodeEvent, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">   podInformer := filter.NewFilteredSharedIndexInformer(c.opts.DiscoveryNamespacesFilter.Filter, kubeClient.KubeInformer().Core().V1().Pods().Informer())</span><br><span class="line">   c.registerHandlers(c.pods.informer, <span class="string">&quot;Pods&quot;</span>, c.pods.onEvent, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">   c.exports = newServiceExportCache(c)</span><br><span class="line">   c.imports = newServiceImportCache(c)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于单个集群是这么做的，那多个集群呢，我们接着往下看</p>
<p>在实践的过程中，我们已经知道对于纳管的集群，istio 会生成一个 configmap 存放目标集群的 KUBECONF，也就是随着主机群（配置集群）中的CM被建立就会触发如下操作进行。</p>
<figure class="highlight go"><figcaption><span>clusterAdd</span><a href="https://github.com/istio/istio/blob/4768755bdf953f7b2bf4ca5bbf18bc4ec6f612b5/pilot/pkg/serviceregistry/kube/controller/multicluster.go#L145-L279">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// ClusterAdded is passed to the secret controller as a callback to be called</span></span><br><span class="line"><span class="comment">// when a remote cluster is added.  This function needs to set up all the handlers</span></span><br><span class="line"><span class="comment">// to watch for resources being added, deleted or changed on remote clusters.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Multicluster)</span></span> ClusterAdded(cluster *multicluster.Cluster, clusterStopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">    m.m.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> m.closing &#123;</span><br><span class="line">        m.m.Unlock()</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed adding member cluster %s: server shutting down&quot;</span>, cluster.ID)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client := cluster.Client</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clusterStopCh is a channel that will be closed when this cluster removed.</span></span><br><span class="line">    options := m.opts</span><br><span class="line">    options.ClusterID = cluster.ID</span><br><span class="line">    <span class="comment">// the aggregate registry&#x27;s HasSynced will use the k8s controller&#x27;s HasSynced, so we reference the same timeout</span></span><br><span class="line">    options.SyncTimeout = cluster.SyncTimeout</span><br><span class="line">    <span class="comment">// different clusters may have different k8s version, re-apply conditional default</span></span><br><span class="line">    options.EndpointMode = DetectEndpointMode(client)</span><br><span class="line"></span><br><span class="line">    log.Infof(<span class="string">&quot;Initializing Kubernetes service registry %q&quot;</span>, options.ClusterID)</span><br><span class="line">    kubeRegistry := NewController(client, options)</span><br><span class="line">    m.remoteKubeControllers[cluster.ID] = &amp;kubeController&#123;</span><br><span class="line">        Controller: kubeRegistry,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// localCluster may also be the &quot;config&quot; cluster, in an external-istiod setup.</span></span><br><span class="line">    localCluster := m.opts.ClusterID == cluster.ID</span><br><span class="line"></span><br><span class="line">    m.m.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO move instance cache out of registries</span></span><br><span class="line">    <span class="keyword">if</span> m.serviceEntryStore != <span class="literal">nil</span> &amp;&amp; features.EnableServiceEntrySelectPods &#123;</span><br><span class="line">        <span class="comment">// Add an instance handler in the kubernetes registry to notify service entry store about pod events</span></span><br><span class="line">        kubeRegistry.AppendWorkloadHandler(m.serviceEntryStore.WorkloadInstanceHandler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// TODO only create namespace controller and cert patch for remote clusters (no way to tell currently)</span></span><br><span class="line">    <span class="keyword">if</span> m.startNsController &amp;&amp; (features.ExternalIstiod || localCluster) &#123;</span><br><span class="line">        <span class="comment">// Block server exit on graceful termination of the leader controller.</span></span><br><span class="line">        m.s.RunComponentAsyncAndWait(<span class="function"><span class="keyword">func</span><span class="params">(_ &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">            log.Infof(<span class="string">&quot;joining leader-election for %s in %s on cluster %s&quot;</span>,</span><br><span class="line">                leaderelection.NamespaceController, options.SystemNamespace, options.ClusterID)</span><br><span class="line">            leaderelection.</span><br><span class="line">                NewLeaderElection(options.SystemNamespace, m.serverID, leaderelection.NamespaceController, m.revision, client).</span><br><span class="line">                AddRunFunction(<span class="function"><span class="keyword">func</span><span class="params">(leaderStop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">                    log.Infof(<span class="string">&quot;starting namespace controller for cluster %s&quot;</span>, cluster.ID)</span><br><span class="line">                    nc := NewNamespaceController(client, m.caBundleWatcher)</span><br><span class="line">                    <span class="comment">// Start informers again. This fixes the case where informers for namespace do not start,</span></span><br><span class="line">                    <span class="comment">// as we create them only after acquiring the leader lock</span></span><br><span class="line">                    <span class="comment">// Note: stop here should be the overall pilot stop, NOT the leader election stop. We are</span></span><br><span class="line">                    <span class="comment">// basically lazy loading the informer, if we stop it when we lose the lock we will never</span></span><br><span class="line">                    <span class="comment">// recreate it again.</span></span><br><span class="line">                    client.RunAndWait(clusterStopCh)</span><br><span class="line">                    nc.Run(leaderStop)</span><br><span class="line">                &#125;).Run(clusterStopCh)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="XdsResourceGenerator"><a class="header-anchor" href="#XdsResourceGenerator">¶</a>XdsResourceGenerator</h2>
<p>当我们知道了 istio 的 数据源和数据模式之后，那下一步就是 istio 是如何把这些数据转为 Envoy 所能感知到的 XDS 的协议，这部分是通过 XdsResourceGenerator 来生成各种配置。</p>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2022/202210211356751.png" alt=""></p>
<p>最终的抽象如下</p>
<figure class="highlight go"><figcaption><span>Generator</span><a href="https://github.com/istio/istio/blob/202e88863858342eeb0206944e9d277a545eb194/pilot/pkg/model/context.go#L215-L215">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> XdsResourceGenerator <span class="keyword">interface</span> &#123;</span><br><span class="line">   <span class="comment">// Generate generates the Sotw resources for Xds.</span></span><br><span class="line">   Generate(proxy *Proxy, push *PushContext, w *WatchedResource, updates *PushRequest) (Resources, XdsLogDetails, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于不同的资源产生的方式采用了不同的方式实现。<br>
比如 NDS 就是用来处理 DNS 的规则</p>
<figure class="highlight go"><figcaption><span>NDS</span><a href="https://github.com/istio/istio/blob/202e88863858342eeb0206944e9d277a545eb194/pilot/pkg/xds/nds.go#L31-L31">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NdsGenerator <span class="keyword">struct</span> &#123;</span><br><span class="line">   Server *DiscoveryServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n NdsGenerator)</span></span> Generate(proxy *model.Proxy, push *model.PushContext, w *model.WatchedResource,</span><br><span class="line">   req *model.PushRequest) (model.Resources, model.XdsLogDetails, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> !ndsNeedsPush(req) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, model.DefaultXdsLogDetails, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   nt := n.Server.ConfigGenerator.BuildNameTable(proxy, push)</span><br><span class="line">   <span class="keyword">if</span> nt == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, model.DefaultXdsLogDetails, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   resources := model.Resources&#123;&amp;discovery.Resource&#123;Resource: util.MessageToAny(nt)&#125;&#125;</span><br><span class="line">   <span class="keyword">return</span> resources, model.DefaultXdsLogDetails, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.staticaly.com/gh/yanickxia/picture-bed@master/2022/202211111042177.png" alt=""></p>
<h3 id="Proxyelss-ConfigGenerator"><a class="header-anchor" href="#Proxyelss-ConfigGenerator">¶</a>Proxyelss ConfigGenerator</h3>
<p>在充满私货的 <a href="https://cloud.google.com/traffic-director/docs/proxyless-overview">无代理 gRPC 服务的 Traffic Director</a>  中，谷歌为 <code>istiod</code> 增加了对 <code>Proxyless</code> 的支持，我们来看看这是如何实现的。</p>
<p>我们既然知道了 istio 提供了生成的抽象，我们自然可以从 <code>XdsResourceGenerator</code> 入手，快速的定位 grpc 的配置生成的地方。</p>
<figure class="highlight go"><figcaption><span>Generate</span><a href="https://github.com/istio/istio/blob/1dbd193cf990ce42810b2627d2251f0ad67d496a/pilot/pkg/networking/grpcgen/grpcgen.go#L56-L69">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GrpcConfigGenerator)</span></span> Generate(proxy *model.Proxy, push *model.PushContext,</span><br><span class="line">	w *model.WatchedResource, updates *model.PushRequest) (model.Resources, model.XdsLogDetails, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">switch</span> w.TypeUrl &#123;</span><br><span class="line">	<span class="keyword">case</span> v3.ListenerType:</span><br><span class="line">		<span class="keyword">return</span> g.BuildListeners(proxy, push, w.ResourceNames), model.DefaultXdsLogDetails, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> v3.ClusterType:</span><br><span class="line">		<span class="keyword">return</span> g.BuildClusters(proxy, push, w.ResourceNames), model.DefaultXdsLogDetails, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> v3.RouteType:</span><br><span class="line">		<span class="keyword">return</span> g.BuildHTTPRoutes(proxy, push, w.ResourceNames), model.DefaultXdsLogDetails, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, model.DefaultXdsLogDetails, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然在 <code>LDS</code> <code>CDS</code> 之外新增了一种新的 <code>XDS</code> 类型。</p>
<figure class="highlight go"><figcaption><span>InitGenerators</span><a href="https://github.com/istio/istio/blob/1dbd193cf990ce42810b2627d2251f0ad67d496a/pilot/pkg/xds/discovery.go#L590-L595">github</a></figcaption><table><tr><td class="code"><pre><span class="line">s.Generators[<span class="string">&quot;grpc&quot;</span>] = &amp;grpcgen.GrpcConfigGenerator&#123;&#125;</span><br><span class="line">s.Generators[<span class="string">&quot;grpc/&quot;</span>+v3.EndpointType] = edsGen</span><br><span class="line">s.Generators[<span class="string">&quot;grpc/&quot;</span>+v3.ListenerType] = s.Generators[<span class="string">&quot;grpc&quot;</span>]</span><br><span class="line">s.Generators[<span class="string">&quot;grpc/&quot;</span>+v3.RouteType] = s.Generators[<span class="string">&quot;grpc&quot;</span>]</span><br><span class="line">s.Generators[<span class="string">&quot;grpc/&quot;</span>+v3.ClusterType] = s.Generators[<span class="string">&quot;grpc&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>根据子类型，我们显然知道了，<code>Proxyless GRPC</code> 会关注 <code>Listener</code> <code>Route</code> 和 <code>Cluster</code> <code>Endopint</code> 这四个类型。</p>
<h2 id="XDS"><a class="header-anchor" href="#XDS">¶</a>XDS</h2>
<p>从上面的 数据源 和 XdsResourceGenerator  中我们已经得知了系统是如何从 各种配置+数据变化为 XDS 资源的。<br>
那下步就是如何将数据推送到各个实例上，这里就涉及到 PushContext</p>
<p>他们之间联系的枢纽是  XDSUpdater</p>
<figure class="highlight go"><figcaption><span>XDSUpdater</span><a href="https://github.com/istio/istio/blob/4f5b41f609296f901cbfb850ccea5f24a28c9bca/pilot/pkg/model/push_context.go#L276-L303">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> XDSUpdater <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// EDSUpdate is called when the list of endpoints or labels in a Service is changed.</span></span><br><span class="line">    <span class="comment">// For each cluster and hostname, the full list of active endpoints (including empty list)</span></span><br><span class="line">    <span class="comment">// must be sent. The shard name is used as a key - current implementation is using the</span></span><br><span class="line">    <span class="comment">// registry name.</span></span><br><span class="line">    EDSUpdate(shard ShardKey, hostname <span class="type">string</span>, namespace <span class="type">string</span>, entry []*IstioEndpoint)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EDSCacheUpdate is called when the list of endpoints or labels in a Service is changed.</span></span><br><span class="line">    <span class="comment">// For each cluster and hostname, the full list of active endpoints (including empty list)</span></span><br><span class="line">    <span class="comment">// must be sent. The shard name is used as a key - current implementation is using the</span></span><br><span class="line">    <span class="comment">// registry name.</span></span><br><span class="line">    <span class="comment">// Note: the difference with `EDSUpdate` is that it only update the cache rather than requesting a push</span></span><br><span class="line">    EDSCacheUpdate(shard ShardKey, hostname <span class="type">string</span>, namespace <span class="type">string</span>, entry []*IstioEndpoint)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SvcUpdate is called when a service definition is updated/deleted.</span></span><br><span class="line">    SvcUpdate(shard ShardKey, hostname <span class="type">string</span>, namespace <span class="type">string</span>, event Event)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ConfigUpdate is called to notify the XDS server of config updates and request a push.</span></span><br><span class="line">    <span class="comment">// The requests may be collapsed and throttled.</span></span><br><span class="line">    ConfigUpdate(req *PushRequest)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ProxyUpdate is called to notify the XDS server to send a push to the specified proxy.</span></span><br><span class="line">    <span class="comment">// The requests may be collapsed and throttled.</span></span><br><span class="line">    ProxyUpdate(clusterID cluster.ID, ip <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RemoveShard removes all endpoints for the given shard key</span></span><br><span class="line">    RemoveShard(shardKey ShardKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在各个 ServiceController 和 ConfigStore 产生变化的时候，都会触发这里的 Update 函数来完成推送，比如在 Kube Endpoint 产生变化的时候就会触发如下逻辑</p>
<figure class="highlight go"><figcaption><span>process</span><a href="https://github.com/istio/istio/blob/5bf146fced9189c65e00f738cb5e95e9a801198e/pilot/pkg/serviceregistry/kube/controller/endpointcontroller.go#L62-L89">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// processEndpointEvent triggers the config update.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processEndpointEvent</span><span class="params">(c *Controller, epc kubeEndpointsController, name <span class="type">string</span>, namespace <span class="type">string</span>, event model.Event, ep <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// Update internal endpoint cache no matter what kind of service, even headless service.</span></span><br><span class="line">    <span class="comment">// As for gateways, the cluster discovery type is `EDS` for headless service.</span></span><br><span class="line">    updateEDS(c, epc, ep, event)</span><br><span class="line">    <span class="keyword">if</span> features.EnableHeadlessService &#123;</span><br><span class="line">        <span class="keyword">if</span> svc, _ := c.serviceLister.Services(namespace).Get(name); svc != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _, modelSvc := <span class="keyword">range</span> c.servicesForNamespacedName(kube.NamespacedNameForK8sObject(svc)) &#123;</span><br><span class="line">                <span class="comment">// if the service is headless service, trigger a full push.</span></span><br><span class="line">                <span class="keyword">if</span> svc.Spec.ClusterIP == v1.ClusterIPNone &#123;</span><br><span class="line">                    c.opts.XDSUpdater.ConfigUpdate(&amp;model.PushRequest&#123;</span><br><span class="line">                        Full: <span class="literal">true</span>,</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> extend and set service instance type, so no need to re-init push context</span></span><br><span class="line">                        ConfigsUpdated: <span class="keyword">map</span>[model.ConfigKey]<span class="keyword">struct</span>&#123;&#125;&#123;&#123;</span><br><span class="line">                            Kind:      gvk.ServiceEntry,</span><br><span class="line">                            Name:      modelSvc.Hostname.String(),</span><br><span class="line">                            Namespace: svc.Namespace,</span><br><span class="line">                        &#125;: &#123;&#125;&#125;,</span><br><span class="line">                        Reason: []model.TriggerReason&#123;model.EndpointUpdate&#125;,</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PushContext"><a class="header-anchor" href="#PushContext">¶</a>PushContext</h3>
<p>PushContext 这里有两种</p>
<ul>
<li>Global 当前系统的最新的状态， 作用在 DiscoveryServer 中的 Env</li>
<li>Request 中包含的局部有时间戳作为版本的 Context ,作用于 PushRequest 中</li>
</ul>
<h4 id="Proxy"><a class="header-anchor" href="#Proxy">¶</a>Proxy</h4>
<p>每一个 IstioProxy 节点就是一个 Proxy，因为对于不同的 Proxy 需要传输不同的数据，因此，大多数的构建逻辑中，包含的也就是 PushContext &amp; Proxy 这两个对象。</p>
<figure class="highlight go"><figcaption><span>Proxy</span><a href="https://github.com/istio/istio/blob/release-1.13/pilot/pkg/model/context.go#L231-L336">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://github.com/istio/istio/blob/release-1.13/pilot/pkg/model/context.go#L231-L336</span></span><br><span class="line"><span class="keyword">type</span> Proxy <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// Type specifies the node type. First part of the ID.</span></span><br><span class="line">        Type NodeType</span><br><span class="line"></span><br><span class="line">        <span class="comment">// IPAddresses is the IP addresses of the proxy used to identify it and its</span></span><br><span class="line">        <span class="comment">// co-located service instances. Example: &quot;10.60.1.6&quot;. In some cases, the host</span></span><br><span class="line">        <span class="comment">// where the proxy and service instances reside may have more than one IP address</span></span><br><span class="line">        IPAddresses []<span class="type">string</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ID is the unique platform-specific sidecar proxy ID. For k8s it is the pod ID and</span></span><br><span class="line">        <span class="comment">// namespace &lt;podName.namespace&gt;.</span></span><br><span class="line">        ID <span class="type">string</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Locality is the location of where Envoy proxy runs. This is extracted from</span></span><br><span class="line">        <span class="comment">// the registry where possible. If the registry doesn&#x27;t provide a locality for the</span></span><br><span class="line">        <span class="comment">// proxy it will use the one sent via ADS that can be configured in the Envoy bootstrap</span></span><br><span class="line">        Locality *core.Locality</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PushRequest"><a class="header-anchor" href="#PushRequest">¶</a>PushRequest</h4>
<p>当系统发生一次需要更新事件的时候，就会触发一个 PushRequest，代表了系统需要进行更新。这个有个初学者错误的认知，这个 PushRequet 并不和 Sidecar 绑定，代表的是整个网格产生了变化，应该发生 Push 至于 Push 给谁，不是这个对象处理的。所以在</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDiscoveryServer</span><span class="params">(env *model.Environment, plugins []<span class="type">string</span>, instanceID <span class="type">string</span>, systemNameSpace <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   clusterAliases <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span></span> *DiscoveryServer &#123;</span><br><span class="line">   out := &amp;DiscoveryServer&#123;</span><br><span class="line">      pushChannel:             <span class="built_in">make</span>(<span class="keyword">chan</span> *model.PushRequest, <span class="number">10</span>),</span><br><span class="line">      pushQueue:               NewPushQueue(),</span><br><span class="line">      Cache:      model.DisabledCache&#123;&#125;,</span><br><span class="line">      instanceID: instanceID,</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>pushChannel</code> 并不很大，因为仅仅代表了系统触发更新，需要给 <code>Clients</code> 进行推送。<br>
因此在推送完当前的 <code>PushRequest</code> 之后，需要更新后续的 <code>PushRequest</code></p>
<figure class="highlight go"><figcaption><span>Push</span><a href="https://github.com/istio/istio/blob/202e88863858342eeb0206944e9d277a545eb194/pilot/pkg/xds/discovery.go#L333-L366">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span></span> Push(req *model.PushRequest) &#123;</span><br><span class="line">   <span class="comment">// Reset the status during the push.</span></span><br><span class="line">   oldPushContext := s.globalPushContext()</span><br><span class="line"></span><br><span class="line">   versionLocal := time.Now().Format(time.RFC3339) + <span class="string">&quot;/&quot;</span> + strconv.FormatUint(versionNum.Inc(), <span class="number">10</span>)</span><br><span class="line">   push, err := s.initPushContext(req, oldPushContext, versionLocal)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   req.Push = push</span><br><span class="line">   s.AdsPushAll(versionLocal, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里根据之前的生成了当前的 PushRequest，在我们初始化完 当前请求的 context 之后又回过来更新</p>
<figure class="highlight go"><figcaption><span>initPushContext</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span></span> initPushContext(req *model.PushRequest, oldPushContext *model.PushContext, version <span class="type">string</span>) (*model.PushContext, <span class="type">error</span>) &#123;</span><br><span class="line">   push := model.NewPushContext()</span><br><span class="line">   push.PushVersion = version</span><br><span class="line">   push.JwtKeyResolver = s.JwtKeyResolver</span><br><span class="line">   <span class="keyword">if</span> err := push.InitContext(s.Env, oldPushContext, req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Errorf(<span class="string">&quot;XDS: failed to init push context: %v&quot;</span>, err)</span><br><span class="line">      <span class="comment">// We can&#x27;t push if we can&#x27;t read the data - stick with previous version.</span></span><br><span class="line">      pushContextErrors.Increment()</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err := s.UpdateServiceShards(push); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   s.updateMutex.Lock()</span><br><span class="line">   s.Env.PushContext = push</span><br><span class="line">   <span class="comment">// Ensure we drop the cache in the lock to avoid races, where we drop the cache, fill it back up, then update push context</span></span><br><span class="line">   s.dropCacheForRequest(req)</span><br><span class="line">   s.updateMutex.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> push, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，我们每一次处理请求之后，都会将本次请求的内容转化为全局的当前状态。</p>
<p>也就是整个系统有三种状态。</p>
<ol>
<li>上一次已经推送的状态</li>
<li>期望的状态 (&lt;---- 处理中</li>
<li>期望的最新状态 ( &lt;---- Pending</li>
</ol>


<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: Push 流程',
	 'EventSource -> PushChannel: xDS Update',
	 'note left: Send to Channel',
     'PushChannel -> DiscoveryServer: Process',
     'DiscoveryServer -> PushContext: Create / Update',
     'DiscoveryServer -> Env: Update GobalPushContext',
     'DiscoveryServer -> PushQueue: Push To Clients',
     'note left: Append to Queue'
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>
<h5 id="API"><a class="header-anchor" href="#API">¶</a>API</h5>
<p>客户端(pliot-agent)和服务端(istiod) 之间的 API，定义在  <a href="https://github.com/envoyproxy/envoy/blob/main/api/envoy/service/discovery/v2/ads.proto">ads.go</a> 中，也就是 api 规范中的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> envoy.service.discovery.v3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;envoy/service/discovery/v3/discovery.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;udpa/annotations/status.proto&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;udpa/annotations/versioning.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">option java_package = <span class="string">&quot;io.envoyproxy.envoy.service.discovery.v3&quot;</span>;</span><br><span class="line">option java_outer_classname = <span class="string">&quot;AdsProto&quot;</span>;</span><br><span class="line">option java_multiple_files = <span class="literal">true</span>;</span><br><span class="line">option go_package = <span class="string">&quot;github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3;discoveryv3&quot;</span>;</span><br><span class="line">option java_generic_services = <span class="literal">true</span>;</span><br><span class="line">option (udpa.annotations.file_status).package_version_status = ACTIVE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [#protodoc-title: Aggregated Discovery Service (ADS)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Discovery services for endpoints, clusters, routes,</span></span><br><span class="line"><span class="comment">// and listeners are retained in the package `envoy.api.v2` for backwards</span></span><br><span class="line"><span class="comment">// compatibility with existing management servers. New development in discovery</span></span><br><span class="line"><span class="comment">// services should proceed in the package `envoy.service.discovery.v2`.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// See https://github.com/envoyproxy/envoy-api#apis for a description of the role of</span></span><br><span class="line"><span class="comment">// ADS and how it is intended to be used by a management server. ADS requests</span></span><br><span class="line"><span class="comment">// have the same structure as their singleton xDS counterparts, but can</span></span><br><span class="line"><span class="comment">// multiplex many resource types on a single stream. The type_url in the</span></span><br><span class="line"><span class="comment">// DiscoveryRequest/DiscoveryResponse provides sufficient information to recover</span></span><br><span class="line"><span class="comment">// the multiplexed singleton APIs at the Envoy instance and management server.</span></span><br><span class="line">service AggregatedDiscoveryService &#123;</span><br><span class="line">  <span class="comment">// This is a gRPC-only API.</span></span><br><span class="line">  rpc StreamAggregatedResources(stream DiscoveryRequest) returns (stream DiscoveryResponse) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rpc DeltaAggregatedResources(stream DeltaDiscoveryRequest)</span><br><span class="line">      returns (stream DeltaDiscoveryResponse) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing</span></span><br><span class="line"><span class="comment">// services: https://github.com/google/protobuf/issues/4221</span></span><br><span class="line">message AdsDummy &#123;</span><br><span class="line">  option (udpa.annotations.versioning).previous_message_type =</span><br><span class="line">      <span class="string">&quot;envoy.service.discovery.v2.AdsDummy&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也其实只有2个接口</p>
<ul>
<li>StreamAggregatedResources: 一个双向通讯的聚合资源接口</li>
<li>DeltaAggregatedResources：支持增量的接口</li>
</ul>
<p>服务端接收到的请求在  processRequest 进行处理</p>
<figure class="highlight go"><figcaption><span>processRequest</span><a href="https://github.com/istio/istio/blob/1dbd193cf990ce42810b2627d2251f0ad67d496a/pilot/pkg/xds/ads.go#L192-L245">github</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// processRequest is handling one request. This is currently called from the &#x27;main&#x27; thread, which also</span></span><br><span class="line"><span class="comment">// handles &#x27;push&#x27; requests and close - the code will eventually call the &#x27;push&#x27; code, and it needs more mutex</span></span><br><span class="line"><span class="comment">// protection. Original code avoided the mutexes by doing both &#x27;push&#x27; and &#x27;process requests&#x27; in same thread.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span></span> processRequest(req *discovery.DiscoveryRequest, con *Connection) <span class="type">error</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> !s.shouldProcessRequest(con.proxy, req) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// For now, don&#x27;t let xDS piggyback debug requests start watchers.</span></span><br><span class="line">   <span class="keyword">if</span> strings.HasPrefix(req.TypeUrl, v3.DebugType) &#123;</span><br><span class="line">      <span class="keyword">return</span> s.pushXds(con, s.globalPushContext(), &amp;model.WatchedResource&#123;</span><br><span class="line">         TypeUrl: req.TypeUrl, ResourceNames: req.ResourceNames,</span><br><span class="line">      &#125;, &amp;model.PushRequest&#123;Full: <span class="literal">true</span>&#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> s.StatusReporter != <span class="literal">nil</span> &#123;</span><br><span class="line">      s.StatusReporter.RegisterEvent(con.ConID, req.TypeUrl, req.ResponseNonce)</span><br><span class="line">   &#125;</span><br><span class="line">   shouldRespond := s.shouldRespond(con, req)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> request *model.PushRequest</span><br><span class="line">   push := s.globalPushContext()</span><br><span class="line">   <span class="keyword">if</span> shouldRespond &#123;</span><br><span class="line">      <span class="comment">// This is a request, trigger a full push for this type. Override the blocked push (if it exists),</span></span><br><span class="line">      <span class="comment">// as this full push is guaranteed to be a superset of what we would have pushed from the blocked push.</span></span><br><span class="line">      request = &amp;model.PushRequest&#123;Full: <span class="literal">true</span>, Push: push&#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Check if we have a blocked push. If this was an ACK, we will send it.</span></span><br><span class="line">      <span class="comment">// Either way we remove the blocked push as we will send a push.</span></span><br><span class="line">      haveBlockedPush := <span class="literal">false</span></span><br><span class="line">      con.proxy.Lock()</span><br><span class="line">      request, haveBlockedPush = con.blockedPushes[req.TypeUrl]</span><br><span class="line">      <span class="built_in">delete</span>(con.blockedPushes, req.TypeUrl)</span><br><span class="line">      con.proxy.Unlock()</span><br><span class="line">      <span class="keyword">if</span> haveBlockedPush &#123;</span><br><span class="line">         <span class="comment">// we have a blocked push which we will use</span></span><br><span class="line">         log.Debugf(<span class="string">&quot;%s: DEQUEUE for node:%s&quot;</span>, v3.GetShortType(req.TypeUrl), con.proxy.ID)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// This is an ACK, no delayed push</span></span><br><span class="line">         <span class="comment">// Return immediately, no action needed</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   request.Reason = <span class="built_in">append</span>(request.Reason, model.ProxyRequest)</span><br><span class="line">   request.Start = time.Now()</span><br><span class="line">   <span class="comment">// SidecarScope for the proxy may not have been updated based on this pushContext.</span></span><br><span class="line">   <span class="comment">// It can happen when `processRequest` comes after push context has been updated(s.initPushContext),</span></span><br><span class="line">   <span class="comment">// but before proxy&#x27;s SidecarScope has been updated(s.updateProxy).</span></span><br><span class="line">   <span class="keyword">if</span> con.proxy.SidecarScope != <span class="literal">nil</span> &amp;&amp; con.proxy.SidecarScope.Version != push.PushVersion &#123;</span><br><span class="line">      s.computeProxyState(con.proxy, request)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s.pushXds(con, push, con.Watched(req.TypeUrl), request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也不用看的太深入就会发现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span></span> pushXds(con *Connection, push *model.PushContext,</span><br><span class="line">   w *model.WatchedResource, req *model.PushRequest) <span class="type">error</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> w == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   gen := s.findGenerator(w.TypeUrl, con)</span><br><span class="line">   <span class="keyword">if</span> gen == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   t0 := time.Now()</span><br><span class="line"></span><br><span class="line">   res, logdata, err := gen.Generate(con.proxy, push, w, req)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; recordPushTime(w.TypeUrl, time.Since(t0)) &#125;()</span><br><span class="line"></span><br><span class="line">   resp := &amp;discovery.DiscoveryResponse&#123;</span><br><span class="line">      ControlPlane: ControlPlane(),</span><br><span class="line">      TypeUrl:      w.TypeUrl,</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> send different version for incremental eds</span></span><br><span class="line">      VersionInfo: push.PushVersion,</span><br><span class="line">      Nonce:       nonce(push.LedgerVersion),</span><br><span class="line">      Resources:   model.ResourcesToAny(res),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   configSize := ResourceSize(res)</span><br><span class="line">   configSizeBytes.With(typeTag.Value(w.TypeUrl)).Record(<span class="type">float64</span>(configSize))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是找到所对应的资源类型的 Generator 来生成资源就可以返回给服务端了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>isito</category>
        <category>how-it-work</category>
      </categories>
      <tags>
        <tag>isito</tag>
        <tag>how-it-work</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 网络大全</title>
    <url>/2020/09/25/networking/linux/linux-network-subsystem/</url>
    <content><![CDATA[<p><img src="https://s3.jpg.cm/2020/09/28/JJUHE.png" alt="JJUHE.png"></p>
<p>不是很喜欢起这么大的一个名字，不过好像也没啥办法，这次带大家一起聊聊，<code>Linux Network</code> 的全貌（从软件工程师的角度）</p>
<span id="more"></span>
<h2 id="修订记录"><a class="header-anchor" href="#修订记录">¶</a>修订记录</h2>
<ul>
<li>2020.9.30: 增加 <a href="#ebpf"><code>ebpf</code></a> 相关</li>
</ul>
<h2 id="基础概念"><a class="header-anchor" href="#基础概念">¶</a>基础概念</h2>
<p>觉得啰嗦的可以：<a href="#mmio">直接跳转至正文</a></p>
<h3 id="Linux-分层"><a class="header-anchor" href="#Linux-分层">¶</a>Linux 分层</h3>
<p><img src="https://s3.jpg.cm/2020/09/25/JRPSU.png" alt="JRPSU.png"></p>
<p>内核提供了一组 API，通常称为“系统调用”。这些 API 不同于常规的库 API，因为它们是执行从用户模式切换到内核模式的边界。</p>
<p>为了提供应用程序兼容性，很少更改系统调用。Linux特别强调这一点（与内核 API 不同，内核 API 可以根据需要进行更改）。</p>
<p>内核代码本身可以在逻辑上分为核心内核代码和设备驱动程序代码。设备驱动程序代码负责访问特定的设备，而核心内核代码是通用的。核心内核可以进一步划分为多个逻辑子系统（如文件访问、联网、进程管理等）</p>
<h3 id="SMP"><a class="header-anchor" href="#SMP">¶</a>SMP</h3>
<p><img src="https://s3.jpg.cm/2020/09/25/JRR2O.png" alt="JRR2O.png"></p>
<p>在现在的硬件体系下，因为我们的系统都是 <code>多核</code> 架构，因此大部分的时候，我们的Linux都运行在 <code>Symmetric MultiProcessing</code> 状态下，也就是内核可能在多个 CPU 中进行运行。如果两个进程运行访问相同内存位置的内核函数，则会在内核中产生竞争条件。因此在内核代码的大多数地方都需要使用到 <code>synchronization</code> 机制，来保证代码的线程安全线。</p>
<h3 id="线程"><a class="header-anchor" href="#线程">¶</a>线程</h3>
<p>在单纯的应用侧我们无感知 <code>CPU</code> 的线程概念，在操作系统这个层面就不得不去面对了。</p>
<ul>
<li><code>操作系统</code> 中的 <code>Thread</code>: 任务的单位，保存当前执行的栈，和同一个进程共享地址空间等，这个就是我们熟悉的线程。</li>
<li><code>CPU</code> 中的 <code>Thread</code>: 执行单位，当前 CPU 上可以同时执行的基本单位。</li>
</ul>
<h3 id="mmio"><a class="header-anchor" href="#mmio">¶</a>mmio</h3>
<p>MMIO(Memory mapping I/O)即内存映射I/O，它是PCI规范的一部分，I/O设备被放置在内存空间而不是I/O空间。从处理器的角度看，内存映射I/O后系统设备访问起来和内存一样。</p>
<h2 id="Network-Packet-Travel"><a class="header-anchor" href="#Network-Packet-Travel">¶</a>Network Packet Travel</h2>
<p>开局一张图，谨防迷路，代码原理大部分针对 <code>Linux 2.4</code>，具体的实现部分可能会截取 <code>Linux 4.19</code>。</p>
<p><img src="https://s3.jpg.cm/2020/09/27/Jc8rR.png" alt="Jc8rR.png"></p>


<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<h2 id="Network-Driver"><a class="header-anchor" href="#Network-Driver">¶</a>Network Driver</h2>
<p>本文试图从软件的角度解释一个网络请求的今生前世，我们这里选取 <a href="https://wiki.osdev.org/RTL8139">RTL8139</a> 作为我们了解网络驱动的硬件设备。</p>
<h3 id="设备数据结构定义：net-device"><a class="header-anchor" href="#设备数据结构定义：net-device">¶</a>设备数据结构定义：net_device</h3>
<p><code>Linux</code> 内核中设备的抽象对应的结构体是 <code>struct net_device</code></p>
<figure class="highlight c"><figcaption><span>net_device</span><a href="https://elixir.bootlin.com/linux/v4.19.144/source/include/linux/netdevice.h#L1747">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[IFNAMSIZ];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *	I/O 相关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mem_end;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mem_start;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> base_addr;</span><br><span class="line">    <span class="type">int</span> irq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设备 Index</span></span><br><span class="line">    <span class="type">int</span> ifindex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stats 数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device_stats</span> <span class="title">stats</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netdev_rx_queue</span> *_<span class="title">rx</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num_rx_queues;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> real_num_rx_queues;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netdev_queue</span> *_<span class="title">tx</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num_tx_queues;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> real_num_tx_queues;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于现在硬件设备都会基于 <code>mmio</code> 模式进行工作，因此我们读取数据也是直接和读取内存类似的方式进行读取的。</p>
<h3 id="网卡数据的读取"><a class="header-anchor" href="#网卡数据的读取">¶</a>网卡数据的读取</h3>
<p>外部数据的读取会涉及到中断体系，<code>Linux</code> 将 <code>中断</code> 分为了两个部分: <code>top half</code> 与 <code>bottom half</code>。<code>top half</code>是在呼叫 <code>request_irq()</code> 时所指定的 <code>interrupt handler</code> 函数，<code>bottom half</code> 则是真正负责响应中断的 <code>task</code>。</p>
<h4 id="硬中断部分"><a class="header-anchor" href="#硬中断部分">¶</a>硬中断部分</h4>
<p>对于数据初次抵达硬件，会触发硬件中断，如下图所示（网卡类似）。</p>
<p><img src="https://s3.jpg.cm/2020/09/26/J6IXC.png" alt="J6IXC.png"><br>
因此从中断的入口观察是最好的，下面的代码逻辑从 <code>linux-1.x</code> 版本中截取，比最近的要简单一些，容易理解，另外就是新版的已经改为 <code>NAPI</code> 模式，下文提到再说。</p>
<figure class="highlight c"><figcaption><span>rtl8139_interrupt</span><a href="https://elixir.bootlin.com/linux/2.4.18/source/drivers/net/8139too.c#L2011">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rtl8139_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_instance, <span class="keyword">struct</span> pt_regs *regs)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> net_device *) dev_instance;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_private</span> *<span class="title">tp</span> =</span> dev-&gt;priv;</span><br><span class="line">    <span class="type">void</span> *ioaddr = tp-&gt;mmio_addr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> isr = readw(ioaddr + ISR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理接受信号，上面略过了发送部分</span></span><br><span class="line">    <span class="keyword">if</span> (isr &amp; RxOK) &#123;</span><br><span class="line">        LOG_MSG(<span class="string">&quot;receive interrupt received\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> ((readb(ioaddr + CR) &amp; RxBufEmpty) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> rx_status;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> rx_size;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> pkt_size;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理环形队列</span></span><br><span class="line">            <span class="keyword">if</span> (tp-&gt;cur_rx &gt; RX_BUF_LEN)</span><br><span class="line">                tp-&gt;cur_rx = tp-&gt;cur_rx % RX_BUF_LEN;</span><br><span class="line"></span><br><span class="line">            rx_status = *(<span class="type">unsigned</span> <span class="type">int</span> *) (tp-&gt;rx_ring + tp-&gt;cur_rx);</span><br><span class="line">            rx_size = rx_status &gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">            pkt_size = rx_size - <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 创建内核态的 skb 储存接受到的数据 */</span></span><br><span class="line">            skb = dev_alloc_skb(pkt_size + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (skb) &#123;</span><br><span class="line">                skb-&gt;dev = dev;</span><br><span class="line">                skb_reserve(skb, <span class="number">2</span>); <span class="comment">/* 16 byte align the IP fields */</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 拷贝数据并且检查 checksum</span></span><br><span class="line">                eth_copy_and_sum(</span><br><span class="line">                        skb, tp-&gt;rx_ring + tp-&gt;cur_rx + <span class="number">4</span>, pkt_size, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                skb_put(skb, pkt_size);</span><br><span class="line">                skb-&gt;protocol = eth_type_trans(skb, dev);</span><br><span class="line">                netif_rx(skb);</span><br><span class="line"></span><br><span class="line">                dev-&gt;last_rx = jiffies;</span><br><span class="line">                tp-&gt;stats.rx_bytes += pkt_size;</span><br><span class="line">                tp-&gt;stats.rx_packets++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG_MSG(<span class="string">&quot;Memory squeeze, dropping packet.\n&quot;</span>);</span><br><span class="line">                tp-&gt;stats.rx_dropped++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 移动读取指针  * /</span></span><br><span class="line"><span class="comment">            tp-&gt;cur_rx = (tp-&gt;cur_rx + rx_size + 4 + 3) &amp; ~3;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p>中断模式下，我们收到一个数据包是非常的好理解的，将数据从网卡中 <code>COPY</code> 到我们的内核中即可，<a href="https://www.kernel.org/doc/htmldocs/networking/API-netif-rx.html"><code>netif_rx</code></a> 就是我们从 <code>Hardware</code> 向 <code>Kernel</code> 转换的核心点。</p>
<figure class="highlight c"><figcaption><span>netif_rx</span><a href="https://elixir.bootlin.com/linux/2.4.18/source/net/core/dev.c#L1214">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">netif_rx</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span> &#123;</span><br><span class="line">    <span class="type">int</span> this_cpu = smp_processor_id();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">queue</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们为每个 Core 分配了一个 待处理的数据队列，这里的处理如注释所言，</span></span><br><span class="line">	<span class="comment">// 代码可能被重排，这里只用当前的 CPU 保证了处理路径的最短化</span></span><br><span class="line">    <span class="built_in">queue</span> = &amp;softnet_data[this_cpu];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有超过backlog的限制就置于队列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;input_pkt_queue.qlen &lt;= netdev_max_backlog) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;input_pkt_queue.qlen) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;throttle) <span class="comment">// 不然就丢弃 -&gt; 因为还没响应，等于丢包</span></span><br><span class="line">                <span class="keyword">goto</span> drop;</span><br><span class="line">enqueue:</span><br><span class="line">            dev_hold(skb-&gt;dev);</span><br><span class="line">            __skb_queue_tail(&amp;<span class="built_in">queue</span>-&gt;input_pkt_queue, skb);</span><br><span class="line">            <span class="keyword">return</span> softnet_data[this_cpu].cng_level;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> enqueue;</span><br><span class="line">    &#125;</span><br><span class="line">drop:</span><br><span class="line">    netdev_rx_stat[this_cpu].dropped++;</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">    <span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>硬中断部分到此结束，我们将数据压入内核的虚拟接受列队中结束。</p>
<h4 id="选读-硬中断成本"><a class="header-anchor" href="#选读-硬中断成本">¶</a>[选读] 硬中断成本</h4>
<p><code>硬中断</code> 是一个有硬件主导，软件配合的出来体系，但是这样的模式不是没有成本的，打断正在运行的软件进程，我们不得不涉及到进程的切换，还有中断标记的处理等工作。<strong>It’s not free.</strong> ，有兴趣的可以参考 <a href="http://www.cs.utah.edu/~ald/pubs/interrupts.pdf">Profiling I/O Interrupts in Modern Architectures</a>，</p>
<p>截止至今，我们知道了对于从网卡来的数据，我们至少会涉及到 ➊ <code>Hard Interrupt</code> 导致的 <code>进程切换</code>，并且 ➋ 涉及到一次数据从网卡的 <code>Buffer</code> 向内核拷贝的过程。</p>
<h4 id="软中断部分"><a class="header-anchor" href="#软中断部分">¶</a>软中断部分</h4>
<p>软中断的逻辑在 <code>net_rx_action</code> 中</p>
<figure class="highlight c"><figcaption><span>net_rx_action</span><a href="https://elixir.bootlin.com/linux/2.4.18/source/net/core/dev.c#L188">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">net_rx_action</span><span class="params">(<span class="keyword">struct</span> softirq_action *h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> this_cpu = smp_processor_id();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">queue</span> =</span> &amp;softnet_data[this_cpu];</span><br><span class="line">    <span class="type">int</span> bugdet = netdev_max_backlog;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">rx_dev</span>;</span></span><br><span class="line">        <span class="comment">// 将数据弹出</span></span><br><span class="line">        skb = __skb_dequeue(&amp;<span class="built_in">queue</span>-&gt;input_pkt_queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没数据直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (skb == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        skb-&gt;h.raw = skb-&gt;nh.raw = skb-&gt;data;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> *<span class="title">ptype</span>, *<span class="title">pt_prev</span>;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> type = skb-&gt;protocol;</span><br><span class="line"></span><br><span class="line">            pt_prev = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 根据 package 类型找到对应的处理函数进行处理</span></span><br><span class="line">            <span class="keyword">for</span> (ptype = ptype_all; ptype; ptype = ptype-&gt;next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pt_prev) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!pt_prev-&gt;data) &#123;</span><br><span class="line">                            deliver_to_old_ones(pt_prev, skb, <span class="number">0</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="type">atomic_inc</span>(&amp;skb-&gt;users);</span><br><span class="line">                            <span class="comment">// 调用预置的回调函数</span></span><br><span class="line">                            pt_prev-&gt;func(skb,skb-&gt;dev,pt_prev);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pt_prev = ptype;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回调的函数签名如下：</p>
<p><code>int (*func) (struct sk_buff *, struct net_device *, struct packet_type *);</code> 很标准的指针函数。不过也很讨厌看这部分的代码，如果不是 <code>Runtime</code> 阶段很难找到这个定义的函数是什么。这里实际上在接收到 <code>TCP/IP</code> 协议包的时候，回调的是 <code>int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt)</code> 函数。在看 <code>IP</code> 处理的之前，我们先看看这个 <code>packet_type</code> 的相关函数。</p>
<h4 id="选读-Packet-Type-钩子"><a class="header-anchor" href="#选读-Packet-Type-钩子">¶</a>[选读] Packet Type 钩子</h4>
<p><code>packet_type</code> 的定义很简单</p>
<figure class="highlight c"><figcaption><span>packet_type</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> type;    <span class="comment">/*  协议类型	*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span>    <span class="comment">/* 不设置就是通配符	*/</span></span><br><span class="line">    <span class="type">int</span> (*func)(<span class="keyword">struct</span> sk_buff *, <span class="keyword">struct</span> net_device *, <span class="keyword">struct</span> packet_type *); <span class="comment">/* 回调函数 */</span></span><br><span class="line">    <span class="type">void</span> *data;    <span class="comment">/* 私有数据	*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>dev.c</code> 的源码中，我们可以动态的向 <code>ptype_all</code> 注册我们需要的 <code>ptype</code></p>
<figure class="highlight c"><figcaption><span>dev_add_pack</span><a href="https://elixir.bootlin.com/linux/2.4.18/C/ident/dev_add_pack">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dev_add_pack</span><span class="params">(<span class="keyword">struct</span> packet_type *pt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pt-&gt;type == htons(ETH_P_ALL)) &#123;</span><br><span class="line">        netdev_nit++;</span><br><span class="line">        pt-&gt;next = ptype_all;</span><br><span class="line">        ptype_all = pt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hash = ntohs(pt-&gt;type) &amp; <span class="number">15</span>;</span><br><span class="line">        pt-&gt;next = ptype_base[hash];</span><br><span class="line">        ptype_base[hash] = pt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们如果需要处理比如 <code>arp</code> 的请求，可以单独增加一个，所以在 <code>arp.c</code> 初始化的时候，就可以出发。</p>
<figure class="highlight c"><figcaption><span>arp_init</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> <span class="title">arp_packet_type</span> =</span> &#123;</span><br><span class="line">        type:    __constant_htons(ETH_P_ARP),</span><br><span class="line">        func:    arp_rcv,</span><br><span class="line">        data:    (<span class="type">void</span> *) <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">arp_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    dev_add_pack(&amp;arp_packet_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="TCPDUMP"><a class="header-anchor" href="#TCPDUMP">¶</a>TCPDUMP</h5>
<p><code>tcpdump</code> 二层抓包，用的是 <code>libpcap</code> 库，它的基本原理是</p>
<ol>
<li>先创建socket，内核dev_add_packet()挂上自己的钩子函数</li>
<li>然后在钩子函数中，把skb放到自己的接收队列中，</li>
<li>接着系统调用recv取出skb来，把数据包skb-&gt;data拷贝到用户空间</li>
<li>最后关闭socket，内核dev_remove_packet()删除自己的钩子函数</li>
</ol>
<p>因此代码如下表述</p>
<figure class="highlight c"><figcaption><span>af_packet.c:packet_create</span><a href="https://elixir.bootlin.com/linux/2.4.18/source/net/packet/af_packet.c#L936">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_create</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> protocol)</span> &#123;</span><br><span class="line">    <span class="comment">// 略部分代码</span></span><br><span class="line">    <span class="keyword">if</span> (protocol) &#123;</span><br><span class="line">        sk-&gt;protinfo.af_packet-&gt;prot_hook.type = protocol;</span><br><span class="line">        dev_add_pack(&amp;sk-&gt;protinfo.af_packet-&gt;prot_hook); <span class="comment">/* 增加 Hook 在此协议上 */</span></span><br><span class="line">        sock_hold(sk);</span><br><span class="line">        sk-&gt;protinfo.af_packet-&gt;running = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>直到此处，我们走到这里算是和硬件越来越远了。再下来的历程，我们要去面对的是更加高纬度的 <code>Socket</code> 抽象。</p>
<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: 硬中断 -> 软中断',
	 'interrupt->netif_rx: 1. 将网卡数据copy到内核态',
	 'netif_rx->softnet_data: 2. 将数据放置于虚拟的网卡队列',
	 'softirq->softnet_data: 3. 软中断读取软网卡数据',
	 'softirq->callback_func: 4. 调用对应协议的回调函数',
	 'Note over interrupt,softnet_data: top half',
	 'Note over softnet_data,callback_func: bottom half',
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>
<h4 id="选读-软断成本"><a class="header-anchor" href="#选读-软断成本">¶</a>[选读] 软断成本</h4>
<p>对于常见的硬件中断来说，比如键入了一个字母，过程简单，很快可以处理完成，对于网络IO就复杂的多，涉及到从驱动拷贝数据，然后到虚拟的网络协议栈，再到Socket的Buffer中，因此才才产生的了软中断的，将中断一分为二，软中断优先级较低但是因为软件中断复杂，成本上是要更多的。</p>
<p>软中断依然需要 ➊ 进程上下文的切换（这里切换到 内核线程 <code>ksoftirqd</code> ），这里只不过相对于硬中断是操作系统自己进行调度的 ➋ 就是和系统开销调用一下，因为对于正常运行的用户态进程，我们需要把当前的上下文保存。</p>
<p>内核线程 <code>ksoftirqd</code> 也会充分利用多核的能力，对于每一个 <code>core</code> 都会启动一个 <code>ksoftirqd</code>，暂且可以把它当做一个普通的进程看待。</p>
<h4 id="NAPI"><a class="header-anchor" href="#NAPI">¶</a>NAPI</h4>
<p>单纯的看，上面的开销，我们一眼就可以发现硬中断部分有一个非常不合理的情况，考虑如果出现以下情况</p>
<blockquote>
<p>网卡每隔 10 ms 获得一个数据包，我们硬中断处理需要 9ms</p>
</blockquote>
<p>那会出现一个很神奇的现象就是我们虽然每次都要将中断结束，但是每一次刚刚结束又要唤醒，结果我们会浪费大量的时间在处理中断请求上。针对这一的情况，<code>Linux 2.6</code> 之后提供了一个全新的API来处理这种情况（实际上对于大部分的数据，网络请求从不间断）。</p>
<p><img src="https://s3.jpg.cm/2020/09/27/JULvD.png" alt="JULvD.png"></p>
<p>既然每次进中断都很浪费，那我们就不要每一次都进中断了，<code>NAPI</code> 的解决之道就是，当我们接收到请求之后，我们将从此网卡读取作为一个 <code>Task</code> 注册到 <code>napi_scheluder</code> 中，然后屏蔽中断，内核定时的去 <code>poll</code> 数据即可。主要就是减少了硬中断切换的成本。</p>
<h5 id="NAPI-定义"><a class="header-anchor" href="#NAPI-定义">¶</a>NAPI 定义</h5>
<figure class="highlight c"><figcaption><span>napi</span><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/include/linux/netdevice.h#L353">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// poll 列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">poll_list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> state;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得数据的 poll 函数</span></span><br><span class="line">    <span class="type">int</span> (*poll)(<span class="keyword">struct</span> napi_struct *, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>核心的逻辑都是在 <code>poll</code> 的回调函数中。</p>
<h5 id="NAPI-之下的硬中断处理"><a class="header-anchor" href="#NAPI-之下的硬中断处理">¶</a>NAPI 之下的硬中断处理</h5>
<figure class="highlight c"><figcaption><span>rtl8139_interrupt</span><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/drivers/net/8139too.c#L2104">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">rtl8139_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_instance)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> net_device *) dev_instance;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_private</span> *<span class="title">tp</span> =</span> netdev_priv(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Receive packets are processed by poll routine.</span></span><br><span class="line"><span class="comment">       If not running start it now.</span></span><br><span class="line"><span class="comment">	   如注释所言，现在的处理都早 POLL 的子函数中，我们在这里只是向 __napi_schedule 注册我们的 poll 函数</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (status &amp; RxAckBits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (napi_schedule_prep(&amp;tp-&gt;napi)) &#123;</span><br><span class="line">            RTL_W16_F(IntrMask, rtl8139_norx_intr_mask);</span><br><span class="line">            __napi_schedule(&amp;tp-&gt;napi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    netdev_dbg(dev, <span class="string">&quot;exiting interrupt, intr_status=%#4.4x\n&quot;</span>,</span><br><span class="line">               RTL_R16(IntrStatus));</span><br><span class="line">    <span class="keyword">return</span> IRQ_RETVAL(handled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>poll</code> 函数的实现这里就不做展开了，和传统的体系一样，直接将数据拷贝到内核态没有区别。</p>
<h5 id="软中断唤醒"><a class="header-anchor" href="#软中断唤醒">¶</a>软中断唤醒</h5>
<p>因此到此版本，网络请求的软中断环境代码也相对应的有所改变</p>
<figure class="highlight c"><figcaption><span>net_rx_action</span><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/net/core/dev.c#L3731">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">net_rx_action</span><span class="params">(<span class="keyword">struct</span> softirq_action *h)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> =</span> &amp;__get_cpu_var(softnet_data);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> time_limit = jiffies + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> budget = netdev_budget;</span><br><span class="line">    <span class="type">void</span> *have;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!list_empty(&amp;sd-&gt;poll_list)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span> *<span class="title">n</span>;</span></span><br><span class="line">        <span class="type">int</span> work, weight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得可运行的 poll</span></span><br><span class="line">        n = list_first_entry(&amp;sd-&gt;poll_list,</span><br><span class="line">        <span class="keyword">struct</span> napi_struct, poll_list);</span><br><span class="line"></span><br><span class="line">        work = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state)) &#123;</span><br><span class="line">            work = n-&gt;poll(n, weight); <span class="comment">// 执行 poll 操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只将核心的逻辑展示出来，比如代码中 <code>budget</code> 防止饥饿的操作都留于读者自行理解了， <code>NAPI</code> 解决了我们依靠硬中断导致的大量的进程切换的问题，加上现在的操作系统都是基于 <code>DMA</code> ，因此整个过程中的成本就只有 ➊ 软中断导致的线程切换  ➋ 数据的拷贝</p>
<p><img src="https://s3.jpg.cm/2020/09/27/JUWsT.png" alt="JUWsT.png"></p>
<hr>
<h2 id="IP-Level"><a class="header-anchor" href="#IP-Level">¶</a>IP Level</h2>
<p>我们从 <code>软中断</code> 归来，数据开始进入了我们熟悉的协议处理部分，从 <code>ip_rcv</code> 开始作为我们正式的处理逻辑。</p>
<p><code>Linux</code> 这也使用了 <code>ip_rt_hash_table</code> 的一种设计方式。</p>
<figure class="highlight c"><figcaption><span>ip_rcv</span><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/net/ipv4/ip_input.c#L375">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> net_device *orig_dev)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    u32 len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得IP协议的头部数据</span></span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *	按照 RFC1122 进行检测</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (iph-&gt;ihl &lt; <span class="number">5</span> || iph-&gt;version != <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">goto</span> inhdr_error;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (unlikely(ip_fast_csum((u8 *) iph, iph-&gt;ihl)))</span><br><span class="line">        <span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">    len = ntohs(iph-&gt;tot_len);</span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;len &lt; len) &#123;</span><br><span class="line">        IP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);</span><br><span class="line">        <span class="keyword">goto</span> drop;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt; (iph-&gt;ihl * <span class="number">4</span>))</span><br><span class="line">        <span class="keyword">goto</span> inhdr_error;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pskb_trim_rcsum(skb, len)) &#123;</span><br><span class="line">        IP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);</span><br><span class="line">        <span class="keyword">goto</span> drop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(IPCB(skb), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inet_skb_parm));</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 上面一圈检测没啥问题进入 Nefilter 预留的 HOOK 进行处理</span></span><br><span class="line">    <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, dev, <span class="literal">NULL</span>, ip_rcv_finish);</span><br><span class="line">	</span><br><span class="line">inhdr_error:</span><br><span class="line">    IP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);</span><br><span class="line">drop:</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>NF_HOOK</code> 的逻辑不在本文的探讨范围内，我们直接看最后在 <code>NF_INET_PRE_ROUTING</code> 阶段完成，进入了下一步的逻辑处理 <code>ip_rcv_finish</code></p>
<figure class="highlight c"><figcaption><span>ip_rcv_finish</span><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/net/ipv4/ip_input.c#L443">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">ip_rcv_finish</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> skb-&gt;dev;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> =</span> skb-&gt;nh.iph;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *	Initialise the virtual path cache for the packet. It describes</span></span><br><span class="line"><span class="comment">     *	how the packet travels inside Linux networking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;dst == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 查找 route 表，不可达就直接丢弃</span></span><br><span class="line">        <span class="keyword">if</span> (ip_route_input(skb, iph-&gt;daddr, iph-&gt;saddr, iph-&gt;tos, dev))</span><br><span class="line">            <span class="keyword">goto</span> drop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// header 长度超过 5，说明还有其他需要处理的</span></span><br><span class="line">    <span class="keyword">if</span> (iph-&gt;ihl &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 略，暂时不关心</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> skb-&gt;dst-&gt;input(skb);</span><br><span class="line"></span><br><span class="line">drop:</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">    <span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只能从中得知我们下一步最重要的就是去处理 <code>route</code> 关系。</p>
<h3 id="选读-IP-Route"><a class="header-anchor" href="#选读-IP-Route">¶</a>[选读] IP Route</h3>
<p><code>Linux</code> 在这里进行了大量的 <code>Cache</code> 操作，我们滤过那些 Cache 的部分，读者如果愿意可以自行阅读代码。</p>
<figure class="highlight c"><figcaption><span>route.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_route_input_slow</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, __be32 daddr, __be32 saddr,</span></span><br><span class="line"><span class="params">                               u8 tos, <span class="keyword">struct</span> net_device *dev)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fib_result</span> <span class="title">res</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_device</span> *<span class="title">in_dev</span> =</span> __in_dev_get_rcu(dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flowi4</span> <span class="title">fl4</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> flags = <span class="number">0</span>;</span><br><span class="line">    u32 itag = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rth</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> hash;</span><br><span class="line">    __be32 spec_dst;</span><br><span class="line">    <span class="type">int</span> err = -EINVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* IP on this device is disabled. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_dev)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多播部分的逻辑跳转</span></span><br><span class="line">    <span class="keyword">if</span> (ipv4_is_multicast(saddr) || ipv4_is_lbcast(saddr) ||</span><br><span class="line">        ipv4_is_loopback(saddr))</span><br><span class="line">        <span class="keyword">goto</span> martian_source;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广播逻辑的跳转，下略</span></span><br><span class="line">    <span class="keyword">if</span> (ipv4_is_lbcast(daddr) || (saddr == <span class="number">0</span> &amp;&amp; daddr == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">goto</span> brd_input;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ipv4_is_zeronet(saddr))</span><br><span class="line">        <span class="keyword">goto</span> martian_source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ipv4_is_zeronet(daddr) || ipv4_is_loopback(daddr))</span><br><span class="line">        <span class="keyword">goto</span> martian_destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *	我们开始处理IP协议逻辑的部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fl4.flowi4_oif = <span class="number">0</span>;</span><br><span class="line">    fl4.flowi4_iif = dev-&gt;ifindex;</span><br><span class="line">    fl4.flowi4_mark = skb-&gt;mark;</span><br><span class="line">    fl4.flowi4_tos = tos;</span><br><span class="line">    fl4.flowi4_scope = RT_SCOPE_UNIVERSE;</span><br><span class="line">    fl4.daddr = daddr;</span><br><span class="line">    fl4.saddr = saddr;</span><br><span class="line">    err = fib_lookup(net, &amp;fl4, &amp;res);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果设备不允许转发，host不可达错误</span></span><br><span class="line">        <span class="keyword">if</span> (!IN_DEV_FORWARD(in_dev))</span><br><span class="line">            <span class="keyword">goto</span> e_hostunreach;</span><br><span class="line">        <span class="keyword">goto</span> no_route;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RT_CACHE_STAT_INC(in_slow_tot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.type == RTN_BROADCAST)</span><br><span class="line">        <span class="keyword">goto</span> brd_input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local 的处理</span></span><br><span class="line">    <span class="keyword">if</span> (res.type == RTN_LOCAL) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IN_DEV_FORWARD(in_dev))</span><br><span class="line">        <span class="keyword">goto</span> e_hostunreach;</span><br><span class="line">    <span class="keyword">if</span> (res.type != RTN_UNICAST)</span><br><span class="line">        <span class="keyword">goto</span> martian_destination;</span><br><span class="line">	<span class="comment">// ip_mkroute_input 使我们的核心逻辑处</span></span><br><span class="line">    err = ip_mkroute_input(skb, &amp;res, &amp;fl4, in_dev, daddr, saddr, tos);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于路由算法部分，请参考 <a href="https://blog.csdn.net/qy532846454/article/details/6423496">Linux内核分析 - 网络[四]：路由表</a> 这里不做展开了，最终我们将我们的 <code>skb-&gt;dst-&gt;input</code> 函数指向了 <code>int ip_local_deliver(struct sk_buff *skb)</code> 函数，因为这个数据包是需要我们本地进行处理，而不是进行转发等操作。</p>
<h3 id="IP-Deliver"><a class="header-anchor" href="#IP-Deliver">¶</a>IP Deliver</h3>
<figure class="highlight c"><figcaption><span>ip_local_deliver</span><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/net/ipv4/ip_input.c#L253">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_local_deliver</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 这里要重新排下 IP 的包顺序</span></span><br><span class="line">	<span class="keyword">if</span> (ip_hdr(skb)-&gt;frag_off &amp; htons(IP_MF | IP_OFFSET)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里又是熟悉的 Netfilter 的埋点，NF_INET_LOCAL_IN 阶段的回调事件</span></span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN, skb, skb-&gt;dev, <span class="literal">NULL</span>, ip_local_deliver_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终在 <code>ip_local_deliver_finish</code> 函数中</p>
<figure class="highlight c"><figcaption><span>ip_local_deliver_finish</span><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/net/ipv4/ip_input.c#L188">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_local_deliver_finish</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(skb-&gt;dev);</span><br><span class="line">	<span class="comment">// 跳过 ip 协议的 Header 部分</span></span><br><span class="line">    __skb_pull(skb, ip_hdrlen(skb));</span><br><span class="line">	<span class="type">int</span> protocol = ip_hdr(skb)-&gt;protocol;</span><br><span class="line">    <span class="keyword">if</span> (ipprot != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">		<span class="comment">// 针对IP Protocol 的协议进行处理</span></span><br><span class="line">        ret = ipprot-&gt;handler(skb);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            protocol = -ret;</span><br><span class="line">            <span class="keyword">goto</span> resubmit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 IP 层之上，还有除了 <code>TCP</code> 之外其他的协议，因此这里需要针对不同的 <code>protocol</code> 调用相对应的 <code>函数</code>，这里其实就是我们的 <code>int tcp_v4_rcv(struct sk_buff *skb)</code>，再往下走就是我们熟悉的 <code>TCP</code> 层。</p>
<hr>
<h2 id="TCP-Level"><a class="header-anchor" href="#TCP-Level">¶</a>TCP Level</h2>
<p>对于我们来说，网络编程大部分的时候都在和 <code>Socket</code> 这个抽象进行斗争，<code>TCP</code> 层开始，我们就将 <code>IP</code>包组成 <code>TCP</code> 报文发送给 <code>Socket</code>了。对于 <code>socket</code> 有两种抽象：</p>
<ul>
<li><strong>struct socket</strong> 接近用户态的抽象，为用户实现 <a href="http://en.wikipedia.org/wiki/Berkeley_sockets"><code>BSD Socket</code></a> 抽象</li>
<li><strong>struct sock</strong> 内核中表示的网络连接抽象。</li>
</ul>
<h3 id="Sock-定义"><a class="header-anchor" href="#Sock-定义">¶</a>Sock 定义</h3>
<p>对于 <code>Sock</code> 有着一个很巨大复杂的定义，我们尽量剥离出那些比较重要的。</p>
<figure class="highlight c"><figcaption><span>struct_sock</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_common</span> __<span class="title">sk_common</span>;</span></span><br><span class="line">    <span class="type">socket_lock_t</span> sk_lock;</span><br><span class="line">    <span class="comment">// 接受数据的队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> <span class="title">sk_receive_queue</span>;</span></span><br><span class="line">    <span class="comment">// 发送数据队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> <span class="title">sk_write_queue</span>;</span></span><br><span class="line">    <span class="comment">// 计时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">sk_timer</span>;</span></span><br><span class="line">    <span class="comment">// 对应的用户侧 socket</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sk_socket</span>;</span></span><br><span class="line">    <span class="comment">// 此 socket 的上下文数据</span></span><br><span class="line">    <span class="type">void</span> *sk_user_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调函数</span></span><br><span class="line">    <span class="type">void</span> (*sk_state_change)(<span class="keyword">struct</span> sock *sk);</span><br><span class="line">    <span class="type">void</span> (*sk_data_ready)(<span class="keyword">struct</span> sock *sk);</span><br><span class="line">    <span class="type">void</span> (*sk_write_space)(<span class="keyword">struct</span> sock *sk);</span><br><span class="line">    <span class="type">void</span> (*sk_error_report)(<span class="keyword">struct</span> sock *sk);</span><br><span class="line">    <span class="type">int</span> (*sk_backlog_rcv)(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb);</span><br><span class="line">    <span class="type">void</span> (*sk_destruct)(<span class="keyword">struct</span> sock *sk);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从最简单的设计定义上，我们可以发现，对于 <code>sock</code>，我们知道我们有一个 <code>Recv</code> 的队列，和一个 <code>Send</code> 的队列，现在我们的大部分的操作都会在这两个队列进行操作。</p>
<h3 id="Sock-读取数据"><a class="header-anchor" href="#Sock-读取数据">¶</a>Sock 读取数据</h3>
<p>在 <code>sock.c</code> 中写的非常的清晰</p>
<figure class="highlight c"><figcaption><span>sock_queue_rcv_skb</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// sk 是待接收数据的 sock， skb 是内核接收到的数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sock_queue_rcv_skb</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span> &#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> *<span class="title">list</span> =</span> &amp;sk-&gt;sk_receive_queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据积压超过 rcvbuf 限制，返回异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">atomic_read</span>(&amp;sk-&gt;sk_rmem_alloc) &gt;= sk-&gt;sk_rcvbuf) &#123;</span><br><span class="line">        <span class="type">atomic_inc</span>(&amp;sk-&gt;sk_drops);</span><br><span class="line">        trace_sock_rcvqueue_full(sk, skb);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 Netfilter 逻辑</span></span><br><span class="line">    err = sk_filter(sk, skb);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 skb 的归属者设置下</span></span><br><span class="line">    skb-&gt;dev = <span class="literal">NULL</span>;</span><br><span class="line">    skb_set_owner_r(skb, sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据置于  receive_queue 的尾部</span></span><br><span class="line">    __skb_queue_tail(<span class="built_in">list</span>, skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何 Socket 不处于 READ 状态，就触发下 sk_data_ready 回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (!sock_flag(sk, SOCK_DEAD))</span><br><span class="line">        sk-&gt;sk_data_ready(sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sock 写入数据类似，这里不做展开。我们先暂且不考虑被我忽略的 <code>Lock</code> 的部分的逻辑。其实代码的逻辑非常的好理解，我们将受到的 bytes 数据置于队列的尾部，通知下数据就绪就可以了。</p>
<h3 id="谁负责写入队列"><a class="header-anchor" href="#谁负责写入队列">¶</a>谁负责写入队列</h3>
<h4 id="TCP-IP-模式"><a class="header-anchor" href="#TCP-IP-模式">¶</a>TCP/IP 模式</h4>
<figure class="highlight c"><figcaption><span>tcp_v4_rcv</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/net/ipv4/tcp_ipv4.c#L1695">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(skb-&gt;dev);</span><br><span class="line">    <span class="type">int</span> sdif = inet_sdif(skb);</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">    <span class="type">bool</span> refcounted;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得 tcp header 部分</span></span><br><span class="line">    th = (<span class="type">const</span> <span class="keyword">struct</span> tcphdr *) skb-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得 ip header 部分</span></span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">lookup:  <span class="comment">// 查表获得 对应的 sock, 这里会根据 source ip / dist ip / source port / dis port 获得有个唯一的 sock</span></span><br><span class="line">    sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, __tcp_hdrlen(th), th-&gt;source,</span><br><span class="line">                           th-&gt;dest, sdif, &amp;refcounted);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有直接跳转到异常处理</span></span><br><span class="line">    <span class="keyword">if</span> (!sk)</span><br><span class="line">        <span class="keyword">goto</span> no_tcp_socket;</span><br><span class="line"></span><br><span class="line">process:</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_TIME_WAIT)</span><br><span class="line">        <span class="keyword">goto</span> do_time_wait;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_NEW_SYN_RECV) &#123;</span><br><span class="line">        <span class="comment">// TCP_NEW_SYN_RECV 处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Netfilter 失败直接 discard</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_filter(sk, skb))</span><br><span class="line">        <span class="keyword">goto</span> discard_and_relse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得 tcp header 部分</span></span><br><span class="line">    th = (<span class="type">const</span> <span class="keyword">struct</span> tcphdr *) skb-&gt;data;</span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用填充数据的回调</span></span><br><span class="line">    tcp_v4_fill_cb(skb, iph, th);</span><br><span class="line"></span><br><span class="line">    skb-&gt;dev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 TCP LISTEN 状态下直接进入 tcp_v4_do_rcv</span></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN) &#123;</span><br><span class="line">        ret = tcp_v4_do_rcv(sk, skb);</span><br><span class="line">        <span class="keyword">goto</span> put_and_return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bh_lock_sock_nested(sk); <span class="comment">// 先上锁</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!sock_owned_by_user(sk)) &#123; <span class="comment">// 如果在此 Sock 在内核态中 接收请求数据</span></span><br><span class="line">        ret = tcp_v4_do_rcv(sk, skb);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tcp_add_backlog(sk, skb)) &#123; <span class="comment">// 不在内核态说明在用户侧处理，将数据放置到 backlog 中</span></span><br><span class="line">        <span class="keyword">goto</span> discard_and_relse;</span><br><span class="line">    &#125;</span><br><span class="line">    bh_unlock_sock(sk); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>tcp_v4_rcv()</code> 函数来说，针对现在 <code>sock</code> 所在的不同状态进行处理我们收到的数据，逻辑也非常的容易理解。</p>
<figure class="highlight c"><figcaption><span>tcp_ipv4.c:tcp_v4_do_rcv</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_do_rcv</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">rsk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求已经建立</span></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_ESTABLISHED) &#123;</span><br><span class="line">        tcp_rcv_established(sk, skb);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是监听状态</span></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">nsk</span> =</span> tcp_v4_cookie_check(sk, skb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!nsk)</span><br><span class="line">            <span class="keyword">goto</span> discard;</span><br><span class="line">        <span class="keyword">if</span> (nsk != sk) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tcp_child_process(sk, nsk, skb)) &#123;</span><br><span class="line">                rsk = nsk;</span><br><span class="line">                <span class="keyword">goto</span> reset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态处理</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_rcv_state_process(sk, skb)) &#123;</span><br><span class="line">        rsk = sk;</span><br><span class="line">        <span class="keyword">goto</span> reset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从入口处我们就发现了，对于<code>Linux</code> 内核来说，根据不同的状态处理 <code>Socket</code> 就所谓的内核虚拟协议栈最重要的事情。我们来看看接受数据的的最终地，对于 <code>TCP/IP4</code> 模式，反而没有直接调用 <code>sock_queue_rcv_skb</code> 而是选择了另外一种方式，因为在此模式下，我们已经在事先检查了大量的阈值状态。</p>
<figure class="highlight c"><figcaption><span>tcp_queue_rcv</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/net/ipv4/tcp_input.c#L4631">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_queue_rcv</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> hdrlen, <span class="type">bool</span> *fragstolen)</span> &#123;</span><br><span class="line">    <span class="type">int</span> eaten;</span><br><span class="line">	<span class="comment">// 获得队列尾</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">tail</span> =</span> skb_peek_tail(&amp;sk-&gt;sk_receive_queue);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 滤过 Header 部分的数据</span></span><br><span class="line">    __skb_pull(skb, hdrlen);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尝试将数据和 tail 进行合并</span></span><br><span class="line">    eaten = (tail &amp;&amp;</span><br><span class="line">             tcp_try_coalesce(sk, tail,</span><br><span class="line">                              skb, fragstolen)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//  不成功就放入 sk_receive_queue 中</span></span><br><span class="line">    <span class="keyword">if</span> (!eaten) &#123;</span><br><span class="line">        __skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);</span><br><span class="line">        skb_set_owner_r(skb, sk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eaten;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="TCP-STATE-PROCESS"><a class="header-anchor" href="#TCP-STATE-PROCESS">¶</a>TCP STATE PROCESS</h5>
<p>对 <code>TCP</code> 协议来说，本质上我们就是在维护一个有限状态的自动机，状态切换的代码在 <a href="https://elixir.bootlin.com/linux/v4.19.148/source/net/ipv4/tcp_input.c#L6017"><code>ipv4/tcp_input.c:tcp_rcv_state_process</code></a> 函数，比较的长就不做展开，处理状态，就是如下图进行各种状态的变换。<br>
<img src="https://s3.jpg.cm/2020/09/25/JWO8G.png" alt="JWO8G.png"></p>
<h4 id="可选-RAW-模式"><a class="header-anchor" href="#可选-RAW-模式">¶</a>[可选] RAW 模式</h4>
<p>Raw也就是混杂模式，这里的实现在 <code>ipv4/raw.c</code> 中</p>
<figure class="highlight c"><figcaption><span>raw_v4_input</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">raw_v4_input</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> iphdr *iph, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="type">int</span> delivered = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line"></span><br><span class="line">    read_lock(&amp;raw_v4_hashinfo.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 Hash 获得对应的链表</span></span><br><span class="line">    head = &amp;raw_v4_hashinfo.ht[hash];</span><br><span class="line">    <span class="keyword">if</span> (hlist_empty(head))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到这个数据从哪个网卡进来的</span></span><br><span class="line">    net = dev_net(skb-&gt;dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查表获得对应的 sock 对象, 这里直接循环了</span></span><br><span class="line">    sk = __raw_v4_lookup(net, __sk_head(head), iph-&gt;protocol,</span><br><span class="line">                         iph-&gt;saddr, iph-&gt;daddr,</span><br><span class="line">                         skb-&gt;dev-&gt;ifindex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sk) &#123;</span><br><span class="line">        delivered = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 这里处理下多播的可能，直到遍历完成就可以跳转至 out 了</span></span><br><span class="line">        <span class="keyword">if</span> ((iph-&gt;protocol != IPPROTO_ICMP || !icmp_filter(sk, skb)) &amp;&amp;</span><br><span class="line">            ip_mc_sf_allow(sk, iph-&gt;daddr, iph-&gt;saddr,</span><br><span class="line">                           skb-&gt;dev-&gt;ifindex)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">clone</span> =</span> skb_clone(skb, GFP_ATOMIC);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Not releasing hash table! */</span></span><br><span class="line">            <span class="keyword">if</span> (clone)</span><br><span class="line">                raw_rcv(sk, clone);</span><br><span class="line">        &#125;</span><br><span class="line">        sk = __raw_v4_lookup(net, sk_next(sk), iph-&gt;protocol,</span><br><span class="line">                             iph-&gt;saddr, iph-&gt;daddr,</span><br><span class="line">                             skb-&gt;dev-&gt;ifindex);</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    read_unlock(&amp;raw_v4_hashinfo.lock);</span><br><span class="line">    <span class="keyword">return</span> delivered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点是不检测 <code>目标端口</code> 只要是 IP 匹配的上就可以传递</p>
<h2 id="Linux-Networking-Stack"><a class="header-anchor" href="#Linux-Networking-Stack">¶</a>Linux Networking Stack</h2>
<p><code>Linux</code> 不仅仅的单纯的提供实现了 <code>TCP/IP</code> 协议，在历代的版本中都尝试在 <code>数据流</code> 处理的过程中增加一些额外的管控能力。ip firewall，ipchains，iptanles，nftables 都是为了让用户在处理的过程中做一些额外的工作。</p>
<h3 id="netfilter"><a class="header-anchor" href="#netfilter">¶</a>netfilter</h3>
<p><a href="https://www.netfilter.org/">netfilter</a> 应该是最出名的项目了，从 <code>Linux 2.4.X</code> 版本开始作为内置的功能提供给运维管理员。针对 <code>Netfilter</code> 的分析比较的多，这里就不展开了，可以查阅 <a href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture">A Deep Dive into Iptables and Netfilter Architecture</a></p>
<p>但是仍有一些不致命但是很烦人的缺点。</p>
<ul>
<li>iptables规则不支持增量配置，时间复杂度均为 <code>O(n)</code></li>
<li>基于配置化回调函数，性能不高</li>
</ul>
<h3 id="ebpf"><a class="header-anchor" href="#ebpf">¶</a>ebpf</h3>
<p><a href="https://ebpf.io/"><code>ebpf</code></a> 是 <code>Linux</code> 社区的一个新星。为了追求性能上的提高，在内核里提供了一个虚拟机，将用户的过滤规则代码编译成<code>字节码</code>然后交付给虚拟机，内核根据这些指令来过滤网络数据包。</p>
<p><img src="https://s3.jpg.cm/2020/09/30/JkLe8.png" alt="JkLe8.png"></p>
<h4 id="基础知识"><a class="header-anchor" href="#基础知识">¶</a>基础知识</h4>
<p>要理解 <code>ebpf</code> 还需要明白 <code>bpf_map</code>， 其本质上是以「键/值」方式存储在内核中的数据结构，它们可以被任何知道它们的 BPF 程序访问。在内核空间的程序创建 BPF Map 并返回对应的文件描述符，在用户空间运行的程序就可以通过这个文件描述符来访问并操作 BPF Map，这就是为什么 BPF Map 在 BPF 世界中是桥梁的存在了。</p>
<p><img src="https://s3.jpg.cm/2020/09/30/JkGaw.png" alt="JkGaw.png"></p>
<h4 id="Example"><a class="header-anchor" href="#Example">¶</a>Example</h4>
<figure class="highlight c"><figcaption><span>sockex1_kern.c[内核态逻辑]</span><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/samples/bpf/sockex1_kern.c">source code</a></figcaption><table><tr><td class="code"><pre><span class="line">SEC(<span class="string">&quot;socket1&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_prog1</span><span class="params">(<span class="keyword">struct</span> __sk_buff *skb)</span> &#123;</span><br><span class="line">    <span class="comment">// 从 skb 获得固定改长度的数据 -&gt; 转换成 index</span></span><br><span class="line">    <span class="type">int</span> index = load_byte(skb, ETH_HLEN + offsetof(</span><br><span class="line">    <span class="keyword">struct</span> iphdr, protocol));</span><br><span class="line">    <span class="type">long</span> *value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;pkt_type != PACKET_OUTGOING)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从 map 中获得储存的数据</span></span><br><span class="line">    value = bpf_map_lookup_elem(&amp;my_map, &amp;index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 skb 中增加我们储存在 map 中的数据</span></span><br><span class="line">    <span class="keyword">if</span> (value)</span><br><span class="line">        __sync_fetch_and_add(value, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> _license[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>sockex1_user.c[用户态逻辑]</span><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/samples/bpf/sockex1_user.c">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> ac, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_object</span> *<span class="title">obj</span>;</span></span><br><span class="line">    <span class="type">int</span> map_fd, prog_fd;</span><br><span class="line">    <span class="type">char</span> filename[<span class="number">256</span>];</span><br><span class="line">    <span class="type">int</span> i, sock;</span><br><span class="line">    FILE *f;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;%s_kern.o&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将编译好内核态代码载入 bpf 模块</span></span><br><span class="line">    <span class="keyword">if</span> (bpf_prog_load(filename, BPF_PROG_TYPE_SOCKET_FILTER, &amp;obj, &amp;prog_fd))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    map_fd = bpf_object__find_map_fd_by_name(obj, <span class="string">&quot;my_map&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个 lo 网卡的 Raw Socket</span></span><br><span class="line">    sock = open_raw_sock(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 Socket 设置 SO_ATTACH_BPF 标记，功能是 prog_fd，也就是我们上面刚刚载入的</span></span><br><span class="line">    assert(setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <span class="keyword">sizeof</span>(prog_fd)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 PING 操作</span></span><br><span class="line">    f = popen(<span class="string">&quot;ping -4 -c5 localhost&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    (<span class="type">void</span>) f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> tcp_cnt, udp_cnt, icmp_cnt;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">        key = IPPROTO_TCP;</span><br><span class="line">        assert(bpf_map_lookup_elem(map_fd, &amp;key, &amp;tcp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        key = IPPROTO_UDP;</span><br><span class="line">        assert(bpf_map_lookup_elem(map_fd, &amp;key, &amp;udp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        key = IPPROTO_ICMP;</span><br><span class="line">        assert(bpf_map_lookup_elem(map_fd, &amp;key, &amp;icmp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;TCP %lld UDP %lld ICMP %lld bytes\n&quot;</span>,</span><br><span class="line">               tcp_cnt, udp_cnt, icmp_cnt);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内核-Hook"><a class="header-anchor" href="#内核-Hook">¶</a>内核 Hook</h4>
<p>从例子中我们也可以很清晰的发现，核心点在于 <code>setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, sizeof(prog_fd)</code>  我们在内核中一顿操作之后就可以发现在</p>
<figure class="highlight c"><figcaption><span>sock_setsockopt</span><a href="https://elixir.bootlin.com/linux/v5.8.12/source/net/core/sock.c#L1084">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> SO_ATTACH_BPF:</span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (optlen == <span class="keyword">sizeof</span>(u32)) &#123;</span><br><span class="line">        u32 ufd;</span><br><span class="line"></span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;ufd, optval, <span class="keyword">sizeof</span>(ufd)))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        ret = sk_attach_bpf(ufd, sk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>这行代码也非常的简单，直接构建了一个全新的 <code>sk_filter</code>，然后给此 <code>sock</code> 设置即可。</p>
<figure class="highlight c"><figcaption><span>sk_filter</span><a href="https://elixir.bootlin.com/linux/v5.8.12/source/net/core/filter.c#L1421">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __sk_attach_prog(<span class="keyword">struct</span> bpf_prog *prog, <span class="keyword">struct</span> sock *sk) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_filter</span> *<span class="title">fp</span>, *<span class="title">old_fp</span>;</span></span><br><span class="line">    <span class="comment">// 开辟内核空间</span></span><br><span class="line">    fp = kmalloc(<span class="keyword">sizeof</span>(*fp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!fp)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 sk_filter 程序就是我们用户编写的</span></span><br><span class="line">    fp-&gt;prog = prog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rcu 设置 fp 对象</span></span><br><span class="line">    old_fp = rcu_dereference_protected(sk-&gt;sk_filter,</span><br><span class="line">                                       lockdep_sock_is_held(sk));</span><br><span class="line">    rcu_assign_pointer(sk-&gt;sk_filter, fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而调用的地方也非常的清晰，比如说在接受数据的地方。</p>
<figure class="highlight c"><figcaption><span>sock_queue_rcv_skb</span><a href="https://elixir.bootlin.com/linux/v5.8.12/source/net/core/sock.c#L483">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sock_queue_rcv_skb</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span> &#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    err = sk_filter(sk, skb);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __sock_queue_rcv_skb(sk, skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实调用处</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sk_filter_trim_cap</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> cap)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上读锁</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    <span class="comment">// 获得 filter</span></span><br><span class="line">    filter = rcu_dereference(sk-&gt;sk_filter);</span><br><span class="line">    <span class="keyword">if</span> (filter) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">save_sk</span> =</span> skb-&gt;sk;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> pkt_len;</span><br><span class="line"></span><br><span class="line">        skb-&gt;sk = sk;</span><br><span class="line">        <span class="comment">// 执行回调</span></span><br><span class="line">        pkt_len = bpf_prog_run_save_cb(filter-&gt;prog, skb);</span><br><span class="line">        skb-&gt;sk = save_sk;</span><br><span class="line">        err = pkt_len ? pskb_trim(skb, max(cap, pkt_len)) : -EPERM;</span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h4>
<p>对于 <code>ebpf</code> 不算是什么新的技术 <a href="http://www.tcpdump.org/papers/bpf-usenix93.pdf">The BSD Packet Filter: A New Architecture for User-level Packet Capture</a> 发表在 <code>1992</code> 年，其核心还是基于 <code>编译器</code> 优化成特定平台的代码以提高效率，并且因为配置项都是 <code>case by case</code> 的模式，因为也不存在维护一个巨大的 <code>tables</code> 的困扰，最终再通过 <code>mmap</code> 映射的方式，将数据在内核和用户侧进行共享。</p>
<p><code>ebpf</code> 代表了内核向用户开放能力的趋势。现在能使用的点也并不少。<br>
<img src="https://s3.jpg.cm/2020/09/30/JFZpO.png" alt="JFZpO.png"></p>
<p>可以畅想下，未来可能会出现如下的功能架构</p>
<p><img src="https://s3.jpg.cm/2020/09/30/JkrhS.png" alt="JkrhS.png"></p>
<p>我们可以直接通过可编程的模式，从 <code>云端</code> 直接推送可插拔在 <code>内核</code> 中的代码逻辑。</p>
<h2 id="用户空间"><a class="header-anchor" href="#用户空间">¶</a>用户空间</h2>
<p>到上面为止，我们已经走完了所有内核部分的网络代码，下面的逻辑就是用户态的部分了。</p>
<h3 id="BIO-模型"><a class="header-anchor" href="#BIO-模型">¶</a>BIO 模型</h3>
<p>这个模型大家都熟悉，我们通过 <code>Read()</code> 来读取数据</p>
<h4 id="Example-v2"><a class="header-anchor" href="#Example-v2">¶</a>Example</h4>
<figure class="highlight c"><figcaption><span>bio</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr *) &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ERROR on binding&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    listen(sockfd, <span class="number">5</span>);</span><br><span class="line">    clilen = <span class="keyword">sizeof</span>(cli_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accept 一个新请求</span></span><br><span class="line">    newsockfd = accept(sockfd, (<span class="keyword">struct</span> sockaddr *) &amp;cli_addr, &amp;clilen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newsockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ERROR on accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(buffer, <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最多读取 255 个字节的数据</span></span><br><span class="line">    n = read(newsockfd, buffer, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出错返回</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ERROR reading from socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Read"><a class="header-anchor" href="#Read">¶</a>Read</h4>
<p>读取消息的话，内部API经历的多个版本的变更，因为为了后面讲解 <code>epoll</code>，我们看比较新的 <code>4.19</code> 版本</p>
<figure class="highlight c"><figcaption><span>do_sys_recvmmsg</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/net/socket.c#L2343">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// wrap 下 __sys_recvmmsg 函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_sys_recvmmsg</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> mmsghdr __user *mmsg,</span></span><br><span class="line"><span class="params">			   <span class="type">unsigned</span> <span class="type">int</span> vlen, <span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">			   <span class="keyword">struct</span> timespec __user *timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> datagrams;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timeout_sys</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MSG_CMSG_COMPAT)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!timeout)</span><br><span class="line">		<span class="keyword">return</span> __sys_recvmmsg(fd, mmsg, vlen, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	datagrams = __sys_recvmmsg(fd, mmsg, vlen, flags, &amp;timeout_sys);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里需要注意的就是大家常说的 零拷贝，这里我们其实需要将内核的数据 COPY 至用户态</span></span><br><span class="line">	<span class="keyword">if</span> (datagrams &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">	    copy_to_user(timeout, &amp;timeout_sys, <span class="keyword">sizeof</span>(timeout_sys)))</span><br><span class="line">		datagrams = -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> datagrams;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __sys_recvmmsg(<span class="type">int</span> fd, <span class="keyword">struct</span> mmsghdr __user *mmsg, <span class="type">unsigned</span> <span class="type">int</span> vlen,</span><br><span class="line">           <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="keyword">struct</span> timespec *timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//找到 FD 对应的 sock 对象</span></span><br><span class="line">    sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">    <span class="keyword">if</span> (!sock)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    entry = mmsg;</span><br><span class="line">    compat_entry = (<span class="keyword">struct</span> compat_mmsghdr __user *)mmsg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ➊ loop 读取数据</span></span><br><span class="line">    <span class="keyword">while</span> (datagrams &lt; vlen) &#123; </span><br><span class="line">        err = ___sys_recvmsg(sock, (<span class="keyword">struct</span> user_msghdr __user *)entry, &amp;msg_sys, flags &amp; ~MSG_WAITFORONE, datagrams);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        err = put_user(err, &amp;entry-&gt;msg_len);</span><br><span class="line">        ++entry;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ++datagrams;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果是 MSG_WAITFORONE 就设置 MSG_DONTWAIT */</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; MSG_WAITFORONE)</span><br><span class="line">            flags |= MSG_DONTWAIT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 无需等待的情况下就直接 Ret 了 */</span></span><br><span class="line">        <span class="keyword">if</span> (msg_sys.msg_flags &amp; MSG_OOB)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果数据没读够就 yield 掉</span></span><br><span class="line">        cond_resched();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_put;</span><br><span class="line"></span><br><span class="line">out_put:</span><br><span class="line">    fput_light(sock-&gt;file, fput_needed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> datagrams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们在配置 <code>FD</code> 的时候，如果是非阻塞的，我们哪怕获取不到数据也会立即返回，在最初的 <code>Blocking IO</code> 模式下，我们需要等待数据的获取，才能返回，因此我们会在 ➊ 处进行 LOOP，我们在 <code>cond_resched</code> 主动将自己释放出来，然后等待下次的调用。</p>
<p>我们再往下走一层，<code>Read</code> 函数的下一层则是 <code>tcp.c:tcp_recvmsg()</code></p>
<figure class="highlight c"><figcaption><span>tcp_recvmsg</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/net/ipv4/tcp.c#L1998">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	u32 offset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从 sk_receive_queue 获得想要的数据</span></span><br><span class="line">	last = skb_peek_tail(&amp;sk-&gt;sk_receive_queue);</span><br><span class="line">	skb_queue_walk(&amp;sk-&gt;sk_receive_queue, skb)</span><br><span class="line">	&#123;</span><br><span class="line">		last = skb;</span><br><span class="line"></span><br><span class="line">		offset = *seq - TCP_SKB_CB(skb)-&gt;seq;</span><br><span class="line">		<span class="keyword">if</span> (offset &lt; skb-&gt;len)</span><br><span class="line">			<span class="keyword">goto</span> found_ok_skb;</span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN)</span><br><span class="line">			<span class="keyword">goto</span> found_fin_ok;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 找到了 skb</span></span><br><span class="line">found_ok_skb:</span><br><span class="line">	<span class="comment">/* 足够需要么？ */</span></span><br><span class="line">	used = skb-&gt;len - offset;</span><br><span class="line">	<span class="keyword">if</span> (len &lt; used)</span><br><span class="line">		used = len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝数据到 MSG 也就是用户态中</span></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; MSG_TRUNC)) &#123;</span><br><span class="line">		err = skb_copy_datagram_msg(skb, offset, msg, used);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*seq += used;</span><br><span class="line">	copied += used;</span><br><span class="line">	len -= used;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理 FIN. */</span></span><br><span class="line">found_fin_ok:</span><br><span class="line">	++*seq;</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; MSG_PEEK))</span><br><span class="line">		sk_eat_skb(sk, skb);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (len &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>直到这里我们已经把握到了数据读取的命门，真实调用的就是 <code>skb_copy_datagram_msg()</code> 函数，而他所读取的恰好就是我们的 <code>sock</code> 的 <code>sk_receive_queue</code>，因此到此为止，我们已经将用户态至网卡的所有流程全面打通。</p>
<h4 id="BIO的成本"><a class="header-anchor" href="#BIO的成本">¶</a>BIO的成本</h4>
<p>在 <code>Blocking</code> 模式下，读取数据需要两方面的成本：<code>模态切换</code>和<code>线程等待</code></p>
<h5 id="模态切换"><a class="header-anchor" href="#模态切换">¶</a>模态切换</h5>
<p><code>用户态</code> 切换至 <code>内核态</code> 我们使用的 <code>Syscall</code> 模式，因此对于这一步的切换本身也是有成本的，我们需要切换<code>堆栈</code>，切换 <code>cs/ip</code> 寄存器，这一步也不是免费的，<a href="https://en.wikipedia.org/wiki/Protection_ring">Protection ring</a></p>
<blockquote>
<p>In most existing systems, switching from user mode to kernel mode has an associated high cost in performance. It has been measured, on the basic request getpid, to cost 1000–1500 cycles on most machines. Of these just around 100 are for the actual switch (70 from user to kernel space, and 40 back), the rest is “kernel overhead”. In the L3 microkernel, the minimization of this overhead reduced the overall cost to around 150 cycles.</p>
</blockquote>
<h5 id="线程等待"><a class="header-anchor" href="#线程等待">¶</a>线程等待</h5>
<p><img src="https://s3.jpg.cm/2020/09/27/JuepH.png" alt="JuepH.png"></p>
<p>因为对于如果我们 <code>read</code> 不到数据，也就是在等待的过程中，我们就不得不去面对 <code>cond_resched()</code> 我们将自己执行的CPU时间让出来，然后等待下次的调用，这个数量和我们的 <code>socket</code> 数量成正比，尤其是我们传统的每一个 <code>socket</code> 配给一个 <code>thread</code> 进行处理的时候，我们要付出大量的线程切换时间。</p>
<h3 id="NIO-模型"><a class="header-anchor" href="#NIO-模型">¶</a>NIO 模型</h3>
<p>为了解决 <a href="#%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85">线程等待</a> 的问题，<code>Linux</code> 提供了新的编程模式 <code>epoll</code>。</p>
<h4 id="Example-v3"><a class="header-anchor" href="#Example-v3">¶</a>Example</h4>
<figure class="highlight c"><figcaption><span>epoll</span><a href="https://github.com/millken/c-example/blob/master/epoll-example.c">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    n = epoll_wait(efd, events, MAXEVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            i &lt; n;</span><br><span class="line">            i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) ||</span><br><span class="line">            (events[i].events &amp; EPOLLHUP) ||</span><br><span class="line">            (!(events[i].events &amp; EPOLLIN))) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">                    <span class="string">&quot;epoll error\n&quot;</span>);</span><br><span class="line">            close(events[i]</span><br><span class="line">                          .data.fd);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sfd == events[i].data.fd) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">struct</span> sockaddr in_addr;</span><br><span class="line">                <span class="type">socklen_t</span> in_len;</span><br><span class="line">                <span class="type">int</span> infd;</span><br><span class="line">                <span class="type">char</span> hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];</span><br><span class="line"></span><br><span class="line">                in_len = <span class="keyword">sizeof</span> in_addr;</span><br><span class="line">                infd = accept(sfd, &amp;in_addr, &amp;in_len);</span><br><span class="line">                <span class="keyword">if</span> (infd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((errno == EAGAIN) ||</span><br><span class="line">                        (errno == EWOULDBLOCK)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                s = getnameinfo(&amp;in_addr, in_len,</span><br><span class="line">                                hbuf, <span class="keyword">sizeof</span> hbuf,</span><br><span class="line">                                sbuf, <span class="keyword">sizeof</span> sbuf,</span><br><span class="line">                                NI_NUMERICHOST | NI_NUMERICSERV);</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection on descriptor %d &quot;</span></span><br><span class="line">                           <span class="string">&quot;(host=%s, port=%s)\n&quot;</span>, infd, hbuf, sbuf);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                s = make_socket_non_blocking(infd);</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">                event.data.</span><br><span class="line">                        fd = infd;</span><br><span class="line">                event.</span><br><span class="line">                        events = EPOLLIN | EPOLLET;</span><br><span class="line">                s = epoll_ctl(efd, EPOLL_CTL_ADD, infd, &amp;event);</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Read-数据"><a class="header-anchor" href="#Read-数据">¶</a>Read 数据</h4>
<p>对于 <code>epoll</code> 来说，没有数据就直接返回了，这块就没有什么特别，在上面的分析我们也可以看到。最重要的是如何维护 <code>events</code> 列表的</p>
<h4 id="Event"><a class="header-anchor" href="#Event">¶</a>Event</h4>
<figure class="highlight c"><figcaption><span>epoll_evnet</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/fs/eventpoll.c#L188">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，也就是这个epoll监控的事件*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line">　　</span><br><span class="line">	<span class="comment">/* 双向链表 rdllist (rd -&gt; Ready) 保存着将要通过epoll_wait返回给用户的、满足条件的事件*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 阻塞在 sys_epoll_wait 的队列 */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> wq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 阻塞在 file-&gt;poll() 的队列  */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> poll_wait;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个在 RBR 元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *ptr; <span class="comment">/* 指向用户自定义数据 */</span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* 注册的文件描述符 */</span></span><br><span class="line">    <span class="type">uint32_t</span> u32; <span class="comment">/* 32-bit integer */</span></span><br><span class="line">    <span class="type">uint64_t</span> u64; <span class="comment">/* 64-bit integer */</span></span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>
<p>执行epoll_ctl()时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。因此我们在一个 <code>evnetpoll</code> 对象上可以维护大量的 <code>socket</code> 对象，但是这样还不能足够我们完成事件通知，真正的奥秘还在 <code>rdllist</code> 就绪列表中。</p>
<h4 id="注册文件"><a class="header-anchor" href="#注册文件">¶</a>注册文件</h4>
<p><code>epoll</code> 的就绪列表是基于事件驱动的，这样的就避免了我们一直不断的 <code>轮训</code> 数据导致的 <code>CPU</code> 浪费。因此在我们对 <code>eventpoll</code> 里面增加一个 <code>fd</code>的时候代码如下：</p>
<figure class="highlight c"><figcaption><span>ep_insert</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/fs/eventpoll.c#L1455">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_insert</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep, <span class="type">const</span> <span class="keyword">struct</span> epoll_event *event,</span></span><br><span class="line"><span class="params">                     <span class="keyword">struct</span> file *tfile, <span class="type">int</span> fd, <span class="type">int</span> full_check)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 限制观察的数量 */</span></span><br><span class="line">	user_watches = atomic_long_read(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(user_watches &gt;= max_user_watches))</span><br><span class="line">		<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 初始化 poll_table */</span></span><br><span class="line">	epq.epi = epi;</span><br><span class="line">	init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* ep_ptable_queue_proc 的原型是 </span></span><br><span class="line"><span class="comment">	* typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 向这个FD注册Ready事件 */</span></span><br><span class="line">	revents = ep_item_poll(epi, &amp;epq.pt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 添加到红黑树中 */</span></span><br><span class="line">	ep_rbtree_insert(ep, epi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">	poll_queue_proc _qproc; <span class="comment">/* 回调函数 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> _key; <span class="comment">/* 监听的事件 */</span></span><br><span class="line">&#125; poll_table;</span><br></pre></td></tr></table></figure>
<p><code>ep_item_poll</code> 对应的不同的类型的 <code>poll</code> 函数不同，我们看看最常用的 <code>tcp</code></p>
<figure class="highlight c"><figcaption><span>tcp_poll</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">__poll_t</span> <span class="title function_">tcp_poll</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> socket *sock, poll_table *wait)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">__poll_t</span> mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 核心的 Poll wait 调用</span></span><br><span class="line">	sock_poll_wait(file, sock, wait);</span><br><span class="line"></span><br><span class="line">	state = inet_sk_state_load(sk);</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又去调用了 <code>sock_poll_wait</code>，而这个函数如下</p>
<figure class="highlight c"><figcaption><span>poll_wait</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">poll_wait</span><span class="params">(<span class="keyword">struct</span> file * filp, <span class="type">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)</span><br><span class="line">		p-&gt;_qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_qproc</code> 的定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ep_ptable_queue_proc</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">wait_queue_head_t</span> *whead,</span></span><br><span class="line"><span class="params">                                 poll_table *pt)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> =</span> ep_item_from_epqueue(pt);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册 ep_poll_callback 为 epi，将其加入了 wait queue 中</span></span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">        init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">        pwq-&gt;whead = whead;</span><br><span class="line">        pwq-&gt;base = epi;</span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLEXCLUSIVE)</span><br><span class="line">            add_wait_queue_exclusive(whead, &amp;pwq-&gt;wait);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">        epi-&gt;nwait++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        epi-&gt;nwait = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>帮大家锊一下，到现在到底发生了什么？</p>
<div style="width:100%; overflow-y:scroll;" id="epoll_add"></div>
<script>
	var epoll_add =
	['Title: epoll_add',
	 'ep_insert->ep_pqueue: 1. 将FD包装成ep_pqueue对象',
	 'ep_insert->init_poll_funcptr: 2. 初始化 polltable',
	 'ep_insert->ep_item_poll: 3. 注册Read事件',
	 'ep_item_poll->tcp_poll: 4. 调用 tcp poll 注册等待事件',
	 'tcp_poll->poll_wait: 5. 调用初始化 polltable 的回调函数 ep_ptable_queue_proc',
	 'poll_wait->ep_ptable_queue_proc: 6. 创建 eppoll_entry，回调事件为 ep_poll_callback',
	 'ep_ptable_queue_proc->add_wait_queue: 7. 将 eppoll_entry 加入 sock->wq->wait 队列'
    ].join('\n');
  	var diagram = Diagram.parse(epoll_add);
  	diagram.drawSVG("epoll_add", {theme: 'simple', scale: 0.5});
</script>
<h4 id="callback"><a class="header-anchor" href="#callback">¶</a>callback</h4>
<figure class="highlight c"><figcaption><span>ep_poll_callback</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/fs/eventpoll.c#L1120">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_poll_callback</span><span class="params">(<span class="type">wait_queue_entry_t</span> *wait, <span class="type">unsigned</span> mode, <span class="type">int</span> sync, <span class="type">void</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> =</span> ep_item_from_wait(wait);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> =</span> epi-&gt;ep;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 poll 函数，获得发生的事件</span></span><br><span class="line">    <span class="type">__poll_t</span> pollflags = key_to_poll(key);</span><br><span class="line">    <span class="type">int</span> ewake = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 比对是否是需要处理的事件类型 */</span></span><br><span class="line">    <span class="keyword">if</span> (pollflags &amp;&amp; !(pollflags &amp; epi-&gt;event.events))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果我们不在rdlink里面的话，我们就把自己加入进去 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ep_is_linked(epi)) &#123;</span><br><span class="line">		list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">		ep_pm_stay_awake_rcu(epi);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果有人在等待返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq)) &#123;</span><br><span class="line">        <span class="comment">// ... 一些判断逻辑</span></span><br><span class="line">        wake_up_locked(&amp;ep-&gt;wq); <span class="comment">// 唤醒epoll 中的 wq 队列</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>什么时候会 <code>Invoke</code> 这个 <code>callback</code>，还记得们这个 <code>callback</code> 实际上是在 <code>sock-&gt;wq-&gt;wait</code> 中，而在实际的逻辑中 <code>sock-&gt;wq-&gt;wait</code> 的唤醒是被我们在更早之前所看到的 <code>sock</code> 定义的那些回调函数中</p>
<figure class="highlight c"><figcaption><span>sock_callback</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/include/net/sock.h#L499">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>			(*sk_state_change)(<span class="keyword">struct</span> sock *sk);</span><br><span class="line"><span class="type">void</span>			(*sk_data_ready)(<span class="keyword">struct</span> sock *sk);</span><br><span class="line"><span class="type">void</span>			(*sk_write_space)(<span class="keyword">struct</span> sock *sk);</span><br><span class="line"><span class="type">void</span>			(*sk_error_report)(<span class="keyword">struct</span> sock *sk);</span><br><span class="line"><span class="type">int</span>			  (*sk_backlog_rcv)(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb);</span><br></pre></td></tr></table></figure>
<p>随便点开一个实现，我们都会看到熟悉的 <code>wq</code></p>
<figure class="highlight c"><figcaption><span>tipc_data_ready</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/net/tipc/socket.c#L1933">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tipc_data_ready</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span> *<span class="title">wq</span>;</span></span><br><span class="line">	wq = rcu_dereference(sk-&gt;sk_wq);</span><br><span class="line">	<span class="keyword">if</span> (skwq_has_sleeper(wq))</span><br><span class="line">		<span class="comment">// 唤醒 wq-&gt;wait 队列</span></span><br><span class="line">		wake_up_interruptible_sync_poll(&amp;wq-&gt;wait, EPOLLIN | EPOLLRDNORM | EPOLLRDBAND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ep-poll"><a class="header-anchor" href="#ep-poll">¶</a>ep_poll()</h4>
<p><code>ep_poll</code> 函数比较的简单，</p>
<figure class="highlight c"><figcaption><span>ep_poll</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/fs/eventpoll.c#L1745">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_poll</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep, <span class="keyword">struct</span> epoll_event __user *events,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> maxevents, <span class="type">long</span> timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">fetch_events:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有就绪事件</span></span><br><span class="line">    <span class="keyword">if</span> (!ep_events_available(ep)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 没有任何可用的事件的情况下，在这里 Sleep 掉，等别人 Wake up，</span></span><br><span class="line"><span class="comment">         * 在 ep_poll_callback 触发的时候会从这里继续执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">        __add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 该函数将当前任务设置为TASK_INTERRUPTIBLE，解锁自旋锁并告诉调度程序重新调度，</span></span><br><span class="line"><span class="comment">             * 而且还设置了内核计时器，以在指定的超时时间到期或接收到任何信号时重新调度当前进程。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (fatal_signal_pending(current)) &#123;</span><br><span class="line">                res = -EINTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有可用的事件，或者超时了</span></span><br><span class="line">            <span class="keyword">if</span> (ep_events_available(ep) || timed_out)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">                res = -EINTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            spin_unlock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">            <span class="keyword">if</span> (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))</span><br><span class="line">                timed_out = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            spin_lock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒之后继续把自己从等待队列里面移除</span></span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">        __set_current_state(TASK_RUNNING);</span><br><span class="line">    &#125;</span><br><span class="line">check_events:</span><br><span class="line">    <span class="comment">/* ep_poll()检查是否有任何要报告的就绪事件。然后释放锁 */</span></span><br><span class="line">    eavail = ep_events_available(ep);</span><br><span class="line"></span><br><span class="line">    spin_unlock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果该函数没有任何事件，并且超时尚未到期（如果该函数遇到过早的唤醒，则可能发生），</span></span><br><span class="line"><span class="comment">     * 它只是返回fetch_events 并再次等待。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">        !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)</span><br><span class="line">        <span class="keyword">goto</span> fetch_events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>Epoll</code> 的分析到此结束，<code>epoll</code> 基于 <code>rdlist</code> 来维护我们就绪的事件 <code>fd</code>，然后使用 <code>redblack tree</code> 快速检索这些 <code>fd</code>，而我认为最核心的部分还是莫过于 <code>callback</code> 机制，我们可以在收到数据之后才触发，这样减少了我们 <code>轮训</code> 的时间。</p>
<h4 id="epoll的成本"><a class="header-anchor" href="#epoll的成本">¶</a>epoll的成本</h4>
<p><code>epoll</code> 显然已经将 <code>thread blocking</code> 的成本降低至极限，因为显然我们只需要一个 <code>thread</code> 就可以完成就绪事件的扫描和处理，但是依然有几个成本无法回避 ➊ 模态切换，用户态和内核态转换 ➋ 数据拷贝，因为 <code>Read</code> 依然是需要拷贝数据从内核态到用户态。</p>
<h3 id="Zero-Copy"><a class="header-anchor" href="#Zero-Copy">¶</a>Zero Copy</h3>
<h4 id="传统读写"><a class="header-anchor" href="#传统读写">¶</a>传统读写</h4>
<p>对于 <code>Linux</code> 的读写操作，想象一下从文件中读取一些数据然后写到 <code>socket</code> 中</p>
<figure class="highlight c"><figcaption><span>read/write</span></figcaption><table><tr><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.jpg.cm/2020/09/28/JHDOi.png" alt="JHDOi.png"></p>
<p>读取数据远比想象中的复杂：</p>
<ol>
<li><code>read</code> 系统调用导致从用户模式到内核模式[<code>上下文切换</code>]。第一次复制是由<code>DMA</code>执行的，它从<strong>磁盘</strong>中读取内容并将其存储到内核地址空间缓冲区中。</li>
<li>将数据从内核缓冲区复制到用户缓冲区，然后 <code>read</code> 系统调用返回。调用的返回导致上下文从内核模式切换回用户模式。现在数据被存储在用户地址空间缓冲区中，它可以再次开始向下运行。</li>
<li>write系统调用导致从用户模式到内核模式的上下文切换。执行第三次复制，再次将数据放入内核地址空间缓冲区。但是，这一次数据被放到了一个不同的缓冲区中，这个缓冲区专门与套接字相关联。</li>
<li>write系统调用返回，创建第四个上下文切换。</li>
</ol>
<p>很明显的，我们从<code>用户态</code>向<code>内核态</code>需要拷贝一次数据，显然这次如果有一些机制可以节约下来这次开销，会更加合理一点。</p>
<h4 id="mmap-机制"><a class="header-anchor" href="#mmap-机制">¶</a>mmap 机制</h4>
<p><a href="https://en.wikipedia.org/wiki/Mmap"><code>mmap</code></a> 提供一种对于用户态和内核态的贡献数据的方式。</p>
<figure class="highlight c"><figcaption><span>mmap</span></figcaption><table><tr><td class="code"><pre><span class="line">tmp_buf = mmap(file, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.jpg.cm/2020/09/28/JJLdr.png" alt="JJLdr.png"></p>
<ol>
<li><code>mmap</code>系统调用导致<code>DMA</code>将文件内容复制到内核缓冲区中。然后与用户进程共享缓冲区，而不需要在内核和用户内存空间之间执行任何复制。</li>
<li><code>write</code>系统调用导致内核将数据从内核缓冲区复制到与套接字相关联的内核缓冲区中。</li>
<li><code>DMA</code>将数据从内核套接字缓冲区传递到协议引擎时发生第三次复制。</li>
</ol>
<p>通过使用 <code>mmap</code> 而非 <code>read</code>，我们减少了内核必须复制的数据量的一半。当传输大量数据时，这会产生相当好的结果。</p>
<p>基于类似于 <code>mmap</code> 的机制， <code>Linux</code> 自从 <a href="https://lwn.net/Articles/726917/"><code>4.14</code></a>版本对 <code>Socket</code> 增加了 <code>MSG_ZEROCOPY</code> 选项，只需要执行如下代码：</p>
<figure class="highlight c"><figcaption><span>设置标记位</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_ZEROCOPY, &amp;one, <span class="keyword">sizeof</span>(one)))</span><br><span class="line">        error(<span class="number">1</span>, errno, <span class="string">&quot;setsockopt zerocopy&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在读取和发送的时候使用，详细可以参考 <a href="https://www.kernel.org/doc/html/v4.15/networking/msg_zerocopy.html">内核文档: msg_zerocopy</a></p>
<figure class="highlight c"><figcaption><span>零拷贝读写操作</span></figcaption><table><tr><td class="code"><pre><span class="line">ret = recvmsg(fd, &amp;msg, MSG_ERRQUEUE);</span><br><span class="line"></span><br><span class="line">ret = send(fd, buf, <span class="keyword">sizeof</span>(buf), MSG_ZEROCOPY);</span><br></pre></td></tr></table></figure>
<h5 id="How-it-works"><a class="header-anchor" href="#How-it-works">¶</a>How it works</h5>
<p><code>linux</code> 内核使用 <code>vm_area_struct</code> 结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个 <code>vm_area_struct</code> 结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：</p>
<p><img src="https://s3.jpg.cm/2020/09/29/JSWqf.png" alt="JSWqf.png"></p>
<p>因此从使用者角度看</p>
<ol>
<li>进程在用户空间调用库函数mmap</li>
<li>在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</li>
<li>为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化</li>
<li>将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中</li>
<li>进程的读或写操作访问虚拟地址空间，触发 <code>缺页异常</code>，内核去开辟新的物理页</li>
</ol>
<h4 id="sendfile-机制"><a class="header-anchor" href="#sendfile-机制">¶</a>sendfile 机制</h4>
<figure class="highlight c"><figcaption><span>sendfile</span></figcaption><table><tr><td class="code"><pre><span class="line">sendfile（socket，file，len）;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.jpg.cm/2020/09/28/JJPr5.png" alt="JJPr5.png"></p>
<ol>
<li><code>sendfile</code> 系统调用使 <code>DMA</code> 将文件内容复制到内核缓冲区中。</li>
<li>没有数据复制到套接字缓冲区中。将具有有关数据的地址和长度信息附加到套接字缓冲区。</li>
</ol>
<p>这个可以说是真正的 <code>Zero COPY</code> 技术了。不过缺点也很明显，只能用在 <code>FD</code> 之上，对于大部分时候我们需要处理的是 <code>Byte[]</code> 对于内存的数据，这样的函数接口显然不是那么好用。</p>
<hr>
<p>除此之外：<a href="https://tldp.org/HOWTO/SCSI-Generic-HOWTO/dio.html">Direct I/O</a>  <a href="https://man7.org/linux/man-pages/man7/aio.7.html">Asynchronous direct I/O</a> 都是优化 <code>IO</code> 的操作，对于网络请求一般不使用这些模式，大家可以自行阅读。</p>
<p>不过 <code>Zero Copy</code> 不一定有大家想象中的有效，在 <a href="https://lwn.net/Articles/726917/">Zero-copy networking</a> 有详细的描述。</p>
<blockquote>
<p>As was noted in the introduction, the benefits from zero-copy operation are often less than one might hope. Copying is expensive, but the setup required to avoid a copy operation also has its costs. In this case, the author claims that a simple benchmark (<a href="https://github.com/HewlettPackard/netperf">netperf</a> blasting out data) runs 39% faster, while a more realistic production workload sees a 5-8% improvement. So the benefit for real-world systems is not huge, but it may well be enough to be worth going for on highly-loaded systems that transmit a lot of data.</p>
</blockquote>
<p>不过从提交 <code>PR</code> 的作者的测试结果看还是不错的。</p>
<p>传输 10G 的流量，前三列是 <code>netperf</code> 进程的耗费的时钟周期，后三列是 <code>系统级</code> 的时钟周期。 <code>std</code> 是标准的读写， <code>zc</code> 代表零拷贝。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">        --process cycles--      ----cpu cycles----</span><br><span class="line">           std      zc   %      std         zc   %</span><br><span class="line">4K      27,609  11,217  41      49,217  39,175  79</span><br><span class="line">16K     21,370   3,823  18      43,540  29,213  67</span><br><span class="line">64K     20,557   2,312  11      42,189  26,910  64</span><br><span class="line">256K    21,110   2,134  10      43,006  27,104  63</span><br><span class="line">1M      20,987   1,610   8      42,759  25,931  61</span><br></pre></td></tr></table></figure>
<h3 id="io-uring"><a class="header-anchor" href="#io-uring">¶</a>io_uring</h3>
<p>我们使用 <code>zero copy</code> 技术将我们数据拷贝减少至极致，但是我们依然涉及到 <code>模块切换</code>，在 <code>内核态</code> 和 <code>用户态</code> 之间切换也不是免费的，因此制约我们这个特性又应该怎么解决呢？在 <code>Kernel</code> 解决这个之前，社区提出了一个很出名的解决之道 <a href="https://www.dpdk.org/"><code>dpdk</code></a> 提出了 <code>UIO</code> 的概念。</p>
<p><img src="https://s3.jpg.cm/2020/09/28/JtdzO.png" alt="JtdzO.png"></p>
<p>因此 <code>Linux 5.1</code> 参考了 <code>DPDK</code> 的实现，提出了 <a href="https://lwn.net/Articles/776703/"><code>io_uring</code></a> 的方案，<a href="https://kernel.dk/io_uring.pdf">白皮书</a></p>
<h4 id="Example-v4"><a class="header-anchor" href="#Example-v4">¶</a>Example</h4>
<figure class="highlight c"><figcaption><span>io_uring</span><a href="https://raw.githubusercontent.com/frevib/io_uring-echo-server/master/io_uring_echo_server.c">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CONNECTIONS     4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACKLOG             512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_MESSAGE_LEN     2048</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFERS_COUNT       MAX_CONNECTIONS</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_accept</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr *client_addr, <span class="type">socklen_t</span> *client_len, <span class="type">unsigned</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add_socket_read</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">int</span> fd, <span class="type">unsigned</span> gid, <span class="type">size_t</span> size, <span class="type">unsigned</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add_socket_write</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">int</span> fd, __u16 bid, <span class="type">size_t</span> size, <span class="type">unsigned</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add_provide_buf</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, __u16 bid, <span class="type">unsigned</span> gid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ACCEPT,</span><br><span class="line">    READ,</span><br><span class="line">    WRITE,</span><br><span class="line">    PROV_BUF,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">conn_info</span> &#123;</span></span><br><span class="line">    __u32 fd;</span><br><span class="line">    __u16 type;</span><br><span class="line">    __u16 bid;</span><br><span class="line">&#125; conn_info;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> bufs[BUFFERS_COUNT][MAX_MESSAGE_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> group_id = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> portno = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始 listen socket</span></span><br><span class="line">    <span class="type">int</span> sock_listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sock_listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;val, <span class="keyword">sizeof</span>(val));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">if</span> (bind(sock_listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error binding socket...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span> (listen(sock_listen_fd, BACKLOG) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error listening on socket...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;io_uring echo server listening for connections on port: %d\n&quot;</span>, portno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 io_uring</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">params</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;params, <span class="number">0</span>, <span class="keyword">sizeof</span>(params));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (io_uring_queue_init_params(<span class="number">2048</span>, &amp;ring, &amp;params) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_init_failed...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 SQE 和 CQE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 accept SQE 监视新连接</span></span><br><span class="line">    add_accept(&amp;ring, sock_listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待事件的发生</span></span><br><span class="line">        io_uring_submit_and_wait(&amp;ring, <span class="number">1</span>); </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> head;</span><br><span class="line">        <span class="type">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 CQE</span></span><br><span class="line">        io_uring_for_each_cqe(&amp;ring, head, cqe) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">conn_info</span> <span class="title">conn_i</span>;</span></span><br><span class="line">            <span class="built_in">memcpy</span>(&amp;conn_i, &amp;cqe-&gt;user_data, <span class="keyword">sizeof</span>(conn_i));</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> type = conn_i.type;</span><br><span class="line">            <span class="keyword">if</span> (type == ACCEPT) &#123;</span><br><span class="line">                <span class="type">int</span> sock_conn_fd = cqe-&gt;res;</span><br><span class="line">                <span class="comment">// 为建立的连接增加 read 监听</span></span><br><span class="line">                <span class="keyword">if</span> (sock_conn_fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    add_socket_read(&amp;ring, sock_conn_fd, group_id, MAX_MESSAGE_LEN, IOSQE_BUFFER_SELECT);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 继续监听</span></span><br><span class="line">                add_accept(&amp;ring, sock_listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_len, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == READ) &#123;</span><br><span class="line">                <span class="type">int</span> bytes_read = cqe-&gt;res;</span><br><span class="line">                <span class="comment">// 这里可以读取数据</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        io_uring_cq_advance(&amp;ring, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_accept</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr *client_addr, <span class="type">socklen_t</span> *client_len, <span class="type">unsigned</span> flags)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(ring);</span><br><span class="line">    io_uring_prep_accept(sqe, fd, client_addr, client_len, <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_flags(sqe, flags);</span><br><span class="line"></span><br><span class="line">    conn_info conn_i = &#123;</span><br><span class="line">        .fd = fd,</span><br><span class="line">        .type = ACCEPT,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sqe-&gt;user_data, &amp;conn_i, <span class="keyword">sizeof</span>(conn_i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_socket_read</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">int</span> fd, <span class="type">unsigned</span> gid, <span class="type">size_t</span> message_size, <span class="type">unsigned</span> flags)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(ring);</span><br><span class="line">    io_uring_prep_recv(sqe, fd, <span class="literal">NULL</span>, message_size, <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_flags(sqe, flags);</span><br><span class="line">    sqe-&gt;buf_group = gid;</span><br><span class="line"></span><br><span class="line">    conn_info conn_i = &#123;</span><br><span class="line">        .fd = fd,</span><br><span class="line">        .type = READ,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sqe-&gt;user_data, &amp;conn_i, <span class="keyword">sizeof</span>(conn_i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="How-it-works-v2"><a class="header-anchor" href="#How-it-works-v2">¶</a>How it works</h4>
<p><code>Linux</code> 只增加了 3 个 <code>syscall</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">no         syscall</span><br><span class="line">425        io_uring_setup</span><br><span class="line">426        io_uring_enter</span><br><span class="line">427        io_uring_register</span><br></pre></td></tr></table></figure>
<h5 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h5>
<p>并没有常见的 <code>read</code> 和 <code>write</code>，因为现在的这两步可以在用户态进行了（这不废话，我们就是要解决模态切换的问题）。为了实现用户态和内核态通讯，<code>io_uring</code> 提供了2个队列：提交队列（submission queue）和完成队列（completion queue）</p>
<p>定义如下</p>
<figure class="highlight c"><figcaption><span>io_uring.h</span><a href="https://elixir.bootlin.com/linux/v5.8.11/source/include/uapi/linux/io_uring.h#L230">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> &#123;</span></span><br><span class="line">	__u32 sq_entries;</span><br><span class="line">	__u32 cq_entries;</span><br><span class="line">	__u32 flags;</span><br><span class="line">	__u32 sq_thread_cpu;</span><br><span class="line">	__u32 sq_thread_idle;</span><br><span class="line">	__u32 features;</span><br><span class="line">	__u32 wq_fd;</span><br><span class="line">	__u32 resv[<span class="number">3</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_sqring_offsets</span> <span class="title">sq_off</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_cqring_offsets</span> <span class="title">cq_off</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_sqring_offsets</span> &#123;</span></span><br><span class="line">	__u32 head; <span class="comment">/* head offset */</span></span><br><span class="line">	__u32 tail; <span class="comment">/* tail offset */</span></span><br><span class="line">	__u32 ring_mask;</span><br><span class="line">	__u32 ring_entries;</span><br><span class="line">	__u32 flags;</span><br><span class="line">	__u32 dropped;</span><br><span class="line">	__u32 <span class="built_in">array</span>;</span><br><span class="line">	__u32 resv1;</span><br><span class="line">	__u64 resv2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_cqring_offsets</span> &#123;</span></span><br><span class="line">	__u32 head;</span><br><span class="line">	__u32 tail;</span><br><span class="line">	__u32 ring_mask;</span><br><span class="line">	__u32 ring_entries;</span><br><span class="line">	__u32 overflow;</span><br><span class="line">	__u32 cqes;</span><br><span class="line">	__u32 flags;</span><br><span class="line">	__u32 resv1;</span><br><span class="line">	__u64 resv2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> &#123;</span></span><br><span class="line">	__u64	user_data;	<span class="comment">/* sqe-&gt;data submission passed back */</span></span><br><span class="line">	__s32	res;		<span class="comment">/* result code for this event */</span></span><br><span class="line">	__u32	flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.jpg.cm/2020/09/28/JtFjD.png" alt="JtFjD.png"></p>
<p><code>SQ</code>，<code>CQ</code>，<code>SQEs</code> 是在内核中分配的，所以用户态程序并不能直接访问。<code>io_setup</code> 的返回值是一个 <code>fd</code>，应用程序使用这个 <code>fd</code> 进行 mmap，和 <code>kernel</code> 共享一块内存。</p>
<h5 id="IO-submit"><a class="header-anchor" href="#IO-submit">¶</a>IO submit</h5>
<p>IO 提交的做法是找到一个空闲的 SQE，根据请求设置 SQE，并将这个 SQE 的索引放到 SQ 中。SQ 是一个典型的 RingBuffer，有 head，tail 两个成员，如果 head == tail，意味着队列为空。SQE 设置完成后，需要修改 SQ 的 tail，以表示向 RingBuffer 中插入一个请求。当所有请求都加入 SQ 后，就可以使用 ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_enter</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, u32 to_submit, u32 min_complete, u32 flags)</span>;</span><br></pre></td></tr></table></figure>
<p>不过这样还是会涉及到 <code>模态切换</code>，因此还提供了另外一个模式。</p>
<h5 id="offload-模式"><a class="header-anchor" href="#offload-模式">¶</a>offload 模式</h5>
<p>调用 <code>io_uring_setup</code> 时设置了 <code>IORING_SETUP_SQPOLL</code> 的 flag，内核会额外启动一个内核线程，我们称作 <code>SQ</code> 线程。</p>
<p><img src="https://s3.jpg.cm/2020/09/28/Jtm5p.png" alt="Jtm5p.png"></p>
<h5 id="IO-Completion"><a class="header-anchor" href="#IO-Completion">¶</a>IO Completion</h5>
<p>当 <code>IO</code> 完成时，内核负责将完成 <code>IO</code> 在 <code>SQEs</code> 中的 <code>index</code> 放到 <code>CQ</code> 中。由于 <code>IO</code> 在提交的时候可以顺便返回完成的 <code>IO</code>，所以收割 <code>IO</code> 不需要额外系统调用。这是跟 <code>libaio</code> 比较大的不同，省去了一次系统调用。</p>
<h2 id="框架层"><a class="header-anchor" href="#框架层">¶</a>框架层</h2>
<p>在 <code>OS</code> 上提供的 <code>epoll</code> <code>io_uring</code> 的情况下，在应用层如何高效的使用也是一个相对复杂的问题。不过在这层上来说，我们更需要的是配合 <code>编程语言</code> 的并发模式提供一种高效的编程框架。</p>
<h3 id="Thread-编程模型：Netty-Reactor"><a class="header-anchor" href="#Thread-编程模型：Netty-Reactor">¶</a>Thread 编程模型：Netty &amp; Reactor</h3>
<p><code>epoll</code> 也不算是一个新东西，业界也整理出一套比较高效的 <code>框架模型</code>，常用的高性能 IO 模型 <code>Reactor</code>。</p>
<p><img src="https://s3.jpg.cm/2020/09/28/Jtv0T.png" alt="Jtv0T.png"></p>
<p><code>Netty</code> 抽象的 <code>Acceptor</code> 作为接受者，对应的线程是 <code>bossGroup</code>，从图上看好像是单个的，但是并不是 <code>Acceptor</code> 也可以有多个线程，<code>Dispatch</code> 将接收到的请求分发到 <code>workGroup</code> 的线程组进行繁重的读写工作。</p>
<p>对于读写操作，提供了 <code>pipeline</code> 的机制<br>
<img src="https://s3.jpg.cm/2020/09/28/Jt4bQ.png" alt="Jt4bQ.png"></p>
<h3 id="Goroutines：netpoller"><a class="header-anchor" href="#Goroutines：netpoller">¶</a>Goroutines：netpoller</h3>
<p><code>go</code> 语言提供一套将  <code>异步io</code> 转化为 <code>同步io</code> 的机制，这样对于开发者来说会更加的轻松，得益于 <code>goroutine</code> 并不会带来不可承担的成本。</p>
<p><code>go</code> 会初始化一个全局的 <code>netpoll</code>，在 <code>linux</code> 的实现是创建一个 <code>epfd</code></p>
<figure class="highlight go"><figcaption><span>netpollinit</span><a href="https://go.googlesource.com/go/+/refs/tags/go1.14.9/src/runtime/netpoll_epoll.go#27">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	epfd <span class="type">int32</span> = <span class="number">-1</span></span><br><span class="line">	netpollBreakRd, netpollBreakWr <span class="type">uintptr</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	epfd = epollcreate1(_EPOLL_CLOEXEC)</span><br><span class="line">	r, w, _ := nonblockingPipe()</span><br><span class="line">	ev := epollevent&#123;</span><br><span class="line">		events: _EPOLLIN,</span><br><span class="line">	&#125;</span><br><span class="line">	*(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) = &amp;netpollBreakRd</span><br><span class="line">	epollctl(epfd, _EPOLL_CTL_ADD, r, &amp;ev)</span><br><span class="line">	netpollBreakRd = <span class="type">uintptr</span>(r)</span><br><span class="line">	netpollBreakWr = <span class="type">uintptr</span>(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们打开一个 <code>file</code> 的时候，就会向 <code>epoll</code> 注册事件</p>
<figure class="highlight go"><figcaption><span>netpollopen</span><a href="https://go.googlesource.com/go/+/refs/tags/go1.14.9/src/runtime/netpoll_epoll.go#59">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="type">uintptr</span>, pd *pollDesc)</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ev epollevent</span><br><span class="line">	ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class="line">	*(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class="line">	<span class="keyword">return</span> -epollctl(epfd, _EPOLL_CTL_ADD, <span class="type">int32</span>(fd), &amp;ev) <span class="comment">// 注册关注事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在文件描述符上执行读写操作时，如果文件描述符不可读或者不可写，当前 Goroutine 就会执行 <code>runtime.poll_runtime_pollWait</code> 检查 <code>runtime.pollDesc</code> 的状态并调用 <code>runtime.netpollblock</code> 等待文件描述符的可读或者可写</p>
<figure class="highlight go"><figcaption><span>netpollblock</span><a href="https://go.googlesource.com/go/+/refs/tags/go1.14.9/src/runtime/netpoll.go#394">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>, waitio <span class="type">bool</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	gpp := &amp;pd.rg</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		gpp = &amp;pd.wg</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让出执行的线程，将 Goroutine 转换到休眠状态并等待运行时的唤醒</span></span><br><span class="line">		gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, <span class="number">5</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唤醒操作也很简单</p>
<figure class="highlight go"><figcaption><span>netpollready</span><a href="https://go.googlesource.com/go/+/refs/tags/go1.14.9/src/runtime/netpoll.go#344">source code</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollready</span><span class="params">(toRun *gList, pd *pollDesc, mode <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rg, wg *g</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        <span class="comment">// 将可以唤醒的 Goroutine 重新置为可运行</span></span><br><span class="line">		wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">true</span>) </span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">		toRun.push(wg)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div>
    <label class="author-mark-label">小声比比</label>
    <p class="author-mark">Go 的大道至简，的确很香。</p>
</div>
<h2 id="小结-v2"><a class="header-anchor" href="#小结-v2">¶</a>小结</h2>
<p>大概前前后后写了半个月才将本文写完，也没有预计到可以写这么多，试图帮助大家从 <code>硬件</code> 到 <code>框架</code> 整理出一套体系，但是为了达成高性能的 <code>Web Server</code>，除了我们本文提到了 <code>OS</code> 的一些优化，还有很多在框架层面上可以优化的地方。<code>连接池</code> <code>Fast Path算法</code> <code>缓存</code> 等等。</p>
<hr>
<p>希望大家在网络的世界里面玩的开心 ;)</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://linux-kernel-labs.github.io/refs/heads/master">The Linux Kernel Labs</a></li>
<li><a href="https://tldp.org/LDP/LG/issue93/bhaskaran.html">Writing a Network device driver</a></li>
<li><a href="https://linuxgazette.net/156/jangir.html">Writing Network Device Drivers for Linux</a></li>
<li><a href="https://www.kernel.org/doc/htmldocs/networking">kernel</a></li>
<li><a href="https://www.cnblogs.com/CasonChan/p/5166250.html">网络数据包收发流程(四)：协议栈之packet_type</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/80513852">软中断会吃掉你多少CPU？</a></li>
<li><a href="https://courses.engr.illinois.edu/cs423/sp2014/Lectures/LinuxDriver.pdf">Understanding Linux Network Device Driver and NAPI</a></li>
<li><a href="https://lwn.net/Articles/244640/">Newer, newer NAPI</a></li>
<li><a href="https://tldp.org/LDP/tlk/net/net.html">Networks</a></li>
<li><a href="https://www.cnblogs.com/super-king/p/3296091.html">Linux IP 路由实现</a></li>
<li><a href="https://www.zhihu.com/question/35004859">cond_resched()之后，后面的代码什么时候才被再次调度回来执行？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/62682475">AIO 的新归宿：io_uring</a></li>
<li><a href="https://draveness.me/golang-netpoller/">Go 语言设计与实现</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>linux</category>
        <category>network</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>network</tag>
      </tags>
  </entry>
</search>
