<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/2020/logo-thin.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/2020/logo-thin.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/2020/logo-thin.png">
  <link rel="mask-icon" href="/images/2020/logo-thin.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="https://lib.baomitu.com/font-awesome/5.15.3/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.yanick.site","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"changyan","storage":true,"lazyload":true,"nav":{"livere":{"text":"LiveRe","order":2},"disqus":{"text":"Disqus","order":3},"changyan":{"text":"ChangYan","order":1}},"activeClass":"changyan"},"algolia":{"appID":"SLJ0R87CAH","apiKey":"fd4f2896d73497ea343ec5d504a06bb4","indexName":"yann_blog","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文基于 0.15.0 版本，因为 Mosn 代码非常的巨大，对于 * 开头的章节作为补充部分，可以跳过。">
<meta property="og:type" content="article">
<meta property="og:title" content="Mosn源码速读">
<meta property="og:url" content="http://blog.yanick.site/2020/08/18/go/mosn/index.html">
<meta property="og:site_name" content="Yanick&#39;s Blog">
<meta property="og:description" content="本文基于 0.15.0 版本，因为 Mosn 代码非常的巨大，对于 * 开头的章节作为补充部分，可以跳过。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.jpg.cm/2020/08/20/uEJCp.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/08/18/uuloL.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/08/19/uSvPQ.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/03/1JDhU.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/08/20/uES1T.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/08/24/uyuC5.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/02/1HMfG.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/03/1JAdf.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/03/1troW.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/03/1SLTy.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/03/1YSLR.png">
<meta property="article:published_time" content="2020-08-18T09:51:26.000Z">
<meta property="article:modified_time" content="2021-03-22T05:25:36.505Z">
<meta property="article:author" content="Yanick.xia">
<meta property="article:tag" content="go">
<meta property="article:tag" content="mosn">
<meta property="article:tag" content="gateway">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.jpg.cm/2020/08/20/uEJCp.png">

<link rel="canonical" href="http://blog.yanick.site/2020/08/18/go/mosn/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Mosn源码速读 | Yanick's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c033617f45ecdaad648e08ab6a03ae3a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yanick's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-专栏">

    <a href="/column/" rel="section"><i class="fa fa-edit fa-fw"></i>专栏</a>

  </li>
        <li class="menu-item menu-item-计划">

    <a href="/plan/" rel="section"><i class="fa fa-paper-plane fa-fw"></i>计划</a>

  </li>
        <li class="menu-item menu-item-推荐">

    <a href="/annual-recommend/2021.html" rel="section"><i class="fas fa-thumbs-up fa-fw"></i>推荐</a>

  </li>
        <li class="menu-item menu-item-地图">

    <a href="/knowledge-map/" rel="section"><i class="fa fa-map fa-fw"></i>地图</a>

  </li>
        <li class="menu-item menu-item-分享">

    <a href="/link/" rel="section"><i class="fa fa-link fa-fw"></i>分享</a>

  </li>
        <li class="menu-item menu-item-百科">

    <a href="https://wiki.yanick.site/" rel="noopener" target="_blank"><i class="fab fa-wikipedia-w fa-fw"></i>百科</a>

  </li>
        <li class="menu-item menu-item-随想">

    <a href="https://misc.yanick.site/" rel="noopener" target="_blank"><i class="fas fa-compact-disc fa-fw"></i>随想</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.yanick.site/2020/08/18/go/mosn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yanick.xia">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yanick's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Mosn源码速读
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-18 17:51:26" itemprop="dateCreated datePublished" datetime="2020-08-18T17:51:26+08:00">2020-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-22 13:25:36" itemprop="dateModified" datetime="2021-03-22T13:25:36+08:00">2021-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/mosn/" itemprop="url" rel="index"><span itemprop="name">mosn</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/mosn/gateway/" itemprop="url" rel="index"><span itemprop="name">gateway</span></a>
                </span>
            </span>

          
            <span id="/2020/08/18/go/mosn/" class="post-meta-item leancloud_visitors" data-flag-title="Mosn源码速读" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://s3.jpg.cm/2020/08/20/uEJCp.png" alt="uEJCp.png"></p>
<p>本文基于 <code>0.15.0</code> 版本，因为 <code>Mosn</code> 代码非常的巨大，对于 <code>*</code> 开头的章节作为补充部分，可以跳过。</p>
<a id="more"></a>


<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<h2 id="MOSN-的-IO-模型"><a class="header-anchor" href="#MOSN-的-IO-模型">¶</a>MOSN 的 IO 模型</h2>
<p><code>Mosn</code> 支持两种网络模型 <code>Netpoll</code> / <code>RawEpoll</code></p>
<h3 id="Netpoll-模式"><a class="header-anchor" href="#Netpoll-模式">¶</a>Netpoll 模式</h3>
<p>Netpoll 模式是标准的 <code>Go</code> 的网络模型， <code>goroutine-per-connection</code> 相对缺点就是消耗高点，但是编程会简单很多。</p>
<p><img src="https://s3.jpg.cm/2020/08/18/uuloL.png" alt="uuloL.png"></p>
<h3 id="RawEpoll-模式"><a class="header-anchor" href="#RawEpoll-模式">¶</a>RawEpoll 模式</h3>
<p><img src="https://s3.jpg.cm/2020/08/19/uSvPQ.png" alt="uSvPQ.png"></p>
<ol>
<li>链接建立后，向 Epoll 注册 <code>oneshot</code> 可读事件监听；并且此时不允许有协程调用 <code>conn.read</code>，避免与 <code>runtime netpoll</code> 冲突。</li>
<li>可读事件到达，从 <code>goroutine pool</code> 挑选一个协程进行读事件处理；由于使用的是 <code>oneshot</code> 模式，该 fd 后续可读事件不会再触发。</li>
<li>请求处理过程中，协程调度与经典 <code>netpoll</code> 模式一致。</li>
<li>请求处理完成，将协程归还给协程池；同时将 <code>fd</code> 重新添加到 <code>RawEpoll</code> 中。</li>
</ol>
<h2 id="How-it-work"><a class="header-anchor" href="#How-it-work">¶</a>How it work</h2>
<p>大家先瞧一眼模块图，瞧瞧就好了。<br>
<img src="https://s3.jpg.cm/2020/09/03/1JDhU.png" alt="1JDhU.png"></p>
<h3 id="Start-Server"><a class="header-anchor" href="#Start-Server">¶</a>Start Server</h3>
<p>代码的入口在 <code>pkg/mosn/starter.go:300</code>，我们采用文件的方式进行启动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start -c config.json</span><br></pre></td></tr></table></figure>
<p>我们看到熟悉的对于 <code>Listener</code> 的构建，对于 <code>xDS</code> 协议来说， <code>Listener</code> 部分决定了对外的监听部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, _ := <span class="keyword">range</span> serverConfig.Listeners &#123;</span><br><span class="line">    lc := configmanager.ParseListenerConfig(&amp;serverConfig.Listeners[idx], inheritListeners, inheritPacketConn)</span><br><span class="line">    deprecatedRouter, err := configmanager.ParseRouterConfiguration(&amp;lc.FilterChains[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> _, err := srv.AddListener(lc); err != <span class="literal">nil</span> &#123; <span class="comment">// 此处添加 Listener</span></span><br><span class="line">        log.StartLogger.Fatalf(<span class="string">"[mosn] [NewMosn] AddListener error:%s"</span>, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于熟悉 <code>Linux</code> 编程的同学， <code>Listener</code> 势必是创建一个 <code>ServerSocket</code> 进行监听。对于处理的逻辑，应该也是在构建的过程中创建出来的，我们跳至创建处：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ch *connHandler)</span> <span class="title">AddOrUpdateListener</span><span class="params">(lc *v2.Listener)</span> <span class="params">(types.ListenerEventListener, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> listenerName <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">if</span> lc.Name == <span class="string">""</span> &#123;</span><br><span class="line">		listenerName = utils.GenerateUUID()</span><br><span class="line">		lc.Name = listenerName</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		listenerName = lc.Name</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// currently, we just support one filter chain</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(lc.FilterChains) != <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"error updating listener, listener have filter chains count is not 1"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// set listener filter , network filter and stream filter</span></span><br><span class="line">	<span class="keyword">var</span> listenerFiltersFactories []api.ListenerFilterChainFactory</span><br><span class="line">	<span class="keyword">var</span> networkFiltersFactories []api.NetworkFilterChainFactory</span><br><span class="line">	<span class="keyword">var</span> streamFiltersFactories []api.StreamFilterChainFactory</span><br><span class="line">	listenerFiltersFactories = configmanager.GetListenerFilters(lc.ListenerFilters)</span><br><span class="line">	networkFiltersFactories = configmanager.GetNetworkFilters(&amp;lc.FilterChains[<span class="number">0</span>])</span><br><span class="line">	streamFiltersFactories = configmanager.GetStreamFilters(lc.StreamFilters)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> al *activeListener</span><br><span class="line">	<span class="keyword">if</span> al = ch.findActiveListenerByName(listenerName); al != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 略去更新的操作</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		listenerStopChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) ➊</span><br><span class="line">		l := network.NewListener(lc)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		al, err = newActiveListener(l, lc, als, listenerFiltersFactories, networkFiltersFactories, streamFiltersFactories, ch, listenerStopChan) ➋</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> al, err</span><br><span class="line">		&#125;</span><br><span class="line">		l.SetListenerCallbacks(al)</span><br><span class="line">		ch.listeners = <span class="built_in">append</span>(ch.listeners, al)</span><br><span class="line">		log.DefaultLogger.Infof(<span class="string">"[server] [conn handler] [add listener] add listener: %s"</span>, lc.Addr.String())</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	admin.SetListenerConfig(listenerName, *al.listener.Config())</span><br><span class="line">	<span class="keyword">return</span> al, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分的代码显然不能满足我们对于核心，怎么 <code>AC</code> 请求的需求，这里是简单的创建了 <code>Listener</code>，让我们继续跟踪下去，不过值得注意的在 ➊ 创建了一个 <code>StopChain</code>，这是非常标准 <code>Go</code> 中如何通知他人 <code>Close</code> 的方式。不过从 ➋ 处，我们可以看到一些熟悉的  <code>Filters</code> 的单字，想必也是通过 <code>FilterChains</code> 进行工作的。</p>
<p>在构建的 <code>newActiveListener</code> 进行了一些监控的初始化。真正进行工作的代码是在 <code>pkg/server/handler.go:StartListener</code></p>
<figure class="highlight go"><figcaption><span>Start</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *listener)</span> <span class="title">Start</span><span class="params">(lctx context.Context, restart <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> l.bindToPort &#123;</span><br><span class="line">		ignore := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">if</span> l.rawl == <span class="literal">nil</span> &amp;&amp; l.packetConn == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> err := l.listen(lctx); err != <span class="literal">nil</span> &#123; <span class="comment">// 实际上启动的地方</span></span><br><span class="line">						log.StartLogger.Fatalf(<span class="string">"[network] [listener start] [listen] %s listen failed, %v"</span>, l.name, err)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			l.state = ListenerRunning</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> l.network &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"udp"</span>:</span><br><span class="line">			l.readMsgEventLoop(lctx)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			l.acceptEventLoop(lctx)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Start</code> 有两个重点 <code>listen(lctx)</code> 创建了监听器，在 <code>l.acceptEventLoop(lctx)</code> 进行接受的事件循环，<code>listen(lctx)</code> 的逻辑就比较简单就是标准的 <code>Go Net</code>，我们进入下个函数在 <code>l.acceptEventLoop(lctx)</code> 中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *listener)</span> <span class="title">acceptEventLoop</span><span class="params">(lctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := l.accept(lctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Timeout() &#123;</span><br><span class="line">				log.DefaultLogger.Infof(<span class="string">"[network] [listener start] [accept] listener %s stop accepting connections by deadline"</span>, l.name)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ope, ok := err.(*net.OpError); ok &#123;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Accept-Connection"><a class="header-anchor" href="#Accept-Connection">¶</a>Accept Connection</h3>
<p>直接只有 <code>loop</code> 循环，不断的去接受即可，标准的 <code>Networking</code> 编程。</p>
<figure class="highlight go"><figcaption><span>accept</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *listener)</span> <span class="title">accept</span><span class="params">(lctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	rawc, err := l.rawl.Accept()</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> use thread pool</span></span><br><span class="line">	utils.GoWithRecover(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		l.cb.OnAccept(rawc, l.useOriginalDst, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>OnAccept</code> 中就是我们线程模型的开始</p>
<figure class="highlight go"><figcaption><span>OnAccept</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(al *activeListener)</span> <span class="title">OnAccept</span><span class="params">(rawc net.Conn, useOriginalDst <span class="keyword">bool</span>, oriRemoteAddr net.Addr, ch <span class="keyword">chan</span> api.Connection, buf []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rawf *os.File</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !useOriginalDst &#123;</span><br><span class="line">		<span class="keyword">if</span> network.UseNetpollMode &#123; ➊</span><br><span class="line">			<span class="comment">// store fd for further usage</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span> rawc.LocalAddr().Network() &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"udp"</span>:</span><br><span class="line">				<span class="keyword">if</span> tc, ok := rawc.(*net.UDPConn); ok &#123;</span><br><span class="line">					rawf, _ = tc.File()</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">if</span> tc, ok := rawc.(*net.TCPConn); ok &#123;</span><br><span class="line">					rawf, _ = tc.File()</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arc := newActiveRawConn(rawc, al)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// listener filter chain.</span></span><br><span class="line">	<span class="keyword">for</span> _, lfcf := <span class="keyword">range</span> al.listenerFiltersFactories &#123;</span><br><span class="line">		arc.acceptedFilters = <span class="built_in">append</span>(arc.acceptedFilters, lfcf) ➋</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx := mosnctx.WithValue(context.Background(), types.ContextKeyListenerPort, al.listenPort)</span><br><span class="line">	<span class="comment">//略 大量的初始化对象的代码</span></span><br><span class="line"></span><br><span class="line">	arc.ctx = ctx</span><br><span class="line"></span><br><span class="line">	arc.ContinueFilterChain(ctx, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ➊ 处，我们就开始区分我们的 <code>RawEpoll</code> 和 <code>NetPoll</code> 的模式了。最重要的部分就是 ➋ 处理进行了 <code>Listener</code> 的 <code>FilterChain</code> 构建，我们继续往下探索</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arc *activeRawConn)</span> <span class="title">ContinueFilterChain</span><span class="params">(ctx context.Context, success <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !success &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ; arc.acceptedFilterIndex &lt; <span class="built_in">len</span>(arc.acceptedFilters); arc.acceptedFilterIndex++ &#123;</span><br><span class="line">		filterStatus := arc.acceptedFilters[arc.acceptedFilterIndex].OnAccept(arc)  ➊</span><br><span class="line">		<span class="keyword">if</span> filterStatus == api.Stop &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arc.activeListener.newConnection(ctx, arc.rawc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 ➊ 处，我们就发现了 <code>FliterChain</code> 从返回的对象也可以清晰的发现，这和 <code>Servlet Filter</code> 不同，每个 <code>Filter</code> 返回对象来决定是否需要继续下去。</p>
<p>在 <code>newConnection</code> 在中 处理下各种超时的设置，我们勇敢的往前进，后续的 <code>OnNewConnection</code> 有我们的大头戏了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(al *activeListener)</span> <span class="title">OnNewConnection</span><span class="params">(ctx context.Context, conn api.Connection)</span></span> &#123;</span><br><span class="line">	<span class="comment">//在这里我们初始化我们的 FilterManager</span></span><br><span class="line">	filterManager := conn.FilterManager()</span><br><span class="line">	<span class="keyword">for</span> _, nfcf := <span class="keyword">range</span> al.networkFiltersFactories &#123;</span><br><span class="line">		nfcf.CreateFilterChain(ctx, filterManager)</span><br><span class="line">	&#125;</span><br><span class="line">	filterManager.InitializeReadFilters()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当我们并没有 ReadFilter 或者 WriterFilter 我们快速的返回即可</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(filterManager.ListReadFilter()) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">		<span class="built_in">len</span>(filterManager.ListWriteFilters()) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// no filter found, close connection</span></span><br><span class="line">		conn.Close(api.NoFlush, api.LocalClose)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	ac := newActiveConnection(al, conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里将请求按栈，有什么用我们后续再看</span></span><br><span class="line">	al.connsMux.Lock()</span><br><span class="line">	e := al.conns.PushBack(ac)</span><br><span class="line">	al.connsMux.Unlock()</span><br><span class="line">	ac.element = e</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始真实的处理阶段</span></span><br><span class="line">	conn.Start(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Let's Play!</code> 这里开始上文的不同IO模型了</p>
<figure class="highlight go"><figcaption><span>Start</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *connection)</span> <span class="title">Start</span><span class="params">(lctx context.Context)</span></span> &#123;</span><br><span class="line">	c.startOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> UseNetpollMode &#123;</span><br><span class="line">			c.attachEventLoop(lctx)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c.startRWLoop(lctx)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Read-Connection"><a class="header-anchor" href="#Read-Connection">¶</a>Read Connection</h3>
<h4 id="Read-EventLoop-attachEventLoop"><a class="header-anchor" href="#Read-EventLoop-attachEventLoop">¶</a>Read: EventLoop [attachEventLoop]</h4>
<h5 id="Read-Write事件监听"><a class="header-anchor" href="#Read-Write事件监听">¶</a>Read/Write事件监听</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *connection)</span> <span class="title">attachEventLoop</span><span class="params">(lctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里用了当前的一个递增的序列号，取余 epoll poll 获得一个 eventloop</span></span><br><span class="line">	c.eventLoop = attach()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register read only, write is supported now because it is more complex than read.</span></span><br><span class="line">	<span class="comment">// We need to write our own code based on syscall.write to deal with the EAGAIN and writable epoll event</span></span><br><span class="line">	err := c.eventLoop.registerRead(c, &amp;connEventHandler&#123;</span><br><span class="line">		onRead: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> c.readEnabled &#123; ➊</span><br><span class="line">				err := c.doRead()</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> te, ok := err.(net.Error); ok &amp;&amp; te.Timeout() &#123;</span><br><span class="line">						<span class="keyword">if</span> c.readBuffer != <span class="literal">nil</span> &amp;&amp; c.readBuffer.Len() == <span class="number">0</span> &#123;</span><br><span class="line">							c.readBuffer.Free()</span><br><span class="line">							c.readBuffer.Alloc(DefaultBufferReadCapacity)</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-c.readEnabledChan:</span><br><span class="line">				<span class="keyword">case</span> &lt;-time.After(<span class="number">100</span> * time.Millisecond): ➋</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;,</span><br><span class="line"></span><br><span class="line">		onHup: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">			log.DefaultLogger.Errorf(<span class="string">"[network] [event loop] [onHup] ReadHup error. Connection = %d, Remote Address = %s"</span>, c.id, c.RemoteAddr().String())</span><br><span class="line">			c.Close(api.NoFlush, api.RemoteClose)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的  ➊ ➋ 做了一些 <code>ReadEnable</code> 的控制，应该是对 <code>Transfer FD</code> 部分进行设计，这里定义我们在读取和 <code>Hup</code> 时候的回调，我们看看回调事件是如何注册的。</p>
<figure class="highlight go"><figcaption><span>registerRead</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(el *eventLoop)</span> <span class="title">registerRead</span><span class="params">(conn *connection, handler *connEventHandler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// handle read</span></span><br><span class="line">	read, err := netpoll.HandleFile(conn.file, netpoll.EventRead|netpoll.EventOneShot)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// register</span></span><br><span class="line">	el.poller.Start(read, el.readWrapper(read, handler))</span><br><span class="line"></span><br><span class="line">	el.mu.Lock()</span><br><span class="line">	<span class="comment">//store</span></span><br><span class="line">	el.conn[conn.id] = &amp;connEvent&#123;</span><br><span class="line">		read: read,</span><br><span class="line">	&#125;</span><br><span class="line">	el.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心的就是在 <code>el.poller.Start(read, el.readWrapper(read, handler))</code>  开始监听我们的执行事件，对 <code>Write</code>写事件也是一样的模式</p>
<figure class="highlight go"><figcaption><span>register</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el.poller.Start(read, el.readWrapper(read, handler))</span><br><span class="line">el.poller.Start(write, el.writeWrapper(write, handler))</span><br></pre></td></tr></table></figure>
<p>不过值得注意是，对一个同一个请求的读写事件的 <code>Poller</code> 肯定是在同一个上面。那我们下面需要看我们最重要的部分，我们真实的读取数据从何而来，不过先小结一下：</p>
<h5 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h5>
<p><img src="https://s3.jpg.cm/2020/08/20/uES1T.png" alt="uES1T.png"></p>
<p>对于 <code>Mosn</code> 来说，我们对于 <code>Read/Write</code> 可以使用多个 <code>RawPoller</code> 进行操作，这样可以有效的利用多核的性质，不过这里又和我们后面的 <code>GoRoutine</code> 会冲突，这里需要好好设计你的 <code>poolsize</code>，不过从源码看现阶段仅支持 <code>1</code> 个的读写监听器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line"></span><br><span class="line">	readPool  = mosnsync.NewWorkerPool(runtime.NumCPU())</span><br><span class="line">	writePool = mosnsync.NewWorkerPool(runtime.NumCPU())</span><br><span class="line"></span><br><span class="line">	rrCounter                 <span class="keyword">uint32</span></span><br><span class="line">	poolSize                  <span class="keyword">uint32</span> = <span class="number">1</span> <span class="comment">//uint32(runtime.NumCPU()) ➊</span></span><br><span class="line">	eventLoopPool                    = <span class="built_in">make</span>([]*eventLoop, poolSize)</span><br><span class="line">	errEventAlreadyRegistered        = errors.New(<span class="string">"event already registered"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在 ➊ 处已经被标记出来的，暂时还没有查找到修改的地方。</p>
<h5 id="读写事件处理"><a class="header-anchor" href="#读写事件处理">¶</a>读写事件处理</h5>
<p>本章在操作之前由于 <code>Master</code> 版本尚未完善 <code>pkg/network/eventloop.go:45</code> 此处需要打开初始化才能够工作</p>
<p>执行事件的循环肯定在我们最熟悉的 <code>epoll.wait()</code> 中，在 <code>netpoll/epoll.go:235</code> 中就不看了，我们直接看数据的读取的过程，在我们回调事件中</p>
<figure class="highlight go"><figcaption><span>pkg/network/eventloop.go:188</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">readPool.Schedule(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !handler.onRead() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	el.poller.Resume(desc)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们执行了 <code>readPool</code> 的操作，而这个 <code>Schedule</code> 操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *workerPool)</span> <span class="title">Schedule</span><span class="params">(task <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> p.work &lt;- task:</span><br><span class="line">	<span class="keyword">case</span> p.sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">		<span class="keyword">go</span> p.spawnWorker(task)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以简单的认为是发生了一个任务通知了我们 <code>work</code> 通道，在下面的代码进行处理</p>
<figure class="highlight go"><figcaption><span>spawnWorker</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *workerPool)</span> <span class="title">spawnWorker</span><span class="params">(task <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.DefaultLogger.Alertf(<span class="string">"syncpool"</span>, <span class="string">"[syncpool] panic %v\n%s"</span>, p, <span class="keyword">string</span>(debug.Stack()))</span><br><span class="line">		&#125;</span><br><span class="line">		&lt;-p.sem</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		task()</span><br><span class="line">		task = &lt;-p.work <span class="comment">//我们开始处理这个 Task</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="题外话1：Mosn-的-WorkerPool"><a class="header-anchor" href="#题外话1：Mosn-的-WorkerPool">¶</a>题外话1：Mosn 的 WorkerPool</h6>
<p>笔者之前写<code>Java</code>为主，这次看到这样的工作池设计，一时半会还没看懂，理了一下才行还是有点意思的。</p>
<figure class="highlight go"><figcaption><span>NewWorkerPool</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorkerPool</span><span class="params">(size <span class="keyword">int</span>)</span> <span class="title">WorkerPool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;workerPool&#123;</span><br><span class="line">		work: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>),</span> </span><br><span class="line">		sem:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, size), <span class="comment">// 这里 Channel 控制最多生成多少个 Worker。默认是 CPU CORE</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><figcaption><span>Schedule</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *workerPool)</span> <span class="title">Schedule</span><span class="params">(task <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> p.work &lt;- task:</span><br><span class="line">	<span class="keyword">case</span> p.sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;: <span class="comment">// ➊ 当我们执行一个 fun 的时候，如果 work 被阻塞就会触发这里的 case </span></span><br><span class="line">		<span class="keyword">go</span> p.spawnWorker(task) <span class="comment">// ➋ 我们这里创建一个 Worker</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><figcaption><span>spawnWorker</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *workerPool)</span> <span class="title">spawnWorker</span><span class="params">(task <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.DefaultLogger.Alertf(<span class="string">"syncpool"</span>, <span class="string">"[syncpool] panic %v\n%s"</span>, p, <span class="keyword">string</span>(debug.Stack()))</span><br><span class="line">		&#125;</span><br><span class="line">		&lt;-p.sem <span class="comment">// ➌ 最终结束这个 Loop 的时候回收这个 SEM</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		task()</span><br><span class="line">		task = &lt;-p.work <span class="comment">// ➍ 所有的 Worker 都在竞争这一个没有缓冲的 task channel</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的控制任务池的方法还是很精妙的， 如果请求量不大，处理很快的话不一定需要创建最大<code>Maxium</code>的<code>Worker</code>，不过缺点就是并不会在高峰之后并不会回收。</p>
<h4 id="Read-RWLoop-startRWLoop"><a class="header-anchor" href="#Read-RWLoop-startRWLoop">¶</a>Read: RWLoop [startRWLoop]</h4>
<p>看完了 <code>RawEpoll</code> 的模式，我们看看 <code>RWLoop</code> 的模式</p>
<figure class="highlight go"><figcaption><span>startRWLoop</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *connection)</span> <span class="title">startRWLoop</span><span class="params">(lctx context.Context)</span></span> &#123;</span><br><span class="line">	c.internalLoopStarted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	utils.GoWithRecover(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		c.startReadLoop()</span><br><span class="line">	&#125;, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		c.Close(api.NoFlush, api.LocalClose)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>pkg/network/connection.go:startReadLoop</code> 和上面大同小异进行了一系列的处理，在这里我们就直接创建一个新的 <code>GoRotinue</code> 进行该请求的处理，核心的代码在 <code>pkg/network/connection.go:doRead()</code> 中。在 <code>doRead()</code> 的上半段就是在处理读取数据，从 <code>pkg/network/connection.go:507：</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.onRead(bytesRead)</span><br></pre></td></tr></table></figure>
<p>进入了数据的读取阶段。可以发现对于 <code>RWLoop</code> 方式的代码是比较的简单的。</p>
<hr>
<h4 id="Read-Chian"><a class="header-anchor" href="#Read-Chian">¶</a>Read Chian</h4>
<p>对于不同的 <code>IO</code> 处理部分已经在上文结束，我们进入数据获得的部分：</p>
<figure class="highlight go"><figcaption><span>onRead()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *connection)</span> <span class="title">onRead</span><span class="params">(bytesRead <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, cb := <span class="keyword">range</span> c.bytesReadCallbacks &#123;</span><br><span class="line">		cb(<span class="keyword">uint64</span>(bytesRead)) <span class="comment">// ➊ 预留的回调的 Hook</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.filterManager.OnRead()</span><br><span class="line">	c.updateReadBufStats(bytesRead, <span class="keyword">int64</span>(c.readBuffer.Len())) <span class="comment">// ➋ 统计部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们又看到了我们的老熟人 <code>FilterManager</code>，在 <code>Envoy 源码分析</code> 中，我们也发现了 <code>Envoy</code> 是相同的设计模式。我们看看这个 <code>FilterManager</code> 的工作机制</p>
<h5 id="FilterManager"><a class="header-anchor" href="#FilterManager">¶</a>FilterManager</h5>
<figure class="highlight go"><figcaption><span>FilterManager</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FilterManager <span class="keyword">interface</span> &#123;</span><br><span class="line">	AddReadFilter(rf ReadFilter)</span><br><span class="line">	AddWriteFilter(wf WriteFilter)</span><br><span class="line">	ListReadFilter() []ReadFilter</span><br><span class="line">	ListWriteFilters() []WriteFilter</span><br><span class="line">	InitializeReadFilters() <span class="keyword">bool</span></span><br><span class="line">	OnRead()</span><br><span class="line">	OnWrite(buffer []buffer.IoBuffer) FilterStatus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <code>FilterManager</code> 声明看，类似于 <code>Netty</code> 一样的 <code>Inbound Channel</code> 和 <code>Outbound Channel</code>。我们深入 <code>OnRead</code> 部分</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fm *filterManager)</span> <span class="title">onContinueReading</span><span class="params">(filter *activeReadFilter)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> index <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> uf *activeReadFilter</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> filter != <span class="literal">nil</span> &#123;</span><br><span class="line">		index = filter.index + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ; index &lt; <span class="built_in">len</span>(fm.upstreamFilters); index++ &#123;</span><br><span class="line">		uf = fm.upstreamFilters[index]</span><br><span class="line">		uf.index = index</span><br><span class="line">		<span class="comment">// 源码此处有 !uf.initialized 这条路径是针对非 accept 成功的请求处理的，我们在 Read 部分不会进入这里</span></span><br><span class="line">		buf := fm.conn.GetReadBuffer()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; buf.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			status := uf.filter.OnData(buf) <span class="comment">// ➊ 和 netty 一样直接把 当前 获得所有的 bytes 传递给下层</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> status == api.Stop &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们需要处理的逻辑显然都是在 <code>Filter:OnData</code> 部分了。这部分的 <code>Filter</code> 类型，在 <code>yaml</code> 配置可以指定：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">"filter_chains":</span> <span class="string">[&#123;</span></span><br><span class="line">	<span class="attr">"filters":</span> <span class="string">[</span></span><br><span class="line">		<span class="string">&#123;</span></span><br><span class="line">			<span class="attr">"type":</span> <span class="string">"proxy"</span><span class="string">,</span></span><br><span class="line">			<span class="attr">"config":</span> <span class="string">&#123;</span></span><br><span class="line">				<span class="attr">"downstream_protocol":</span> <span class="string">"Http1"</span><span class="string">,</span></span><br><span class="line">				<span class="attr">"upstream_protocol":</span> <span class="string">"Http1"</span><span class="string">,</span></span><br><span class="line">				<span class="string">"router_config_name"</span><span class="string">:"client_router"</span></span><br><span class="line">			<span class="string">&#125;</span></span><br><span class="line">		<span class="string">&#125;</span></span><br><span class="line">	<span class="string">]</span></span><br><span class="line"><span class="string">&#125;]</span></span><br></pre></td></tr></table></figure>
<p>我们来看看最常用的 <code>ProxyFilter</code>。</p>
<h5 id="ProxyFilter"><a class="header-anchor" href="#ProxyFilter">¶</a>ProxyFilter</h5>
<p>在 阅读 <code>ProxyFilter</code> 之前，我们先看下 <code>pkg/proxy/proxy.go:InitializeReadFilterCallbacks</code> 这里我们创建了面向下游的 <code>ServerStreamConn</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *proxy)</span> <span class="title">InitializeReadFilterCallbacks</span><span class="params">(cb api.ReadFilterCallbacks)</span></span> &#123;</span><br><span class="line">	p.readCallbacks.Connection().AddConnectionEventListener(p.downstreamListener)</span><br><span class="line">	<span class="keyword">if</span> p.config.DownstreamProtocol != <span class="keyword">string</span>(protocol.Auto) &#123;</span><br><span class="line">		p.serverStreamConn = stream.CreateServerStreamConnection(p.context, types.ProtocolName(p.config.DownstreamProtocol), p.readCallbacks.Connection(), p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是比较好理解的，我们向下游发送数据总是需要一个单独的连接的。对于 <code>OnData</code> 函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *proxy)</span> <span class="title">OnData</span><span class="params">(buf buffer.IoBuffer)</span> <span class="title">api</span>.<span class="title">FilterStatus</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> p.serverStreamConn == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">	p.serverStreamConn.Dispatch(buf)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> api.Stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接进入了 <code>ServerSteamConn</code> 的  <code>Dispatch</code> 函数而在其中很有趣，我们仅仅将 <code>bytes</code> 写入了一个 <code>byfChan</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *streamConnection)</span> <span class="title">Dispatch</span><span class="params">(buffer buffer.IoBuffer)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// ....</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> buffer.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		sc.bufChan &lt;- buffer</span><br><span class="line">		&lt;-sc.bufChan</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那显然我们需要一个地方进行 <code>Read</code>，没错就是下面几行</p>
<figure class="highlight go"><figcaption><span>Read</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(conn *streamConnection)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	data, ok := &lt;-conn.bufChan</span><br><span class="line">	n = <span class="built_in">copy</span>(p, data.Bytes())</span><br><span class="line">	data.Drain(n)</span><br><span class="line">	conn.bufChan &lt;- <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是有一个疑问放在我们面前，是谁启动这个 <code>Read()</code> 的处理者呢？这个问题要回溯到我们的 <code>ServerConnection</code> 创建的时刻</p>
<figure class="highlight go"><figcaption><span>newServerStreamConnection</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newServerStreamConnection</span><span class="params">(ctx context.Context, connection api.Connection,</span></span></span><br><span class="line"><span class="function"><span class="params">	callbacks types.ServerStreamConnectionEventListener)</span> <span class="title">types</span>.<span class="title">ServerStreamConnection</span></span> &#123;</span><br><span class="line">	ssc := &amp;serverStreamConnection&#123;</span><br><span class="line">		streamConnection: streamConnection&#123;</span><br><span class="line">			context:    ctx,</span><br><span class="line">			conn:       connection,</span><br><span class="line">			bufChan:    <span class="built_in">make</span>(<span class="keyword">chan</span> buffer.IoBuffer),</span><br><span class="line">			connClosed: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>),</span><br><span class="line">		&#125;,</span><br><span class="line">		contextManager:           str.NewContextManager(ctx),</span><br><span class="line">		serverStreamConnListener: callbacks,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// init first context</span></span><br><span class="line">	ssc.contextManager.Next()</span><br><span class="line"></span><br><span class="line">	ssc.br = bufio.NewReader(ssc)</span><br><span class="line">	ssc.bw = bufio.NewWriter(ssc)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reset would not be called in server-side scene, so add listener for connection event</span></span><br><span class="line">	connection.AddConnectionEventListener(ssc)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set not support transfer connection</span></span><br><span class="line">	ssc.conn.SetTransferEventListener(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		ssc.<span class="built_in">close</span> = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	utils.GoWithRecover(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ssc.serve()</span><br><span class="line">	&#125;, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ssc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在这里构建所有的变量，最重要的是 <code>callbacks</code>，我们接收到来自外侧的请求处理逻辑，而这个对象本身的处理逻辑都是在 <code>ssc.serve()</code> 中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(conn *serverStreamConnection)</span> <span class="title">serve</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		ctx := conn.contextManager.Get()</span><br><span class="line">		buffers := httpBuffersByContext(ctx)</span><br><span class="line">		request := &amp;buffers.serverRequest</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2. 这里用了 Fasthttp 来获取请求的数据</span></span><br><span class="line">		err := request.ReadLimitBody(conn.br, maxRequestBodySize)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 3. 生成一个唯一ID</span></span><br><span class="line">		id := protocol.GenerateID()</span><br><span class="line">		s := &amp;buffers.serverStream</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4. 处理请求</span></span><br><span class="line">		s.stream = stream&#123;</span><br><span class="line">			id:       id,</span><br><span class="line">			ctx:      mosnctx.WithValue(ctx, types.ContextKeyStreamID, id),</span><br><span class="line">			request:  request,</span><br><span class="line">			response: &amp;buffers.serverResponse,</span><br><span class="line">		&#125;</span><br><span class="line">		s.connection = conn</span><br><span class="line">		s.responseDoneChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">		s.header = mosnhttp.RequestHeader&#123;&amp;s.request.Header, <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line">		conn.mutex.Lock()</span><br><span class="line">		conn.stream = s</span><br><span class="line">		conn.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> atomic.LoadInt32(&amp;s.readDisableCount) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">			s.handleRequest() <span class="comment">// IMP! 这里进行请求的处理</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 5. 等待请求处理完成</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-s.responseDoneChan:</span><br><span class="line">		<span class="keyword">case</span> &lt;-conn.connClosed:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		conn.contextManager.Next()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里给大家做个小结，我们先理清顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+------------+               +-------------+          +--------------+</span><br><span class="line">|   upsteam  +--------------&gt;+     mosn    +---------&gt;+  downsteam   |</span><br><span class="line">+------------+               +-------------+          +--------------+</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.jpg.cm/2020/08/24/uyuC5.png" alt="uyuC5.png"></p>
<p>对于 <code>Upsteam Conn</code> 根据模型的不同，可能是 <code>RawEpoll</code>，而 <code>ServerSteamConn</code> 是一个被 <code>Pool</code> 化的 <code>Conn</code>，但是对于这个 <code>Conn</code> 本身也有自己的 <code>Read</code> 和 <code>Write</code> 处理函数，是在一个 <code>Gorotine</code> 中，启动的代码是在 <code>ssc.serve()</code> 中。</p>
<h5 id="OnReceive"><a class="header-anchor" href="#OnReceive">¶</a>OnReceive</h5>
<p>对于常见的 <code>Http proxy filter（pkg/proxy/proxy.go）</code> 来说，我们处理  <code>Http encoder</code> 之后，进入 <code>OnReceive</code> 部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *downStream)</span> <span class="title">OnReceive</span><span class="params">(ctx context.Context, headers types.HeaderMap, data types.IoBuffer, trailers types.HeaderMap)</span></span> &#123;</span><br><span class="line">	s.downstreamReqHeaders = headers</span><br><span class="line">	s.context = mosnctx.WithValue(s.context, types.ContextKeyDownStreamHeaders, headers)</span><br><span class="line">	s.downstreamReqDataBuf = data</span><br><span class="line">	s.downstreamReqTrailers = trailers</span><br><span class="line"></span><br><span class="line">	id := s.ID</span><br><span class="line">	<span class="comment">// goroutine for proxy</span></span><br><span class="line">	pool.ScheduleAuto(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">//....</span></span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		phase := types.InitPhase</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			phase = s.receive(ctx, id, phase)</span><br><span class="line">			<span class="keyword">switch</span> phase &#123;</span><br><span class="line">			<span class="comment">//....</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里采用了一个状态机进行处理，。不过值得注意的最多进行 <code>10</code> 此的状态切换就必须进入 <code>End</code> 状态，不过此处其实一个小设计，应该后面的执行步骤刚好就是10次。真实的处理流程在 <code>pkg/proxy/downstream.go:394</code> 中。执行顺序是 <code>DownFilter</code> <code>MatchRoute</code> <code>DownFilterAfterRoute</code> <code>ChooseHost</code> <code>DownFilterAfterChooseHost</code> <code>DownRecvHeader</code> <code>DownRecvData</code> <code>DownRecvTrailer</code> <code>Oneway</code> <code>Retry</code> <code>WaitNotify</code> <code>UpFilter</code> <code>UpRecvHeader</code> <code>UpRecvData</code> <code>UpRecvTrailer</code> <code>End</code>，这里的处理恰好就是 <code>Mosn</code> 的处理核心部分。</p>
<h3 id="Receive-Data-Upstream"><a class="header-anchor" href="#Receive-Data-Upstream">¶</a>Receive Data [Upstream]</h3>
<p>对于 <code>receive</code> 部分值得详细的分析一下。对于前面分了很多种类型的阶段处理，大部分的状态会调用如下的代码，这里的代码是后续的拓展点，先不展开。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *downStream)</span> <span class="title">runReceiveFilters</span><span class="params">(p types.Phase, headers types.HeaderMap, data types.IoBuffer, trailers types.HeaderMap)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> ; s.receiverFiltersIndex &lt; <span class="built_in">len</span>(s.receiverFilters); s.receiverFiltersIndex++ &#123;</span><br><span class="line">		f := s.receiverFilters[s.receiverFiltersIndex]</span><br><span class="line">		<span class="keyword">if</span> f.p != p &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		s.context = mosnctx.WithValue(s.context, types.ContextKeyStreamFilterPhase, p)</span><br><span class="line"></span><br><span class="line">		status := f.filter.OnReceive(s.context, headers, data, trailers)</span><br><span class="line">		<span class="keyword">switch</span> status &#123;</span><br><span class="line">			<span class="comment">//略....</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.receiverFiltersIndex = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑不啰嗦了，找到匹配的逻辑进行处理即可。而其他的有些状态处理各不相同。</p>
<h4 id="matchRoute"><a class="header-anchor" href="#matchRoute">¶</a>*matchRoute</h4>
<p>比如对于 <code>matchRoute</code> 部分</p>
<figure class="highlight go"><figcaption><span>matchRoute</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *downStream)</span> <span class="title">matchRoute</span><span class="params">()</span></span> &#123;</span><br><span class="line">	headers := s.downstreamReqHeaders</span><br><span class="line">	<span class="keyword">if</span> s.proxy.routersWrapper == <span class="literal">nil</span> || s.proxy.routersWrapper.GetRouters() == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 没有路由配置。直接Ret了</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	routers := s.proxy.routersWrapper.GetRouters()</span><br><span class="line">	handlerChain := router.CallMakeHandlerChain(s.context, headers, routers, s.proxy.clusterManager)</span><br><span class="line">	<span class="keyword">if</span> handlerChain == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s.snapshot, s.route = handlerChain.DoNextHandler()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无处不在的 <code>Chain</code>，对于 <code>Route</code> 的匹配我们也需要创建一个 <code>RouteHandlerChain</code> 进行匹配。对于单个的 <code>RouteHandler</code> 里面来说最核心的就是包含的属性 <code>Route</code>,分为 <code>PathRoute</code> <code>PrefixRoute</code> <code>RegexRoute</code> <code>SofaRoute</code>，具体的逻辑就在内部不展开说了。</p>
<h4 id="DownRecvHeader"><a class="header-anchor" href="#DownRecvHeader">¶</a>DownRecvHeader</h4>
<p>在接收到数据处理过程中 <code>DownRecvHeader</code> 进行了数据的发送。发送数据也是蛮有趣的设计：</p>
<figure class="highlight go"><figcaption><span>appendHeaders</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *upstreamRequest)</span> <span class="title">appendHeaders</span><span class="params">(endStream <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.downStream.processDone() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	r.sendComplete = endStream</span><br><span class="line">	<span class="keyword">if</span> r.downStream.oneway &#123;</span><br><span class="line">		r.connPool.NewStream(r.downStream.context, <span class="literal">nil</span>, r)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		r.connPool.NewStream(r.downStream.context, r, r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实并没直接发送，而是从我们的 <code>ConnPool</code> 中获得一个对下游的 <code>Stream</code> 我们将这个 <code>r</code> 对象直接作为了构建这个下游请求连接的参数。而真正的写入在</p>
<figure class="highlight go"><figcaption><span>endStream</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *clientStream)</span> <span class="title">endStream</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := s.doSend()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Proxy.Errorf(s.stream.ctx, <span class="string">"[stream] [http] send client request error: %+v"</span>, err)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err == types.ErrConnectionHasClosed &#123;</span><br><span class="line">			s.ResetStream(types.StreamConnectionFailed)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			s.ResetStream(types.StreamLocalReset)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> log.Proxy.GetLogLevel() &gt;= log.DEBUG &#123;</span><br><span class="line">		log.Proxy.Debugf(s.stream.ctx, <span class="string">"[stream] [http] send client request, requestId = %v"</span>, s.stream.id)</span><br><span class="line">	&#125;</span><br><span class="line">	s.connection.requestSent &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将请求 <code>Send</code> 出去将 <code>requestSent</code> 标记置为 <code>true</code> 即可。而对于读取数据，就在下一个阶段 <code>DownRecvData</code></p>
<h3 id="Receive-Data-Downstream"><a class="header-anchor" href="#Receive-Data-Downstream">¶</a>Receive Data [Downstream]</h3>
<h4 id="DownRecvData"><a class="header-anchor" href="#DownRecvData">¶</a>DownRecvData</h4>
<p><code>DownRecvHeader</code> 先去获取了 <code>DownSteam</code> 的 <code>Header</code> 部分的数据，不过值得注意的如果是 <code>Get</code> 并不会走这里。在 <code>receiveHeaders</code> 中，我们首先调用了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *downStream)</span> <span class="title">receiveData</span><span class="params">(endStream <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	data := s.downstreamReqDataBuf</span><br><span class="line">	s.requestInfo.SetBytesReceived(s.requestInfo.BytesReceived() + <span class="keyword">uint64</span>(data.Len()))</span><br><span class="line">	s.downstreamRecvDone = endStream</span><br><span class="line">	s.upstreamRequest.appendData(endStream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在最开始标记我们需要获得多少数据在 <code>SetBytesReceived(s.requestInfo.BytesReceived() + uint64(data.Len()))</code>,然后将这些数据放到了发送的队列中。</p>
<h4 id="UpRecvHeader"><a class="header-anchor" href="#UpRecvHeader">¶</a>UpRecvHeader</h4>
<p>上面2步走完了发送的流程，而接受的流程从 <code>UpRecvHeader</code> 开始，我们一开始接收到的 <code>Downstream</code> 的 <code>HttpHeader</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *downStream)</span> <span class="title">appendHeaders</span><span class="params">(endStream <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	s.upstreamProcessDone = endStream</span><br><span class="line">	headers := s.convertHeader(s.downstreamRespHeaders)</span><br><span class="line">	<span class="keyword">if</span> err := s.responseSender.AppendHeaders(s.context, headers, endStream); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Proxy.Errorf(s.context, <span class="string">"append headers error: %s"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后读取数据就在</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *downStream)</span> <span class="title">appendData</span><span class="params">(endStream <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	s.upstreamProcessDone = endStream</span><br><span class="line"></span><br><span class="line">	data := s.convertData(s.downstreamRespDataBuf)</span><br><span class="line">	s.requestInfo.SetBytesSent(s.requestInfo.BytesSent() + <span class="keyword">uint64</span>(data.Len()))</span><br><span class="line">	s.responseSender.AppendData(s.context, data, endStream)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> endStream &#123;</span><br><span class="line">		s.endStream()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说到这里，我们一定要好好分析下 这几个 <code>appendData</code> 是怎么工作的，其实看起来还是挺绕的。</p>
<h4 id="小结2-Upstream-和-DownStream-的交互"><a class="header-anchor" href="#小结2-Upstream-和-DownStream-的交互">¶</a>小结2: Upstream 和 DownStream 的交互</h4>
<p>对于整个处理流程的核心部分，我们就一直在和 <code>upstream</code> 和 <code>downstream</code> 这两个 package 的对象进行交互。<br>
大概有这么几个函数很重要：</p>
<ul>
<li>OnReceive：这是接收到数据时候的方法</li>
<li>receiveHeaders：接收到 http header 部分</li>
<li>receiveData： 接收到 http body 部分</li>
</ul>
<p>这里面有一个很重要的抽象是 <code>pkg/types/stream.go:StreamSender</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StreamSender <span class="keyword">interface</span> &#123;</span><br><span class="line">	AppendHeaders(ctx context.Context, headers api.HeaderMap, endStream <span class="keyword">bool</span>) error</span><br><span class="line">	AppendData(ctx context.Context, data buffer.IoBuffer, endStream <span class="keyword">bool</span>) error</span><br><span class="line">	AppendTrailers(ctx context.Context, trailers api.HeaderMap) error</span><br><span class="line">	GetStream() Stream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: UpStream 和 DownStream 交互',
	 'Down#OnReceive->Down#receiveHeaders: 1. 接收到上游的请求',
	 'Down#receiveHeaders->Up#appendHeaders: 2. 将Upstream的Header置于连接池中的某个连接',
	 'Up#appendHeaders->Up#OnReady: 3. 连接就绪',
	 'Up#appendData->Up#convertData: 4. 将请求的Body写入连接，这个转换协议是可选部分',
	 'Down#OnReceive->Up#receiveHeaders: 5.将Donw的回传的Header回写',
	 'Up#receiveHeaders->Down#appendHeaders: 6.同上，这里又可以可选的重写 Header 的逻辑',
	 'Down#OnReceive->Up#receiveData: 7. 将 Down 的Body回写到 Upstream 中',
	 'Up#receiveData->Up#appendData: 8. 同上'
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>

<p>整个流程还是在 <code>Downstream:OnReceive</code> 进行控制，逻辑也就分为 <code>将输入的Header</code>/<code>输入的Body</code> 写入 <code>DownStream</code>，将输出按照同样的方式执行一次。不过值得注意的是，和架构图上一致。在处理单一请求的过程中，写入和回读都是同一个 <code>goroutinue</code>，对于 <code>Downstream</code> 的 <code>io</code> 处理是遵守标准的 <code>NetPoller</code> 的模型的，并没有  <code>RawPoller</code> 机制，<code>RawPoller</code> 机制仅在 <code>接受侧</code> 有单独的定义。</p>
<h3 id="小结：all-in-one"><a class="header-anchor" href="#小结：all-in-one">¶</a>小结：all in one</h3>
<p><img src="https://s3.jpg.cm/2020/09/02/1HMfG.png" alt="1HMfG.png"></p>
<p>对于 <code>Go Lanague</code> 因为 <code>Goroutine</code> 使用起来很方便，分析 <code>Go</code> 项目很难分析 <code>Theadmodel</code> 这块内容，或者也可以认为开 <code>Goroutine</code> 本身的成本很低，大家不用过于担心切换的成本。</p>
<p>作为对比，下面也放上官方的一张图。<br>
<img src="https://s3.jpg.cm/2020/09/03/1JAdf.png" alt="1JAdf.png"></p>
<p>直到这里我们已经将 <code>监听请求</code> <code>接受数据</code> <code>转发请求</code> <code>响应请求</code> 这几个部分都阅读过了，整个流程已经走通了，我们再去看看其他重要的功能。</p>
<h3 id="多协议机制"><a class="header-anchor" href="#多协议机制">¶</a>多协议机制</h3>
<p><code>Mosn</code> 支持多协议之间的转换，我们从想问的分析中，我们可以知道所谓的 <code>Proxy</code> 就是我们整个 <code>FilterManager</code> 中的一个 <code>Filter</code>。因此对于配置文件</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"type"</span>: <span class="string">"proxy"</span>,</span><br><span class="line">	<span class="attr">"config"</span>: &#123;</span><br><span class="line">		<span class="attr">"downstream_protocol"</span>: <span class="string">"Http1"</span>,</span><br><span class="line">		<span class="attr">"upstream_protocol"</span>: <span class="string">"Http1"</span>,</span><br><span class="line">		<span class="attr">"router_config_name"</span>: <span class="string">"server_router"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Mosn</code> 这个功能非常的有趣，因为实际上因为RPC协议非常的多，因此想要支持多种协议的话，都是需要用户自行进行拓展的，不过 <code>Mosn</code> 帮大家做了一部分的工作，流程如下图：</p>
<p><img src="https://s3.jpg.cm/2020/09/03/1troW.png" alt="1troW.png"></p>
<p>在 <code>pkg/protocol/xprotocol/example/encoder.go</code> 中有一个例子。对于大多数的 <code>RPC</code> 协议我们都是需要获取到 <code>足够</code> 信息之后再处理，那第一步显然是我们需要先获得一些数据也就是 <code>MinimalDecodeLen</code></p>
<figure class="highlight go"><figcaption><span>Decode</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proto *proto)</span> <span class="title">Decode</span><span class="params">(ctx context.Context, data types.IoBuffer)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> data.Len() &gt;= MinimalDecodeLen &#123; <span class="comment">// 这里我们需要获得至少获得 Header 部分的信息</span></span><br><span class="line">		magic := data.Bytes()[<span class="number">0</span>]</span><br><span class="line">		dir := data.Bytes()[<span class="number">2</span>]</span><br><span class="line">		<span class="keyword">switch</span> dir &#123;</span><br><span class="line">		<span class="keyword">case</span> DirRequest:</span><br><span class="line">			<span class="keyword">return</span> decodeRequest(ctx, data)</span><br><span class="line">		<span class="keyword">case</span> DirResponse:</span><br><span class="line">			<span class="keyword">return</span> decodeResponse(ctx, data)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后我们需要获得完整的数据</p>
<figure class="highlight go"><figcaption><span>decodeRequest</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeRequest</span><span class="params">(ctx context.Context, data types.IoBuffer)</span> <span class="params">(cmd <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">	bytesLen := data.Len()</span><br><span class="line">	bytes := data.Bytes()</span><br><span class="line"></span><br><span class="line">	payloadLen := binary.BigEndian.Uint32(bytes[<span class="number">7</span>:])</span><br><span class="line">	frameLen := RequestHeaderLen + <span class="keyword">int</span>(payloadLen)</span><br><span class="line">	<span class="keyword">if</span> bytesLen &lt; frameLen &#123;</span><br><span class="line">		<span class="keyword">return</span>  <span class="comment">// 如果没有获取到足够的数据就等待下次执行</span></span><br><span class="line">	&#125;</span><br><span class="line">	data.Drain(frameLen)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//处理数据略</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> request, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就足够满足我们对于自定义数据的处理能力。而对于协议的解析部分还有一个困难的问题需要我们继续处理也就是 <code>多路复用</code>，我们不能在一个 <code>TCP</code> 链路上仅仅处理一个请求，这就是最低效的 <code>Http1</code>，因此协议需要能够定义出来，如果我在一个链路上进行多次请求是怎么区分的。对于 <code>Mosn</code> 来说这里还是有一个很精妙的设计，利用上下的隐性属性作为唯一的 <code>ID</code> 进行判断。这里就不展开，可以查看官方的 <a href="https://mosn.io/docs/concept/multi-protocol/#%E5%8D%8F%E8%AE%AE%E6%89%A9%E5%B1%95%E6%A1%86%E6%9E%B6-mosn" target="_blank" rel="noopener">协议扩展框架</a></p>
<p>我们来关注下对于流程线上的问题，就是这段逻辑是镶嵌在我们的流程的何处的。在特殊的协议处理部分我们在启动时候定义的数据格式都类似于</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">"filters": [</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"type"</span>: <span class="string">"proxy"</span>,</span><br><span class="line">		<span class="attr">"config"</span>: &#123;</span><br><span class="line">			<span class="attr">"downstream_protocol"</span>: <span class="string">"X"</span>,</span><br><span class="line">			<span class="attr">"upstream_protocol"</span>: <span class="string">"X"</span>,</span><br><span class="line">			<span class="attr">"router_config_name"</span>: <span class="string">"server_router"</span>,</span><br><span class="line">			<span class="attr">"extend_config"</span>: &#123;</span><br><span class="line">				<span class="attr">"sub_protocol"</span>: <span class="string">"dubbo"</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>因此我们在处理特定协议的时候需要传入指定的扩展协议如 <code>dubbo</code> 等。因此在构建的 <code>proxy</code> 的时候，将这个保存在 <code>proxy</code> 的属性中。</p>
<figure class="highlight go"><figcaption><span>proxy:NewProxy</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> json.Unmarshal([]<span class="keyword">byte</span>(extJSON), &amp;xProxyExtendConfig); xProxyExtendConfig.SubProtocol != <span class="string">""</span> &#123;</span><br><span class="line">	proxy.context = mosnctx.WithValue(proxy.context, types.ContextSubProtocol, xProxyExtendConfig.SubProtocol)</span><br><span class="line">	log.DefaultLogger.Tracef(<span class="string">"[proxy] extend config subprotocol = %v"</span>, xProxyExtendConfig.SubProtocol)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在我们收到数据的时候会发现在 <code>OnData</code> 的时候我们会创建 <code>ServerStream</code> 的时候传入协议属性</p>
<figure class="highlight go"><figcaption><span>proxy:OnData</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *proxy)</span> <span class="title">OnData</span><span class="params">(buf buffer.IoBuffer)</span> <span class="title">api</span>.<span class="title">FilterStatus</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> p.serverStreamConn == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 这里会创建我们的 ServerStreamConn 而这对象是需要传入 protocol，也就是这里进行了处理</span></span><br><span class="line">		protocol, err := stream.SelectStreamFactoryProtocol(p.context, prot, buf.Bytes())</span><br><span class="line">		p.serverStreamConn = stream.CreateServerStreamConnection(p.context, protocol, p.readCallbacks.Connection(), p)</span><br><span class="line">	&#125;</span><br><span class="line">	p.serverStreamConn.Dispatch(buf) <span class="comment">// 处理 Buf</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> api.Stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此如果我们使用扩展的 <code>协议</code> 这里创建的 <code>ServerStreamConn</code> 也就是 <code>pkg/stream/xprotocol/conn.go</code>，而他的处理逻辑如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *streamConn)</span> <span class="title">Dispatch</span><span class="params">(buf types.IoBuffer)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		streamCtx := sc.ctxManager.Get()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 进行 Decode 和我们上面分析的逻辑一致</span></span><br><span class="line">		frame, err := sc.protocol.Decode(streamCtx, buf)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.1 为null则等待下一次的 Dispatch</span></span><br><span class="line">		<span class="keyword">if</span> frame == <span class="literal">nil</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.3 处理协议包</span></span><br><span class="line">		<span class="keyword">if</span> frame != <span class="literal">nil</span> &#123;</span><br><span class="line">			xframe, ok := frame.(xprotocol.XFrame)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				log.Proxy.Errorf(sc.ctx, <span class="string">"[stream] [xprotocol] conn %d, %v frame type not match : %T"</span>, sc.netConn.ID(), sc.netConn.RemoteAddr(), frame)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			sc.handleFrame(streamCtx, xframe)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.4 下一个，这里其实就是在处理我们的 多路复用 部分</span></span><br><span class="line">		sc.ctxManager.Next()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此这段逻辑其实还是穿插在我们的 <code>Proxy</code> 中作为 <code>Filter</code> 中的一环，而这一环有需要依赖构建出不同的 <code>StreamConn</code> 进行处理，现在已知的支持 <code>http1</code> <code>http2</code> <code>xprotocol</code> 这3个类型。</p>
<h3 id="插件机制"><a class="header-anchor" href="#插件机制">¶</a>插件机制</h3>
<p>对于 <code>Mosn</code> 的插件机制也相对复杂，对于 <code>Envoy</code> 来说我们只有2处可以进行插件埋点，<code>Mosn</code> 也相对一致。</p>
<h4 id="SteamFilter"><a class="header-anchor" href="#SteamFilter">¶</a>SteamFilter</h4>
<p><img src="https://s3.jpg.cm/2020/09/03/1SLTy.png" alt="1SLTy.png"></p>
<p>MOSN 扩展中使用频率最高的扩展点。对于配置项如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">"listeners":[&#123;</span><br><span class="line">	"filter_chains": [&#123;</span><br><span class="line">	&#125;],</span><br><span class="line">	"stream_filters": [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">"type"</span>:<span class="string">"demo"</span>,</span><br><span class="line">			<span class="attr">"config"</span>: &#123;</span><br><span class="line">				<span class="attr">"User"</span>:<span class="string">"admin"</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>从配置看，我可以发现 <code>StreamFilter</code> 和 <code>FilterChain</code> 是平级的（不过实际上并不是）。因此 <code>Stream</code> 分了两种类型：</p>
<blockquote>
<p>进入 proxy 流程以后，如果存在 ReceiverFilter，那么就会执行对应的逻辑，ReceiverFilter 包括两个阶段，“路由前”和“路由后”，在每个 Filter 处理完成以后，会返回一个状态，如果是 Stop 则会中止后续尚未执行的 ReceiverFilter，通常情况下，返回 Stop 状态的 Filter 都会回写一个响应。如果是 Continue 则会执行下一个 ReceiverFilter，直到本阶段的 ReceiverFilter 都执行完成或中止；路由前阶段的 ReceiverFIlter 执行完成后，就会执行路由后阶段，其逻辑和路由前一致。如果是正常转发，那么随后 MOSN 会收到一个响应或者发现其他异常直接回写一个响应，此时就会进入到 SenderFilter 的流程中，完成 SenderFilter 的处理。SenderFilter 处理完成以后，MOSN 会写响应给 Client，并且完成最后的收尾工作，收尾工作包括一些数据的回收、日志的记录，以及 StreamFilter 的“销毁”（调用 OnDestroy）。</p>
</blockquote>
<p>原文中有几个重点，在系统解析完一个 <code>请求</code> 之后才会进入这个流程，因此在 <code>pkg/stream/http/stream.go:serve</code> 中可以发现构建这个 <code>StreamFilter</code> 的逻辑</p>
<figure class="highlight go"><figcaption><span>pkg/proxy/downstream.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *downStream)</span> <span class="title">AddStreamSenderFilter</span><span class="params">(filter api.StreamSenderFilter)</span></span> &#123;</span><br><span class="line">	sf := newActiveStreamSenderFilter(s, filter)</span><br><span class="line">	s.senderFilters = <span class="built_in">append</span>(s.senderFilters, sf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到我们熟悉的地方来 <code>DownStream:receive</code> 中</p>
<figure class="highlight go"><figcaption><span>receive</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> types.DownFilterAfterChooseHost:</span><br><span class="line">	<span class="keyword">if</span> log.Proxy.GetLogLevel() &gt;= log.DEBUG &#123;</span><br><span class="line">		s.printPhaseInfo(types.DownFilterAfterChooseHost, id)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里执行了我们注册在流程中的 `ReceiveFilter`</span></span><br><span class="line">	s.runReceiveFilters(phase, s.downstreamReqHeaders, s.downstreamReqDataBuf, s.downstreamReqTrailers)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> p, err := s.processError(id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p</span><br><span class="line">	&#125;</span><br><span class="line">	phase++</span><br></pre></td></tr></table></figure>
<p>官方的Demo可以看一下，使用起来还是很方便的 <a href="https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/simple_streamfilter" target="_blank" rel="noopener">Stream Filter Demo</a></p>
<h4 id="MOSN-Plugin-机制"><a class="header-anchor" href="#MOSN-Plugin-机制">¶</a>MOSN Plugin 机制</h4>
<p><code>Mosn</code> 还提供了另外一种基于通讯机制的方式</p>
<p><img src="https://s3.jpg.cm/2020/09/03/1YSLR.png" alt="1YSLR.png"></p>
<p>在这里有个例子：<a href="https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/plugin/filter" target="_blank" rel="noopener">Stream Filter Plugin demo</a></p>
<p>不过这种算是上面一种的变形，实际上我们依然需要将 <code>StreamFilter</code> 注册到系统中，不过这一次所有的逻辑处理不在编译器固定，而是有一个 <code>gRPC</code> 的外部服务可以进行通讯判断。因此其实不再限于单一语言，我们只需要遵守 <code>gRPC</code> 的协议即可。</p>
<h3 id="平滑升级"><a class="header-anchor" href="#平滑升级">¶</a>平滑升级</h3>
<p>平滑升级可以参考 <a href="/2020/06/12/other/hot-restart/">聊聊服务端热更新</a> 和 <a href="https://mosn.io/blog/posts/nginx-envoy-mosn-hot-upgrade/" target="_blank" rel="noopener">Nginx vs Envoy vs MOSN 平滑升级原理解析</a> 不做展开了。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://mosn.io/blog/code/" target="_blank" rel="noopener">官方源码分析</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    
    
    
      
  <div class="popular-posts-header">推荐阅读</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2021/03/26/go/ot/" rel="bookmark">Opentelemetry Collector 源码解读</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div>来杯奶茶, 嗝~~~</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wxpay.jpg" alt="Yanick.xia 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay-2.jpg" alt="Yanick.xia 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
              <a href="/tags/mosn/" rel="tag"># mosn</a>
              <a href="/tags/gateway/" rel="tag"># gateway</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/10/networking/epoll-thread/" rel="prev" title="面试拾遗：Epoll 之下的线程模型 / Envoy 快速之谜">
      <i class="fa fa-chevron-left"></i> 面试拾遗：Epoll 之下的线程模型 / Envoy 快速之谜
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/04/rust/understanding-rust-async/" rel="next" title="解密 Rust 异步编程">
      解密 Rust 异步编程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-changyan">ChangYan</a></li>
            <li class="tab"><a href="#comment-livere">LiveRe</a></li>
            <li class="tab"><a href="#comment-disqus">Disqus</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane changyan" id="comment-changyan">
              
  <div class="comments">
    <div id="SOHUCS"></div>
  </div>
  
            </div>
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMjYxNi85MTc3"></div>
  </div>
  
            </div>
            <div class="tab-pane disqus" id="comment-disqus">
              
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#MOSN-的-IO-模型"><span class="nav-number">1.</span> <span class="nav-text">MOSN 的 IO 模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Netpoll-模式"><span class="nav-number">1.1.</span> <span class="nav-text">Netpoll 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RawEpoll-模式"><span class="nav-number">1.2.</span> <span class="nav-text">RawEpoll 模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-it-work"><span class="nav-number">2.</span> <span class="nav-text">How it work</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Start-Server"><span class="nav-number">2.1.</span> <span class="nav-text">Start Server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Accept-Connection"><span class="nav-number">2.2.</span> <span class="nav-text">Accept Connection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-Connection"><span class="nav-number">2.3.</span> <span class="nav-text">Read Connection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Read-EventLoop-attachEventLoop"><span class="nav-number">2.3.1.</span> <span class="nav-text">Read: EventLoop [attachEventLoop]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Read-Write事件监听"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">Read&#x2F;Write事件监听</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小结"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#读写事件处理"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">读写事件处理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#题外话1：Mosn-的-WorkerPool"><span class="nav-number">2.3.1.3.1.</span> <span class="nav-text">题外话1：Mosn 的 WorkerPool</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Read-RWLoop-startRWLoop"><span class="nav-number">2.3.2.</span> <span class="nav-text">Read: RWLoop [startRWLoop]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Read-Chian"><span class="nav-number">2.3.3.</span> <span class="nav-text">Read Chian</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FilterManager"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">FilterManager</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ProxyFilter"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">ProxyFilter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#OnReceive"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">OnReceive</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Receive-Data-Upstream"><span class="nav-number">2.4.</span> <span class="nav-text">Receive Data [Upstream]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#matchRoute"><span class="nav-number">2.4.1.</span> <span class="nav-text">*matchRoute</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DownRecvHeader"><span class="nav-number">2.4.2.</span> <span class="nav-text">DownRecvHeader</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Receive-Data-Downstream"><span class="nav-number">2.5.</span> <span class="nav-text">Receive Data [Downstream]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DownRecvData"><span class="nav-number">2.5.1.</span> <span class="nav-text">DownRecvData</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UpRecvHeader"><span class="nav-number">2.5.2.</span> <span class="nav-text">UpRecvHeader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结2-Upstream-和-DownStream-的交互"><span class="nav-number">2.5.3.</span> <span class="nav-text">小结2: Upstream 和 DownStream 的交互</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结：all-in-one"><span class="nav-number">2.6.</span> <span class="nav-text">小结：all in one</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多协议机制"><span class="nav-number">2.7.</span> <span class="nav-text">多协议机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插件机制"><span class="nav-number">2.8.</span> <span class="nav-text">插件机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SteamFilter"><span class="nav-number">2.8.1.</span> <span class="nav-text">SteamFilter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MOSN-Plugin-机制"><span class="nav-number">2.8.2.</span> <span class="nav-text">MOSN Plugin 机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#平滑升级"><span class="nav-number">2.9.</span> <span class="nav-text">平滑升级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">3.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yanick.xia</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">84</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element">
    <a onclick="Chatra('openChat', true);"><i class="comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:yanick.xia@qq.com" title="Mail → mailto:yanick.xia@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/yanickxia" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yanickxia" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/yann.xia" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yann.xia" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i>知乎</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fas fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://sakeven.me/" title="https:&#x2F;&#x2F;sakeven.me&#x2F;" rel="noopener" target="_blank">Sakeven</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://reficul.io/" title="https:&#x2F;&#x2F;reficul.io&#x2F;" rel="noopener" target="_blank">Reficul</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.tomwei7.com/" title="https:&#x2F;&#x2F;www.tomwei7.com&#x2F;" rel="noopener" target="_blank">Tomwei</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.jinwei.me/" title="https:&#x2F;&#x2F;blog.jinwei.me" rel="noopener" target="_blank">Jinwei</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://renlulu.github.io/" title="https:&#x2F;&#x2F;renlulu.github.io&#x2F;" rel="noopener" target="_blank">Renlulu</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://justjjy.com/" title="http:&#x2F;&#x2F;justjjy.com&#x2F;" rel="noopener" target="_blank">JJY</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://zhyee.top/" title="http:&#x2F;&#x2F;zhyee.top" rel="noopener" target="_blank">Zhyee</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://blog.ihypo.net/" title="http:&#x2F;&#x2F;blog.ihypo.net" rel="noopener" target="_blank">Hypo</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://blog.heytaoge.com/" title="http:&#x2F;&#x2F;blog.heytaoge.com&#x2F;" rel="noopener" target="_blank">Taoge</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.hdls.me/" title="https:&#x2F;&#x2F;blog.hdls.me&#x2F;" rel="noopener" target="_blank">海的澜色</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://farer.org/" title="https:&#x2F;&#x2F;farer.org&#x2F;" rel="noopener" target="_blank">Windfarer</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.41tair.org/" title="https:&#x2F;&#x2F;blog.41tair.org&#x2F;" rel="noopener" target="_blank">Byron</a>
        </li>
    </ul>
  </div>
<div class="sidebar-inner">
    
    <div id="hitokoto">:D 获取中...</div>
    <i id="hitofrom">:D 获取中...</i>

    <script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script>
    <script>
    fetch('https://v1.hitokoto.cn/?c=k&c=i&c=d&c=l')
        .then(function (res){
            return res.json();
        })
        .then(function (data) {
            var hitokoto = document.getElementById('hitokoto');
            hitokoto.innerText = '\xa0\xa0\xa0\xa0\xa0\xa0\xa0' + data.hitokoto;
            var hitofrom = document.getElementById('hitofrom');
            hitofrom.innerText = "——" + data.from + '\xa0'; 
        })
        .catch(function (err) {
            console.error(err);
        })
    </script>
</div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备15036539号-2 </a>
  </div>

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="yanick"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yanick.Xia</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><p>本网站由<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank" rel="noopener"><img src="images/upyun_logos/logo2.png" style="display: inline; height: 15px"></a>提供CDN加速/云存储服务</p>
<!--- 
<p>Hosted by <a href="https://pages.coding.me" target="_blank" rel="noopener" style="font-weight: bold">Coding Pages</a></p>
--->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"KPHj3vsvOqeV377r9yw1DdLl-gzGzoHsz","app_key":"wGzWlWVU3AFfxa6TgF2BadlD","security":false,"server_url":"https://kphj3vsv.lc-cn-n1-shared.com"};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 29715,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="https://lib.baomitu.com/algoliasearch/4.3.0/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>





  <script>
    (function(d, w, c) {
      w.ChatraID = 'ZPdnXR7os9z2MNTzG';
      var s = d.createElement('script');
      w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
      };
      s.async = true;
      s.src = 'https://call.chatra.io/chatra.js';
      if (d.head) d.head.appendChild(s);
    })(document, window, 'Chatra');
  </script>









  

  

  <script>
  NexT.utils.loadComments(document.querySelector('#SOHUCS'), () => {
    var appid = 'cysL8VSAs';
    var conf = '500d337f521f3d63f3031f16746e9470';
    var width = window.innerWidth || document.documentElement.clientWidth;
    if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
    } else {
      var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})});
    }
  });
  </script>
  <script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>

<script>
  var disqus_config = function() {
    this.page.url = "http://blog.yanick.site/2020/08/18/go/mosn/";
    this.page.identifier = "2020/08/18/go/mosn/";
    this.page.title = "Mosn源码速读";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://yann-blog.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
