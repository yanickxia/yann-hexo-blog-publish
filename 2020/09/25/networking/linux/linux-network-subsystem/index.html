<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/2020/logo-thin.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/2020/logo-thin.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/2020/logo-thin.png">
  <link rel="mask-icon" href="/images/2020/logo-thin.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="https://lib.baomitu.com/font-awesome/5.15.3/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.yanick.site","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"changyan","storage":true,"lazyload":true,"nav":{"livere":{"text":"LiveRe","order":2},"disqus":{"text":"Disqus","order":3},"changyan":{"text":"ChangYan","order":1}},"activeClass":"changyan"},"algolia":{"appID":"SLJ0R87CAH","apiKey":"fd4f2896d73497ea343ec5d504a06bb4","indexName":"yann_blog","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="不是很喜欢起这么大的一个名字，不过好像也没啥办法，这次带大家一起聊聊，Linux Network 的全貌（从软件工程师的角度）">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 网络大全">
<meta property="og:url" content="http://blog.yanick.site/2020/09/25/networking/linux/linux-network-subsystem/index.html">
<meta property="og:site_name" content="Yanick&#39;s Blog">
<meta property="og:description" content="不是很喜欢起这么大的一个名字，不过好像也没啥办法，这次带大家一起聊聊，Linux Network 的全貌（从软件工程师的角度）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/28/JJUHE.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/25/JRPSU.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/25/JRR2O.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/27/Jc8rR.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/26/J6IXC.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/27/JULvD.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/27/JUWsT.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/25/JWO8G.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/30/JkLe8.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/30/JkGaw.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/30/JFZpO.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/30/JkrhS.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/27/JuepH.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/28/JHDOi.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/28/JJLdr.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/29/JSWqf.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/28/JJPr5.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/28/JtdzO.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/28/JtFjD.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/28/Jtm5p.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/28/Jtv0T.png">
<meta property="og:image" content="https://s3.jpg.cm/2020/09/28/Jt4bQ.png">
<meta property="article:published_time" content="2020-09-25T02:09:07.000Z">
<meta property="article:modified_time" content="2021-10-21T03:11:29.432Z">
<meta property="article:author" content="Yanick.xia">
<meta property="article:tag" content="network">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.jpg.cm/2020/09/28/JJUHE.png">

<link rel="canonical" href="http://blog.yanick.site/2020/09/25/networking/linux/linux-network-subsystem/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux 网络大全 | Yanick's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c033617f45ecdaad648e08ab6a03ae3a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yanick's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-专栏">

    <a href="https://article.yanick.site/" rel="noopener" target="_blank"><i class="fa fa-edit fa-fw"></i>专栏</a>

  </li>
        <li class="menu-item menu-item-百科">

    <a href="https://wiki.yanick.site/" rel="noopener" target="_blank"><i class="fab fa-wikipedia-w fa-fw"></i>百科</a>

  </li>
        <li class="menu-item menu-item-随想">

    <a href="https://misc.yanick.site/" rel="noopener" target="_blank"><i class="fas fa-compact-disc fa-fw"></i>随想</a>

  </li>
        <li class="menu-item menu-item-计划">

    <a href="/plan/" rel="section"><i class="fa fa-paper-plane fa-fw"></i>计划</a>

  </li>
        <li class="menu-item menu-item-推荐">

    <a href="/annual-recommend/2021.html" rel="section"><i class="fas fa-thumbs-up fa-fw"></i>推荐</a>

  </li>
        <li class="menu-item menu-item-地图">

    <a href="/knowledge-map/" rel="section"><i class="fa fa-map fa-fw"></i>地图</a>

  </li>
        <li class="menu-item menu-item-分享">

    <a href="/link/" rel="section"><i class="fa fa-link fa-fw"></i>分享</a>

  </li>
        <li class="menu-item menu-item-专题">

    <a href="/column/" rel="section"><i class="fa fa-columns fa-fw"></i>专题</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.yanick.site/2020/09/25/networking/linux/linux-network-subsystem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yanick.xia">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yanick's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux 网络大全
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-25 10:09:07" itemprop="dateCreated datePublished" datetime="2020-09-25T10:09:07+08:00">2020-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 11:11:29" itemprop="dateModified" datetime="2021-10-21T11:11:29+08:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
                </span>
            </span>

          
            <span id="/2020/09/25/networking/linux/linux-network-subsystem/" class="post-meta-item leancloud_visitors" data-flag-title="Linux 网络大全" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://s3.jpg.cm/2020/09/28/JJUHE.png" alt="JJUHE.png"></p>
<p>不是很喜欢起这么大的一个名字，不过好像也没啥办法，这次带大家一起聊聊，<code>Linux Network</code> 的全貌（从软件工程师的角度）</p>
<a id="more"></a>
<h2 id="修订记录"><a class="header-anchor" href="#修订记录">¶</a>修订记录</h2>
<ul>
<li>2020.9.30: 增加 <a href="#ebpf"><code>ebpf</code></a> 相关</li>
</ul>
<h2 id="基础概念"><a class="header-anchor" href="#基础概念">¶</a>基础概念</h2>
<p>觉得啰嗦的可以：<a href="#mmio">直接跳转至正文</a></p>
<h3 id="Linux-分层"><a class="header-anchor" href="#Linux-分层">¶</a>Linux 分层</h3>
<p><img src="https://s3.jpg.cm/2020/09/25/JRPSU.png" alt="JRPSU.png"></p>
<p>内核提供了一组 API，通常称为“系统调用”。这些 API 不同于常规的库 API，因为它们是执行从用户模式切换到内核模式的边界。</p>
<p>为了提供应用程序兼容性，很少更改系统调用。Linux特别强调这一点（与内核 API 不同，内核 API 可以根据需要进行更改）。</p>
<p>内核代码本身可以在逻辑上分为核心内核代码和设备驱动程序代码。设备驱动程序代码负责访问特定的设备，而核心内核代码是通用的。核心内核可以进一步划分为多个逻辑子系统（如文件访问、联网、进程管理等）</p>
<h3 id="SMP"><a class="header-anchor" href="#SMP">¶</a>SMP</h3>
<p><img src="https://s3.jpg.cm/2020/09/25/JRR2O.png" alt="JRR2O.png"></p>
<p>在现在的硬件体系下，因为我们的系统都是 <code>多核</code> 架构，因此大部分的时候，我们的Linux都运行在 <code>Symmetric MultiProcessing</code> 状态下，也就是内核可能在多个 CPU 中进行运行。如果两个进程运行访问相同内存位置的内核函数，则会在内核中产生竞争条件。因此在内核代码的大多数地方都需要使用到 <code>synchronization</code> 机制，来保证代码的线程安全线。</p>
<h3 id="线程"><a class="header-anchor" href="#线程">¶</a>线程</h3>
<p>在单纯的应用侧我们无感知 <code>CPU</code> 的线程概念，在操作系统这个层面就不得不去面对了。</p>
<ul>
<li><code>操作系统</code> 中的 <code>Thread</code>: 任务的单位，保存当前执行的栈，和同一个进程共享地址空间等，这个就是我们熟悉的线程。</li>
<li><code>CPU</code> 中的 <code>Thread</code>: 执行单位，当前 CPU 上可以同时执行的基本单位。</li>
</ul>
<h3 id="mmio"><a class="header-anchor" href="#mmio">¶</a>mmio</h3>
<p>MMIO(Memory mapping I/O)即内存映射I/O，它是PCI规范的一部分，I/O设备被放置在内存空间而不是I/O空间。从处理器的角度看，内存映射I/O后系统设备访问起来和内存一样。</p>
<h2 id="Network-Packet-Travel"><a class="header-anchor" href="#Network-Packet-Travel">¶</a>Network Packet Travel</h2>
<p>开局一张图，谨防迷路，代码原理大部分针对 <code>Linux 2.4</code>，具体的实现部分可能会截取 <code>Linux 4.19</code>。</p>
<p><img src="https://s3.jpg.cm/2020/09/27/Jc8rR.png" alt="Jc8rR.png"></p>


<script src="https://lib.baomitu.com/webfont/1.6.28/webfontloader.js"></script>
<script src="https://lib.baomitu.com/snap.svg/0.5.1/snap.svg-min.js"></script>
<script src="https://lib.baomitu.com/underscore.js/1.9.0/underscore-min.js"></script>
<script src="https://lib.baomitu.com/raphael/2.2.7/raphael.min.js"></script>
<script src="https://lib.baomitu.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script>


<h2 id="Network-Driver"><a class="header-anchor" href="#Network-Driver">¶</a>Network Driver</h2>
<p>本文试图从软件的角度解释一个网络请求的今生前世，我们这里选取 <a href="https://wiki.osdev.org/RTL8139" target="_blank" rel="noopener">RTL8139</a> 作为我们了解网络驱动的硬件设备。</p>
<h3 id="设备数据结构定义：net-device"><a class="header-anchor" href="#设备数据结构定义：net-device">¶</a>设备数据结构定义：net_device</h3>
<p><code>Linux</code> 内核中设备的抽象对应的结构体是 <code>struct net_device</code></p>
<figure class="highlight c"><figcaption><span>net_device</span><a href="https://elixir.bootlin.com/linux/v4.19.144/source/include/linux/netdevice.h#L1747" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[IFNAMSIZ];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *	I/O 相关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mem_end;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mem_start;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> base_addr;</span><br><span class="line">    <span class="keyword">int</span> irq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设备 Index</span></span><br><span class="line">    <span class="keyword">int</span> ifindex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stats 数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device_stats</span> <span class="title">stats</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netdev_rx_queue</span> *_<span class="title">rx</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num_rx_queues;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> real_num_rx_queues;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netdev_queue</span> *_<span class="title">tx</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num_tx_queues;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> real_num_tx_queues;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于现在硬件设备都会基于 <code>mmio</code> 模式进行工作，因此我们读取数据也是直接和读取内存类似的方式进行读取的。</p>
<h3 id="网卡数据的读取"><a class="header-anchor" href="#网卡数据的读取">¶</a>网卡数据的读取</h3>
<p>外部数据的读取会涉及到中断体系，<code>Linux</code> 将 <code>中断</code> 分为了两个部分: <code>top half</code> 与 <code>bottom half</code>。<code>top half</code>是在呼叫 <code>request_irq()</code> 时所指定的 <code>interrupt handler</code> 函数，<code>bottom half</code> 则是真正负责响应中断的 <code>task</code>。</p>
<h4 id="硬中断部分"><a class="header-anchor" href="#硬中断部分">¶</a>硬中断部分</h4>
<p>对于数据初次抵达硬件，会触发硬件中断，如下图所示（网卡类似）。</p>
<p><img src="https://s3.jpg.cm/2020/09/26/J6IXC.png" alt="J6IXC.png"><br>
因此从中断的入口观察是最好的，下面的代码逻辑从 <code>linux-1.x</code> 版本中截取，比最近的要简单一些，容易理解，另外就是新版的已经改为 <code>NAPI</code> 模式，下文提到再说。</p>
<figure class="highlight c"><figcaption><span>rtl8139_interrupt</span><a href="https://elixir.bootlin.com/linux/2.4.18/source/drivers/net/8139too.c#L2011" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_interrupt</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_instance, struct pt_regs *regs)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">net_device</span> *) <span class="title">dev_instance</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_private</span> *<span class="title">tp</span> = <span class="title">dev</span>-&gt;<span class="title">priv</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *ioaddr = tp-&gt;mmio_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> short isr = readw(ioaddr + ISR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理接受信号，上面略过了发送部分</span></span><br><span class="line">    <span class="keyword">if</span> (isr &amp; RxOK) &#123;</span><br><span class="line">        LOG_MSG(<span class="string">"receive interrupt received\n"</span>);</span><br><span class="line">        <span class="keyword">while</span> ((readb(ioaddr + CR) &amp; RxBufEmpty) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> rx_status;</span><br><span class="line">            <span class="keyword">unsigned</span> short rx_size;</span><br><span class="line">            <span class="keyword">unsigned</span> short pkt_size;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理环形队列</span></span><br><span class="line">            <span class="keyword">if</span> (tp-&gt;cur_rx &gt; RX_BUF_LEN)</span><br><span class="line">                tp-&gt;cur_rx = tp-&gt;cur_rx % RX_BUF_LEN;</span><br><span class="line"></span><br><span class="line">            rx_status = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *) (tp-&gt;rx_ring + tp-&gt;cur_rx);</span><br><span class="line">            rx_size = rx_status &gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">            pkt_size = rx_size - <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 创建内核态的 skb 储存接受到的数据 */</span></span><br><span class="line">            skb = dev_alloc_skb(pkt_size + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (skb) &#123;</span><br><span class="line">                skb-&gt;dev = dev;</span><br><span class="line">                skb_reserve(skb, <span class="number">2</span>); <span class="comment">/* 16 byte align the IP fields */</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 拷贝数据并且检查 checksum</span></span><br><span class="line">                eth_copy_and_sum(</span><br><span class="line">                        skb, tp-&gt;rx_ring + tp-&gt;cur_rx + <span class="number">4</span>, pkt_size, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                skb_put(skb, pkt_size);</span><br><span class="line">                skb-&gt;protocol = eth_type_trans(skb, dev);</span><br><span class="line">                netif_rx(skb);</span><br><span class="line"></span><br><span class="line">                dev-&gt;last_rx = jiffies;</span><br><span class="line">                tp-&gt;stats.rx_bytes += pkt_size;</span><br><span class="line">                tp-&gt;stats.rx_packets++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG_MSG(<span class="string">"Memory squeeze, dropping packet.\n"</span>);</span><br><span class="line">                tp-&gt;stats.rx_dropped++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 移动读取指针  * /</span></span><br><span class="line"><span class="comment">            tp-&gt;cur_rx = (tp-&gt;cur_rx + rx_size + 4 + 3) &amp; ~3;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p>中断模式下，我们收到一个数据包是非常的好理解的，将数据从网卡中 <code>COPY</code> 到我们的内核中即可，<a href="https://www.kernel.org/doc/htmldocs/networking/API-netif-rx.html" target="_blank" rel="noopener"><code>netif_rx</code></a> 就是我们从 <code>Hardware</code> 向 <code>Kernel</code> 转换的核心点。</p>
<figure class="highlight c"><figcaption><span>netif_rx</span><a href="https://elixir.bootlin.com/linux/2.4.18/source/net/core/dev.c#L1214" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netif_rx</span><span class="params">(struct sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> this_cpu = smp_processor_id();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">queue</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们为每个 Core 分配了一个 待处理的数据队列，这里的处理如注释所言，</span></span><br><span class="line">	<span class="comment">// 代码可能被重排，这里只用当前的 CPU 保证了处理路径的最短化</span></span><br><span class="line">    <span class="built_in">queue</span> = &amp;softnet_data[this_cpu];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有超过backlog的限制就置于队列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;input_pkt_queue.qlen &lt;= netdev_max_backlog) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;input_pkt_queue.qlen) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;throttle) <span class="comment">// 不然就丢弃 -&gt; 因为还没响应，等于丢包</span></span><br><span class="line">                <span class="keyword">goto</span> drop;</span><br><span class="line">enqueue:</span><br><span class="line">            dev_hold(skb-&gt;dev);</span><br><span class="line">            __skb_queue_tail(&amp;<span class="built_in">queue</span>-&gt;input_pkt_queue, skb);</span><br><span class="line">            <span class="keyword">return</span> softnet_data[this_cpu].cng_level;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> enqueue;</span><br><span class="line">    &#125;</span><br><span class="line">drop:</span><br><span class="line">    netdev_rx_stat[this_cpu].dropped++;</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">    <span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>硬中断部分到此结束，我们将数据压入内核的虚拟接受列队中结束。</p>
<h4 id="选读-硬中断成本"><a class="header-anchor" href="#选读-硬中断成本">¶</a>[选读] 硬中断成本</h4>
<p><code>硬中断</code> 是一个有硬件主导，软件配合的出来体系，但是这样的模式不是没有成本的，打断正在运行的软件进程，我们不得不涉及到进程的切换，还有中断标记的处理等工作。<strong>It’s not free.</strong> ，有兴趣的可以参考 <a href="http://www.cs.utah.edu/~ald/pubs/interrupts.pdf" target="_blank" rel="noopener">Profiling I/O Interrupts in Modern Architectures</a>，</p>
<p>截止至今，我们知道了对于从网卡来的数据，我们至少会涉及到 ➊ <code>Hard Interrupt</code> 导致的 <code>进程切换</code>，并且 ➋ 涉及到一次数据从网卡的 <code>Buffer</code> 向内核拷贝的过程。</p>
<h4 id="软中断部分"><a class="header-anchor" href="#软中断部分">¶</a>软中断部分</h4>
<p>软中断的逻辑在 <code>net_rx_action</code> 中</p>
<figure class="highlight c"><figcaption><span>net_rx_action</span><a href="https://elixir.bootlin.com/linux/2.4.18/source/net/core/dev.c#L188" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">net_rx_action</span><span class="params">(struct softirq_action *h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> this_cpu = smp_processor_id();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">queue</span> = &amp;<span class="title">softnet_data</span>[<span class="title">this_cpu</span>];</span></span><br><span class="line">    <span class="keyword">int</span> bugdet = netdev_max_backlog;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">rx_dev</span>;</span></span><br><span class="line">        <span class="comment">// 将数据弹出</span></span><br><span class="line">        skb = __skb_dequeue(&amp;<span class="built_in">queue</span>-&gt;input_pkt_queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没数据直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (skb == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        skb-&gt;h.raw = skb-&gt;nh.raw = skb-&gt;data;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> *<span class="title">ptype</span>, *<span class="title">pt_prev</span>;</span></span><br><span class="line">            <span class="keyword">unsigned</span> short type = skb-&gt;protocol;</span><br><span class="line"></span><br><span class="line">            pt_prev = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 根据 package 类型找到对应的处理函数进行处理</span></span><br><span class="line">            <span class="keyword">for</span> (ptype = ptype_all; ptype; ptype = ptype-&gt;next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pt_prev) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!pt_prev-&gt;data) &#123;</span><br><span class="line">                            deliver_to_old_ones(pt_prev, skb, <span class="number">0</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            atomic_inc(&amp;skb-&gt;users);</span><br><span class="line">                            <span class="comment">// 调用预置的回调函数</span></span><br><span class="line">                            pt_prev-&gt;func(skb,skb-&gt;dev,pt_prev);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pt_prev = ptype;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回调的函数签名如下：</p>
<p><code>int (*func) (struct sk_buff *, struct net_device *, struct packet_type *);</code> 很标准的指针函数。不过也很讨厌看这部分的代码，如果不是 <code>Runtime</code> 阶段很难找到这个定义的函数是什么。这里实际上在接收到 <code>TCP/IP</code> 协议包的时候，回调的是 <code>int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt)</code> 函数。在看 <code>IP</code> 处理的之前，我们先看看这个 <code>packet_type</code> 的相关函数。</p>
<h4 id="选读-Packet-Type-钩子"><a class="header-anchor" href="#选读-Packet-Type-钩子">¶</a>[选读] Packet Type 钩子</h4>
<p><code>packet_type</code> 的定义很简单</p>
<figure class="highlight c"><figcaption><span>packet_type</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short type;    <span class="comment">/*  协议类型	*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span>    <span class="comment">/* 不设置就是通配符	*/</span></span><br><span class="line">    <span class="keyword">int</span> (*func)(struct sk_buff *, struct net_device *, struct packet_type *); <span class="comment">/* 回调函数 */</span></span><br><span class="line">    <span class="keyword">void</span> *data;    <span class="comment">/* 私有数据	*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>dev.c</code> 的源码中，我们可以动态的向 <code>ptype_all</code> 注册我们需要的 <code>ptype</code></p>
<figure class="highlight c"><figcaption><span>dev_add_pack</span><a href="https://elixir.bootlin.com/linux/2.4.18/C/ident/dev_add_pack" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dev_add_pack</span><span class="params">(struct packet_type *pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt-&gt;type == htons(ETH_P_ALL)) &#123;</span><br><span class="line">        netdev_nit++;</span><br><span class="line">        pt-&gt;next = ptype_all;</span><br><span class="line">        ptype_all = pt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hash = ntohs(pt-&gt;type) &amp; <span class="number">15</span>;</span><br><span class="line">        pt-&gt;next = ptype_base[hash];</span><br><span class="line">        ptype_base[hash] = pt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们如果需要处理比如 <code>arp</code> 的请求，可以单独增加一个，所以在 <code>arp.c</code> 初始化的时候，就可以出发。</p>
<figure class="highlight c"><figcaption><span>arp_init</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> <span class="title">arp_packet_type</span> = &#123;</span></span><br><span class="line">        type:    __constant_htons(ETH_P_ARP),</span><br><span class="line">        func:    arp_rcv,</span><br><span class="line">        data:    (<span class="keyword">void</span> *) <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">arp_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dev_add_pack(&amp;arp_packet_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="TCPDUMP"><a class="header-anchor" href="#TCPDUMP">¶</a>TCPDUMP</h5>
<p><code>tcpdump</code> 二层抓包，用的是 <code>libpcap</code> 库，它的基本原理是</p>
<ol>
<li>先创建socket，内核dev_add_packet()挂上自己的钩子函数</li>
<li>然后在钩子函数中，把skb放到自己的接收队列中，</li>
<li>接着系统调用recv取出skb来，把数据包skb-&gt;data拷贝到用户空间</li>
<li>最后关闭socket，内核dev_remove_packet()删除自己的钩子函数</li>
</ol>
<p>因此代码如下表述</p>
<figure class="highlight c"><figcaption><span>af_packet.c:packet_create</span><a href="https://elixir.bootlin.com/linux/2.4.18/source/net/packet/af_packet.c#L936" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">packet_create</span><span class="params">(struct socket *sock, <span class="keyword">int</span> protocol)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 略部分代码</span></span><br><span class="line">    <span class="keyword">if</span> (protocol) &#123;</span><br><span class="line">        sk-&gt;protinfo.af_packet-&gt;prot_hook.type = protocol;</span><br><span class="line">        dev_add_pack(&amp;sk-&gt;protinfo.af_packet-&gt;prot_hook); <span class="comment">/* 增加 Hook 在此协议上 */</span></span><br><span class="line">        sock_hold(sk);</span><br><span class="line">        sk-&gt;protinfo.af_packet-&gt;<span class="built_in">running</span> = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>直到此处，我们走到这里算是和硬件越来越远了。再下来的历程，我们要去面对的是更加高纬度的 <code>Socket</code> 抽象。</p>
<div style="width:100%; overflow-y:scroll;" id="diagram"></div>
<script>
	var data =
	['Title: 硬中断 -> 软中断',
	 'interrupt->netif_rx: 1. 将网卡数据copy到内核态',
	 'netif_rx->softnet_data: 2. 将数据放置于虚拟的网卡队列',
	 'softirq->softnet_data: 3. 软中断读取软网卡数据',
	 'softirq->callback_func: 4. 调用对应协议的回调函数',
	 'Note over interrupt,softnet_data: top half',
	 'Note over softnet_data,callback_func: bottom half',
    ].join('\n');
  	var diagram = Diagram.parse(data);
  	diagram.drawSVG("diagram", {theme: 'simple', scale: 0.5});
</script>
<h4 id="选读-软断成本"><a class="header-anchor" href="#选读-软断成本">¶</a>[选读] 软断成本</h4>
<p>对于常见的硬件中断来说，比如键入了一个字母，过程简单，很快可以处理完成，对于网络IO就复杂的多，涉及到从驱动拷贝数据，然后到虚拟的网络协议栈，再到Socket的Buffer中，因此才才产生的了软中断的，将中断一分为二，软中断优先级较低但是因为软件中断复杂，成本上是要更多的。</p>
<p>软中断依然需要 ➊ 进程上下文的切换（这里切换到 内核线程 <code>ksoftirqd</code> ），这里只不过相对于硬中断是操作系统自己进行调度的 ➋ 就是和系统开销调用一下，因为对于正常运行的用户态进程，我们需要把当前的上下文保存。</p>
<p>内核线程 <code>ksoftirqd</code> 也会充分利用多核的能力，对于每一个 <code>core</code> 都会启动一个 <code>ksoftirqd</code>，暂且可以把它当做一个普通的进程看待。</p>
<h4 id="NAPI"><a class="header-anchor" href="#NAPI">¶</a>NAPI</h4>
<p>单纯的看，上面的开销，我们一眼就可以发现硬中断部分有一个非常不合理的情况，考虑如果出现以下情况</p>
<blockquote>
<p>网卡每隔 10 ms 获得一个数据包，我们硬中断处理需要 9ms</p>
</blockquote>
<p>那会出现一个很神奇的现象就是我们虽然每次都要将中断结束，但是每一次刚刚结束又要唤醒，结果我们会浪费大量的时间在处理中断请求上。针对这一的情况，<code>Linux 2.6</code> 之后提供了一个全新的API来处理这种情况（实际上对于大部分的数据，网络请求从不间断）。</p>
<p><img src="https://s3.jpg.cm/2020/09/27/JULvD.png" alt="JULvD.png"></p>
<p>既然每次进中断都很浪费，那我们就不要每一次都进中断了，<code>NAPI</code> 的解决之道就是，当我们接收到请求之后，我们将从此网卡读取作为一个 <code>Task</code> 注册到 <code>napi_scheluder</code> 中，然后屏蔽中断，内核定时的去 <code>poll</code> 数据即可。主要就是减少了硬中断切换的成本。</p>
<h5 id="NAPI-定义"><a class="header-anchor" href="#NAPI-定义">¶</a>NAPI 定义</h5>
<figure class="highlight c"><figcaption><span>napi</span><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/include/linux/netdevice.h#L353" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// poll 列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">poll_list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> state;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得数据的 poll 函数</span></span><br><span class="line">    <span class="keyword">int</span> (*poll)(struct napi_struct *, <span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>核心的逻辑都是在 <code>poll</code> 的回调函数中。</p>
<h5 id="NAPI-之下的硬中断处理"><a class="header-anchor" href="#NAPI-之下的硬中断处理">¶</a>NAPI 之下的硬中断处理</h5>
<figure class="highlight c"><figcaption><span>rtl8139_interrupt</span><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/drivers/net/8139too.c#L2104" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">rtl8139_interrupt</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_instance)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">net_device</span> *) <span class="title">dev_instance</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_private</span> *<span class="title">tp</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Receive packets are processed by poll routine.</span></span><br><span class="line"><span class="comment">       If not running start it now.</span></span><br><span class="line"><span class="comment">	   如注释所言，现在的处理都早 POLL 的子函数中，我们在这里只是向 __napi_schedule 注册我们的 poll 函数</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (status &amp; RxAckBits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (napi_schedule_prep(&amp;tp-&gt;napi)) &#123;</span><br><span class="line">            RTL_W16_F(IntrMask, rtl8139_norx_intr_mask);</span><br><span class="line">            __napi_schedule(&amp;tp-&gt;napi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    netdev_dbg(dev, <span class="string">"exiting interrupt, intr_status=%#4.4x\n"</span>,</span><br><span class="line">               RTL_R16(IntrStatus));</span><br><span class="line">    <span class="keyword">return</span> IRQ_RETVAL(handled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>poll</code> 函数的实现这里就不做展开了，和传统的体系一样，直接将数据拷贝到内核态没有区别。</p>
<h5 id="软中断唤醒"><a class="header-anchor" href="#软中断唤醒">¶</a>软中断唤醒</h5>
<p>因此到此版本，网络请求的软中断环境代码也相对应的有所改变</p>
<figure class="highlight c"><figcaption><span>net_rx_action</span><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/net/core/dev.c#L3731" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">net_rx_action</span><span class="params">(struct softirq_action *h)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> = &amp;__<span class="title">get_cpu_var</span>(<span class="title">softnet_data</span>);</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> time_limit = jiffies + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> budget = netdev_budget;</span><br><span class="line">    <span class="keyword">void</span> *have;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!list_empty(&amp;sd-&gt;poll_list)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span> *<span class="title">n</span>;</span></span><br><span class="line">        <span class="keyword">int</span> work, weight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得可运行的 poll</span></span><br><span class="line">        n = list_first_entry(&amp;sd-&gt;poll_list,</span><br><span class="line">        struct napi_struct, poll_list);</span><br><span class="line"></span><br><span class="line">        work = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state)) &#123;</span><br><span class="line">            work = n-&gt;poll(n, weight); <span class="comment">// 执行 poll 操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只将核心的逻辑展示出来，比如代码中 <code>budget</code> 防止饥饿的操作都留于读者自行理解了， <code>NAPI</code> 解决了我们依靠硬中断导致的大量的进程切换的问题，加上现在的操作系统都是基于 <code>DMA</code> ，因此整个过程中的成本就只有 ➊ 软中断导致的线程切换  ➋ 数据的拷贝</p>
<p><img src="https://s3.jpg.cm/2020/09/27/JUWsT.png" alt="JUWsT.png"></p>
<hr>
<h2 id="IP-Level"><a class="header-anchor" href="#IP-Level">¶</a>IP Level</h2>
<p>我们从 <code>软中断</code> 归来，数据开始进入了我们熟悉的协议处理部分，从 <code>ip_rcv</code> 开始作为我们正式的处理逻辑。</p>
<p><code>Linux</code> 这也使用了 <code>ip_rt_hash_table</code> 的一种设计方式。</p>
<figure class="highlight c"><figcaption><span>ip_rcv</span><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/net/ipv4/ip_input.c#L375" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ip_rcv</span><span class="params">(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,</span></span></span><br><span class="line"><span class="function"><span class="params">	struct net_device *orig_dev)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    u32 len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得IP协议的头部数据</span></span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *	按照 RFC1122 进行检测</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (iph-&gt;ihl &lt; <span class="number">5</span> || iph-&gt;version != <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">goto</span> inhdr_error;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (unlikely(ip_fast_csum((u8 *) iph, iph-&gt;ihl)))</span><br><span class="line">        <span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">    len = ntohs(iph-&gt;tot_len);</span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;len &lt; len) &#123;</span><br><span class="line">        IP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);</span><br><span class="line">        <span class="keyword">goto</span> drop;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt; (iph-&gt;ihl * <span class="number">4</span>))</span><br><span class="line">        <span class="keyword">goto</span> inhdr_error;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pskb_trim_rcsum(skb, len)) &#123;</span><br><span class="line">        IP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);</span><br><span class="line">        <span class="keyword">goto</span> drop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(IPCB(skb), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct inet_skb_parm));</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 上面一圈检测没啥问题进入 Nefilter 预留的 HOOK 进行处理</span></span><br><span class="line">    <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, dev, <span class="literal">NULL</span>, ip_rcv_finish);</span><br><span class="line">	</span><br><span class="line">inhdr_error:</span><br><span class="line">    IP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);</span><br><span class="line">drop:</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>NF_HOOK</code> 的逻辑不在本文的探讨范围内，我们直接看最后在 <code>NF_INET_PRE_ROUTING</code> 阶段完成，进入了下一步的逻辑处理 <code>ip_rcv_finish</code></p>
<figure class="highlight c"><figcaption><span>ip_rcv_finish</span><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/net/ipv4/ip_input.c#L443" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ip_rcv_finish</span><span class="params">(struct sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">skb</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> = <span class="title">skb</span>-&gt;<span class="title">nh</span>.<span class="title">iph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *	Initialise the virtual path cache for the packet. It describes</span></span><br><span class="line"><span class="comment">     *	how the packet travels inside Linux networking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;dst == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 查找 route 表，不可达就直接丢弃</span></span><br><span class="line">        <span class="keyword">if</span> (ip_route_input(skb, iph-&gt;daddr, iph-&gt;saddr, iph-&gt;tos, dev))</span><br><span class="line">            <span class="keyword">goto</span> drop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// header 长度超过 5，说明还有其他需要处理的</span></span><br><span class="line">    <span class="keyword">if</span> (iph-&gt;ihl &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 略，暂时不关心</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> skb-&gt;dst-&gt;input(skb);</span><br><span class="line"></span><br><span class="line">drop:</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">    <span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只能从中得知我们下一步最重要的就是去处理 <code>route</code> 关系。</p>
<h3 id="选读-IP-Route"><a class="header-anchor" href="#选读-IP-Route">¶</a>[选读] IP Route</h3>
<p><code>Linux</code> 在这里进行了大量的 <code>Cache</code> 操作，我们滤过那些 Cache 的部分，读者如果愿意可以自行阅读代码。</p>
<figure class="highlight c"><figcaption><span>route.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ip_route_input_slow</span><span class="params">(struct sk_buff *skb, __be32 daddr, __be32 saddr,</span></span></span><br><span class="line"><span class="function"><span class="params">                               u8 tos, struct net_device *dev)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fib_result</span> <span class="title">res</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_device</span> *<span class="title">in_dev</span> = __<span class="title">in_dev_get_rcu</span>(<span class="title">dev</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flowi4</span> <span class="title">fl4</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> flags = <span class="number">0</span>;</span><br><span class="line">    u32 itag = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rth</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> hash;</span><br><span class="line">    __be32 spec_dst;</span><br><span class="line">    <span class="keyword">int</span> err = -EINVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">dev_net</span>(<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* IP on this device is disabled. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_dev)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多播部分的逻辑跳转</span></span><br><span class="line">    <span class="keyword">if</span> (ipv4_is_multicast(saddr) || ipv4_is_lbcast(saddr) ||</span><br><span class="line">        ipv4_is_loopback(saddr))</span><br><span class="line">        <span class="keyword">goto</span> martian_source;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广播逻辑的跳转，下略</span></span><br><span class="line">    <span class="keyword">if</span> (ipv4_is_lbcast(daddr) || (saddr == <span class="number">0</span> &amp;&amp; daddr == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">goto</span> brd_input;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ipv4_is_zeronet(saddr))</span><br><span class="line">        <span class="keyword">goto</span> martian_source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ipv4_is_zeronet(daddr) || ipv4_is_loopback(daddr))</span><br><span class="line">        <span class="keyword">goto</span> martian_destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *	我们开始处理IP协议逻辑的部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fl4.flowi4_oif = <span class="number">0</span>;</span><br><span class="line">    fl4.flowi4_iif = dev-&gt;ifindex;</span><br><span class="line">    fl4.flowi4_mark = skb-&gt;mark;</span><br><span class="line">    fl4.flowi4_tos = tos;</span><br><span class="line">    fl4.flowi4_scope = RT_SCOPE_UNIVERSE;</span><br><span class="line">    fl4.daddr = daddr;</span><br><span class="line">    fl4.saddr = saddr;</span><br><span class="line">    err = fib_lookup(net, &amp;fl4, &amp;res);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果设备不允许转发，host不可达错误</span></span><br><span class="line">        <span class="keyword">if</span> (!IN_DEV_FORWARD(in_dev))</span><br><span class="line">            <span class="keyword">goto</span> e_hostunreach;</span><br><span class="line">        <span class="keyword">goto</span> no_route;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RT_CACHE_STAT_INC(in_slow_tot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.type == RTN_BROADCAST)</span><br><span class="line">        <span class="keyword">goto</span> brd_input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local 的处理</span></span><br><span class="line">    <span class="keyword">if</span> (res.type == RTN_LOCAL) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IN_DEV_FORWARD(in_dev))</span><br><span class="line">        <span class="keyword">goto</span> e_hostunreach;</span><br><span class="line">    <span class="keyword">if</span> (res.type != RTN_UNICAST)</span><br><span class="line">        <span class="keyword">goto</span> martian_destination;</span><br><span class="line">	<span class="comment">// ip_mkroute_input 使我们的核心逻辑处</span></span><br><span class="line">    err = ip_mkroute_input(skb, &amp;res, &amp;fl4, in_dev, daddr, saddr, tos);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于路由算法部分，请参考 <a href="https://blog.csdn.net/qy532846454/article/details/6423496" target="_blank" rel="noopener">Linux内核分析 - 网络[四]：路由表</a> 这里不做展开了，最终我们将我们的 <code>skb-&gt;dst-&gt;input</code> 函数指向了 <code>int ip_local_deliver(struct sk_buff *skb)</code> 函数，因为这个数据包是需要我们本地进行处理，而不是进行转发等操作。</p>
<h3 id="IP-Deliver"><a class="header-anchor" href="#IP-Deliver">¶</a>IP Deliver</h3>
<figure class="highlight c"><figcaption><span>ip_local_deliver</span><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/net/ipv4/ip_input.c#L253" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ip_local_deliver</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 这里要重新排下 IP 的包顺序</span></span><br><span class="line">	<span class="keyword">if</span> (ip_hdr(skb)-&gt;frag_off &amp; htons(IP_MF | IP_OFFSET)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里又是熟悉的 Netfilter 的埋点，NF_INET_LOCAL_IN 阶段的回调事件</span></span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN, skb, skb-&gt;dev, <span class="literal">NULL</span>, ip_local_deliver_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终在 <code>ip_local_deliver_finish</code> 函数中</p>
<figure class="highlight c"><figcaption><span>ip_local_deliver_finish</span><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/net/ipv4/ip_input.c#L188" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ip_local_deliver_finish</span><span class="params">(struct sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">dev_net</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line">	<span class="comment">// 跳过 ip 协议的 Header 部分</span></span><br><span class="line">    __skb_pull(skb, ip_hdrlen(skb));</span><br><span class="line">	<span class="keyword">int</span> protocol = ip_hdr(skb)-&gt;protocol;</span><br><span class="line">    <span class="keyword">if</span> (ipprot != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">		<span class="comment">// 针对IP Protocol 的协议进行处理</span></span><br><span class="line">        ret = ipprot-&gt;handler(skb);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            protocol = -ret;</span><br><span class="line">            <span class="keyword">goto</span> resubmit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 IP 层之上，还有除了 <code>TCP</code> 之外其他的协议，因此这里需要针对不同的 <code>protocol</code> 调用相对应的 <code>函数</code>，这里其实就是我们的 <code>int tcp_v4_rcv(struct sk_buff *skb)</code>，再往下走就是我们熟悉的 <code>TCP</code> 层。</p>
<hr>
<h2 id="TCP-Level"><a class="header-anchor" href="#TCP-Level">¶</a>TCP Level</h2>
<p>对于我们来说，网络编程大部分的时候都在和 <code>Socket</code> 这个抽象进行斗争，<code>TCP</code> 层开始，我们就将 <code>IP</code>包组成 <code>TCP</code> 报文发送给 <code>Socket</code>了。对于 <code>socket</code> 有两种抽象：</p>
<ul>
<li><strong>struct socket</strong> 接近用户态的抽象，为用户实现 <a href="http://en.wikipedia.org/wiki/Berkeley_sockets" target="_blank" rel="noopener"><code>BSD Socket</code></a> 抽象</li>
<li><strong>struct sock</strong> 内核中表示的网络连接抽象。</li>
</ul>
<h3 id="Sock-定义"><a class="header-anchor" href="#Sock-定义">¶</a>Sock 定义</h3>
<p>对于 <code>Sock</code> 有着一个很巨大复杂的定义，我们尽量剥离出那些比较重要的。</p>
<figure class="highlight c"><figcaption><span>struct_sock</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_common</span> __<span class="title">sk_common</span>;</span></span><br><span class="line">    <span class="keyword">socket_lock_t</span> sk_lock;</span><br><span class="line">    <span class="comment">// 接受数据的队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> <span class="title">sk_receive_queue</span>;</span></span><br><span class="line">    <span class="comment">// 发送数据队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> <span class="title">sk_write_queue</span>;</span></span><br><span class="line">    <span class="comment">// 计时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">sk_timer</span>;</span></span><br><span class="line">    <span class="comment">// 对应的用户侧 socket</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sk_socket</span>;</span></span><br><span class="line">    <span class="comment">// 此 socket 的上下文数据</span></span><br><span class="line">    <span class="keyword">void</span> *sk_user_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调函数</span></span><br><span class="line">    <span class="keyword">void</span> (*sk_state_change)(struct sock *sk);</span><br><span class="line">    <span class="keyword">void</span> (*sk_data_ready)(struct sock *sk);</span><br><span class="line">    <span class="keyword">void</span> (*sk_write_space)(struct sock *sk);</span><br><span class="line">    <span class="keyword">void</span> (*sk_error_report)(struct sock *sk);</span><br><span class="line">    <span class="keyword">int</span> (*sk_backlog_rcv)(struct sock *sk, struct sk_buff *skb);</span><br><span class="line">    <span class="keyword">void</span> (*sk_destruct)(struct sock *sk);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从最简单的设计定义上，我们可以发现，对于 <code>sock</code>，我们知道我们有一个 <code>Recv</code> 的队列，和一个 <code>Send</code> 的队列，现在我们的大部分的操作都会在这两个队列进行操作。</p>
<h3 id="Sock-读取数据"><a class="header-anchor" href="#Sock-读取数据">¶</a>Sock 读取数据</h3>
<p>在 <code>sock.c</code> 中写的非常的清晰</p>
<figure class="highlight c"><figcaption><span>sock_queue_rcv_skb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sk 是待接收数据的 sock， skb 是内核接收到的数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_queue_rcv_skb</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> *<span class="title">list</span> = &amp;<span class="title">sk</span>-&gt;<span class="title">sk_receive_queue</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据积压超过 rcvbuf 限制，返回异常</span></span><br><span class="line">    <span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt;= sk-&gt;sk_rcvbuf) &#123;</span><br><span class="line">        atomic_inc(&amp;sk-&gt;sk_drops);</span><br><span class="line">        trace_sock_rcvqueue_full(sk, skb);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 Netfilter 逻辑</span></span><br><span class="line">    err = sk_filter(sk, skb);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 skb 的归属者设置下</span></span><br><span class="line">    skb-&gt;dev = <span class="literal">NULL</span>;</span><br><span class="line">    skb_set_owner_r(skb, sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据置于  receive_queue 的尾部</span></span><br><span class="line">    __skb_queue_tail(<span class="built_in">list</span>, skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何 Socket 不处于 READ 状态，就触发下 sk_data_ready 回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (!sock_flag(sk, SOCK_DEAD))</span><br><span class="line">        sk-&gt;sk_data_ready(sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sock 写入数据类似，这里不做展开。我们先暂且不考虑被我忽略的 <code>Lock</code> 的部分的逻辑。其实代码的逻辑非常的好理解，我们将受到的 bytes 数据置于队列的尾部，通知下数据就绪就可以了。</p>
<h3 id="谁负责写入队列"><a class="header-anchor" href="#谁负责写入队列">¶</a>谁负责写入队列</h3>
<h4 id="TCP-IP-模式"><a class="header-anchor" href="#TCP-IP-模式">¶</a>TCP/IP 模式</h4>
<figure class="highlight c"><figcaption><span>tcp_v4_rcv</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/net/ipv4/tcp_ipv4.c#L1695" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_rcv</span><span class="params">(struct sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">dev_net</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line">    <span class="keyword">int</span> sdif = inet_sdif(skb);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> refcounted;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得 tcp header 部分</span></span><br><span class="line">    th = (<span class="keyword">const</span> struct tcphdr *) skb-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得 ip header 部分</span></span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">lookup:  <span class="comment">// 查表获得 对应的 sock, 这里会根据 source ip / dist ip / source port / dis port 获得有个唯一的 sock</span></span><br><span class="line">    sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, __tcp_hdrlen(th), th-&gt;source,</span><br><span class="line">                           th-&gt;dest, sdif, &amp;refcounted);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有直接跳转到异常处理</span></span><br><span class="line">    <span class="keyword">if</span> (!sk)</span><br><span class="line">        <span class="keyword">goto</span> no_tcp_socket;</span><br><span class="line"></span><br><span class="line"><span class="built_in">process</span>:</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_TIME_WAIT)</span><br><span class="line">        <span class="keyword">goto</span> do_time_wait;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_NEW_SYN_RECV) &#123;</span><br><span class="line">        <span class="comment">// TCP_NEW_SYN_RECV 处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Netfilter 失败直接 discard</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_filter(sk, skb))</span><br><span class="line">        <span class="keyword">goto</span> discard_and_relse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得 tcp header 部分</span></span><br><span class="line">    th = (<span class="keyword">const</span> struct tcphdr *) skb-&gt;data;</span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用填充数据的回调</span></span><br><span class="line">    tcp_v4_fill_cb(skb, iph, th);</span><br><span class="line"></span><br><span class="line">    skb-&gt;dev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 TCP LISTEN 状态下直接进入 tcp_v4_do_rcv</span></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN) &#123;</span><br><span class="line">        ret = tcp_v4_do_rcv(sk, skb);</span><br><span class="line">        <span class="keyword">goto</span> put_and_return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bh_lock_sock_nested(sk); <span class="comment">// 先上锁</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!sock_owned_by_user(sk)) &#123; <span class="comment">// 如果在此 Sock 在内核态中 接收请求数据</span></span><br><span class="line">        ret = tcp_v4_do_rcv(sk, skb);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tcp_add_backlog(sk, skb)) &#123; <span class="comment">// 不在内核态说明在用户侧处理，将数据放置到 backlog 中</span></span><br><span class="line">        <span class="keyword">goto</span> discard_and_relse;</span><br><span class="line">    &#125;</span><br><span class="line">    bh_unlock_sock(sk); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>tcp_v4_rcv()</code> 函数来说，针对现在 <code>sock</code> 所在的不同状态进行处理我们收到的数据，逻辑也非常的容易理解。</p>
<figure class="highlight c"><figcaption><span>tcp_ipv4.c:tcp_v4_do_rcv</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_do_rcv</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">rsk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求已经建立</span></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_ESTABLISHED) &#123;</span><br><span class="line">        tcp_rcv_established(sk, skb);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是监听状态</span></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">nsk</span> = <span class="title">tcp_v4_cookie_check</span>(<span class="title">sk</span>, <span class="title">skb</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!nsk)</span><br><span class="line">            <span class="keyword">goto</span> discard;</span><br><span class="line">        <span class="keyword">if</span> (nsk != sk) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tcp_child_process(sk, nsk, skb)) &#123;</span><br><span class="line">                rsk = nsk;</span><br><span class="line">                <span class="keyword">goto</span> reset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态处理</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_rcv_state_process(sk, skb)) &#123;</span><br><span class="line">        rsk = sk;</span><br><span class="line">        <span class="keyword">goto</span> reset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从入口处我们就发现了，对于<code>Linux</code> 内核来说，根据不同的状态处理 <code>Socket</code> 就所谓的内核虚拟协议栈最重要的事情。我们来看看接受数据的的最终地，对于 <code>TCP/IP4</code> 模式，反而没有直接调用 <code>sock_queue_rcv_skb</code> 而是选择了另外一种方式，因为在此模式下，我们已经在事先检查了大量的阈值状态。</p>
<figure class="highlight c"><figcaption><span>tcp_queue_rcv</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/net/ipv4/tcp_input.c#L4631" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_queue_rcv</span><span class="params">(struct sock *sk, struct sk_buff *skb, <span class="keyword">int</span> hdrlen, <span class="keyword">bool</span> *fragstolen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eaten;</span><br><span class="line">	<span class="comment">// 获得队列尾</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">tail</span> = <span class="title">skb_peek_tail</span>(&amp;<span class="title">sk</span>-&gt;<span class="title">sk_receive_queue</span>);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 滤过 Header 部分的数据</span></span><br><span class="line">    __skb_pull(skb, hdrlen);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尝试将数据和 tail 进行合并</span></span><br><span class="line">    eaten = (tail &amp;&amp;</span><br><span class="line">             tcp_try_coalesce(sk, tail,</span><br><span class="line">                              skb, fragstolen)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//  不成功就放入 sk_receive_queue 中</span></span><br><span class="line">    <span class="keyword">if</span> (!eaten) &#123;</span><br><span class="line">        __skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);</span><br><span class="line">        skb_set_owner_r(skb, sk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eaten;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="TCP-STATE-PROCESS"><a class="header-anchor" href="#TCP-STATE-PROCESS">¶</a>TCP STATE PROCESS</h5>
<p>对 <code>TCP</code> 协议来说，本质上我们就是在维护一个有限状态的自动机，状态切换的代码在 <a href="https://elixir.bootlin.com/linux/v4.19.148/source/net/ipv4/tcp_input.c#L6017" target="_blank" rel="noopener"><code>ipv4/tcp_input.c:tcp_rcv_state_process</code></a> 函数，比较的长就不做展开，处理状态，就是如下图进行各种状态的变换。<br>
<img src="https://s3.jpg.cm/2020/09/25/JWO8G.png" alt="JWO8G.png"></p>
<h4 id="可选-RAW-模式"><a class="header-anchor" href="#可选-RAW-模式">¶</a>[可选] RAW 模式</h4>
<p>Raw也就是混杂模式，这里的实现在 <code>ipv4/raw.c</code> 中</p>
<figure class="highlight c"><figcaption><span>raw_v4_input</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">raw_v4_input</span><span class="params">(struct sk_buff *skb, <span class="keyword">const</span> struct iphdr *iph, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> delivered = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line"></span><br><span class="line">    read_lock(&amp;raw_v4_hashinfo.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 Hash 获得对应的链表</span></span><br><span class="line">    head = &amp;raw_v4_hashinfo.ht[hash];</span><br><span class="line">    <span class="keyword">if</span> (hlist_empty(head))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到这个数据从哪个网卡进来的</span></span><br><span class="line">    net = dev_net(skb-&gt;dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查表获得对应的 sock 对象, 这里直接循环了</span></span><br><span class="line">    sk = __raw_v4_lookup(net, __sk_head(head), iph-&gt;protocol,</span><br><span class="line">                         iph-&gt;saddr, iph-&gt;daddr,</span><br><span class="line">                         skb-&gt;dev-&gt;ifindex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sk) &#123;</span><br><span class="line">        delivered = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 这里处理下多播的可能，直到遍历完成就可以跳转至 out 了</span></span><br><span class="line">        <span class="keyword">if</span> ((iph-&gt;protocol != IPPROTO_ICMP || !icmp_filter(sk, skb)) &amp;&amp;</span><br><span class="line">            ip_mc_sf_allow(sk, iph-&gt;daddr, iph-&gt;saddr,</span><br><span class="line">                           skb-&gt;dev-&gt;ifindex)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">clone</span> = <span class="title">skb_clone</span>(<span class="title">skb</span>, <span class="title">GFP_ATOMIC</span>);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Not releasing hash table! */</span></span><br><span class="line">            <span class="keyword">if</span> (clone)</span><br><span class="line">                raw_rcv(sk, clone);</span><br><span class="line">        &#125;</span><br><span class="line">        sk = __raw_v4_lookup(net, sk_next(sk), iph-&gt;protocol,</span><br><span class="line">                             iph-&gt;saddr, iph-&gt;daddr,</span><br><span class="line">                             skb-&gt;dev-&gt;ifindex);</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    read_unlock(&amp;raw_v4_hashinfo.lock);</span><br><span class="line">    <span class="keyword">return</span> delivered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点是不检测 <code>目标端口</code> 只要是 IP 匹配的上就可以传递</p>
<h2 id="Linux-Networking-Stack"><a class="header-anchor" href="#Linux-Networking-Stack">¶</a>Linux Networking Stack</h2>
<p><code>Linux</code> 不仅仅的单纯的提供实现了 <code>TCP/IP</code> 协议，在历代的版本中都尝试在 <code>数据流</code> 处理的过程中增加一些额外的管控能力。ip firewall，ipchains，iptanles，nftables 都是为了让用户在处理的过程中做一些额外的工作。</p>
<h3 id="netfilter"><a class="header-anchor" href="#netfilter">¶</a>netfilter</h3>
<p><a href="https://www.netfilter.org/" target="_blank" rel="noopener">netfilter</a> 应该是最出名的项目了，从 <code>Linux 2.4.X</code> 版本开始作为内置的功能提供给运维管理员。针对 <code>Netfilter</code> 的分析比较的多，这里就不展开了，可以查阅 <a href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture" target="_blank" rel="noopener">A Deep Dive into Iptables and Netfilter Architecture</a></p>
<p>但是仍有一些不致命但是很烦人的缺点。</p>
<ul>
<li>iptables规则不支持增量配置，时间复杂度均为 <code>O(n)</code></li>
<li>基于配置化回调函数，性能不高</li>
</ul>
<h3 id="ebpf"><a class="header-anchor" href="#ebpf">¶</a>ebpf</h3>
<p><a href="https://ebpf.io/" target="_blank" rel="noopener"><code>ebpf</code></a> 是 <code>Linux</code> 社区的一个新星。为了追求性能上的提高，在内核里提供了一个虚拟机，将用户的过滤规则代码编译成<code>字节码</code>然后交付给虚拟机，内核根据这些指令来过滤网络数据包。</p>
<p><img src="https://s3.jpg.cm/2020/09/30/JkLe8.png" alt="JkLe8.png"></p>
<h4 id="基础知识"><a class="header-anchor" href="#基础知识">¶</a>基础知识</h4>
<p>要理解 <code>ebpf</code> 还需要明白 <code>bpf_map</code>， 其本质上是以「键/值」方式存储在内核中的数据结构，它们可以被任何知道它们的 BPF 程序访问。在内核空间的程序创建 BPF Map 并返回对应的文件描述符，在用户空间运行的程序就可以通过这个文件描述符来访问并操作 BPF Map，这就是为什么 BPF Map 在 BPF 世界中是桥梁的存在了。</p>
<p><img src="https://s3.jpg.cm/2020/09/30/JkGaw.png" alt="JkGaw.png"></p>
<h4 id="Example"><a class="header-anchor" href="#Example">¶</a>Example</h4>
<figure class="highlight c"><figcaption><span>sockex1_kern.c[内核态逻辑]</span><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/samples/bpf/sockex1_kern.c" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">"socket1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_prog1</span><span class="params">(struct __sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 skb 获得固定改长度的数据 -&gt; 转换成 index</span></span><br><span class="line">    <span class="keyword">int</span> index = load_byte(skb, ETH_HLEN + offsetof(</span><br><span class="line">    struct iphdr, protocol));</span><br><span class="line">    <span class="keyword">long</span> *value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;pkt_type != PACKET_OUTGOING)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从 map 中获得储存的数据</span></span><br><span class="line">    value = bpf_map_lookup_elem(&amp;my_map, &amp;index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 skb 中增加我们储存在 map 中的数据</span></span><br><span class="line">    <span class="keyword">if</span> (value)</span><br><span class="line">        __sync_fetch_and_add(value, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> _license[] SEC(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>sockex1_user.c[用户态逻辑]</span><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/samples/bpf/sockex1_user.c" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> ac, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_object</span> *<span class="title">obj</span>;</span></span><br><span class="line">    <span class="keyword">int</span> map_fd, prog_fd;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> i, sock;</span><br><span class="line">    FILE *f;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">"%s_kern.o"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将编译好内核态代码载入 bpf 模块</span></span><br><span class="line">    <span class="keyword">if</span> (bpf_prog_load(filename, BPF_PROG_TYPE_SOCKET_FILTER, &amp;obj, &amp;prog_fd))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    map_fd = bpf_object__find_map_fd_by_name(obj, <span class="string">"my_map"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个 lo 网卡的 Raw Socket</span></span><br><span class="line">    sock = open_raw_sock(<span class="string">"lo"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 Socket 设置 SO_ATTACH_BPF 标记，功能是 prog_fd，也就是我们上面刚刚载入的</span></span><br><span class="line">    assert(setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <span class="keyword">sizeof</span>(prog_fd)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 PING 操作</span></span><br><span class="line">    f = popen(<span class="string">"ping -4 -c5 localhost"</span>, <span class="string">"r"</span>);</span><br><span class="line">    (<span class="keyword">void</span>) f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tcp_cnt, udp_cnt, icmp_cnt;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line"></span><br><span class="line">        key = IPPROTO_TCP;</span><br><span class="line">        assert(bpf_map_lookup_elem(map_fd, &amp;key, &amp;tcp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        key = IPPROTO_UDP;</span><br><span class="line">        assert(bpf_map_lookup_elem(map_fd, &amp;key, &amp;udp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        key = IPPROTO_ICMP;</span><br><span class="line">        assert(bpf_map_lookup_elem(map_fd, &amp;key, &amp;icmp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"TCP %lld UDP %lld ICMP %lld bytes\n"</span>,</span><br><span class="line">               tcp_cnt, udp_cnt, icmp_cnt);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内核-Hook"><a class="header-anchor" href="#内核-Hook">¶</a>内核 Hook</h4>
<p>从例子中我们也可以很清晰的发现，核心点在于 <code>setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, sizeof(prog_fd)</code>  我们在内核中一顿操作之后就可以发现在</p>
<figure class="highlight c"><figcaption><span>sock_setsockopt</span><a href="https://elixir.bootlin.com/linux/v5.8.12/source/net/core/sock.c#L1084" target="_blank" rel="noopener">source code </a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SO_ATTACH_BPF:</span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (optlen == <span class="keyword">sizeof</span>(u32)) &#123;</span><br><span class="line">        u32 ufd;</span><br><span class="line"></span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;ufd, optval, <span class="keyword">sizeof</span>(ufd)))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        ret = sk_attach_bpf(ufd, sk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>这行代码也非常的简单，直接构建了一个全新的 <code>sk_filter</code>，然后给此 <code>sock</code> 设置即可。</p>
<figure class="highlight c"><figcaption><span>sk_filter</span><a href="https://elixir.bootlin.com/linux/v5.8.12/source/net/core/filter.c#L1421" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __sk_attach_prog(struct bpf_prog *prog, struct sock *sk) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_filter</span> *<span class="title">fp</span>, *<span class="title">old_fp</span>;</span></span><br><span class="line">    <span class="comment">// 开辟内核空间</span></span><br><span class="line">    fp = kmalloc(<span class="keyword">sizeof</span>(*fp), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!fp)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 sk_filter 程序就是我们用户编写的</span></span><br><span class="line">    fp-&gt;prog = prog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rcu 设置 fp 对象</span></span><br><span class="line">    old_fp = rcu_dereference_protected(sk-&gt;sk_filter,</span><br><span class="line">                                       lockdep_sock_is_held(sk));</span><br><span class="line">    rcu_assign_pointer(sk-&gt;sk_filter, fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而调用的地方也非常的清晰，比如说在接受数据的地方。</p>
<figure class="highlight c"><figcaption><span>sock_queue_rcv_skb</span><a href="https://elixir.bootlin.com/linux/v5.8.12/source/net/core/sock.c#L483" target="_blank" rel="noopener">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_queue_rcv_skb</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    err = sk_filter(sk, skb);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __sock_queue_rcv_skb(sk, skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实调用处</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sk_filter_trim_cap</span><span class="params">(struct sock *sk, struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上读锁</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    <span class="comment">// 获得 filter</span></span><br><span class="line">    filter = rcu_dereference(sk-&gt;sk_filter);</span><br><span class="line">    <span class="keyword">if</span> (filter) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">save_sk</span> = <span class="title">skb</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> pkt_len;</span><br><span class="line"></span><br><span class="line">        skb-&gt;sk = sk;</span><br><span class="line">        <span class="comment">// 执行回调</span></span><br><span class="line">        pkt_len = bpf_prog_run_save_cb(filter-&gt;prog, skb);</span><br><span class="line">        skb-&gt;sk = save_sk;</span><br><span class="line">        err = pkt_len ? pskb_trim(skb, <span class="built_in">max</span>(cap, pkt_len)) : -EPERM;</span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h4>
<p>对于 <code>ebpf</code> 不算是什么新的技术 <a href="http://www.tcpdump.org/papers/bpf-usenix93.pdf" target="_blank" rel="noopener">The BSD Packet Filter: A New Architecture for User-level Packet Capture</a> 发表在 <code>1992</code> 年，其核心还是基于 <code>编译器</code> 优化成特定平台的代码以提高效率，并且因为配置项都是 <code>case by case</code> 的模式，因为也不存在维护一个巨大的 <code>tables</code> 的困扰，最终再通过 <code>mmap</code> 映射的方式，将数据在内核和用户侧进行共享。</p>
<p><code>ebpf</code> 代表了内核向用户开放能力的趋势。现在能使用的点也并不少。<br>
<img src="https://s3.jpg.cm/2020/09/30/JFZpO.png" alt="JFZpO.png"></p>
<p>可以畅想下，未来可能会出现如下的功能架构</p>
<p><img src="https://s3.jpg.cm/2020/09/30/JkrhS.png" alt="JkrhS.png"></p>
<p>我们可以直接通过可编程的模式，从 <code>云端</code> 直接推送可插拔在 <code>内核</code> 中的代码逻辑。</p>
<h2 id="用户空间"><a class="header-anchor" href="#用户空间">¶</a>用户空间</h2>
<p>到上面为止，我们已经走完了所有内核部分的网络代码，下面的逻辑就是用户态的部分了。</p>
<h3 id="BIO-模型"><a class="header-anchor" href="#BIO-模型">¶</a>BIO 模型</h3>
<p>这个模型大家都熟悉，我们通过 <code>Read()</code> 来读取数据</p>
<h4 id="Example-v2"><a class="header-anchor" href="#Example-v2">¶</a>Example</h4>
<figure class="highlight c"><figcaption><span>bio</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (struct sockaddr *) &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ERROR on binding"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">listen</span>(sockfd, <span class="number">5</span>);</span><br><span class="line">    clilen = <span class="keyword">sizeof</span>(cli_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accept 一个新请求</span></span><br><span class="line">    newsockfd = accept(sockfd, (struct sockaddr *) &amp;cli_addr, &amp;clilen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newsockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ERROR on accept"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(<span class="built_in">buffer</span>, <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最多读取 255 个字节的数据</span></span><br><span class="line">    n = <span class="built_in">read</span>(newsockfd, <span class="built_in">buffer</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出错返回</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ERROR reading from socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Read"><a class="header-anchor" href="#Read">¶</a>Read</h4>
<p>读取消息的话，内部API经历的多个版本的变更，因为为了后面讲解 <code>epoll</code>，我们看比较新的 <code>4.19</code> 版本</p>
<figure class="highlight c"><figcaption><span>do_sys_recvmmsg</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/net/socket.c#L2343" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrap 下 __sys_recvmmsg 函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_sys_recvmmsg</span><span class="params">(<span class="keyword">int</span> fd, struct mmsghdr __user *mmsg,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">			   struct timespec __user *timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> datagrams;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timeout_sys</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MSG_CMSG_COMPAT)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!timeout)</span><br><span class="line">		<span class="keyword">return</span> __sys_recvmmsg(fd, mmsg, vlen, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	datagrams = __sys_recvmmsg(fd, mmsg, vlen, flags, &amp;timeout_sys);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里需要注意的就是大家常说的 零拷贝，这里我们其实需要将内核的数据 COPY 至用户态</span></span><br><span class="line">	<span class="keyword">if</span> (datagrams &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">	    copy_to_user(timeout, &amp;timeout_sys, <span class="keyword">sizeof</span>(timeout_sys)))</span><br><span class="line">		datagrams = -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> datagrams;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __sys_recvmmsg(<span class="keyword">int</span> fd, struct mmsghdr __user *mmsg, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen,</span><br><span class="line">           <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, struct timespec *timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//找到 FD 对应的 sock 对象</span></span><br><span class="line">    sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">    <span class="keyword">if</span> (!sock)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    entry = mmsg;</span><br><span class="line">    compat_entry = (struct compat_mmsghdr __user *)mmsg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ➊ loop 读取数据</span></span><br><span class="line">    <span class="keyword">while</span> (datagrams &lt; vlen) &#123; </span><br><span class="line">        err = ___sys_recvmsg(sock, (struct user_msghdr __user *)entry, &amp;msg_sys, flags &amp; ~MSG_WAITFORONE, datagrams);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        err = put_user(err, &amp;entry-&gt;msg_len);</span><br><span class="line">        ++entry;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ++datagrams;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果是 MSG_WAITFORONE 就设置 MSG_DONTWAIT */</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; MSG_WAITFORONE)</span><br><span class="line">            flags |= MSG_DONTWAIT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 无需等待的情况下就直接 Ret 了 */</span></span><br><span class="line">        <span class="keyword">if</span> (msg_sys.msg_flags &amp; MSG_OOB)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果数据没读够就 yield 掉</span></span><br><span class="line">        cond_resched();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_put;</span><br><span class="line"></span><br><span class="line">out_put:</span><br><span class="line">    fput_light(sock-&gt;file, fput_needed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> datagrams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们在配置 <code>FD</code> 的时候，如果是非阻塞的，我们哪怕获取不到数据也会立即返回，在最初的 <code>Blocking IO</code> 模式下，我们需要等待数据的获取，才能返回，因此我们会在 ➊ 处进行 LOOP，我们在 <code>cond_resched</code> 主动将自己释放出来，然后等待下次的调用。</p>
<p>我们再往下走一层，<code>Read</code> 函数的下一层则是 <code>tcp.c:tcp_recvmsg()</code></p>
<figure class="highlight c"><figcaption><span>tcp_recvmsg</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/net/ipv4/tcp.c#L1998" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	u32 offset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从 sk_receive_queue 获得想要的数据</span></span><br><span class="line">	last = skb_peek_tail(&amp;sk-&gt;sk_receive_queue);</span><br><span class="line">	skb_queue_walk(&amp;sk-&gt;sk_receive_queue, skb)</span><br><span class="line">	&#123;</span><br><span class="line">		last = skb;</span><br><span class="line"></span><br><span class="line">		offset = *seq - TCP_SKB_CB(skb)-&gt;seq;</span><br><span class="line">		<span class="keyword">if</span> (offset &lt; skb-&gt;len)</span><br><span class="line">			<span class="keyword">goto</span> found_ok_skb;</span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN)</span><br><span class="line">			<span class="keyword">goto</span> found_fin_ok;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 找到了 skb</span></span><br><span class="line">found_ok_skb:</span><br><span class="line">	<span class="comment">/* 足够需要么？ */</span></span><br><span class="line">	used = skb-&gt;len - offset;</span><br><span class="line">	<span class="keyword">if</span> (len &lt; used)</span><br><span class="line">		used = len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝数据到 MSG 也就是用户态中</span></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; MSG_TRUNC)) &#123;</span><br><span class="line">		err = skb_copy_datagram_msg(skb, offset, msg, used);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*seq += used;</span><br><span class="line">	copied += used;</span><br><span class="line">	len -= used;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理 FIN. */</span></span><br><span class="line">found_fin_ok:</span><br><span class="line">	++*seq;</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; MSG_PEEK))</span><br><span class="line">		sk_eat_skb(sk, skb);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (len &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>直到这里我们已经把握到了数据读取的命门，真实调用的就是 <code>skb_copy_datagram_msg()</code> 函数，而他所读取的恰好就是我们的 <code>sock</code> 的 <code>sk_receive_queue</code>，因此到此为止，我们已经将用户态至网卡的所有流程全面打通。</p>
<h4 id="BIO的成本"><a class="header-anchor" href="#BIO的成本">¶</a>BIO的成本</h4>
<p>在 <code>Blocking</code> 模式下，读取数据需要两方面的成本：<code>模态切换</code>和<code>线程等待</code></p>
<h5 id="模态切换"><a class="header-anchor" href="#模态切换">¶</a>模态切换</h5>
<p><code>用户态</code> 切换至 <code>内核态</code> 我们使用的 <code>Syscall</code> 模式，因此对于这一步的切换本身也是有成本的，我们需要切换<code>堆栈</code>，切换 <code>cs/ip</code> 寄存器，这一步也不是免费的，<a href="https://en.wikipedia.org/wiki/Protection_ring" target="_blank" rel="noopener">Protection ring</a></p>
<blockquote>
<p>In most existing systems, switching from user mode to kernel mode has an associated high cost in performance. It has been measured, on the basic request getpid, to cost 1000–1500 cycles on most machines. Of these just around 100 are for the actual switch (70 from user to kernel space, and 40 back), the rest is “kernel overhead”. In the L3 microkernel, the minimization of this overhead reduced the overall cost to around 150 cycles.</p>
</blockquote>
<h5 id="线程等待"><a class="header-anchor" href="#线程等待">¶</a>线程等待</h5>
<p><img src="https://s3.jpg.cm/2020/09/27/JuepH.png" alt="JuepH.png"></p>
<p>因为对于如果我们 <code>read</code> 不到数据，也就是在等待的过程中，我们就不得不去面对 <code>cond_resched()</code> 我们将自己执行的CPU时间让出来，然后等待下次的调用，这个数量和我们的 <code>socket</code> 数量成正比，尤其是我们传统的每一个 <code>socket</code> 配给一个 <code>thread</code> 进行处理的时候，我们要付出大量的线程切换时间。</p>
<h3 id="NIO-模型"><a class="header-anchor" href="#NIO-模型">¶</a>NIO 模型</h3>
<p>为了解决 <a href="#%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85">线程等待</a> 的问题，<code>Linux</code> 提供了新的编程模式 <code>epoll</code>。</p>
<h4 id="Example-v3"><a class="header-anchor" href="#Example-v3">¶</a>Example</h4>
<figure class="highlight c"><figcaption><span>epoll</span><a href="https://github.com/millken/c-example/blob/master/epoll-example.c" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    n = epoll_wait(efd, events, MAXEVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            i &lt; n;</span><br><span class="line">            i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) ||</span><br><span class="line">            (events[i].events &amp; EPOLLHUP) ||</span><br><span class="line">            (!(events[i].events &amp; EPOLLIN))) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">                    <span class="string">"epoll error\n"</span>);</span><br><span class="line">            <span class="built_in">close</span>(events[i]</span><br><span class="line">                          .data.fd);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sfd == events[i].data.fd) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                struct sockaddr in_addr;</span><br><span class="line">                <span class="keyword">socklen_t</span> in_len;</span><br><span class="line">                <span class="keyword">int</span> infd;</span><br><span class="line">                <span class="keyword">char</span> hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];</span><br><span class="line"></span><br><span class="line">                in_len = <span class="keyword">sizeof</span> in_addr;</span><br><span class="line">                infd = accept(sfd, &amp;in_addr, &amp;in_len);</span><br><span class="line">                <span class="keyword">if</span> (infd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((errno == EAGAIN) ||</span><br><span class="line">                        (errno == EWOULDBLOCK)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        perror(<span class="string">"accept"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                s = getnameinfo(&amp;in_addr, in_len,</span><br><span class="line">                                hbuf, <span class="keyword">sizeof</span> hbuf,</span><br><span class="line">                                sbuf, <span class="keyword">sizeof</span> sbuf,</span><br><span class="line">                                NI_NUMERICHOST | NI_NUMERICSERV);</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Accepted connection on descriptor %d "</span></span><br><span class="line">                           <span class="string">"(host=%s, port=%s)\n"</span>, infd, hbuf, sbuf);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                s = make_socket_non_blocking(infd);</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">                event.data.</span><br><span class="line">                        fd = infd;</span><br><span class="line">                event.</span><br><span class="line">                        events = EPOLLIN | EPOLLET;</span><br><span class="line">                s = epoll_ctl(efd, EPOLL_CTL_ADD, infd, &amp;event);</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">"epoll_ctl"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Read-数据"><a class="header-anchor" href="#Read-数据">¶</a>Read 数据</h4>
<p>对于 <code>epoll</code> 来说，没有数据就直接返回了，这块就没有什么特别，在上面的分析我们也可以看到。最重要的是如何维护 <code>events</code> 列表的</p>
<h4 id="Event"><a class="header-anchor" href="#Event">¶</a>Event</h4>
<figure class="highlight c"><figcaption><span>epoll_evnet</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/fs/eventpoll.c#L188" target="_blank" rel="noopener">source code </a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，也就是这个epoll监控的事件*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line">　　</span><br><span class="line">	<span class="comment">/* 双向链表 rdllist (rd -&gt; Ready) 保存着将要通过epoll_wait返回给用户的、满足条件的事件*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 阻塞在 sys_epoll_wait 的队列 */</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> wq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 阻塞在 file-&gt;poll() 的队列  */</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> poll_wait;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个在 RBR 元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">/* 指向用户自定义数据 */</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* 注册的文件描述符 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> u32; <span class="comment">/* 32-bit integer */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> u64; <span class="comment">/* 64-bit integer */</span></span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>
<p>执行epoll_ctl()时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。因此我们在一个 <code>evnetpoll</code> 对象上可以维护大量的 <code>socket</code> 对象，但是这样还不能足够我们完成事件通知，真正的奥秘还在 <code>rdllist</code> 就绪列表中。</p>
<h4 id="注册文件"><a class="header-anchor" href="#注册文件">¶</a>注册文件</h4>
<p><code>epoll</code> 的就绪列表是基于事件驱动的，这样的就避免了我们一直不断的 <code>轮训</code> 数据导致的 <code>CPU</code> 浪费。因此在我们对 <code>eventpoll</code> 里面增加一个 <code>fd</code>的时候代码如下：</p>
<figure class="highlight c"><figcaption><span>ep_insert</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/fs/eventpoll.c#L1455" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_insert</span><span class="params">(struct eventpoll *ep, <span class="keyword">const</span> struct epoll_event *event,</span></span></span><br><span class="line"><span class="function"><span class="params">                     struct file *tfile, <span class="keyword">int</span> fd, <span class="keyword">int</span> full_check)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 限制观察的数量 */</span></span><br><span class="line">	user_watches = atomic_long_read(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(user_watches &gt;= max_user_watches))</span><br><span class="line">		<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 初始化 poll_table */</span></span><br><span class="line">	epq.epi = epi;</span><br><span class="line">	init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* ep_ptable_queue_proc 的原型是 </span></span><br><span class="line"><span class="comment">	* typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 向这个FD注册Ready事件 */</span></span><br><span class="line">	revents = ep_item_poll(epi, &amp;epq.pt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 添加到红黑树中 */</span></span><br><span class="line">	ep_rbtree_insert(ep, epi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">	poll_queue_proc _qproc; <span class="comment">/* 回调函数 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> _key; <span class="comment">/* 监听的事件 */</span></span><br><span class="line">&#125; poll_table;</span><br></pre></td></tr></table></figure>
<p><code>ep_item_poll</code> 对应的不同的类型的 <code>poll</code> 函数不同，我们看看最常用的 <code>tcp</code></p>
<figure class="highlight c"><figcaption><span>tcp_poll</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">__poll_t</span> <span class="title">tcp_poll</span><span class="params">(struct file *file, struct socket *sock, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">__poll_t</span> mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">	<span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 核心的 Poll wait 调用</span></span><br><span class="line">	sock_poll_wait(file, sock, wait);</span><br><span class="line"></span><br><span class="line">	state = inet_sk_state_load(sk);</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又去调用了 <code>sock_poll_wait</code>，而这个函数如下</p>
<figure class="highlight c"><figcaption><span>poll_wait</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)</span><br><span class="line">		p-&gt;_qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_qproc</code> 的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 poll_table *pt)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_epqueue</span>(<span class="title">pt</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册 ep_poll_callback 为 epi，将其加入了 wait queue 中</span></span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">        init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">        pwq-&gt;whead = whead;</span><br><span class="line">        pwq-&gt;base = epi;</span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLEXCLUSIVE)</span><br><span class="line">            add_wait_queue_exclusive(whead, &amp;pwq-&gt;wait);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">        epi-&gt;nwait++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        epi-&gt;nwait = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>帮大家锊一下，到现在到底发生了什么？</p>
<div style="width:100%; overflow-y:scroll;" id="epoll_add"></div>
<script>
	var epoll_add =
	['Title: epoll_add',
	 'ep_insert->ep_pqueue: 1. 将FD包装成ep_pqueue对象',
	 'ep_insert->init_poll_funcptr: 2. 初始化 polltable',
	 'ep_insert->ep_item_poll: 3. 注册Read事件',
	 'ep_item_poll->tcp_poll: 4. 调用 tcp poll 注册等待事件',
	 'tcp_poll->poll_wait: 5. 调用初始化 polltable 的回调函数 ep_ptable_queue_proc',
	 'poll_wait->ep_ptable_queue_proc: 6. 创建 eppoll_entry，回调事件为 ep_poll_callback',
	 'ep_ptable_queue_proc->add_wait_queue: 7. 将 eppoll_entry 加入 sock->wq->wait 队列'
    ].join('\n');
  	var diagram = Diagram.parse(epoll_add);
  	diagram.drawSVG("epoll_add", {theme: 'simple', scale: 0.5});
</script>
<h4 id="callback"><a class="header-anchor" href="#callback">¶</a>callback</h4>
<figure class="highlight c"><figcaption><span>ep_poll_callback</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/fs/eventpoll.c#L1120" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_callback</span><span class="params">(<span class="keyword">wait_queue_entry_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_wait</span>(<span class="title">wait</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">epi</span>-&gt;<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 poll 函数，获得发生的事件</span></span><br><span class="line">    <span class="keyword">__poll_t</span> pollflags = key_to_poll(key);</span><br><span class="line">    <span class="keyword">int</span> ewake = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 比对是否是需要处理的事件类型 */</span></span><br><span class="line">    <span class="keyword">if</span> (pollflags &amp;&amp; !(pollflags &amp; epi-&gt;event.events))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果我们不在rdlink里面的话，我们就把自己加入进去 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ep_is_linked(epi)) &#123;</span><br><span class="line">		list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">		ep_pm_stay_awake_rcu(epi);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果有人在等待返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq)) &#123;</span><br><span class="line">        <span class="comment">// ... 一些判断逻辑</span></span><br><span class="line">        wake_up_locked(&amp;ep-&gt;wq); <span class="comment">// 唤醒epoll 中的 wq 队列</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>什么时候会 <code>Invoke</code> 这个 <code>callback</code>，还记得们这个 <code>callback</code> 实际上是在 <code>sock-&gt;wq-&gt;wait</code> 中，而在实际的逻辑中 <code>sock-&gt;wq-&gt;wait</code> 的唤醒是被我们在更早之前所看到的 <code>sock</code> 定义的那些回调函数中</p>
<figure class="highlight c"><figcaption><span>sock_callback</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/include/net/sock.h#L499" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>			(*sk_state_change)(struct sock *sk);</span><br><span class="line"><span class="keyword">void</span>			(*sk_data_ready)(struct sock *sk);</span><br><span class="line"><span class="keyword">void</span>			(*sk_write_space)(struct sock *sk);</span><br><span class="line"><span class="keyword">void</span>			(*sk_error_report)(struct sock *sk);</span><br><span class="line"><span class="keyword">int</span>			  (*sk_backlog_rcv)(struct sock *sk, struct sk_buff *skb);</span><br></pre></td></tr></table></figure>
<p>随便点开一个实现，我们都会看到熟悉的 <code>wq</code></p>
<figure class="highlight c"><figcaption><span>tipc_data_ready</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/net/tipc/socket.c#L1933" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tipc_data_ready</span><span class="params">(struct sock *sk)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span> *<span class="title">wq</span>;</span></span><br><span class="line">	wq = rcu_dereference(sk-&gt;sk_wq);</span><br><span class="line">	<span class="keyword">if</span> (skwq_has_sleeper(wq))</span><br><span class="line">		<span class="comment">// 唤醒 wq-&gt;wait 队列</span></span><br><span class="line">		wake_up_interruptible_sync_poll(&amp;wq-&gt;wait, EPOLLIN | EPOLLRDNORM | EPOLLRDBAND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ep-poll"><a class="header-anchor" href="#ep-poll">¶</a>ep_poll()</h4>
<p><code>ep_poll</code> 函数比较的简单，</p>
<figure class="highlight c"><figcaption><span>ep_poll</span><a href="https://elixir.bootlin.com/linux/v4.19.148/source/fs/eventpoll.c#L1745" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fetch_events:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有就绪事件</span></span><br><span class="line">    <span class="keyword">if</span> (!ep_events_available(ep)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 没有任何可用的事件的情况下，在这里 Sleep 掉，等别人 Wake up，</span></span><br><span class="line"><span class="comment">         * 在 ep_poll_callback 触发的时候会从这里继续执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">        __add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 该函数将当前任务设置为TASK_INTERRUPTIBLE，解锁自旋锁并告诉调度程序重新调度，</span></span><br><span class="line"><span class="comment">             * 而且还设置了内核计时器，以在指定的超时时间到期或接收到任何信号时重新调度当前进程。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (fatal_signal_pending(current)) &#123;</span><br><span class="line">                res = -EINTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有可用的事件，或者超时了</span></span><br><span class="line">            <span class="keyword">if</span> (ep_events_available(ep) || timed_out)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">                res = -EINTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            spin_unlock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">            <span class="keyword">if</span> (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))</span><br><span class="line">                timed_out = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            spin_lock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒之后继续把自己从等待队列里面移除</span></span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">        __set_current_state(TASK_RUNNING);</span><br><span class="line">    &#125;</span><br><span class="line">check_events:</span><br><span class="line">    <span class="comment">/* ep_poll()检查是否有任何要报告的就绪事件。然后释放锁 */</span></span><br><span class="line">    eavail = ep_events_available(ep);</span><br><span class="line"></span><br><span class="line">    spin_unlock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果该函数没有任何事件，并且超时尚未到期（如果该函数遇到过早的唤醒，则可能发生），</span></span><br><span class="line"><span class="comment">     * 它只是返回fetch_events 并再次等待。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">        !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)</span><br><span class="line">        <span class="keyword">goto</span> fetch_events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>Epoll</code> 的分析到此结束，<code>epoll</code> 基于 <code>rdlist</code> 来维护我们就绪的事件 <code>fd</code>，然后使用 <code>redblack tree</code> 快速检索这些 <code>fd</code>，而我认为最核心的部分还是莫过于 <code>callback</code> 机制，我们可以在收到数据之后才触发，这样减少了我们 <code>轮训</code> 的时间。</p>
<h4 id="epoll的成本"><a class="header-anchor" href="#epoll的成本">¶</a>epoll的成本</h4>
<p><code>epoll</code> 显然已经将 <code>thread blocking</code> 的成本降低至极限，因为显然我们只需要一个 <code>thread</code> 就可以完成就绪事件的扫描和处理，但是依然有几个成本无法回避 ➊ 模态切换，用户态和内核态转换 ➋ 数据拷贝，因为 <code>Read</code> 依然是需要拷贝数据从内核态到用户态。</p>
<h3 id="Zero-Copy"><a class="header-anchor" href="#Zero-Copy">¶</a>Zero Copy</h3>
<h4 id="传统读写"><a class="header-anchor" href="#传统读写">¶</a>传统读写</h4>
<p>对于 <code>Linux</code> 的读写操作，想象一下从文件中读取一些数据然后写到 <code>socket</code> 中</p>
<figure class="highlight c"><figcaption><span>read/write </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(file, tmp_buf, len);</span><br><span class="line"><span class="built_in">write</span>(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.jpg.cm/2020/09/28/JHDOi.png" alt="JHDOi.png"></p>
<p>读取数据远比想象中的复杂：</p>
<ol>
<li><code>read</code> 系统调用导致从用户模式到内核模式[<code>上下文切换</code>]。第一次复制是由<code>DMA</code>执行的，它从<strong>磁盘</strong>中读取内容并将其存储到内核地址空间缓冲区中。</li>
<li>将数据从内核缓冲区复制到用户缓冲区，然后 <code>read</code> 系统调用返回。调用的返回导致上下文从内核模式切换回用户模式。现在数据被存储在用户地址空间缓冲区中，它可以再次开始向下运行。</li>
<li>write系统调用导致从用户模式到内核模式的上下文切换。执行第三次复制，再次将数据放入内核地址空间缓冲区。但是，这一次数据被放到了一个不同的缓冲区中，这个缓冲区专门与套接字相关联。</li>
<li>write系统调用返回，创建第四个上下文切换。</li>
</ol>
<p>很明显的，我们从<code>用户态</code>向<code>内核态</code>需要拷贝一次数据，显然这次如果有一些机制可以节约下来这次开销，会更加合理一点。</p>
<h4 id="mmap-机制"><a class="header-anchor" href="#mmap-机制">¶</a>mmap 机制</h4>
<p><a href="https://en.wikipedia.org/wiki/Mmap" target="_blank" rel="noopener"><code>mmap</code></a> 提供一种对于用户态和内核态的贡献数据的方式。</p>
<figure class="highlight c"><figcaption><span>mmap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp_buf = mmap(file, len);</span><br><span class="line"><span class="built_in">write</span>(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.jpg.cm/2020/09/28/JJLdr.png" alt="JJLdr.png"></p>
<ol>
<li><code>mmap</code>系统调用导致<code>DMA</code>将文件内容复制到内核缓冲区中。然后与用户进程共享缓冲区，而不需要在内核和用户内存空间之间执行任何复制。</li>
<li><code>write</code>系统调用导致内核将数据从内核缓冲区复制到与套接字相关联的内核缓冲区中。</li>
<li><code>DMA</code>将数据从内核套接字缓冲区传递到协议引擎时发生第三次复制。</li>
</ol>
<p>通过使用 <code>mmap</code> 而非 <code>read</code>，我们减少了内核必须复制的数据量的一半。当传输大量数据时，这会产生相当好的结果。</p>
<p>基于类似于 <code>mmap</code> 的机制， <code>Linux</code> 自从 <a href="https://lwn.net/Articles/726917/" target="_blank" rel="noopener"><code>4.14</code></a>版本对 <code>Socket</code> 增加了 <code>MSG_ZEROCOPY</code> 选项，只需要执行如下代码：</p>
<figure class="highlight c"><figcaption><span>设置标记位</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_ZEROCOPY, &amp;one, <span class="keyword">sizeof</span>(one)))</span><br><span class="line">        error(<span class="number">1</span>, errno, <span class="string">"setsockopt zerocopy"</span>);</span><br></pre></td></tr></table></figure>
<p>在读取和发送的时候使用，详细可以参考 <a href="https://www.kernel.org/doc/html/v4.15/networking/msg_zerocopy.html" target="_blank" rel="noopener">内核文档: msg_zerocopy</a></p>
<figure class="highlight c"><figcaption><span>零拷贝读写操作</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = recvmsg(fd, &amp;msg, MSG_ERRQUEUE);</span><br><span class="line"></span><br><span class="line">ret = send(fd, buf, <span class="keyword">sizeof</span>(buf), MSG_ZEROCOPY);</span><br></pre></td></tr></table></figure>
<h5 id="How-it-works"><a class="header-anchor" href="#How-it-works">¶</a>How it works</h5>
<p><code>linux</code> 内核使用 <code>vm_area_struct</code> 结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个 <code>vm_area_struct</code> 结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：</p>
<p><img src="https://s3.jpg.cm/2020/09/29/JSWqf.png" alt="JSWqf.png"></p>
<p>因此从使用者角度看</p>
<ol>
<li>进程在用户空间调用库函数mmap</li>
<li>在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</li>
<li>为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化</li>
<li>将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中</li>
<li>进程的读或写操作访问虚拟地址空间，触发 <code>缺页异常</code>，内核去开辟新的物理页</li>
</ol>
<h4 id="sendfile-机制"><a class="header-anchor" href="#sendfile-机制">¶</a>sendfile 机制</h4>
<figure class="highlight c"><figcaption><span>sendfile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendfile（socket，file，len）;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.jpg.cm/2020/09/28/JJPr5.png" alt="JJPr5.png"></p>
<ol>
<li><code>sendfile</code> 系统调用使 <code>DMA</code> 将文件内容复制到内核缓冲区中。</li>
<li>没有数据复制到套接字缓冲区中。将具有有关数据的地址和长度信息附加到套接字缓冲区。</li>
</ol>
<p>这个可以说是真正的 <code>Zero COPY</code> 技术了。不过缺点也很明显，只能用在 <code>FD</code> 之上，对于大部分时候我们需要处理的是 <code>Byte[]</code> 对于内存的数据，这样的函数接口显然不是那么好用。</p>
<hr>
<p>除此之外：<a href="https://tldp.org/HOWTO/SCSI-Generic-HOWTO/dio.html" target="_blank" rel="noopener">Direct I/O</a>  <a href="https://man7.org/linux/man-pages/man7/aio.7.html" target="_blank" rel="noopener">Asynchronous direct I/O</a> 都是优化 <code>IO</code> 的操作，对于网络请求一般不使用这些模式，大家可以自行阅读。</p>
<p>不过 <code>Zero Copy</code> 不一定有大家想象中的有效，在 <a href="https://lwn.net/Articles/726917/" target="_blank" rel="noopener">Zero-copy networking</a> 有详细的描述。</p>
<blockquote>
<p>As was noted in the introduction, the benefits from zero-copy operation are often less than one might hope. Copying is expensive, but the setup required to avoid a copy operation also has its costs. In this case, the author claims that a simple benchmark (<a href="https://github.com/HewlettPackard/netperf" target="_blank" rel="noopener">netperf</a> blasting out data) runs 39% faster, while a more realistic production workload sees a 5-8% improvement. So the benefit for real-world systems is not huge, but it may well be enough to be worth going for on highly-loaded systems that transmit a lot of data.</p>
</blockquote>
<p>不过从提交 <code>PR</code> 的作者的测试结果看还是不错的。</p>
<p>传输 10G 的流量，前三列是 <code>netperf</code> 进程的耗费的时钟周期，后三列是 <code>系统级</code> 的时钟周期。 <code>std</code> 是标准的读写， <code>zc</code> 代表零拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        --process cycles--      ----cpu cycles----</span><br><span class="line">           std      zc   %      std         zc   %</span><br><span class="line">4K      27,609  11,217  41      49,217  39,175  79</span><br><span class="line">16K     21,370   3,823  18      43,540  29,213  67</span><br><span class="line">64K     20,557   2,312  11      42,189  26,910  64</span><br><span class="line">256K    21,110   2,134  10      43,006  27,104  63</span><br><span class="line">1M      20,987   1,610   8      42,759  25,931  61</span><br></pre></td></tr></table></figure>
<h3 id="io-uring"><a class="header-anchor" href="#io-uring">¶</a>io_uring</h3>
<p>我们使用 <code>zero copy</code> 技术将我们数据拷贝减少至极致，但是我们依然涉及到 <code>模块切换</code>，在 <code>内核态</code> 和 <code>用户态</code> 之间切换也不是免费的，因此制约我们这个特性又应该怎么解决呢？在 <code>Kernel</code> 解决这个之前，社区提出了一个很出名的解决之道 <a href="https://www.dpdk.org/" target="_blank" rel="noopener"><code>dpdk</code></a> 提出了 <code>UIO</code> 的概念。</p>
<p><img src="https://s3.jpg.cm/2020/09/28/JtdzO.png" alt="JtdzO.png"></p>
<p>因此 <code>Linux 5.1</code> 参考了 <code>DPDK</code> 的实现，提出了 <a href="https://lwn.net/Articles/776703/" target="_blank" rel="noopener"><code>io_uring</code></a> 的方案，<a href="https://kernel.dk/io_uring.pdf" target="_blank" rel="noopener">白皮书</a></p>
<h4 id="Example-v4"><a class="header-anchor" href="#Example-v4">¶</a>Example</h4>
<figure class="highlight c"><figcaption><span>io_uring</span><a href="https://raw.githubusercontent.com/frevib/io_uring-echo-server/master/io_uring_echo_server.c" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CONNECTIONS     4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BACKLOG             512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_MESSAGE_LEN     2048</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFERS_COUNT       MAX_CONNECTIONS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_accept</span><span class="params">(struct io_uring *ring, <span class="keyword">int</span> fd, struct sockaddr *client_addr, <span class="keyword">socklen_t</span> *client_len, <span class="keyword">unsigned</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_socket_read</span><span class="params">(struct io_uring *ring, <span class="keyword">int</span> fd, <span class="keyword">unsigned</span> gid, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">unsigned</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_socket_write</span><span class="params">(struct io_uring *ring, <span class="keyword">int</span> fd, __u16 bid, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">unsigned</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_provide_buf</span><span class="params">(struct io_uring *ring, __u16 bid, <span class="keyword">unsigned</span> gid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    ACCEPT,</span><br><span class="line">    READ,</span><br><span class="line">    WRITE,</span><br><span class="line">    PROV_BUF,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">conn_info</span> &#123;</span></span><br><span class="line">    __u32 fd;</span><br><span class="line">    __u16 type;</span><br><span class="line">    __u16 bid;</span><br><span class="line">&#125; conn_info;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bufs[BUFFERS_COUNT][MAX_MESSAGE_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> group_id = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> portno = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始 listen socket</span></span><br><span class="line">    <span class="keyword">int</span> sock_listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sock_listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;val, <span class="keyword">sizeof</span>(val));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">if</span> (bind(sock_listen_fd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Error binding socket...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(sock_listen_fd, BACKLOG) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Error listening on socket...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"io_uring echo server listening for connections on port: %d\n"</span>, portno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 io_uring</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">params</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;params, <span class="number">0</span>, <span class="keyword">sizeof</span>(params));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (io_uring_queue_init_params(<span class="number">2048</span>, &amp;ring, &amp;params) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"io_uring_init_failed...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 SQE 和 CQE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 accept SQE 监视新连接</span></span><br><span class="line">    add_accept(&amp;ring, sock_listen_fd, (struct sockaddr *)&amp;client_addr, &amp;client_len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待事件的发生</span></span><br><span class="line">        io_uring_submit_and_wait(&amp;ring, <span class="number">1</span>); </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> head;</span><br><span class="line">        <span class="keyword">unsigned</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 CQE</span></span><br><span class="line">        io_uring_for_each_cqe(&amp;ring, head, cqe) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">conn_info</span> <span class="title">conn_i</span>;</span></span><br><span class="line">            <span class="built_in">memcpy</span>(&amp;conn_i, &amp;cqe-&gt;user_data, <span class="keyword">sizeof</span>(conn_i));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> type = conn_i.type;</span><br><span class="line">            <span class="keyword">if</span> (type == ACCEPT) &#123;</span><br><span class="line">                <span class="keyword">int</span> sock_conn_fd = cqe-&gt;res;</span><br><span class="line">                <span class="comment">// 为建立的连接增加 read 监听</span></span><br><span class="line">                <span class="keyword">if</span> (sock_conn_fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    add_socket_read(&amp;ring, sock_conn_fd, group_id, MAX_MESSAGE_LEN, IOSQE_BUFFER_SELECT);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 继续监听</span></span><br><span class="line">                add_accept(&amp;ring, sock_listen_fd, (struct sockaddr *)&amp;client_addr, &amp;client_len, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == READ) &#123;</span><br><span class="line">                <span class="keyword">int</span> bytes_read = cqe-&gt;res;</span><br><span class="line">                <span class="comment">// 这里可以读取数据</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        io_uring_cq_advance(&amp;ring, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_accept</span><span class="params">(struct io_uring *ring, <span class="keyword">int</span> fd, struct sockaddr *client_addr, <span class="keyword">socklen_t</span> *client_len, <span class="keyword">unsigned</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> = <span class="title">io_uring_get_sqe</span>(<span class="title">ring</span>);</span></span><br><span class="line">    io_uring_prep_accept(sqe, fd, client_addr, client_len, <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_flags(sqe, flags);</span><br><span class="line"></span><br><span class="line">    conn_info conn_i = &#123;</span><br><span class="line">        .fd = fd,</span><br><span class="line">        .type = ACCEPT,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sqe-&gt;user_data, &amp;conn_i, <span class="keyword">sizeof</span>(conn_i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_socket_read</span><span class="params">(struct io_uring *ring, <span class="keyword">int</span> fd, <span class="keyword">unsigned</span> gid, <span class="keyword">size_t</span> message_size, <span class="keyword">unsigned</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> = <span class="title">io_uring_get_sqe</span>(<span class="title">ring</span>);</span></span><br><span class="line">    io_uring_prep_recv(sqe, fd, <span class="literal">NULL</span>, message_size, <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_flags(sqe, flags);</span><br><span class="line">    sqe-&gt;buf_group = gid;</span><br><span class="line"></span><br><span class="line">    conn_info conn_i = &#123;</span><br><span class="line">        .fd = fd,</span><br><span class="line">        .type = READ,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sqe-&gt;user_data, &amp;conn_i, <span class="keyword">sizeof</span>(conn_i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="How-it-works-v2"><a class="header-anchor" href="#How-it-works-v2">¶</a>How it works</h4>
<p><code>Linux</code> 只增加了 3 个 <code>syscall</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">no         syscall</span><br><span class="line">425        io_uring_setup</span><br><span class="line">426        io_uring_enter</span><br><span class="line">427        io_uring_register</span><br></pre></td></tr></table></figure>
<h5 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h5>
<p>并没有常见的 <code>read</code> 和 <code>write</code>，因为现在的这两步可以在用户态进行了（这不废话，我们就是要解决模态切换的问题）。为了实现用户态和内核态通讯，<code>io_uring</code> 提供了2个队列：提交队列（submission queue）和完成队列（completion queue）</p>
<p>定义如下</p>
<figure class="highlight c"><figcaption><span>io_uring.h</span><a href="https://elixir.bootlin.com/linux/v5.8.11/source/include/uapi/linux/io_uring.h#L230" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> &#123;</span></span><br><span class="line">	__u32 sq_entries;</span><br><span class="line">	__u32 cq_entries;</span><br><span class="line">	__u32 flags;</span><br><span class="line">	__u32 sq_thread_cpu;</span><br><span class="line">	__u32 sq_thread_idle;</span><br><span class="line">	__u32 features;</span><br><span class="line">	__u32 wq_fd;</span><br><span class="line">	__u32 resv[<span class="number">3</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_sqring_offsets</span> <span class="title">sq_off</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_cqring_offsets</span> <span class="title">cq_off</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_sqring_offsets</span> &#123;</span></span><br><span class="line">	__u32 head; <span class="comment">/* head offset */</span></span><br><span class="line">	__u32 tail; <span class="comment">/* tail offset */</span></span><br><span class="line">	__u32 ring_mask;</span><br><span class="line">	__u32 ring_entries;</span><br><span class="line">	__u32 flags;</span><br><span class="line">	__u32 dropped;</span><br><span class="line">	__u32 <span class="built_in">array</span>;</span><br><span class="line">	__u32 resv1;</span><br><span class="line">	__u64 resv2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_cqring_offsets</span> &#123;</span></span><br><span class="line">	__u32 head;</span><br><span class="line">	__u32 tail;</span><br><span class="line">	__u32 ring_mask;</span><br><span class="line">	__u32 ring_entries;</span><br><span class="line">	__u32 <span class="built_in">overflow</span>;</span><br><span class="line">	__u32 cqes;</span><br><span class="line">	__u32 flags;</span><br><span class="line">	__u32 resv1;</span><br><span class="line">	__u64 resv2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> &#123;</span></span><br><span class="line">	__u64	user_data;	<span class="comment">/* sqe-&gt;data submission passed back */</span></span><br><span class="line">	__s32	res;		<span class="comment">/* result code for this event */</span></span><br><span class="line">	__u32	flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.jpg.cm/2020/09/28/JtFjD.png" alt="JtFjD.png"></p>
<p><code>SQ</code>，<code>CQ</code>，<code>SQEs</code> 是在内核中分配的，所以用户态程序并不能直接访问。<code>io_setup</code> 的返回值是一个 <code>fd</code>，应用程序使用这个 <code>fd</code> 进行 mmap，和 <code>kernel</code> 共享一块内存。</p>
<h5 id="IO-submit"><a class="header-anchor" href="#IO-submit">¶</a>IO submit</h5>
<p>IO 提交的做法是找到一个空闲的 SQE，根据请求设置 SQE，并将这个 SQE 的索引放到 SQ 中。SQ 是一个典型的 RingBuffer，有 head，tail 两个成员，如果 head == tail，意味着队列为空。SQE 设置完成后，需要修改 SQ 的 tail，以表示向 RingBuffer 中插入一个请求。当所有请求都加入 SQ 后，就可以使用 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_uring_enter</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, u32 to_submit, u32 min_complete, u32 flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>不过这样还是会涉及到 <code>模态切换</code>，因此还提供了另外一个模式。</p>
<h5 id="offload-模式"><a class="header-anchor" href="#offload-模式">¶</a>offload 模式</h5>
<p>调用 <code>io_uring_setup</code> 时设置了 <code>IORING_SETUP_SQPOLL</code> 的 flag，内核会额外启动一个内核线程，我们称作 <code>SQ</code> 线程。</p>
<p><img src="https://s3.jpg.cm/2020/09/28/Jtm5p.png" alt="Jtm5p.png"></p>
<h5 id="IO-Completion"><a class="header-anchor" href="#IO-Completion">¶</a>IO Completion</h5>
<p>当 <code>IO</code> 完成时，内核负责将完成 <code>IO</code> 在 <code>SQEs</code> 中的 <code>index</code> 放到 <code>CQ</code> 中。由于 <code>IO</code> 在提交的时候可以顺便返回完成的 <code>IO</code>，所以收割 <code>IO</code> 不需要额外系统调用。这是跟 <code>libaio</code> 比较大的不同，省去了一次系统调用。</p>
<h2 id="框架层"><a class="header-anchor" href="#框架层">¶</a>框架层</h2>
<p>在 <code>OS</code> 上提供的 <code>epoll</code> <code>io_uring</code> 的情况下，在应用层如何高效的使用也是一个相对复杂的问题。不过在这层上来说，我们更需要的是配合 <code>编程语言</code> 的并发模式提供一种高效的编程框架。</p>
<h3 id="Thread-编程模型：Netty-Reactor"><a class="header-anchor" href="#Thread-编程模型：Netty-Reactor">¶</a>Thread 编程模型：Netty &amp; Reactor</h3>
<p><code>epoll</code> 也不算是一个新东西，业界也整理出一套比较高效的 <code>框架模型</code>，常用的高性能 IO 模型 <code>Reactor</code>。</p>
<p><img src="https://s3.jpg.cm/2020/09/28/Jtv0T.png" alt="Jtv0T.png"></p>
<p><code>Netty</code> 抽象的 <code>Acceptor</code> 作为接受者，对应的线程是 <code>bossGroup</code>，从图上看好像是单个的，但是并不是 <code>Acceptor</code> 也可以有多个线程，<code>Dispatch</code> 将接收到的请求分发到 <code>workGroup</code> 的线程组进行繁重的读写工作。</p>
<p>对于读写操作，提供了 <code>pipeline</code> 的机制<br>
<img src="https://s3.jpg.cm/2020/09/28/Jt4bQ.png" alt="Jt4bQ.png"></p>
<h3 id="Goroutines：netpoller"><a class="header-anchor" href="#Goroutines：netpoller">¶</a>Goroutines：netpoller</h3>
<p><code>go</code> 语言提供一套将  <code>异步io</code> 转化为 <code>同步io</code> 的机制，这样对于开发者来说会更加的轻松，得益于 <code>goroutine</code> 并不会带来不可承担的成本。</p>
<p><code>go</code> 会初始化一个全局的 <code>netpoll</code>，在 <code>linux</code> 的实现是创建一个 <code>epfd</code></p>
<figure class="highlight go"><figcaption><span>netpollinit</span><a href="https://go.googlesource.com/go/+/refs/tags/go1.14.9/src/runtime/netpoll_epoll.go#27" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	epfd <span class="keyword">int32</span> = <span class="number">-1</span></span><br><span class="line">	netpollBreakRd, netpollBreakWr <span class="keyword">uintptr</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	epfd = epollcreate1(_EPOLL_CLOEXEC)</span><br><span class="line">	r, w, _ := nonblockingPipe()</span><br><span class="line">	ev := epollevent&#123;</span><br><span class="line">		events: _EPOLLIN,</span><br><span class="line">	&#125;</span><br><span class="line">	*(**<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) = &amp;netpollBreakRd</span><br><span class="line">	epollctl(epfd, _EPOLL_CTL_ADD, r, &amp;ev)</span><br><span class="line">	netpollBreakRd = <span class="keyword">uintptr</span>(r)</span><br><span class="line">	netpollBreakWr = <span class="keyword">uintptr</span>(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们打开一个 <code>file</code> 的时候，就会向 <code>epoll</code> 注册事件</p>
<figure class="highlight go"><figcaption><span>netpollopen</span><a href="https://go.googlesource.com/go/+/refs/tags/go1.14.9/src/runtime/netpoll_epoll.go#59" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="keyword">uintptr</span>, pd *pollDesc)</span> <span class="title">int32</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ev epollevent</span><br><span class="line">	ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class="line">	*(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class="line">	<span class="keyword">return</span> -epollctl(epfd, _EPOLL_CTL_ADD, <span class="keyword">int32</span>(fd), &amp;ev) <span class="comment">// 注册关注事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在文件描述符上执行读写操作时，如果文件描述符不可读或者不可写，当前 Goroutine 就会执行 <code>runtime.poll_runtime_pollWait</code> 检查 <code>runtime.pollDesc</code> 的状态并调用 <code>runtime.netpollblock</code> 等待文件描述符的可读或者可写</p>
<figure class="highlight go"><figcaption><span>netpollblock</span><a href="https://go.googlesource.com/go/+/refs/tags/go1.14.9/src/runtime/netpoll.go#394" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="keyword">int32</span>, waitio <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	gpp := &amp;pd.rg</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">'w'</span> &#123;</span><br><span class="line">		gpp = &amp;pd.wg</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让出执行的线程，将 Goroutine 转换到休眠状态并等待运行时的唤醒</span></span><br><span class="line">		gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, <span class="number">5</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唤醒操作也很简单</p>
<figure class="highlight go"><figcaption><span>netpollready</span><a href="https://go.googlesource.com/go/+/refs/tags/go1.14.9/src/runtime/netpoll.go#344" target="_blank" rel="noopener">source code</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollready</span><span class="params">(toRun *gList, pd *pollDesc, mode <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rg, wg *g</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">'w'</span> || mode == <span class="string">'r'</span>+<span class="string">'w'</span> &#123;</span><br><span class="line">        <span class="comment">// 将可以唤醒的 Goroutine 重新置为可运行</span></span><br><span class="line">		wg = netpollunblock(pd, <span class="string">'w'</span>, <span class="literal">true</span>) </span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">		toRun.push(wg)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div>
    <label class="author-mark-label">小声比比</label>
    <p class="author-mark">Go 的大道至简，的确很香。</p>
</div>
<h2 id="小结-v2"><a class="header-anchor" href="#小结-v2">¶</a>小结</h2>
<p>大概前前后后写了半个月才将本文写完，也没有预计到可以写这么多，试图帮助大家从 <code>硬件</code> 到 <code>框架</code> 整理出一套体系，但是为了达成高性能的 <code>Web Server</code>，除了我们本文提到了 <code>OS</code> 的一些优化，还有很多在框架层面上可以优化的地方。<code>连接池</code> <code>Fast Path算法</code> <code>缓存</code> 等等。</p>
<hr>
<p>希望大家在网络的世界里面玩的开心 ;)</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://linux-kernel-labs.github.io/refs/heads/master" target="_blank" rel="noopener">The Linux Kernel Labs</a></li>
<li><a href="https://tldp.org/LDP/LG/issue93/bhaskaran.html" target="_blank" rel="noopener">Writing a Network device driver</a></li>
<li><a href="https://linuxgazette.net/156/jangir.html" target="_blank" rel="noopener">Writing Network Device Drivers for Linux</a></li>
<li><a href="https://www.kernel.org/doc/htmldocs/networking" target="_blank" rel="noopener">kernel</a></li>
<li><a href="https://www.cnblogs.com/CasonChan/p/5166250.html" target="_blank" rel="noopener">网络数据包收发流程(四)：协议栈之packet_type</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/80513852" target="_blank" rel="noopener">软中断会吃掉你多少CPU？</a></li>
<li><a href="https://courses.engr.illinois.edu/cs423/sp2014/Lectures/LinuxDriver.pdf" target="_blank" rel="noopener">Understanding Linux Network Device Driver and NAPI</a></li>
<li><a href="https://lwn.net/Articles/244640/" target="_blank" rel="noopener">Newer, newer NAPI</a></li>
<li><a href="https://tldp.org/LDP/tlk/net/net.html" target="_blank" rel="noopener">Networks</a></li>
<li><a href="https://www.cnblogs.com/super-king/p/3296091.html" target="_blank" rel="noopener">Linux IP 路由实现</a></li>
<li><a href="https://www.zhihu.com/question/35004859" target="_blank" rel="noopener">cond_resched()之后，后面的代码什么时候才被再次调度回来执行？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/62682475" target="_blank" rel="noopener">AIO 的新归宿：io_uring</a></li>
<li><a href="https://draveness.me/golang-netpoller/" target="_blank" rel="noopener">Go 语言设计与实现</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    
    
    
      
  <div class="popular-posts-header">推荐阅读</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2019/03/07/kubernetes/how-kubernetes-network-0/" rel="bookmark">Kubernetes-网络原理(0) - 网络知识预备</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2019/03/17/kubernetes/how-kubernetes-network-1/" rel="bookmark">Kubernetes-Calico-网络原理(1) - 环境预备 & 初窥网络</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2019/03/17/kubernetes/how-kubernetes-network-2/" rel="bookmark">Kubernetes-Calico-网络原理(2) - Container & Pod</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2019/03/20/kubernetes/how-kubernetes-network-3/" rel="bookmark">Kubernetes-Calico-网络原理(3) - Pod & Node</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2019/03/21/kubernetes/how-kubernetes-network-4/" rel="bookmark">Kubernetes-Calico-网络原理(4) - BGP</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div>来杯奶茶, 嗝~~~</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wxpay.jpg" alt="Yanick.xia 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay-2.jpg" alt="Yanick.xia 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/network/" rel="tag"># network</a>
              <a href="/tags/linux/" rel="tag"># linux</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/23/apm/apm/" rel="prev" title="APM 杂谈">
      <i class="fa fa-chevron-left"></i> APM 杂谈
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/30/networking/tcp-ip/build-tcp/" rel="next" title="自己动手实现 TCP 协议 [WIP]">
      自己动手实现 TCP 协议 [WIP] <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-changyan">ChangYan</a></li>
            <li class="tab"><a href="#comment-livere">LiveRe</a></li>
            <li class="tab"><a href="#comment-disqus">Disqus</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane changyan" id="comment-changyan">
              
  <div class="comments">
    <div id="SOHUCS"></div>
  </div>
  
            </div>
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMjYxNi85MTc3"></div>
  </div>
  
            </div>
            <div class="tab-pane disqus" id="comment-disqus">
              
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#修订记录"><span class="nav-number">1.</span> <span class="nav-text">修订记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基础概念"><span class="nav-number">2.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-分层"><span class="nav-number">2.1.</span> <span class="nav-text">Linux 分层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SMP"><span class="nav-number">2.2.</span> <span class="nav-text">SMP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">2.3.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mmio"><span class="nav-number">2.4.</span> <span class="nav-text">mmio</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Network-Packet-Travel"><span class="nav-number">3.</span> <span class="nav-text">Network Packet Travel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Network-Driver"><span class="nav-number">4.</span> <span class="nav-text">Network Driver</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设备数据结构定义：net-device"><span class="nav-number">4.1.</span> <span class="nav-text">设备数据结构定义：net_device</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网卡数据的读取"><span class="nav-number">4.2.</span> <span class="nav-text">网卡数据的读取</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#硬中断部分"><span class="nav-number">4.2.1.</span> <span class="nav-text">硬中断部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选读-硬中断成本"><span class="nav-number">4.2.2.</span> <span class="nav-text">[选读] 硬中断成本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#软中断部分"><span class="nav-number">4.2.3.</span> <span class="nav-text">软中断部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选读-Packet-Type-钩子"><span class="nav-number">4.2.4.</span> <span class="nav-text">[选读] Packet Type 钩子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TCPDUMP"><span class="nav-number">4.2.4.1.</span> <span class="nav-text">TCPDUMP</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选读-软断成本"><span class="nav-number">4.2.5.</span> <span class="nav-text">[选读] 软断成本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NAPI"><span class="nav-number">4.2.6.</span> <span class="nav-text">NAPI</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#NAPI-定义"><span class="nav-number">4.2.6.1.</span> <span class="nav-text">NAPI 定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NAPI-之下的硬中断处理"><span class="nav-number">4.2.6.2.</span> <span class="nav-text">NAPI 之下的硬中断处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#软中断唤醒"><span class="nav-number">4.2.6.3.</span> <span class="nav-text">软中断唤醒</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP-Level"><span class="nav-number">5.</span> <span class="nav-text">IP Level</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#选读-IP-Route"><span class="nav-number">5.1.</span> <span class="nav-text">[选读] IP Route</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP-Deliver"><span class="nav-number">5.2.</span> <span class="nav-text">IP Deliver</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-Level"><span class="nav-number">6.</span> <span class="nav-text">TCP Level</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sock-定义"><span class="nav-number">6.1.</span> <span class="nav-text">Sock 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sock-读取数据"><span class="nav-number">6.2.</span> <span class="nav-text">Sock 读取数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#谁负责写入队列"><span class="nav-number">6.3.</span> <span class="nav-text">谁负责写入队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-IP-模式"><span class="nav-number">6.3.1.</span> <span class="nav-text">TCP&#x2F;IP 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP-STATE-PROCESS"><span class="nav-number">6.3.1.1.</span> <span class="nav-text">TCP STATE PROCESS</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可选-RAW-模式"><span class="nav-number">6.3.2.</span> <span class="nav-text">[可选] RAW 模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-Networking-Stack"><span class="nav-number">7.</span> <span class="nav-text">Linux Networking Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#netfilter"><span class="nav-number">7.1.</span> <span class="nav-text">netfilter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ebpf"><span class="nav-number">7.2.</span> <span class="nav-text">ebpf</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础知识"><span class="nav-number">7.2.1.</span> <span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example"><span class="nav-number">7.2.2.</span> <span class="nav-text">Example</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内核-Hook"><span class="nav-number">7.2.3.</span> <span class="nav-text">内核 Hook</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">7.2.4.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户空间"><span class="nav-number">8.</span> <span class="nav-text">用户空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO-模型"><span class="nav-number">8.1.</span> <span class="nav-text">BIO 模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-v2"><span class="nav-number">8.1.1.</span> <span class="nav-text">Example</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Read"><span class="nav-number">8.1.2.</span> <span class="nav-text">Read</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BIO的成本"><span class="nav-number">8.1.3.</span> <span class="nav-text">BIO的成本</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#模态切换"><span class="nav-number">8.1.3.1.</span> <span class="nav-text">模态切换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程等待"><span class="nav-number">8.1.3.2.</span> <span class="nav-text">线程等待</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO-模型"><span class="nav-number">8.2.</span> <span class="nav-text">NIO 模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-v3"><span class="nav-number">8.2.1.</span> <span class="nav-text">Example</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Read-数据"><span class="nav-number">8.2.2.</span> <span class="nav-text">Read 数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Event"><span class="nav-number">8.2.3.</span> <span class="nav-text">Event</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注册文件"><span class="nav-number">8.2.4.</span> <span class="nav-text">注册文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#callback"><span class="nav-number">8.2.5.</span> <span class="nav-text">callback</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ep-poll"><span class="nav-number">8.2.6.</span> <span class="nav-text">ep_poll()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll的成本"><span class="nav-number">8.2.7.</span> <span class="nav-text">epoll的成本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zero-Copy"><span class="nav-number">8.3.</span> <span class="nav-text">Zero Copy</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#传统读写"><span class="nav-number">8.3.1.</span> <span class="nav-text">传统读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap-机制"><span class="nav-number">8.3.2.</span> <span class="nav-text">mmap 机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#How-it-works"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">How it works</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sendfile-机制"><span class="nav-number">8.3.3.</span> <span class="nav-text">sendfile 机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io-uring"><span class="nav-number">8.4.</span> <span class="nav-text">io_uring</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-v4"><span class="nav-number">8.4.1.</span> <span class="nav-text">Example</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-it-works-v2"><span class="nav-number">8.4.2.</span> <span class="nav-text">How it works</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数据结构"><span class="nav-number">8.4.2.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IO-submit"><span class="nav-number">8.4.2.2.</span> <span class="nav-text">IO submit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#offload-模式"><span class="nav-number">8.4.2.3.</span> <span class="nav-text">offload 模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IO-Completion"><span class="nav-number">8.4.2.4.</span> <span class="nav-text">IO Completion</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#框架层"><span class="nav-number">9.</span> <span class="nav-text">框架层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-编程模型：Netty-Reactor"><span class="nav-number">9.1.</span> <span class="nav-text">Thread 编程模型：Netty &amp; Reactor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Goroutines：netpoller"><span class="nav-number">9.2.</span> <span class="nav-text">Goroutines：netpoller</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结-v2"><span class="nav-number">10.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">11.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yanick.xia</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">84</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element">
    <a onclick="Chatra('openChat', true);"><i class="comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:yanick.xia@qq.com" title="Mail → mailto:yanick.xia@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/yanickxia" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yanickxia" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/yann.xia" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yann.xia" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i>知乎</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fas fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://sakeven.me/" title="https:&#x2F;&#x2F;sakeven.me&#x2F;" rel="noopener" target="_blank">Sakeven</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://reficul.io/" title="https:&#x2F;&#x2F;reficul.io&#x2F;" rel="noopener" target="_blank">Reficul</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.tomwei7.com/" title="https:&#x2F;&#x2F;www.tomwei7.com&#x2F;" rel="noopener" target="_blank">Tomwei</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.jinwei.me/" title="https:&#x2F;&#x2F;blog.jinwei.me" rel="noopener" target="_blank">Jinwei</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://renlulu.github.io/" title="https:&#x2F;&#x2F;renlulu.github.io&#x2F;" rel="noopener" target="_blank">Renlulu</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://justjjy.com/" title="http:&#x2F;&#x2F;justjjy.com&#x2F;" rel="noopener" target="_blank">JJY</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://zhyee.top/" title="http:&#x2F;&#x2F;zhyee.top" rel="noopener" target="_blank">Zhyee</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://blog.ihypo.net/" title="http:&#x2F;&#x2F;blog.ihypo.net" rel="noopener" target="_blank">Hypo</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://blog.heytaoge.com/" title="http:&#x2F;&#x2F;blog.heytaoge.com&#x2F;" rel="noopener" target="_blank">Taoge</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.hdls.me/" title="https:&#x2F;&#x2F;blog.hdls.me&#x2F;" rel="noopener" target="_blank">海的澜色</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://farer.org/" title="https:&#x2F;&#x2F;farer.org&#x2F;" rel="noopener" target="_blank">Windfarer</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.41tair.org/" title="https:&#x2F;&#x2F;blog.41tair.org&#x2F;" rel="noopener" target="_blank">Byron</a>
        </li>
    </ul>
  </div>
<div class="sidebar-inner">
    
    <div id="hitokoto">:D 获取中...</div>
    <i id="hitofrom">:D 获取中...</i>

    <script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script>
    <script>
    fetch('https://v1.hitokoto.cn/?c=k&c=i&c=d&c=l')
        .then(function (res){
            return res.json();
        })
        .then(function (data) {
            var hitokoto = document.getElementById('hitokoto');
            hitokoto.innerText = '\xa0\xa0\xa0\xa0\xa0\xa0\xa0' + data.hitokoto;
            var hitofrom = document.getElementById('hitofrom');
            hitofrom.innerText = "——" + data.from + '\xa0'; 
        })
        .catch(function (err) {
            console.error(err);
        })
    </script>
</div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备15036539号-2 </a>
  </div>

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="yanick"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yanick.Xia</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><p>本网站由<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank" rel="noopener"><img src="images/upyun_logos/logo2.png" style="display: inline; height: 15px"></a>提供CDN加速/云存储服务</p>
<!--- 
<p>Hosted by <a href="https://pages.coding.me" target="_blank" rel="noopener" style="font-weight: bold">Coding Pages</a></p>
--->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"KPHj3vsvOqeV377r9yw1DdLl-gzGzoHsz","app_key":"wGzWlWVU3AFfxa6TgF2BadlD","security":false,"server_url":"https://kphj3vsv.lc-cn-n1-shared.com"};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 29715,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="https://lib.baomitu.com/algoliasearch/4.3.0/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>





  <script>
    (function(d, w, c) {
      w.ChatraID = 'ZPdnXR7os9z2MNTzG';
      var s = d.createElement('script');
      w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
      };
      s.async = true;
      s.src = 'https://call.chatra.io/chatra.js';
      if (d.head) d.head.appendChild(s);
    })(document, window, 'Chatra');
  </script>









  

  

  <script>
  NexT.utils.loadComments(document.querySelector('#SOHUCS'), () => {
    var appid = 'cysL8VSAs';
    var conf = '500d337f521f3d63f3031f16746e9470';
    var width = window.innerWidth || document.documentElement.clientWidth;
    if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
    } else {
      var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})});
    }
  });
  </script>
  <script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>

<script>
  var disqus_config = function() {
    this.page.url = "http://blog.yanick.site/2020/09/25/networking/linux/linux-network-subsystem/";
    this.page.identifier = "2020/09/25/networking/linux/linux-network-subsystem/";
    this.page.title = "Linux 网络大全";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://yann-blog.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
